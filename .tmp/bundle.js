(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b ||= {})
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/react/cjs/react.development.js"(exports2, module2) {
      "use strict";
      (function() {
        function defineDeprecationWarning(methodName, info) {
          Object.defineProperty(Component.prototype, methodName, {
            get: function() {
              console.warn(
                "%s(...) is deprecated in plain JavaScript React classes. %s",
                info[0],
                info[1]
              );
            }
          });
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function warnNoop(publicInstance, callerName) {
          publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
          var warningKey = publicInstance + "." + callerName;
          didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
            "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
            callerName,
            publicInstance
          ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
        }
        function Component(props, context2, updater) {
          this.props = props;
          this.context = context2;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function ComponentDummy() {
        }
        function PureComponent(props, context2, updater) {
          this.props = props;
          this.context = context2;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function noop() {
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = false;
          } catch (e) {
            JSCompiler_inline_result = true;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            );
            return testStringCoercion(value);
          }
        }
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x) {
                }
            }
          return null;
        }
        function getTaskName(type) {
          if (type === REACT_FRAGMENT_TYPE) return "<>";
          if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
            return "<...>";
          try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
          } catch (x) {
            return "<...>";
          }
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function UnknownOwner() {
          return Error("react-stack-top-frame");
        }
        function hasValidKey(config) {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return false;
          }
          return void 0 !== config.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement(type, key, props, owner, debugStack, debugTask) {
          var refProp = props.ref;
          type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            props,
            _owner: owner
          };
          null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
            enumerable: false,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
          type._store = {};
          Object.defineProperty(type._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: 0
          });
          Object.defineProperty(type, "_debugInfo", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: null
          });
          Object.defineProperty(type, "_debugStack", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugStack
          });
          Object.defineProperty(type, "_debugTask", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugTask
          });
          Object.freeze && (Object.freeze(type.props), Object.freeze(type));
          return type;
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          newKey = ReactElement(
            oldElement.type,
            newKey,
            oldElement.props,
            oldElement._owner,
            oldElement._debugStack,
            oldElement._debugTask
          );
          oldElement._store && (newKey._store.validated = oldElement._store.validated);
          return newKey;
        }
        function validateChildKeys(node) {
          isValidElement2(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE && ("fulfilled" === node._payload.status ? isValidElement2(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
        }
        function isValidElement2(object) {
          return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function escape(key) {
          var escaperLookup = { "=": "=0", ":": "=2" };
          return "$" + key.replace(/[=:]/g, function(match) {
            return escaperLookup[match];
          });
        }
        function getElementKey(element, index) {
          return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
        }
        function resolveThenable(thenable) {
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
            default:
              switch ("string" === typeof thenable.status ? thenable.then(noop, noop) : (thenable.status = "pending", thenable.then(
                function(fulfilledValue) {
                  "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
                },
                function(error) {
                  "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                }
              )), thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenable.reason;
              }
          }
          throw thenable;
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if ("undefined" === type || "boolean" === type) children = null;
          var invokeCallback = false;
          if (null === children) invokeCallback = true;
          else
            switch (type) {
              case "bigint":
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                    break;
                  case REACT_LAZY_TYPE:
                    return invokeCallback = children._init, mapIntoArray(
                      invokeCallback(children._payload),
                      array,
                      escapedPrefix,
                      nameSoFar,
                      callback
                    );
                }
            }
          if (invokeCallback) {
            invokeCallback = children;
            callback = callback(invokeCallback);
            var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
            isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
              return c;
            })) : null != callback && (isValidElement2(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(
              callback,
              escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(
                userProvidedKeyEscapeRegex,
                "$&/"
              ) + "/") + childKey
            ), "" !== nameSoFar && null != invokeCallback && isValidElement2(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
            return 1;
          }
          invokeCallback = 0;
          childKey = "" === nameSoFar ? "." : nameSoFar + ":";
          if (isArrayImpl(children))
            for (var i = 0; i < children.length; i++)
              nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type,
                callback
              );
          else if (i = getIteratorFn(children), "function" === typeof i)
            for (i === children.entries && (didWarnAboutMaps || console.warn(
              "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
            ), didWarnAboutMaps = true), children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
              nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type,
                callback
              );
          else if ("object" === type) {
            if ("function" === typeof children.then)
              return mapIntoArray(
                resolveThenable(children),
                array,
                escapedPrefix,
                nameSoFar,
                callback
              );
            array = String(children);
            throw Error(
              "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
            );
          }
          return invokeCallback;
        }
        function mapChildren(children, func, context2) {
          if (null == children) return children;
          var result = [], count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context2, child, count++);
          });
          return result;
        }
        function lazyInitializer(payload) {
          if (-1 === payload._status) {
            var ioInfo = payload._ioInfo;
            null != ioInfo && (ioInfo.start = ioInfo.end = performance.now());
            ioInfo = payload._result;
            var thenable = ioInfo();
            thenable.then(
              function(moduleObject) {
                if (0 === payload._status || -1 === payload._status) {
                  payload._status = 1;
                  payload._result = moduleObject;
                  var _ioInfo = payload._ioInfo;
                  null != _ioInfo && (_ioInfo.end = performance.now());
                  void 0 === thenable.status && (thenable.status = "fulfilled", thenable.value = moduleObject);
                }
              },
              function(error) {
                if (0 === payload._status || -1 === payload._status) {
                  payload._status = 2;
                  payload._result = error;
                  var _ioInfo2 = payload._ioInfo;
                  null != _ioInfo2 && (_ioInfo2.end = performance.now());
                  void 0 === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                }
              }
            );
            ioInfo = payload._ioInfo;
            if (null != ioInfo) {
              ioInfo.value = thenable;
              var displayName = thenable.displayName;
              "string" === typeof displayName && (ioInfo.name = displayName);
            }
            -1 === payload._status && (payload._status = 0, payload._result = thenable);
          }
          if (1 === payload._status)
            return ioInfo = payload._result, void 0 === ioInfo && console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
              ioInfo
            ), "default" in ioInfo || console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
              ioInfo
            ), ioInfo.default;
          throw payload._result;
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        function releaseAsyncTransition() {
          ReactSharedInternals.asyncTransitions--;
        }
        function enqueueTask(task) {
          if (null === enqueueTaskImpl)
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              enqueueTaskImpl = (module2 && module2[requireString]).call(
                module2,
                "timers"
              ).setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                  "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
                ));
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          return enqueueTaskImpl(task);
        }
        function aggregateErrors(errors) {
          return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
        }
        function popActScope(prevActQueue, prevActScopeDepth) {
          prevActScopeDepth !== actScopeDepth - 1 && console.error(
            "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
          );
          actScopeDepth = prevActScopeDepth;
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject2) {
          var queue = ReactSharedInternals.actQueue;
          if (null !== queue)
            if (0 !== queue.length)
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  return recursivelyFlushAsyncActWork(returnValue, resolve, reject2);
                });
                return;
              } catch (error) {
                ReactSharedInternals.thrownErrors.push(error);
              }
            else ReactSharedInternals.actQueue = null;
          0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject2(queue)) : resolve(returnValue);
        }
        function flushActQueue(queue) {
          if (!isFlushing) {
            isFlushing = true;
            var i = 0;
            try {
              for (; i < queue.length; i++) {
                var callback = queue[i];
                do {
                  ReactSharedInternals.didUsePromise = false;
                  var continuation = callback(false);
                  if (null !== continuation) {
                    if (ReactSharedInternals.didUsePromise) {
                      queue[i] = callback;
                      queue.splice(0, i);
                      return;
                    }
                    callback = continuation;
                  } else break;
                } while (1);
              }
              queue.length = 0;
            } catch (error) {
              queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
            } finally {
              isFlushing = false;
            }
          }
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
          isMounted: function() {
            return false;
          },
          enqueueForceUpdate: function(publicInstance) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance) {
            warnNoop(publicInstance, "setState");
          }
        }, assign2 = Object.assign, emptyObject = {};
        Object.freeze(emptyObject);
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
            throw Error(
              "takes an object of state variables to update or a function which returns an object of state variables."
            );
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        var deprecatedAPIs = {
          isMounted: [
            "isMounted",
            "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
          ],
          replaceState: [
            "replaceState",
            "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
          ]
        };
        for (fnName in deprecatedAPIs)
          deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        ComponentDummy.prototype = Component.prototype;
        deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
        deprecatedAPIs.constructor = PureComponent;
        assign2(deprecatedAPIs, Component.prototype);
        deprecatedAPIs.isPureReactComponent = true;
        var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
          H: null,
          A: null,
          T: null,
          S: null,
          actQueue: null,
          asyncTransitions: 0,
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false,
          didUsePromise: false,
          thrownErrors: [],
          getCurrentStack: null,
          recentlyCreatedOwnerStacks: 0
        }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
          return null;
        };
        deprecatedAPIs = {
          react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
          }
        };
        var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
        var didWarnAboutElementRef = {};
        var unknownOwnerDebugStack = deprecatedAPIs.react_stack_bottom_frame.bind(
          deprecatedAPIs,
          UnknownOwner
        )();
        var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
        var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
          if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
              error
            });
            if (!window.dispatchEvent(event)) return;
          } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
          queueMicrotask(function() {
            return queueMicrotask(callback);
          });
        } : enqueueTask;
        deprecatedAPIs = Object.freeze({
          __proto__: null,
          c: function(size) {
            return resolveDispatcher().useMemoCache(size);
          }
        });
        var fnName = {
          map: mapChildren,
          forEach: function(children, forEachFunc, forEachContext) {
            mapChildren(
              children,
              function() {
                forEachFunc.apply(this, arguments);
              },
              forEachContext
            );
          },
          count: function(children) {
            var n = 0;
            mapChildren(children, function() {
              n++;
            });
            return n;
          },
          toArray: function(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          },
          only: function(children) {
            if (!isValidElement2(children))
              throw Error(
                "React.Children.only expected to receive a single React element child."
              );
            return children;
          }
        };
        exports2.Activity = REACT_ACTIVITY_TYPE;
        exports2.Children = fnName;
        exports2.Component = Component;
        exports2.Fragment = REACT_FRAGMENT_TYPE;
        exports2.Profiler = REACT_PROFILER_TYPE;
        exports2.PureComponent = PureComponent;
        exports2.StrictMode = REACT_STRICT_MODE_TYPE;
        exports2.Suspense = REACT_SUSPENSE_TYPE;
        exports2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
        exports2.__COMPILER_RUNTIME = deprecatedAPIs;
        exports2.act = function(callback) {
          var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
          actScopeDepth++;
          var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
          try {
            var result = callback();
          } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
          }
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          if (null !== result && "object" === typeof result && "function" === typeof result.then) {
            var thenable = result;
            queueSeveralMicrotasks(function() {
              didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
                "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
              ));
            });
            return {
              then: function(resolve, reject2) {
                didAwaitActCall = true;
                thenable.then(
                  function(returnValue) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    if (0 === prevActScopeDepth) {
                      try {
                        flushActQueue(queue), enqueueTask(function() {
                          return recursivelyFlushAsyncActWork(
                            returnValue,
                            resolve,
                            reject2
                          );
                        });
                      } catch (error$0) {
                        ReactSharedInternals.thrownErrors.push(error$0);
                      }
                      if (0 < ReactSharedInternals.thrownErrors.length) {
                        var _thrownError = aggregateErrors(
                          ReactSharedInternals.thrownErrors
                        );
                        ReactSharedInternals.thrownErrors.length = 0;
                        reject2(_thrownError);
                      }
                    } else resolve(returnValue);
                  },
                  function(error) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(
                      ReactSharedInternals.thrownErrors
                    ), ReactSharedInternals.thrownErrors.length = 0, reject2(error)) : reject2(error);
                  }
                );
              }
            };
          }
          var returnValue$jscomp$0 = result;
          popActScope(prevActQueue, prevActScopeDepth);
          0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
              "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
            ));
          }), ReactSharedInternals.actQueue = null);
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          return {
            then: function(resolve, reject2) {
              didAwaitActCall = true;
              0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
                return recursivelyFlushAsyncActWork(
                  returnValue$jscomp$0,
                  resolve,
                  reject2
                );
              })) : resolve(returnValue$jscomp$0);
            }
          };
        };
        exports2.cache = function(fn) {
          return function() {
            return fn.apply(null, arguments);
          };
        };
        exports2.cacheSignal = function() {
          return null;
        };
        exports2.captureOwnerStack = function() {
          var getCurrentStack = ReactSharedInternals.getCurrentStack;
          return null === getCurrentStack ? null : getCurrentStack();
        };
        exports2.cloneElement = function(element, config, children) {
          if (null === element || void 0 === element)
            throw Error(
              "The argument must be a React element, but you passed " + element + "."
            );
          var props = assign2({}, element.props), key = element.key, owner = element._owner;
          if (null != config) {
            var JSCompiler_inline_result;
            a: {
              if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
                config,
                "ref"
              ).get) && JSCompiler_inline_result.isReactWarning) {
                JSCompiler_inline_result = false;
                break a;
              }
              JSCompiler_inline_result = void 0 !== config.ref;
            }
            JSCompiler_inline_result && (owner = getOwner());
            hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
            for (propName in config)
              !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
          }
          var propName = arguments.length - 2;
          if (1 === propName) props.children = children;
          else if (1 < propName) {
            JSCompiler_inline_result = Array(propName);
            for (var i = 0; i < propName; i++)
              JSCompiler_inline_result[i] = arguments[i + 2];
            props.children = JSCompiler_inline_result;
          }
          props = ReactElement(
            element.type,
            key,
            props,
            owner,
            element._debugStack,
            element._debugTask
          );
          for (key = 2; key < arguments.length; key++)
            validateChildKeys(arguments[key]);
          return props;
        };
        exports2.createContext = function(defaultValue) {
          defaultValue = {
            $$typeof: REACT_CONTEXT_TYPE,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          defaultValue.Provider = defaultValue;
          defaultValue.Consumer = {
            $$typeof: REACT_CONSUMER_TYPE,
            _context: defaultValue
          };
          defaultValue._currentRenderer = null;
          defaultValue._currentRenderer2 = null;
          return defaultValue;
        };
        exports2.createElement = function(type, config, children) {
          for (var i = 2; i < arguments.length; i++)
            validateChildKeys(arguments[i]);
          i = {};
          var key = null;
          if (null != config)
            for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = true, console.warn(
              "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
            )), hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key), config)
              hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i[propName] = config[propName]);
          var childrenLength = arguments.length - 2;
          if (1 === childrenLength) i.children = children;
          else if (1 < childrenLength) {
            for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)
              childArray[_i] = arguments[_i + 2];
            Object.freeze && Object.freeze(childArray);
            i.children = childArray;
          }
          if (type && type.defaultProps)
            for (propName in childrenLength = type.defaultProps, childrenLength)
              void 0 === i[propName] && (i[propName] = childrenLength[propName]);
          key && defineKeyPropWarningGetter(
            i,
            "function" === typeof type ? type.displayName || type.name || "Unknown" : type
          );
          var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return ReactElement(
            type,
            key,
            i,
            getOwner(),
            propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask
          );
        };
        exports2.createRef = function() {
          var refObject = { current: null };
          Object.seal(refObject);
          return refObject;
        };
        exports2.forwardRef = function(render) {
          null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error(
            "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
          ) : "function" !== typeof render ? console.error(
            "forwardRef requires a render function but was given %s.",
            null === render ? "null" : typeof render
          ) : 0 !== render.length && 2 !== render.length && console.error(
            "forwardRef render functions accept exactly two parameters: props and ref. %s",
            1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
          );
          null != render && null != render.defaultProps && console.error(
            "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
          );
          var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
            }
          });
          return elementType;
        };
        exports2.isValidElement = isValidElement2;
        exports2.lazy = function(ctor) {
          ctor = { _status: -1, _result: ctor };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: ctor,
            _init: lazyInitializer
          }, ioInfo = {
            name: "lazy",
            start: -1,
            end: -1,
            value: null,
            owner: null,
            debugStack: Error("react-stack-top-frame"),
            debugTask: console.createTask ? console.createTask("lazy()") : null
          };
          ctor._ioInfo = ioInfo;
          lazyType._debugInfo = [{ awaited: ioInfo }];
          return lazyType;
        };
        exports2.memo = function(type, compare) {
          null == type && console.error(
            "memo: The first argument must be a component. Instead received: %s",
            null === type ? "null" : typeof type
          );
          compare = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: void 0 === compare ? null : compare
          };
          var ownName;
          Object.defineProperty(compare, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
            }
          });
          return compare;
        };
        exports2.startTransition = function(scope) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          ReactSharedInternals.T = currentTransition;
          try {
            var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(noop, reportGlobalError));
          } catch (error) {
            reportGlobalError(error);
          } finally {
            null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            )), null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(
              "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
            ), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
          }
        };
        exports2.unstable_useCacheRefresh = function() {
          return resolveDispatcher().useCacheRefresh();
        };
        exports2.use = function(usable) {
          return resolveDispatcher().use(usable);
        };
        exports2.useActionState = function(action, initialState, permalink) {
          return resolveDispatcher().useActionState(
            action,
            initialState,
            permalink
          );
        };
        exports2.useCallback = function(callback, deps) {
          return resolveDispatcher().useCallback(callback, deps);
        };
        exports2.useContext = function(Context) {
          var dispatcher = resolveDispatcher();
          Context.$$typeof === REACT_CONSUMER_TYPE && console.error(
            "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
          );
          return dispatcher.useContext(Context);
        };
        exports2.useDebugValue = function(value, formatterFn) {
          return resolveDispatcher().useDebugValue(value, formatterFn);
        };
        exports2.useDeferredValue = function(value, initialValue) {
          return resolveDispatcher().useDeferredValue(value, initialValue);
        };
        exports2.useEffect = function(create, deps) {
          null == create && console.warn(
            "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useEffect(create, deps);
        };
        exports2.useEffectEvent = function(callback) {
          return resolveDispatcher().useEffectEvent(callback);
        };
        exports2.useId = function() {
          return resolveDispatcher().useId();
        };
        exports2.useImperativeHandle = function(ref, create, deps) {
          return resolveDispatcher().useImperativeHandle(ref, create, deps);
        };
        exports2.useInsertionEffect = function(create, deps) {
          null == create && console.warn(
            "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useInsertionEffect(create, deps);
        };
        exports2.useLayoutEffect = function(create, deps) {
          null == create && console.warn(
            "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useLayoutEffect(create, deps);
        };
        exports2.useMemo = function(create, deps) {
          return resolveDispatcher().useMemo(create, deps);
        };
        exports2.useOptimistic = function(passthrough, reducer2) {
          return resolveDispatcher().useOptimistic(passthrough, reducer2);
        };
        exports2.useReducer = function(reducer2, initialArg, init) {
          return resolveDispatcher().useReducer(reducer2, initialArg, init);
        };
        exports2.useRef = function(initialValue) {
          return resolveDispatcher().useRef(initialValue);
        };
        exports2.useState = function(initialState) {
          return resolveDispatcher().useState(initialState);
        };
        exports2.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
          return resolveDispatcher().useSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        };
        exports2.useTransition = function() {
          return resolveDispatcher().useTransition();
        };
        exports2.version = "19.2.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports2, module2) {
      "use strict";
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_react_development();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.development.js
  var require_react_dom_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom.development.js"(exports2) {
      "use strict";
      (function() {
        function noop() {
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function createPortal$1(children, containerInfo, implementation) {
          var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
          try {
            testStringCoercion(key);
            var JSCompiler_inline_result = false;
          } catch (e) {
            JSCompiler_inline_result = true;
          }
          JSCompiler_inline_result && (console.error(
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"
          ), testStringCoercion(key));
          return {
            $$typeof: REACT_PORTAL_TYPE,
            key: null == key ? null : "" + key,
            children,
            containerInfo,
            implementation
          };
        }
        function getCrossOriginStringAs(as, input) {
          if ("font" === as) return "";
          if ("string" === typeof input)
            return "use-credentials" === input ? input : "";
        }
        function getValueDescriptorExpectingObjectForWarning(thing) {
          return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
        }
        function getValueDescriptorExpectingEnumForWarning(thing) {
          return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var React9 = require_react(), Internals = {
          d: {
            f: noop,
            r: function() {
              throw Error(
                "Invalid form element. requestFormReset must be passed a form that was rendered by React."
              );
            },
            D: noop,
            C: noop,
            L: noop,
            m: noop,
            X: noop,
            S: noop,
            M: noop
          },
          p: 0,
          findDOMNode: null
        }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React9.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
        "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
          "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
        );
        exports2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
        exports2.createPortal = function(children, container) {
          var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
          if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
            throw Error("Target container is not a DOM element.");
          return createPortal$1(children, container, null, key);
        };
        exports2.flushSync = function(fn) {
          var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
          try {
            if (ReactSharedInternals.T = null, Internals.p = 2, fn)
              return fn();
          } finally {
            ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error(
              "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
            );
          }
        };
        exports2.preconnect = function(href, options) {
          "string" === typeof href && href ? null != options && "object" !== typeof options ? console.error(
            "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : null != options && "string" !== typeof options.crossOrigin && console.error(
            "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
            getValueDescriptorExpectingObjectForWarning(options.crossOrigin)
          ) : console.error(
            "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
          "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
        };
        exports2.prefetchDNS = function(href) {
          if ("string" !== typeof href || !href)
            console.error(
              "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
              getValueDescriptorExpectingObjectForWarning(href)
            );
          else if (1 < arguments.length) {
            var options = arguments[1];
            "object" === typeof options && options.hasOwnProperty("crossOrigin") ? console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            ) : console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            );
          }
          "string" === typeof href && Internals.d.D(href);
        };
        exports2.preinit = function(href, options) {
          "string" === typeof href && href ? null == options || "object" !== typeof options ? console.error(
            "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : "style" !== options.as && "script" !== options.as && console.error(
            'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
            getValueDescriptorExpectingEnumForWarning(options.as)
          ) : console.error(
            "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
          if ("string" === typeof href && options && "string" === typeof options.as) {
            var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
            "style" === as ? Internals.d.S(
              href,
              "string" === typeof options.precedence ? options.precedence : void 0,
              {
                crossOrigin,
                integrity,
                fetchPriority
              }
            ) : "script" === as && Internals.d.X(href, {
              crossOrigin,
              integrity,
              fetchPriority,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
          }
        };
        exports2.preinitModule = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "script" !== options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
          if (encountered)
            console.error(
              "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
              encountered
            );
          else
            switch (encountered = options && "string" === typeof options.as ? options.as : "script", encountered) {
              case "script":
                break;
              default:
                encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error(
                  'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                  encountered,
                  href
                );
            }
          if ("string" === typeof href)
            if ("object" === typeof options && null !== options) {
              if (null == options.as || "script" === options.as)
                encountered = getCrossOriginStringAs(
                  options.as,
                  options.crossOrigin
                ), Internals.d.M(href, {
                  crossOrigin: encountered,
                  integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                  nonce: "string" === typeof options.nonce ? options.nonce : void 0
                });
            } else null == options && Internals.d.M(href);
        };
        exports2.preload = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          null == options || "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : "string" === typeof options.as && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
          encountered && console.error(
            'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
            encountered
          );
          if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
            encountered = options.as;
            var crossOrigin = getCrossOriginStringAs(
              encountered,
              options.crossOrigin
            );
            Internals.d.L(href, encountered, {
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0,
              type: "string" === typeof options.type ? options.type : void 0,
              fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
              referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
              imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
              imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
              media: "string" === typeof options.media ? options.media : void 0
            });
          }
        };
        exports2.preloadModule = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "string" !== typeof options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
          encountered && console.error(
            'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
            encountered
          );
          "string" === typeof href && (options ? (encountered = getCrossOriginStringAs(
            options.as,
            options.crossOrigin
          ), Internals.d.m(href, {
            as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
            crossOrigin: encountered,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0
          })) : Internals.d.m(href));
        };
        exports2.requestFormReset = function(form) {
          Internals.d.r(form);
        };
        exports2.unstable_batchedUpdates = function(fn, a) {
          return fn(a);
        };
        exports2.useFormState = function(action, initialState, permalink) {
          return resolveDispatcher().useFormState(action, initialState, permalink);
        };
        exports2.useFormStatus = function() {
          return resolveDispatcher().useHostTransitionStatus();
        };
        exports2.version = "19.2.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports2, module2) {
      "use strict";
      if (false) {
        checkDCE();
        module2.exports = null;
      } else {
        module2.exports = require_react_dom_development();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js
  var require_react_dom_server_legacy_browser_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js"(exports2) {
      "use strict";
      (function() {
        function styleReplacer(match, prefix2, s, suffix2) {
          return "" + prefix2 + ("s" === s ? "\\73 " : "\\53 ") + suffix2;
        }
        function scriptReplacer(match, prefix2, s, suffix2) {
          return "" + prefix2 + ("s" === s ? "\\u0073" : "\\u0053") + suffix2;
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function objectName(object) {
          object = Object.prototype.toString.call(object);
          return object.slice(8, object.length - 1);
        }
        function describeKeyForErrorMessage(key) {
          var encodedKey = JSON.stringify(key);
          return '"' + key + '"' === encodedKey ? key : encodedKey;
        }
        function describeValueForErrorMessage(value) {
          switch (typeof value) {
            case "string":
              return JSON.stringify(
                10 >= value.length ? value : value.slice(0, 10) + "..."
              );
            case "object":
              if (isArrayImpl(value)) return "[...]";
              if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
                return "client";
              value = objectName(value);
              return "Object" === value ? "{...}" : value;
            case "function":
              return value.$$typeof === CLIENT_REFERENCE_TAG ? "client" : (value = value.displayName || value.name) ? "function " + value : "function";
            default:
              return String(value);
          }
        }
        function describeElementType(type) {
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if ("object" === typeof type)
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeElementType(type.render);
              case REACT_MEMO_TYPE:
                return describeElementType(type.type);
              case REACT_LAZY_TYPE:
                var payload = type._payload;
                type = type._init;
                try {
                  return describeElementType(type(payload));
                } catch (x) {
                }
            }
          return "";
        }
        function describeObjectForErrorMessage(objectOrArray, expandedName) {
          var objKind = objectName(objectOrArray);
          if ("Object" !== objKind && "Array" !== objKind) return objKind;
          var start = -1, length = 0;
          if (isArrayImpl(objectOrArray))
            if (jsxChildrenParents.has(objectOrArray)) {
              var type = jsxChildrenParents.get(objectOrArray);
              objKind = "<" + describeElementType(type) + ">";
              for (var i = 0; i < objectOrArray.length; i++) {
                var value = objectOrArray[i];
                value = "string" === typeof value ? value : "object" === typeof value && null !== value ? "{" + describeObjectForErrorMessage(value) + "}" : "{" + describeValueForErrorMessage(value) + "}";
                "" + i === expandedName ? (start = objKind.length, length = value.length, objKind += value) : objKind = 15 > value.length && 40 > objKind.length + value.length ? objKind + value : objKind + "{...}";
              }
              objKind += "</" + describeElementType(type) + ">";
            } else {
              objKind = "[";
              for (type = 0; type < objectOrArray.length; type++)
                0 < type && (objKind += ", "), i = objectOrArray[type], i = "object" === typeof i && null !== i ? describeObjectForErrorMessage(i) : describeValueForErrorMessage(i), "" + type === expandedName ? (start = objKind.length, length = i.length, objKind += i) : objKind = 10 > i.length && 40 > objKind.length + i.length ? objKind + i : objKind + "...";
              objKind += "]";
            }
          else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
            objKind = "<" + describeElementType(objectOrArray.type) + "/>";
          else {
            if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
            if (jsxPropsParents.has(objectOrArray)) {
              objKind = jsxPropsParents.get(objectOrArray);
              objKind = "<" + (describeElementType(objKind) || "...");
              type = Object.keys(objectOrArray);
              for (i = 0; i < type.length; i++) {
                objKind += " ";
                value = type[i];
                objKind += describeKeyForErrorMessage(value) + "=";
                var _value2 = objectOrArray[value];
                var _substr2 = value === expandedName && "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2);
                "string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
                value === expandedName ? (start = objKind.length, length = _substr2.length, objKind += _substr2) : objKind = 10 > _substr2.length && 40 > objKind.length + _substr2.length ? objKind + _substr2 : objKind + "...";
              }
              objKind += ">";
            } else {
              objKind = "{";
              type = Object.keys(objectOrArray);
              for (i = 0; i < type.length; i++)
                0 < i && (objKind += ", "), value = type[i], objKind += describeKeyForErrorMessage(value) + ": ", _value2 = objectOrArray[value], _value2 = "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2), value === expandedName ? (start = objKind.length, length = _value2.length, objKind += _value2) : objKind = 10 > _value2.length && 40 > objKind.length + _value2.length ? objKind + _value2 : objKind + "...";
              objKind += "}";
            }
          }
          return void 0 === expandedName ? objKind : -1 < start && 0 < length ? (objectOrArray = " ".repeat(start) + "^".repeat(length), "\n  " + objKind + "\n  " + objectOrArray) : "\n  " + objKind;
        }
        function murmurhash3_32_gc(key, seed) {
          var remainder = key.length & 3;
          var bytes = key.length - remainder;
          var h1 = seed;
          for (seed = 0; seed < bytes; ) {
            var k1 = key.charCodeAt(seed) & 255 | (key.charCodeAt(++seed) & 255) << 8 | (key.charCodeAt(++seed) & 255) << 16 | (key.charCodeAt(++seed) & 255) << 24;
            ++seed;
            k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295;
            k1 = k1 << 15 | k1 >>> 17;
            k1 = 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
            h1 ^= k1;
            h1 = h1 << 13 | h1 >>> 19;
            h1 = 5 * (h1 & 65535) + ((5 * (h1 >>> 16) & 65535) << 16) & 4294967295;
            h1 = (h1 & 65535) + 27492 + (((h1 >>> 16) + 58964 & 65535) << 16);
          }
          k1 = 0;
          switch (remainder) {
            case 3:
              k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;
            case 2:
              k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;
            case 1:
              k1 ^= key.charCodeAt(seed) & 255, k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295, k1 = k1 << 15 | k1 >>> 17, h1 ^= 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
          }
          h1 ^= key.length;
          h1 ^= h1 >>> 16;
          h1 = 2246822507 * (h1 & 65535) + ((2246822507 * (h1 >>> 16) & 65535) << 16) & 4294967295;
          h1 ^= h1 >>> 13;
          h1 = 3266489909 * (h1 & 65535) + ((3266489909 * (h1 >>> 16) & 65535) << 16) & 4294967295;
          return (h1 ^ h1 >>> 16) >>> 0;
        }
        function typeName(value) {
          return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        }
        function willCoercionThrow(value) {
          try {
            return testStringCoercion(value), false;
          } catch (e) {
            return true;
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
              attributeName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
              propName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkHtmlStringCoercion(value) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
              typeName(value)
            ), testStringCoercion(value);
        }
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
            return true;
          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
            return false;
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
            return validatedAttributeNameCache[attributeName] = true;
          illegalAttributeNameCache[attributeName] = true;
          console.error("Invalid attribute name: `%s`", attributeName);
          return false;
        }
        function checkControlledValueProps(tagName, props) {
          hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
          ) : console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
          ));
          props.onChange || props.readOnly || props.disabled || null == props.checked || console.error(
            "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
          );
        }
        function validateProperty$1(tagName, name) {
          if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
            return true;
          if (rARIACamel$1.test(name)) {
            tagName = "aria-" + name.slice(4).toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
                name
              ), warnedProperties$1[name] = true;
            if (name !== tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. Did you mean `%s`?",
                name,
                tagName
              ), warnedProperties$1[name] = true;
          }
          if (rARIA$1.test(name)) {
            tagName = name.toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName) return warnedProperties$1[name] = true, false;
            name !== tagName && (console.error(
              "Unknown ARIA attribute `%s`. Did you mean `%s`?",
              name,
              tagName
            ), warnedProperties$1[name] = true);
          }
          return true;
        }
        function validateProperties$2(type, props) {
          var invalidProps = [], key;
          for (key in props)
            validateProperty$1(type, key) || invalidProps.push(key);
          props = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === invalidProps.length ? console.error(
            "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          ) : 1 < invalidProps.length && console.error(
            "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          );
        }
        function validateProperty(tagName, name, value, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
            return true;
          var lowerCasedName = name.toLowerCase();
          if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
            return console.error(
              "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
            ), warnedProperties[name] = true;
          if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name))
            return true;
          if (null != eventRegistry) {
            tagName = eventRegistry.possibleRegistrationNames;
            if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
              return true;
            eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
            if (null != eventRegistry)
              return console.error(
                "Invalid event handler property `%s`. Did you mean `%s`?",
                name,
                eventRegistry
              ), warnedProperties[name] = true;
            if (EVENT_NAME_REGEX.test(name))
              return console.error(
                "Unknown event handler property `%s`. It will be ignored.",
                name
              ), warnedProperties[name] = true;
          } else if (EVENT_NAME_REGEX.test(name))
            return INVALID_EVENT_NAME_REGEX.test(name) && console.error(
              "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
              name
            ), warnedProperties[name] = true;
          if (rARIA.test(name) || rARIACamel.test(name)) return true;
          if ("innerhtml" === lowerCasedName)
            return console.error(
              "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
            ), warnedProperties[name] = true;
          if ("aria" === lowerCasedName)
            return console.error(
              "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
            ), warnedProperties[name] = true;
          if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value)
            return console.error(
              "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
              typeof value
            ), warnedProperties[name] = true;
          if ("number" === typeof value && isNaN(value))
            return console.error(
              "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
              name
            ), warnedProperties[name] = true;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name)
              return console.error(
                "Invalid DOM property `%s`. Did you mean `%s`?",
                name,
                lowerCasedName
              ), warnedProperties[name] = true;
          } else if (name !== lowerCasedName)
            return console.error(
              "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
              name,
              lowerCasedName
            ), warnedProperties[name] = true;
          switch (name) {
            case "dangerouslySetInnerHTML":
            case "children":
            case "style":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              return true;
            case "innerText":
            case "textContent":
              return true;
          }
          switch (typeof value) {
            case "boolean":
              switch (name) {
                case "autoFocus":
                case "checked":
                case "multiple":
                case "muted":
                case "selected":
                case "contentEditable":
                case "spellCheck":
                case "draggable":
                case "value":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                case "capture":
                case "download":
                case "inert":
                  return true;
                default:
                  lowerCasedName = name.toLowerCase().slice(0, 5);
                  if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                    return true;
                  value ? console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                    value,
                    name,
                    name,
                    value,
                    name
                  ) : console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                    value,
                    name,
                    name,
                    value,
                    name,
                    name,
                    name
                  );
                  return warnedProperties[name] = true;
              }
            case "function":
            case "symbol":
              return warnedProperties[name] = true, false;
            case "string":
              if ("false" === value || "true" === value) {
                switch (name) {
                  case "checked":
                  case "selected":
                  case "multiple":
                  case "muted":
                  case "allowFullScreen":
                  case "async":
                  case "autoPlay":
                  case "controls":
                  case "default":
                  case "defer":
                  case "disabled":
                  case "disablePictureInPicture":
                  case "disableRemotePlayback":
                  case "formNoValidate":
                  case "hidden":
                  case "loop":
                  case "noModule":
                  case "noValidate":
                  case "open":
                  case "playsInline":
                  case "readOnly":
                  case "required":
                  case "reversed":
                  case "scoped":
                  case "seamless":
                  case "itemScope":
                  case "inert":
                    break;
                  default:
                    return true;
                }
                console.error(
                  "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
                  value,
                  name,
                  "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
                  name,
                  value
                );
                warnedProperties[name] = true;
              }
          }
          return true;
        }
        function warnUnknownProperties(type, props, eventRegistry) {
          var unknownProps = [], key;
          for (key in props)
            validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
          props = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === unknownProps.length ? console.error(
            "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          ) : 1 < unknownProps.length && console.error(
            "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          );
        }
        function camelize(string) {
          return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
          });
        }
        function escapeTextForBrowser(text) {
          if ("boolean" === typeof text || "number" === typeof text || "bigint" === typeof text)
            return "" + text;
          checkHtmlStringCoercion(text);
          text = "" + text;
          var match = matchHtmlRegExp.exec(text);
          if (match) {
            var html = "", index, lastIndex = 0;
            for (index = match.index; index < text.length; index++) {
              switch (text.charCodeAt(index)) {
                case 34:
                  match = "&quot;";
                  break;
                case 38:
                  match = "&amp;";
                  break;
                case 39:
                  match = "&#x27;";
                  break;
                case 60:
                  match = "&lt;";
                  break;
                case 62:
                  match = "&gt;";
                  break;
                default:
                  continue;
              }
              lastIndex !== index && (html += text.slice(lastIndex, index));
              lastIndex = index + 1;
              html += match;
            }
            text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;
          }
          return text;
        }
        function sanitizeURL(url) {
          return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
        }
        function escapeEntireInlineScriptContent(scriptText) {
          checkHtmlStringCoercion(scriptText);
          return ("" + scriptText).replace(scriptRegex, scriptReplacer);
        }
        function createResumableState(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
          return {
            idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
            nextFormID: 0,
            streamingFormat: 0,
            bootstrapScriptContent,
            bootstrapScripts,
            bootstrapModules,
            instructions: NothingSent,
            hasBody: false,
            hasHtml: false,
            unknownResources: {},
            dnsResources: {},
            connectResources: { default: {}, anonymous: {}, credentials: {} },
            imageResources: {},
            styleResources: {},
            scriptResources: {},
            moduleUnknownResources: {},
            moduleScriptResources: {}
          };
        }
        function createFormatContext(insertionMode, selectedValue, tagScope, viewTransition) {
          return {
            insertionMode,
            selectedValue,
            tagScope,
            viewTransition
          };
        }
        function getChildFormatContext(parentContext, type, props) {
          var subtreeScope = parentContext.tagScope & -25;
          switch (type) {
            case "noscript":
              return createFormatContext(HTML_MODE, null, subtreeScope | 1, null);
            case "select":
              return createFormatContext(
                HTML_MODE,
                null != props.value ? props.value : props.defaultValue,
                subtreeScope,
                null
              );
            case "svg":
              return createFormatContext(SVG_MODE, null, subtreeScope, null);
            case "picture":
              return createFormatContext(HTML_MODE, null, subtreeScope | 2, null);
            case "math":
              return createFormatContext(MATHML_MODE, null, subtreeScope, null);
            case "foreignObject":
              return createFormatContext(HTML_MODE, null, subtreeScope, null);
            case "table":
              return createFormatContext(HTML_TABLE_MODE, null, subtreeScope, null);
            case "thead":
            case "tbody":
            case "tfoot":
              return createFormatContext(
                HTML_TABLE_BODY_MODE,
                null,
                subtreeScope,
                null
              );
            case "colgroup":
              return createFormatContext(
                HTML_COLGROUP_MODE,
                null,
                subtreeScope,
                null
              );
            case "tr":
              return createFormatContext(
                HTML_TABLE_ROW_MODE,
                null,
                subtreeScope,
                null
              );
            case "head":
              if (parentContext.insertionMode < HTML_MODE)
                return createFormatContext(
                  HTML_HEAD_MODE,
                  null,
                  subtreeScope,
                  null
                );
              break;
            case "html":
              if (parentContext.insertionMode === ROOT_HTML_MODE)
                return createFormatContext(
                  HTML_HTML_MODE,
                  null,
                  subtreeScope,
                  null
                );
          }
          return parentContext.insertionMode >= HTML_TABLE_MODE || parentContext.insertionMode < HTML_MODE ? createFormatContext(HTML_MODE, null, subtreeScope, null) : parentContext.tagScope !== subtreeScope ? createFormatContext(
            parentContext.insertionMode,
            parentContext.selectedValue,
            subtreeScope,
            null
          ) : parentContext;
        }
        function getSuspenseViewTransition(parentViewTransition) {
          return null === parentViewTransition ? null : {
            update: parentViewTransition.update,
            enter: "none",
            exit: "none",
            share: parentViewTransition.update,
            name: parentViewTransition.autoName,
            autoName: parentViewTransition.autoName,
            nameIdx: 0
          };
        }
        function getSuspenseFallbackFormatContext(resumableState, parentContext) {
          parentContext.tagScope & 32 && (resumableState.instructions |= 128);
          return createFormatContext(
            parentContext.insertionMode,
            parentContext.selectedValue,
            parentContext.tagScope | 12,
            getSuspenseViewTransition(parentContext.viewTransition)
          );
        }
        function getSuspenseContentFormatContext(resumableState, parentContext) {
          resumableState = getSuspenseViewTransition(parentContext.viewTransition);
          var subtreeScope = parentContext.tagScope | 16;
          null !== resumableState && "none" !== resumableState.share && (subtreeScope |= 64);
          return createFormatContext(
            parentContext.insertionMode,
            parentContext.selectedValue,
            subtreeScope,
            resumableState
          );
        }
        function pushStyleAttribute(target, style2) {
          if ("object" !== typeof style2)
            throw Error(
              "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
            );
          var isFirst = true, styleName;
          for (styleName in style2)
            if (hasOwnProperty.call(style2, styleName)) {
              var styleValue = style2[styleName];
              if (null != styleValue && "boolean" !== typeof styleValue && "" !== styleValue) {
                if (0 === styleName.indexOf("--")) {
                  var nameChunk = escapeTextForBrowser(styleName);
                  checkCSSPropertyStringCoercion(styleValue, styleName);
                  styleValue = escapeTextForBrowser(("" + styleValue).trim());
                } else {
                  nameChunk = styleName;
                  var value = styleValue;
                  if (-1 < nameChunk.indexOf("-")) {
                    var name = nameChunk;
                    warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = true, console.error(
                      "Unsupported style property %s. Did you mean %s?",
                      name,
                      camelize(name.replace(msPattern$1, "ms-"))
                    ));
                  } else if (badVendoredStyleNamePattern.test(nameChunk))
                    name = nameChunk, warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = true, console.error(
                      "Unsupported vendor-prefixed style property %s. Did you mean %s?",
                      name,
                      name.charAt(0).toUpperCase() + name.slice(1)
                    ));
                  else if (badStyleValueWithSemicolonPattern.test(value)) {
                    name = nameChunk;
                    var value$jscomp$0 = value;
                    warnedStyleValues.hasOwnProperty(value$jscomp$0) && warnedStyleValues[value$jscomp$0] || (warnedStyleValues[value$jscomp$0] = true, console.error(
                      `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
                      name,
                      value$jscomp$0.replace(
                        badStyleValueWithSemicolonPattern,
                        ""
                      )
                    ));
                  }
                  "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error(
                    "`NaN` is an invalid value for the `%s` css style property.",
                    nameChunk
                  )) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error(
                    "`Infinity` is an invalid value for the `%s` css style property.",
                    nameChunk
                  )));
                  nameChunk = styleName;
                  value = styleNameCache.get(nameChunk);
                  void 0 !== value ? nameChunk = value : (value = escapeTextForBrowser(
                    nameChunk.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-")
                  ), styleNameCache.set(nameChunk, value), nameChunk = value);
                  "number" === typeof styleValue ? styleValue = 0 === styleValue || unitlessNumbers.has(styleName) ? "" + styleValue : styleValue + "px" : (checkCSSPropertyStringCoercion(styleValue, styleName), styleValue = escapeTextForBrowser(
                    ("" + styleValue).trim()
                  ));
                }
                isFirst ? (isFirst = false, target.push(
                  styleAttributeStart,
                  nameChunk,
                  styleAssign,
                  styleValue
                )) : target.push(styleSeparator, nameChunk, styleAssign, styleValue);
              }
            }
          isFirst || target.push(attributeEnd);
        }
        function pushBooleanAttribute(target, name, value) {
          value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator, name, attributeEmptyString);
        }
        function pushStringAttribute(target, name, value) {
          "function" !== typeof value && "symbol" !== typeof value && "boolean" !== typeof value && target.push(
            attributeSeparator,
            name,
            attributeAssign,
            escapeTextForBrowser(value),
            attributeEnd
          );
        }
        function pushAdditionalFormField(value, key) {
          this.push('<input type="hidden"');
          validateAdditionalFormField(value);
          pushStringAttribute(this, "name", key);
          pushStringAttribute(this, "value", value);
          this.push(endOfStartTagSelfClosing);
        }
        function validateAdditionalFormField(value) {
          if ("string" !== typeof value)
            throw Error(
              "File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration."
            );
        }
        function getCustomFormFields(resumableState, formAction) {
          if ("function" === typeof formAction.$$FORM_ACTION) {
            var id = resumableState.nextFormID++;
            resumableState = resumableState.idPrefix + id;
            try {
              var customFields = formAction.$$FORM_ACTION(resumableState);
              if (customFields) {
                var formData = customFields.data;
                null != formData && formData.forEach(validateAdditionalFormField);
              }
              return customFields;
            } catch (x) {
              if ("object" === typeof x && null !== x && "function" === typeof x.then)
                throw x;
              console.error(
                "Failed to serialize an action for progressive enhancement:\n%s",
                x
              );
            }
          }
          return null;
        }
        function pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name) {
          var formData = null;
          if ("function" === typeof formAction) {
            null === name || didWarnFormActionName || (didWarnFormActionName = true, console.error(
              'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
            ));
            null === formEncType && null === formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
              "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
            ));
            null === formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
              "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
            ));
            var customFields = getCustomFormFields(resumableState, formAction);
            null !== customFields ? (name = customFields.name, formAction = customFields.action || "", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(
              attributeSeparator,
              "formAction",
              attributeAssign,
              actionJavaScriptURL,
              attributeEnd
            ), formTarget = formMethod = formEncType = formAction = name = null, injectFormReplayingRuntime(resumableState, renderState));
          }
          null != name && pushAttribute(target, "name", name);
          null != formAction && pushAttribute(target, "formAction", formAction);
          null != formEncType && pushAttribute(target, "formEncType", formEncType);
          null != formMethod && pushAttribute(target, "formMethod", formMethod);
          null != formTarget && pushAttribute(target, "formTarget", formTarget);
          return formData;
        }
        function pushAttribute(target, name, value) {
          switch (name) {
            case "className":
              pushStringAttribute(target, "class", value);
              break;
            case "tabIndex":
              pushStringAttribute(target, "tabindex", value);
              break;
            case "dir":
            case "role":
            case "viewBox":
            case "width":
            case "height":
              pushStringAttribute(target, name, value);
              break;
            case "style":
              pushStyleAttribute(target, value);
              break;
            case "src":
            case "href":
              if ("" === value) {
                "src" === name ? console.error(
                  'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  name,
                  name
                ) : console.error(
                  'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  name,
                  name
                );
                break;
              }
            case "action":
            case "formAction":
              if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
                break;
              checkAttributeStringCoercion(value, name);
              value = sanitizeURL("" + value);
              target.push(
                attributeSeparator,
                name,
                attributeAssign,
                escapeTextForBrowser(value),
                attributeEnd
              );
              break;
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "ref":
              break;
            case "autoFocus":
            case "multiple":
            case "muted":
              pushBooleanAttribute(target, name.toLowerCase(), value);
              break;
            case "xlinkHref":
              if ("function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
                break;
              checkAttributeStringCoercion(value, name);
              value = sanitizeURL("" + value);
              target.push(
                attributeSeparator,
                "xlink:href",
                attributeAssign,
                escapeTextForBrowser(value),
                attributeEnd
              );
              break;
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
              "function" !== typeof value && "symbol" !== typeof value && target.push(
                attributeSeparator,
                name,
                attributeAssign,
                escapeTextForBrowser(value),
                attributeEnd
              );
              break;
            case "inert":
              "" !== value || didWarnForNewBooleanPropsWithEmptyValue[name] || (didWarnForNewBooleanPropsWithEmptyValue[name] = true, console.error(
                "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                name
              ));
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
              value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator, name, attributeEmptyString);
              break;
            case "capture":
            case "download":
              true === value ? target.push(attributeSeparator, name, attributeEmptyString) : false !== value && "function" !== typeof value && "symbol" !== typeof value && target.push(
                attributeSeparator,
                name,
                attributeAssign,
                escapeTextForBrowser(value),
                attributeEnd
              );
              break;
            case "cols":
            case "rows":
            case "size":
            case "span":
              "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value && target.push(
                attributeSeparator,
                name,
                attributeAssign,
                escapeTextForBrowser(value),
                attributeEnd
              );
              break;
            case "rowSpan":
            case "start":
              "function" === typeof value || "symbol" === typeof value || isNaN(value) || target.push(
                attributeSeparator,
                name,
                attributeAssign,
                escapeTextForBrowser(value),
                attributeEnd
              );
              break;
            case "xlinkActuate":
              pushStringAttribute(target, "xlink:actuate", value);
              break;
            case "xlinkArcrole":
              pushStringAttribute(target, "xlink:arcrole", value);
              break;
            case "xlinkRole":
              pushStringAttribute(target, "xlink:role", value);
              break;
            case "xlinkShow":
              pushStringAttribute(target, "xlink:show", value);
              break;
            case "xlinkTitle":
              pushStringAttribute(target, "xlink:title", value);
              break;
            case "xlinkType":
              pushStringAttribute(target, "xlink:type", value);
              break;
            case "xmlBase":
              pushStringAttribute(target, "xml:base", value);
              break;
            case "xmlLang":
              pushStringAttribute(target, "xml:lang", value);
              break;
            case "xmlSpace":
              pushStringAttribute(target, "xml:space", value);
              break;
            default:
              if (!(2 < name.length) || "o" !== name[0] && "O" !== name[0] || "n" !== name[1] && "N" !== name[1]) {
                if (name = aliases.get(name) || name, isAttributeNameSafe(name)) {
                  switch (typeof value) {
                    case "function":
                    case "symbol":
                      return;
                    case "boolean":
                      var prefix2 = name.toLowerCase().slice(0, 5);
                      if ("data-" !== prefix2 && "aria-" !== prefix2) return;
                  }
                  target.push(
                    attributeSeparator,
                    name,
                    attributeAssign,
                    escapeTextForBrowser(value),
                    attributeEnd
                  );
                }
              }
          }
        }
        function pushInnerHTML(target, innerHTML, children) {
          if (null != innerHTML) {
            if (null != children)
              throw Error(
                "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
              );
            if ("object" !== typeof innerHTML || !("__html" in innerHTML))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            innerHTML = innerHTML.__html;
            null !== innerHTML && void 0 !== innerHTML && (checkHtmlStringCoercion(innerHTML), target.push("" + innerHTML));
          }
        }
        function checkSelectProp(props, propName) {
          var value = props[propName];
          null != value && (value = isArrayImpl(value), props.multiple && !value ? console.error(
            "The `%s` prop supplied to <select> must be an array if `multiple` is true.",
            propName
          ) : !props.multiple && value && console.error(
            "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.",
            propName
          ));
        }
        function flattenOptionChildren(children) {
          var content = "";
          React9.Children.forEach(children, function(child) {
            null != child && (content += child, didWarnInvalidOptionChildren || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || (didWarnInvalidOptionChildren = true, console.error(
              "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
            )));
          });
          return content;
        }
        function injectFormReplayingRuntime(resumableState, renderState) {
          if ((resumableState.instructions & 16) === NothingSent) {
            resumableState.instructions |= 16;
            var preamble = renderState.preamble, bootstrapChunks = renderState.bootstrapChunks;
            (preamble.htmlChunks || preamble.headChunks) && 0 === bootstrapChunks.length ? (bootstrapChunks.push(renderState.startInlineScript), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(
              endOfStartTag,
              formReplayingRuntimeScript,
              endInlineScript
            )) : bootstrapChunks.unshift(
              renderState.startInlineScript,
              endOfStartTag,
              formReplayingRuntimeScript,
              endInlineScript
            );
          }
        }
        function pushLinkImpl(target, props) {
          target.push(startChunkForTag("link"));
          for (var propKey in props)
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  default:
                    pushAttribute(target, propKey, propValue);
                }
            }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function escapeStyleTextContent(styleText) {
          checkHtmlStringCoercion(styleText);
          return ("" + styleText).replace(styleRegex, styleReplacer);
        }
        function pushSelfClosing(target, props, tag) {
          target.push(startChunkForTag(tag));
          for (var propKey in props)
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  default:
                    pushAttribute(target, propKey, propValue);
                }
            }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushTitleImpl(target, props) {
          target.push(startChunkForTag("title"));
          var children = null, innerHTML = null, propKey;
          for (propKey in props)
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  default:
                    pushAttribute(target, propKey, propValue);
                }
            }
          target.push(endOfStartTag);
          props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;
          "function" !== typeof props && "symbol" !== typeof props && null !== props && void 0 !== props && target.push(escapeTextForBrowser("" + props));
          pushInnerHTML(target, innerHTML, children);
          target.push(endChunkForTag("title"));
          return null;
        }
        function pushScriptImpl(target, props) {
          target.push(startChunkForTag("script"));
          var children = null, innerHTML = null, propKey;
          for (propKey in props)
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  default:
                    pushAttribute(target, propKey, propValue);
                }
            }
          target.push(endOfStartTag);
          null != children && "string" !== typeof children && (props = "number" === typeof children ? "a number for children" : Array.isArray(children) ? "an array for children" : "something unexpected for children", console.error(
            "A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.",
            props
          ));
          pushInnerHTML(target, innerHTML, children);
          "string" === typeof children && target.push(escapeEntireInlineScriptContent(children));
          target.push(endChunkForTag("script"));
          return null;
        }
        function pushStartSingletonElement(target, props, tag) {
          target.push(startChunkForTag(tag));
          var innerHTML = tag = null, propKey;
          for (propKey in props)
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "children":
                    tag = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  default:
                    pushAttribute(target, propKey, propValue);
                }
            }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, tag);
          return tag;
        }
        function pushStartGenericElement(target, props, tag) {
          target.push(startChunkForTag(tag));
          var innerHTML = tag = null, propKey;
          for (propKey in props)
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "children":
                    tag = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  default:
                    pushAttribute(target, propKey, propValue);
                }
            }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, tag);
          return "string" === typeof tag ? (target.push(escapeTextForBrowser(tag)), null) : tag;
        }
        function startChunkForTag(tag) {
          var tagStartChunk = validatedTagCache.get(tag);
          if (void 0 === tagStartChunk) {
            if (!VALID_TAG_REGEX.test(tag)) throw Error("Invalid tag: " + tag);
            tagStartChunk = "<" + tag;
            validatedTagCache.set(tag, tagStartChunk);
          }
          return tagStartChunk;
        }
        function pushStartInstance(target$jscomp$0, type, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded) {
          validateProperties$2(type, props);
          "input" !== type && "textarea" !== type && "select" !== type || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = true, "select" === type && props.multiple ? console.error(
            "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
            type
          ) : console.error(
            "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
            type
          ));
          b: if (-1 === type.indexOf("-")) var JSCompiler_inline_result = false;
          else
            switch (type) {
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                JSCompiler_inline_result = false;
                break b;
              default:
                JSCompiler_inline_result = true;
            }
          JSCompiler_inline_result || "string" === typeof props.is || warnUnknownProperties(type, props, null);
          !props.suppressContentEditableWarning && props.contentEditable && null != props.children && console.error(
            "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
          );
          formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE && -1 === type.indexOf("-") && type.toLowerCase() !== type && console.error(
            "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
            type
          );
          switch (type) {
            case "div":
            case "span":
            case "svg":
            case "path":
              break;
            case "a":
              target$jscomp$0.push(startChunkForTag("a"));
              var children = null, innerHTML = null, propKey;
              for (propKey in props)
                if (hasOwnProperty.call(props, propKey)) {
                  var propValue = props[propKey];
                  if (null != propValue)
                    switch (propKey) {
                      case "children":
                        children = propValue;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML = propValue;
                        break;
                      case "href":
                        "" === propValue ? pushStringAttribute(target$jscomp$0, "href", "") : pushAttribute(target$jscomp$0, propKey, propValue);
                        break;
                      default:
                        pushAttribute(target$jscomp$0, propKey, propValue);
                    }
                }
              target$jscomp$0.push(endOfStartTag);
              pushInnerHTML(target$jscomp$0, innerHTML, children);
              if ("string" === typeof children) {
                target$jscomp$0.push(escapeTextForBrowser(children));
                var JSCompiler_inline_result$jscomp$0 = null;
              } else JSCompiler_inline_result$jscomp$0 = children;
              return JSCompiler_inline_result$jscomp$0;
            case "g":
            case "p":
            case "li":
              break;
            case "select":
              checkControlledValueProps("select", props);
              checkSelectProp(props, "value");
              checkSelectProp(props, "defaultValue");
              void 0 === props.value || void 0 === props.defaultValue || didWarnDefaultSelectValue || (console.error(
                "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
              ), didWarnDefaultSelectValue = true);
              target$jscomp$0.push(startChunkForTag("select"));
              var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;
              for (propKey$jscomp$0 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$0)) {
                  var propValue$jscomp$0 = props[propKey$jscomp$0];
                  if (null != propValue$jscomp$0)
                    switch (propKey$jscomp$0) {
                      case "children":
                        children$jscomp$0 = propValue$jscomp$0;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$0 = propValue$jscomp$0;
                        break;
                      case "defaultValue":
                      case "value":
                        break;
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$0,
                          propValue$jscomp$0
                        );
                    }
                }
              target$jscomp$0.push(endOfStartTag);
              pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);
              return children$jscomp$0;
            case "option":
              var selectedValue = formatContext.selectedValue;
              target$jscomp$0.push(startChunkForTag("option"));
              var children$jscomp$1 = null, value = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;
              for (propKey$jscomp$1 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$1)) {
                  var propValue$jscomp$1 = props[propKey$jscomp$1];
                  if (null != propValue$jscomp$1)
                    switch (propKey$jscomp$1) {
                      case "children":
                        children$jscomp$1 = propValue$jscomp$1;
                        break;
                      case "selected":
                        selected = propValue$jscomp$1;
                        didWarnSelectedSetOnOption || (console.error(
                          "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
                        ), didWarnSelectedSetOnOption = true);
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$1 = propValue$jscomp$1;
                        break;
                      case "value":
                        value = propValue$jscomp$1;
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$1,
                          propValue$jscomp$1
                        );
                    }
                }
              if (null != selectedValue) {
                if (null !== value) {
                  checkAttributeStringCoercion(value, "value");
                  var stringValue = "" + value;
                } else
                  null === innerHTML$jscomp$1 || didWarnInvalidOptionInnerHTML || (didWarnInvalidOptionInnerHTML = true, console.error(
                    "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
                  )), stringValue = flattenOptionChildren(children$jscomp$1);
                if (isArrayImpl(selectedValue))
                  for (var i = 0; i < selectedValue.length; i++) {
                    if (checkAttributeStringCoercion(selectedValue[i], "value"), "" + selectedValue[i] === stringValue) {
                      target$jscomp$0.push(' selected=""');
                      break;
                    }
                  }
                else
                  checkAttributeStringCoercion(selectedValue, "select.value"), "" + selectedValue === stringValue && target$jscomp$0.push(' selected=""');
              } else selected && target$jscomp$0.push(' selected=""');
              target$jscomp$0.push(endOfStartTag);
              pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);
              return children$jscomp$1;
            case "textarea":
              checkControlledValueProps("textarea", props);
              void 0 === props.value || void 0 === props.defaultValue || didWarnDefaultTextareaValue || (console.error(
                "Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components"
              ), didWarnDefaultTextareaValue = true);
              target$jscomp$0.push(startChunkForTag("textarea"));
              var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;
              for (propKey$jscomp$2 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$2)) {
                  var propValue$jscomp$2 = props[propKey$jscomp$2];
                  if (null != propValue$jscomp$2)
                    switch (propKey$jscomp$2) {
                      case "children":
                        children$jscomp$2 = propValue$jscomp$2;
                        break;
                      case "value":
                        value$jscomp$0 = propValue$jscomp$2;
                        break;
                      case "defaultValue":
                        defaultValue = propValue$jscomp$2;
                        break;
                      case "dangerouslySetInnerHTML":
                        throw Error(
                          "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                        );
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$2,
                          propValue$jscomp$2
                        );
                    }
                }
              null === value$jscomp$0 && null !== defaultValue && (value$jscomp$0 = defaultValue);
              target$jscomp$0.push(endOfStartTag);
              if (null != children$jscomp$2) {
                console.error(
                  "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
                );
                if (null != value$jscomp$0)
                  throw Error(
                    "If you supply `defaultValue` on a <textarea>, do not pass children."
                  );
                if (isArrayImpl(children$jscomp$2)) {
                  if (1 < children$jscomp$2.length)
                    throw Error("<textarea> can only have at most one child.");
                  checkHtmlStringCoercion(children$jscomp$2[0]);
                  value$jscomp$0 = "" + children$jscomp$2[0];
                }
                checkHtmlStringCoercion(children$jscomp$2);
                value$jscomp$0 = "" + children$jscomp$2;
              }
              "string" === typeof value$jscomp$0 && "\n" === value$jscomp$0[0] && target$jscomp$0.push(leadingNewline);
              null !== value$jscomp$0 && (checkAttributeStringCoercion(value$jscomp$0, "value"), target$jscomp$0.push(escapeTextForBrowser("" + value$jscomp$0)));
              return null;
            case "input":
              checkControlledValueProps("input", props);
              target$jscomp$0.push(startChunkForTag("input"));
              var name = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;
              for (propKey$jscomp$3 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$3)) {
                  var propValue$jscomp$3 = props[propKey$jscomp$3];
                  if (null != propValue$jscomp$3)
                    switch (propKey$jscomp$3) {
                      case "children":
                      case "dangerouslySetInnerHTML":
                        throw Error(
                          "input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      case "name":
                        name = propValue$jscomp$3;
                        break;
                      case "formAction":
                        formAction = propValue$jscomp$3;
                        break;
                      case "formEncType":
                        formEncType = propValue$jscomp$3;
                        break;
                      case "formMethod":
                        formMethod = propValue$jscomp$3;
                        break;
                      case "formTarget":
                        formTarget = propValue$jscomp$3;
                        break;
                      case "defaultChecked":
                        defaultChecked = propValue$jscomp$3;
                        break;
                      case "defaultValue":
                        defaultValue$jscomp$0 = propValue$jscomp$3;
                        break;
                      case "checked":
                        checked = propValue$jscomp$3;
                        break;
                      case "value":
                        value$jscomp$1 = propValue$jscomp$3;
                        break;
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$3,
                          propValue$jscomp$3
                        );
                    }
                }
              null === formAction || "image" === props.type || "submit" === props.type || didWarnFormActionType || (didWarnFormActionType = true, console.error(
                'An input can only specify a formAction along with type="submit" or type="image".'
              ));
              var formData = pushFormActionAttribute(
                target$jscomp$0,
                resumableState,
                renderState,
                formAction,
                formEncType,
                formMethod,
                formTarget,
                name
              );
              null === checked || null === defaultChecked || didWarnDefaultChecked || (console.error(
                "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
                "A component",
                props.type
              ), didWarnDefaultChecked = true);
              null === value$jscomp$1 || null === defaultValue$jscomp$0 || didWarnDefaultInputValue || (console.error(
                "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
                "A component",
                props.type
              ), didWarnDefaultInputValue = true);
              null !== checked ? pushBooleanAttribute(target$jscomp$0, "checked", checked) : null !== defaultChecked && pushBooleanAttribute(target$jscomp$0, "checked", defaultChecked);
              null !== value$jscomp$1 ? pushAttribute(target$jscomp$0, "value", value$jscomp$1) : null !== defaultValue$jscomp$0 && pushAttribute(target$jscomp$0, "value", defaultValue$jscomp$0);
              target$jscomp$0.push(endOfStartTagSelfClosing);
              null != formData && formData.forEach(pushAdditionalFormField, target$jscomp$0);
              return null;
            case "button":
              target$jscomp$0.push(startChunkForTag("button"));
              var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;
              for (propKey$jscomp$4 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$4)) {
                  var propValue$jscomp$4 = props[propKey$jscomp$4];
                  if (null != propValue$jscomp$4)
                    switch (propKey$jscomp$4) {
                      case "children":
                        children$jscomp$3 = propValue$jscomp$4;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$2 = propValue$jscomp$4;
                        break;
                      case "name":
                        name$jscomp$0 = propValue$jscomp$4;
                        break;
                      case "formAction":
                        formAction$jscomp$0 = propValue$jscomp$4;
                        break;
                      case "formEncType":
                        formEncType$jscomp$0 = propValue$jscomp$4;
                        break;
                      case "formMethod":
                        formMethod$jscomp$0 = propValue$jscomp$4;
                        break;
                      case "formTarget":
                        formTarget$jscomp$0 = propValue$jscomp$4;
                        break;
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$4,
                          propValue$jscomp$4
                        );
                    }
                }
              null === formAction$jscomp$0 || null == props.type || "submit" === props.type || didWarnFormActionType || (didWarnFormActionType = true, console.error(
                'A button can only specify a formAction along with type="submit" or no type.'
              ));
              var formData$jscomp$0 = pushFormActionAttribute(
                target$jscomp$0,
                resumableState,
                renderState,
                formAction$jscomp$0,
                formEncType$jscomp$0,
                formMethod$jscomp$0,
                formTarget$jscomp$0,
                name$jscomp$0
              );
              target$jscomp$0.push(endOfStartTag);
              null != formData$jscomp$0 && formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);
              pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);
              if ("string" === typeof children$jscomp$3) {
                target$jscomp$0.push(escapeTextForBrowser(children$jscomp$3));
                var JSCompiler_inline_result$jscomp$1 = null;
              } else JSCompiler_inline_result$jscomp$1 = children$jscomp$3;
              return JSCompiler_inline_result$jscomp$1;
            case "form":
              target$jscomp$0.push(startChunkForTag("form"));
              var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;
              for (propKey$jscomp$5 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$5)) {
                  var propValue$jscomp$5 = props[propKey$jscomp$5];
                  if (null != propValue$jscomp$5)
                    switch (propKey$jscomp$5) {
                      case "children":
                        children$jscomp$4 = propValue$jscomp$5;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$3 = propValue$jscomp$5;
                        break;
                      case "action":
                        formAction$jscomp$1 = propValue$jscomp$5;
                        break;
                      case "encType":
                        formEncType$jscomp$1 = propValue$jscomp$5;
                        break;
                      case "method":
                        formMethod$jscomp$1 = propValue$jscomp$5;
                        break;
                      case "target":
                        formTarget$jscomp$1 = propValue$jscomp$5;
                        break;
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$5,
                          propValue$jscomp$5
                        );
                    }
                }
              var formData$jscomp$1 = null, formActionName = null;
              if ("function" === typeof formAction$jscomp$1) {
                null === formEncType$jscomp$1 && null === formMethod$jscomp$1 || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                  "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
                ));
                null === formTarget$jscomp$1 || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                  "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
                ));
                var customFields = getCustomFormFields(
                  resumableState,
                  formAction$jscomp$1
                );
                null !== customFields ? (formAction$jscomp$1 = customFields.action || "", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(
                  attributeSeparator,
                  "action",
                  attributeAssign,
                  actionJavaScriptURL,
                  attributeEnd
                ), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime(resumableState, renderState));
              }
              null != formAction$jscomp$1 && pushAttribute(target$jscomp$0, "action", formAction$jscomp$1);
              null != formEncType$jscomp$1 && pushAttribute(target$jscomp$0, "encType", formEncType$jscomp$1);
              null != formMethod$jscomp$1 && pushAttribute(target$jscomp$0, "method", formMethod$jscomp$1);
              null != formTarget$jscomp$1 && pushAttribute(target$jscomp$0, "target", formTarget$jscomp$1);
              target$jscomp$0.push(endOfStartTag);
              null !== formActionName && (target$jscomp$0.push('<input type="hidden"'), pushStringAttribute(target$jscomp$0, "name", formActionName), target$jscomp$0.push(endOfStartTagSelfClosing), null != formData$jscomp$1 && formData$jscomp$1.forEach(
                pushAdditionalFormField,
                target$jscomp$0
              ));
              pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);
              if ("string" === typeof children$jscomp$4) {
                target$jscomp$0.push(escapeTextForBrowser(children$jscomp$4));
                var JSCompiler_inline_result$jscomp$2 = null;
              } else JSCompiler_inline_result$jscomp$2 = children$jscomp$4;
              return JSCompiler_inline_result$jscomp$2;
            case "menuitem":
              target$jscomp$0.push(startChunkForTag("menuitem"));
              for (var propKey$jscomp$6 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$6)) {
                  var propValue$jscomp$6 = props[propKey$jscomp$6];
                  if (null != propValue$jscomp$6)
                    switch (propKey$jscomp$6) {
                      case "children":
                      case "dangerouslySetInnerHTML":
                        throw Error(
                          "menuitems cannot have `children` nor `dangerouslySetInnerHTML`."
                        );
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$6,
                          propValue$jscomp$6
                        );
                    }
                }
              target$jscomp$0.push(endOfStartTag);
              return null;
            case "object":
              target$jscomp$0.push(startChunkForTag("object"));
              var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;
              for (propKey$jscomp$7 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$7)) {
                  var propValue$jscomp$7 = props[propKey$jscomp$7];
                  if (null != propValue$jscomp$7)
                    switch (propKey$jscomp$7) {
                      case "children":
                        children$jscomp$5 = propValue$jscomp$7;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$4 = propValue$jscomp$7;
                        break;
                      case "data":
                        checkAttributeStringCoercion(propValue$jscomp$7, "data");
                        var sanitizedValue = sanitizeURL("" + propValue$jscomp$7);
                        if ("" === sanitizedValue) {
                          console.error(
                            'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                            propKey$jscomp$7,
                            propKey$jscomp$7
                          );
                          break;
                        }
                        target$jscomp$0.push(
                          attributeSeparator,
                          "data",
                          attributeAssign,
                          escapeTextForBrowser(sanitizedValue),
                          attributeEnd
                        );
                        break;
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$7,
                          propValue$jscomp$7
                        );
                    }
                }
              target$jscomp$0.push(endOfStartTag);
              pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);
              if ("string" === typeof children$jscomp$5) {
                target$jscomp$0.push(escapeTextForBrowser(children$jscomp$5));
                var JSCompiler_inline_result$jscomp$3 = null;
              } else JSCompiler_inline_result$jscomp$3 = children$jscomp$5;
              return JSCompiler_inline_result$jscomp$3;
            case "title":
              var noscriptTagInScope = formatContext.tagScope & 1, isFallback = formatContext.tagScope & 4;
              if (hasOwnProperty.call(props, "children")) {
                var children$jscomp$6 = props.children, child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;
                Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length ? console.error(
                  "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be common to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.",
                  children$jscomp$6.length
                ) : "function" === typeof child || "symbol" === typeof child ? console.error(
                  "React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.",
                  "function" === typeof child ? "a Function" : "a Sybmol"
                ) : child && child.toString === {}.toString && (null != child.$$typeof ? console.error(
                  "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML."
                ) : console.error(
                  "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>."
                ));
              }
              if (formatContext.insertionMode === SVG_MODE || noscriptTagInScope || null != props.itemProp)
                var JSCompiler_inline_result$jscomp$4 = pushTitleImpl(
                  target$jscomp$0,
                  props
                );
              else
                isFallback ? JSCompiler_inline_result$jscomp$4 = null : (pushTitleImpl(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$4 = void 0);
              return JSCompiler_inline_result$jscomp$4;
            case "link":
              var noscriptTagInScope$jscomp$0 = formatContext.tagScope & 1, isFallback$jscomp$0 = formatContext.tagScope & 4, rel = props.rel, href = props.href, precedence = props.precedence;
              if (formatContext.insertionMode === SVG_MODE || noscriptTagInScope$jscomp$0 || null != props.itemProp || "string" !== typeof rel || "string" !== typeof href || "" === href) {
                "stylesheet" === rel && "string" === typeof props.precedence && ("string" === typeof href && href || console.error(
                  'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.',
                  null === href ? "`null`" : void 0 === href ? "`undefined`" : "" === href ? "an empty string" : 'something with type "' + typeof href + '"'
                ));
                pushLinkImpl(target$jscomp$0, props);
                var JSCompiler_inline_result$jscomp$5 = null;
              } else if ("stylesheet" === props.rel)
                if ("string" !== typeof precedence || null != props.disabled || props.onLoad || props.onError) {
                  if ("string" === typeof precedence) {
                    if (null != props.disabled)
                      console.error(
                        'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.'
                      );
                    else if (props.onLoad || props.onError) {
                      var propDescription = props.onLoad && props.onError ? "`onLoad` and `onError` props" : props.onLoad ? "`onLoad` prop" : "`onError` prop";
                      console.error(
                        'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                        propDescription,
                        propDescription
                      );
                    }
                  }
                  JSCompiler_inline_result$jscomp$5 = pushLinkImpl(
                    target$jscomp$0,
                    props
                  );
                } else {
                  var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(
                    href
                  ) ? resumableState.styleResources[href] : void 0;
                  if (resourceState !== EXISTS) {
                    resumableState.styleResources[href] = EXISTS;
                    styleQueue || (styleQueue = {
                      precedence: escapeTextForBrowser(precedence),
                      rules: [],
                      hrefs: [],
                      sheets: /* @__PURE__ */ new Map()
                    }, renderState.styles.set(precedence, styleQueue));
                    var resource = {
                      state: PENDING$1,
                      props: assign2({}, props, {
                        "data-precedence": props.precedence,
                        precedence: null
                      })
                    };
                    if (resourceState) {
                      2 === resourceState.length && adoptPreloadCredentials(resource.props, resourceState);
                      var preloadResource = renderState.preloads.stylesheets.get(href);
                      preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = PRELOADED;
                    }
                    styleQueue.sheets.set(href, resource);
                    hoistableState && hoistableState.stylesheets.add(resource);
                  } else if (styleQueue) {
                    var _resource = styleQueue.sheets.get(href);
                    _resource && hoistableState && hoistableState.stylesheets.add(_resource);
                  }
                  textEmbedded && target$jscomp$0.push("<!-- -->");
                  JSCompiler_inline_result$jscomp$5 = null;
                }
              else
                props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$5 = pushLinkImpl(
                  target$jscomp$0,
                  props
                ) : (textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$5 = isFallback$jscomp$0 ? null : pushLinkImpl(renderState.hoistableChunks, props));
              return JSCompiler_inline_result$jscomp$5;
            case "script":
              var noscriptTagInScope$jscomp$1 = formatContext.tagScope & 1, asyncProp = props.async;
              if ("string" !== typeof props.src || !props.src || !asyncProp || "function" === typeof asyncProp || "symbol" === typeof asyncProp || props.onLoad || props.onError || formatContext.insertionMode === SVG_MODE || noscriptTagInScope$jscomp$1 || null != props.itemProp)
                var JSCompiler_inline_result$jscomp$6 = pushScriptImpl(
                  target$jscomp$0,
                  props
                );
              else {
                var key = props.src;
                if ("module" === props.type) {
                  var resources = resumableState.moduleScriptResources;
                  var preloads = renderState.preloads.moduleScripts;
                } else
                  resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;
                var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : void 0;
                if (resourceState$jscomp$0 !== EXISTS) {
                  resources[key] = EXISTS;
                  var scriptProps = props;
                  if (resourceState$jscomp$0) {
                    2 === resourceState$jscomp$0.length && (scriptProps = assign2({}, props), adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));
                    var preloadResource$jscomp$0 = preloads.get(key);
                    preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);
                  }
                  var resource$jscomp$0 = [];
                  renderState.scripts.add(resource$jscomp$0);
                  pushScriptImpl(resource$jscomp$0, scriptProps);
                }
                textEmbedded && target$jscomp$0.push("<!-- -->");
                JSCompiler_inline_result$jscomp$6 = null;
              }
              return JSCompiler_inline_result$jscomp$6;
            case "style":
              var noscriptTagInScope$jscomp$2 = formatContext.tagScope & 1;
              if (hasOwnProperty.call(props, "children")) {
                var children$jscomp$7 = props.children, child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;
                ("function" === typeof child$jscomp$0 || "symbol" === typeof child$jscomp$0 || Array.isArray(child$jscomp$0)) && console.error(
                  "React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.",
                  "function" === typeof child$jscomp$0 ? "a Function" : "symbol" === typeof child$jscomp$0 ? "a Sybmol" : "an Array"
                );
              }
              var precedence$jscomp$0 = props.precedence, href$jscomp$0 = props.href, nonce = props.nonce;
              if (formatContext.insertionMode === SVG_MODE || noscriptTagInScope$jscomp$2 || null != props.itemProp || "string" !== typeof precedence$jscomp$0 || "string" !== typeof href$jscomp$0 || "" === href$jscomp$0) {
                target$jscomp$0.push(startChunkForTag("style"));
                var children$jscomp$8 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;
                for (propKey$jscomp$8 in props)
                  if (hasOwnProperty.call(props, propKey$jscomp$8)) {
                    var propValue$jscomp$8 = props[propKey$jscomp$8];
                    if (null != propValue$jscomp$8)
                      switch (propKey$jscomp$8) {
                        case "children":
                          children$jscomp$8 = propValue$jscomp$8;
                          break;
                        case "dangerouslySetInnerHTML":
                          innerHTML$jscomp$5 = propValue$jscomp$8;
                          break;
                        default:
                          pushAttribute(
                            target$jscomp$0,
                            propKey$jscomp$8,
                            propValue$jscomp$8
                          );
                      }
                  }
                target$jscomp$0.push(endOfStartTag);
                var child$jscomp$1 = Array.isArray(children$jscomp$8) ? 2 > children$jscomp$8.length ? children$jscomp$8[0] : null : children$jscomp$8;
                "function" !== typeof child$jscomp$1 && "symbol" !== typeof child$jscomp$1 && null !== child$jscomp$1 && void 0 !== child$jscomp$1 && target$jscomp$0.push(escapeStyleTextContent(child$jscomp$1));
                pushInnerHTML(
                  target$jscomp$0,
                  innerHTML$jscomp$5,
                  children$jscomp$8
                );
                target$jscomp$0.push(endChunkForTag("style"));
                var JSCompiler_inline_result$jscomp$7 = null;
              } else {
                href$jscomp$0.includes(" ") && console.error(
                  'React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is "%s".',
                  href$jscomp$0
                );
                var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0), resourceState$jscomp$1 = resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : void 0;
                if (resourceState$jscomp$1 !== EXISTS) {
                  resumableState.styleResources[href$jscomp$0] = EXISTS;
                  resourceState$jscomp$1 && console.error(
                    'React encountered a hoistable style tag for the same href as a preload: "%s". When using a style tag to inline styles you should not also preload it as a stylsheet.',
                    href$jscomp$0
                  );
                  styleQueue$jscomp$0 || (styleQueue$jscomp$0 = {
                    precedence: escapeTextForBrowser(precedence$jscomp$0),
                    rules: [],
                    hrefs: [],
                    sheets: /* @__PURE__ */ new Map()
                  }, renderState.styles.set(
                    precedence$jscomp$0,
                    styleQueue$jscomp$0
                  ));
                  var nonceStyle = renderState.nonce.style;
                  if (nonceStyle && nonceStyle !== nonce)
                    console.error(
                      'React encountered a style tag with `precedence` "%s" and `nonce` "%s". When React manages style rules using `precedence` it will only include rules if the nonce matches the style nonce "%s" that was included with this render.',
                      precedence$jscomp$0,
                      nonce,
                      nonceStyle
                    );
                  else {
                    !nonceStyle && nonce && console.error(
                      'React encountered a style tag with `precedence` "%s" and `nonce` "%s". When React manages style rules using `precedence` it will only include a nonce attributes if you also provide the same style nonce value as a render option.',
                      precedence$jscomp$0,
                      nonce
                    );
                    styleQueue$jscomp$0.hrefs.push(
                      escapeTextForBrowser(href$jscomp$0)
                    );
                    var target = styleQueue$jscomp$0.rules, children$jscomp$9 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;
                    for (propKey$jscomp$9 in props)
                      if (hasOwnProperty.call(props, propKey$jscomp$9)) {
                        var propValue$jscomp$9 = props[propKey$jscomp$9];
                        if (null != propValue$jscomp$9)
                          switch (propKey$jscomp$9) {
                            case "children":
                              children$jscomp$9 = propValue$jscomp$9;
                              break;
                            case "dangerouslySetInnerHTML":
                              innerHTML$jscomp$6 = propValue$jscomp$9;
                          }
                      }
                    var child$jscomp$2 = Array.isArray(children$jscomp$9) ? 2 > children$jscomp$9.length ? children$jscomp$9[0] : null : children$jscomp$9;
                    "function" !== typeof child$jscomp$2 && "symbol" !== typeof child$jscomp$2 && null !== child$jscomp$2 && void 0 !== child$jscomp$2 && target.push(escapeStyleTextContent(child$jscomp$2));
                    pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$9);
                  }
                }
                styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);
                textEmbedded && target$jscomp$0.push("<!-- -->");
                JSCompiler_inline_result$jscomp$7 = void 0;
              }
              return JSCompiler_inline_result$jscomp$7;
            case "meta":
              var noscriptTagInScope$jscomp$3 = formatContext.tagScope & 1, isFallback$jscomp$1 = formatContext.tagScope & 4;
              if (formatContext.insertionMode === SVG_MODE || noscriptTagInScope$jscomp$3 || null != props.itemProp)
                var JSCompiler_inline_result$jscomp$8 = pushSelfClosing(
                  target$jscomp$0,
                  props,
                  "meta"
                );
              else
                textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$8 = isFallback$jscomp$1 ? null : "string" === typeof props.charSet ? pushSelfClosing(renderState.charsetChunks, props, "meta") : "viewport" === props.name ? pushSelfClosing(renderState.viewportChunks, props, "meta") : pushSelfClosing(
                  renderState.hoistableChunks,
                  props,
                  "meta"
                );
              return JSCompiler_inline_result$jscomp$8;
            case "listing":
            case "pre":
              target$jscomp$0.push(startChunkForTag(type));
              var children$jscomp$10 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;
              for (propKey$jscomp$10 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$10)) {
                  var propValue$jscomp$10 = props[propKey$jscomp$10];
                  if (null != propValue$jscomp$10)
                    switch (propKey$jscomp$10) {
                      case "children":
                        children$jscomp$10 = propValue$jscomp$10;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$7 = propValue$jscomp$10;
                        break;
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$10,
                          propValue$jscomp$10
                        );
                    }
                }
              target$jscomp$0.push(endOfStartTag);
              if (null != innerHTML$jscomp$7) {
                if (null != children$jscomp$10)
                  throw Error(
                    "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                  );
                if ("object" !== typeof innerHTML$jscomp$7 || !("__html" in innerHTML$jscomp$7))
                  throw Error(
                    "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                  );
                var html = innerHTML$jscomp$7.__html;
                null !== html && void 0 !== html && ("string" === typeof html && 0 < html.length && "\n" === html[0] ? target$jscomp$0.push(leadingNewline, html) : (checkHtmlStringCoercion(html), target$jscomp$0.push("" + html)));
              }
              "string" === typeof children$jscomp$10 && "\n" === children$jscomp$10[0] && target$jscomp$0.push(leadingNewline);
              return children$jscomp$10;
            case "img":
              var pictureOrNoScriptTagInScope = formatContext.tagScope & 3, src = props.src, srcSet = props.srcSet;
              if (!("lazy" === props.loading || !src && !srcSet || "string" !== typeof src && null != src || "string" !== typeof srcSet && null != srcSet || "low" === props.fetchPriority || pictureOrNoScriptTagInScope) && ("string" !== typeof src || ":" !== src[4] || "d" !== src[0] && "D" !== src[0] || "a" !== src[1] && "A" !== src[1] || "t" !== src[2] && "T" !== src[2] || "a" !== src[3] && "A" !== src[3]) && ("string" !== typeof srcSet || ":" !== srcSet[4] || "d" !== srcSet[0] && "D" !== srcSet[0] || "a" !== srcSet[1] && "A" !== srcSet[1] || "t" !== srcSet[2] && "T" !== srcSet[2] || "a" !== srcSet[3] && "A" !== srcSet[3])) {
                null !== hoistableState && formatContext.tagScope & 64 && (hoistableState.suspenseyImages = true);
                var sizes = "string" === typeof props.sizes ? props.sizes : void 0, key$jscomp$0 = srcSet ? srcSet + "\n" + (sizes || "") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);
                if (resource$jscomp$1) {
                  if ("high" === props.fetchPriority || 10 > renderState.highImagePreloads.size)
                    promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);
                } else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {
                  resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;
                  var input = props.crossOrigin;
                  var crossOrigin = "string" === typeof input ? "use-credentials" === input ? input : "" : void 0;
                  var headers = renderState.headers, header;
                  headers && 0 < headers.remainingCapacity && "string" !== typeof props.srcSet && ("high" === props.fetchPriority || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader(src, "image", {
                    imageSrcSet: props.srcSet,
                    imageSizes: props.sizes,
                    crossOrigin,
                    integrity: props.integrity,
                    nonce: props.nonce,
                    type: props.type,
                    fetchPriority: props.fetchPriority,
                    referrerPolicy: props.refererPolicy
                  }), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS, headers.highImagePreloads && (headers.highImagePreloads += ", "), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl(resource$jscomp$1, {
                    rel: "preload",
                    as: "image",
                    href: srcSet ? void 0 : src,
                    imageSrcSet: srcSet,
                    imageSizes: sizes,
                    crossOrigin,
                    integrity: props.integrity,
                    type: props.type,
                    fetchPriority: props.fetchPriority,
                    referrerPolicy: props.referrerPolicy
                  }), "high" === props.fetchPriority || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));
                }
              }
              return pushSelfClosing(target$jscomp$0, props, "img");
            case "base":
            case "area":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "keygen":
            case "param":
            case "source":
            case "track":
            case "wbr":
              return pushSelfClosing(target$jscomp$0, props, type);
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              break;
            case "head":
              if (formatContext.insertionMode < HTML_MODE) {
                var preamble = preambleState || renderState.preamble;
                if (preamble.headChunks)
                  throw Error("The `<head>` tag may only be rendered once.");
                null !== preambleState && target$jscomp$0.push("<!--head-->");
                preamble.headChunks = [];
                var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(
                  preamble.headChunks,
                  props,
                  "head"
                );
              } else
                JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
                  target$jscomp$0,
                  props,
                  "head"
                );
              return JSCompiler_inline_result$jscomp$9;
            case "body":
              if (formatContext.insertionMode < HTML_MODE) {
                var preamble$jscomp$0 = preambleState || renderState.preamble;
                if (preamble$jscomp$0.bodyChunks)
                  throw Error("The `<body>` tag may only be rendered once.");
                null !== preambleState && target$jscomp$0.push("<!--body-->");
                preamble$jscomp$0.bodyChunks = [];
                var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(
                  preamble$jscomp$0.bodyChunks,
                  props,
                  "body"
                );
              } else
                JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
                  target$jscomp$0,
                  props,
                  "body"
                );
              return JSCompiler_inline_result$jscomp$10;
            case "html":
              if (formatContext.insertionMode === ROOT_HTML_MODE) {
                var preamble$jscomp$1 = preambleState || renderState.preamble;
                if (preamble$jscomp$1.htmlChunks)
                  throw Error("The `<html>` tag may only be rendered once.");
                null !== preambleState && target$jscomp$0.push("<!--html-->");
                preamble$jscomp$1.htmlChunks = [doctypeChunk];
                var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(
                  preamble$jscomp$1.htmlChunks,
                  props,
                  "html"
                );
              } else
                JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
                  target$jscomp$0,
                  props,
                  "html"
                );
              return JSCompiler_inline_result$jscomp$11;
            default:
              if (-1 !== type.indexOf("-")) {
                target$jscomp$0.push(startChunkForTag(type));
                var children$jscomp$11 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;
                for (propKey$jscomp$11 in props)
                  if (hasOwnProperty.call(props, propKey$jscomp$11)) {
                    var propValue$jscomp$11 = props[propKey$jscomp$11];
                    if (null != propValue$jscomp$11) {
                      var attributeName = propKey$jscomp$11;
                      switch (propKey$jscomp$11) {
                        case "children":
                          children$jscomp$11 = propValue$jscomp$11;
                          break;
                        case "dangerouslySetInnerHTML":
                          innerHTML$jscomp$8 = propValue$jscomp$11;
                          break;
                        case "style":
                          pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);
                          break;
                        case "suppressContentEditableWarning":
                        case "suppressHydrationWarning":
                        case "ref":
                          break;
                        case "className":
                          attributeName = "class";
                        default:
                          if (isAttributeNameSafe(propKey$jscomp$11) && "function" !== typeof propValue$jscomp$11 && "symbol" !== typeof propValue$jscomp$11 && false !== propValue$jscomp$11) {
                            if (true === propValue$jscomp$11)
                              propValue$jscomp$11 = "";
                            else if ("object" === typeof propValue$jscomp$11)
                              continue;
                            target$jscomp$0.push(
                              attributeSeparator,
                              attributeName,
                              attributeAssign,
                              escapeTextForBrowser(propValue$jscomp$11),
                              attributeEnd
                            );
                          }
                      }
                    }
                  }
                target$jscomp$0.push(endOfStartTag);
                pushInnerHTML(
                  target$jscomp$0,
                  innerHTML$jscomp$8,
                  children$jscomp$11
                );
                return children$jscomp$11;
              }
          }
          return pushStartGenericElement(target$jscomp$0, props, type);
        }
        function endChunkForTag(tag) {
          var chunk = endTagCache.get(tag);
          void 0 === chunk && (chunk = "</" + tag + ">", endTagCache.set(tag, chunk));
          return chunk;
        }
        function hoistPreambleState(renderState, preambleState) {
          renderState = renderState.preamble;
          null === renderState.htmlChunks && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks);
          null === renderState.headChunks && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks);
          null === renderState.bodyChunks && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks);
        }
        function writeBootstrap(destination, renderState) {
          renderState = renderState.bootstrapChunks;
          for (var i = 0; i < renderState.length - 1; i++)
            destination.push(renderState[i]);
          return i < renderState.length ? (i = renderState[i], renderState.length = 0, destination.push(i)) : true;
        }
        function writeStartPendingSuspenseBoundary(destination, renderState, id) {
          destination.push(startPendingSuspenseBoundary1);
          if (null === id)
            throw Error(
              "An ID must have been assigned before we can complete the boundary."
            );
          destination.push(renderState.boundaryPrefix);
          renderState = id.toString(16);
          destination.push(renderState);
          return destination.push(startPendingSuspenseBoundary2);
        }
        function writeStartSegment(destination, renderState, formatContext, id) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_HTML_MODE:
            case HTML_HEAD_MODE:
            case HTML_MODE:
              return destination.push(startSegmentHTML), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentHTML2);
            case SVG_MODE:
              return destination.push(startSegmentSVG), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentSVG2);
            case MATHML_MODE:
              return destination.push(startSegmentMathML), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentMathML2);
            case HTML_TABLE_MODE:
              return destination.push(startSegmentTable), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentTable2);
            case HTML_TABLE_BODY_MODE:
              return destination.push(startSegmentTableBody), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentTableBody2);
            case HTML_TABLE_ROW_MODE:
              return destination.push(startSegmentTableRow), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentTableRow2);
            case HTML_COLGROUP_MODE:
              return destination.push(startSegmentColGroup), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentColGroup2);
            default:
              throw Error("Unknown insertion mode. This is a bug in React.");
          }
        }
        function writeEndSegment(destination, formatContext) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_HTML_MODE:
            case HTML_HEAD_MODE:
            case HTML_MODE:
              return destination.push(endSegmentHTML);
            case SVG_MODE:
              return destination.push(endSegmentSVG);
            case MATHML_MODE:
              return destination.push(endSegmentMathML);
            case HTML_TABLE_MODE:
              return destination.push(endSegmentTable);
            case HTML_TABLE_BODY_MODE:
              return destination.push(endSegmentTableBody);
            case HTML_TABLE_ROW_MODE:
              return destination.push(endSegmentTableRow);
            case HTML_COLGROUP_MODE:
              return destination.push(endSegmentColGroup);
            default:
              throw Error("Unknown insertion mode. This is a bug in React.");
          }
        }
        function escapeJSStringsForInstructionScripts(input) {
          return JSON.stringify(input).replace(
            regexForJSStringsInInstructionScripts,
            function(match) {
              switch (match) {
                case "<":
                  return "\\u003c";
                case "\u2028":
                  return "\\u2028";
                case "\u2029":
                  return "\\u2029";
                default:
                  throw Error(
                    "escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
                  );
              }
            }
          );
        }
        function escapeJSObjectForInstructionScripts(input) {
          return JSON.stringify(input).replace(
            regexForJSStringsInScripts,
            function(match) {
              switch (match) {
                case "&":
                  return "\\u0026";
                case ">":
                  return "\\u003e";
                case "<":
                  return "\\u003c";
                case "\u2028":
                  return "\\u2028";
                case "\u2029":
                  return "\\u2029";
                default:
                  throw Error(
                    "escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
                  );
              }
            }
          );
        }
        function flushStyleTagsLateForBoundary(styleQueue) {
          var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
          0 < rules.length && 0 === hrefs.length && console.error(
            "React expected to have at least one href for an a hoistable style but found none. This is a bug in React."
          );
          var i = 0;
          if (hrefs.length) {
            this.push(currentlyFlushingRenderState.startInlineStyle);
            this.push(lateStyleTagResourceOpen1);
            this.push(styleQueue.precedence);
            for (this.push(lateStyleTagResourceOpen2); i < hrefs.length - 1; i++)
              this.push(hrefs[i]), this.push(spaceSeparator);
            this.push(hrefs[i]);
            this.push(lateStyleTagResourceOpen3);
            for (i = 0; i < rules.length; i++) this.push(rules[i]);
            destinationHasCapacity = this.push(lateStyleTagTemplateClose);
            currentlyRenderingBoundaryHasStylesToHoist = true;
            rules.length = 0;
            hrefs.length = 0;
          }
        }
        function hasStylesToHoist(stylesheet) {
          return stylesheet.state !== PREAMBLE ? currentlyRenderingBoundaryHasStylesToHoist = true : false;
        }
        function writeHoistablesForBoundary(destination, hoistableState, renderState) {
          currentlyRenderingBoundaryHasStylesToHoist = false;
          destinationHasCapacity = true;
          currentlyFlushingRenderState = renderState;
          hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);
          currentlyFlushingRenderState = null;
          hoistableState.stylesheets.forEach(hasStylesToHoist);
          currentlyRenderingBoundaryHasStylesToHoist && (renderState.stylesToHoist = true);
          return destinationHasCapacity;
        }
        function flushResource(resource) {
          for (var i = 0; i < resource.length; i++) this.push(resource[i]);
          resource.length = 0;
        }
        function flushStyleInPreamble(stylesheet) {
          pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);
          for (var i = 0; i < stylesheetFlushingQueue.length; i++)
            this.push(stylesheetFlushingQueue[i]);
          stylesheetFlushingQueue.length = 0;
          stylesheet.state = PREAMBLE;
        }
        function flushStylesInPreamble(styleQueue) {
          var hasStylesheets = 0 < styleQueue.sheets.size;
          styleQueue.sheets.forEach(flushStyleInPreamble, this);
          styleQueue.sheets.clear();
          var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
          if (!hasStylesheets || hrefs.length) {
            this.push(currentlyFlushingRenderState.startInlineStyle);
            this.push(styleTagResourceOpen1);
            this.push(styleQueue.precedence);
            styleQueue = 0;
            if (hrefs.length) {
              for (this.push(styleTagResourceOpen2); styleQueue < hrefs.length - 1; styleQueue++)
                this.push(hrefs[styleQueue]), this.push(spaceSeparator);
              this.push(hrefs[styleQueue]);
            }
            this.push(styleTagResourceOpen3);
            for (styleQueue = 0; styleQueue < rules.length; styleQueue++)
              this.push(rules[styleQueue]);
            this.push(styleTagResourceClose);
            rules.length = 0;
            hrefs.length = 0;
          }
        }
        function preloadLateStyle(stylesheet) {
          if (stylesheet.state === PENDING$1) {
            stylesheet.state = PRELOADED;
            var props = stylesheet.props;
            pushLinkImpl(stylesheetFlushingQueue, {
              rel: "preload",
              as: "style",
              href: stylesheet.props.href,
              crossOrigin: props.crossOrigin,
              fetchPriority: props.fetchPriority,
              integrity: props.integrity,
              media: props.media,
              hrefLang: props.hrefLang,
              referrerPolicy: props.referrerPolicy
            });
            for (stylesheet = 0; stylesheet < stylesheetFlushingQueue.length; stylesheet++)
              this.push(stylesheetFlushingQueue[stylesheet]);
            stylesheetFlushingQueue.length = 0;
          }
        }
        function preloadLateStyles(styleQueue) {
          styleQueue.sheets.forEach(preloadLateStyle, this);
          styleQueue.sheets.clear();
        }
        function pushCompletedShellIdAttribute(target, resumableState) {
          (resumableState.instructions & SentCompletedShellId) === NothingSent && (resumableState.instructions |= SentCompletedShellId, target.push(
            completedShellIdAttributeStart,
            escapeTextForBrowser("_" + resumableState.idPrefix + "R_"),
            attributeEnd
          ));
        }
        function writeStyleResourceDependenciesInJS(destination, hoistableState) {
          destination.push(arrayFirstOpenBracket);
          var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
          hoistableState.stylesheets.forEach(function(resource) {
            if (resource.state !== PREAMBLE)
              if (resource.state === LATE)
                destination.push(nextArrayOpenBrackChunk), resource = resource.props.href, checkAttributeStringCoercion(resource, "href"), resource = escapeJSObjectForInstructionScripts("" + resource), destination.push(resource), destination.push(arrayCloseBracket), nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
              else {
                destination.push(nextArrayOpenBrackChunk);
                var precedence = resource.props["data-precedence"], props = resource.props, coercedHref = sanitizeURL("" + resource.props.href);
                coercedHref = escapeJSObjectForInstructionScripts(coercedHref);
                destination.push(coercedHref);
                checkAttributeStringCoercion(precedence, "precedence");
                precedence = "" + precedence;
                destination.push(arrayInterstitial);
                precedence = escapeJSObjectForInstructionScripts(precedence);
                destination.push(precedence);
                for (var propKey in props)
                  if (hasOwnProperty.call(props, propKey) && (precedence = props[propKey], null != precedence))
                    switch (propKey) {
                      case "href":
                      case "rel":
                      case "precedence":
                      case "data-precedence":
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        throw Error(
                          "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      default:
                        writeStyleResourceAttributeInJS(
                          destination,
                          propKey,
                          precedence
                        );
                    }
                destination.push(arrayCloseBracket);
                nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
                resource.state = LATE;
              }
          });
          destination.push(arrayCloseBracket);
        }
        function writeStyleResourceAttributeInJS(destination, name, value) {
          var attributeName = name.toLowerCase();
          switch (typeof value) {
            case "function":
            case "symbol":
              return;
          }
          switch (name) {
            case "innerHTML":
            case "dangerouslySetInnerHTML":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "style":
            case "ref":
              return;
            case "className":
              attributeName = "class";
              checkAttributeStringCoercion(value, attributeName);
              name = "" + value;
              break;
            case "hidden":
              if (false === value) return;
              name = "";
              break;
            case "src":
            case "href":
              value = sanitizeURL(value);
              checkAttributeStringCoercion(value, attributeName);
              name = "" + value;
              break;
            default:
              if (2 < name.length && ("o" === name[0] || "O" === name[0]) && ("n" === name[1] || "N" === name[1]) || !isAttributeNameSafe(name))
                return;
              checkAttributeStringCoercion(value, attributeName);
              name = "" + value;
          }
          destination.push(arrayInterstitial);
          attributeName = escapeJSObjectForInstructionScripts(attributeName);
          destination.push(attributeName);
          destination.push(arrayInterstitial);
          attributeName = escapeJSObjectForInstructionScripts(name);
          destination.push(attributeName);
        }
        function createHoistableState() {
          return { styles: /* @__PURE__ */ new Set(), stylesheets: /* @__PURE__ */ new Set(), suspenseyImages: false };
        }
        function preloadBootstrapScriptOrModule(resumableState, renderState, href, props) {
          (resumableState.scriptResources.hasOwnProperty(href) || resumableState.moduleScriptResources.hasOwnProperty(href)) && console.error(
            'Internal React Error: React expected bootstrap script or module with src "%s" to not have been preloaded already. please file an issue',
            href
          );
          resumableState.scriptResources[href] = EXISTS;
          resumableState.moduleScriptResources[href] = EXISTS;
          resumableState = [];
          pushLinkImpl(resumableState, props);
          renderState.bootstrapScripts.add(resumableState);
        }
        function adoptPreloadCredentials(target, preloadState) {
          null == target.crossOrigin && (target.crossOrigin = preloadState[0]);
          null == target.integrity && (target.integrity = preloadState[1]);
        }
        function getPreloadAsHeader(href, as, params) {
          href = escapeHrefForLinkHeaderURLContext(href);
          as = escapeStringForLinkHeaderQuotedParamValueContext(as, "as");
          as = "<" + href + '>; rel=preload; as="' + as + '"';
          for (var paramName in params)
            hasOwnProperty.call(params, paramName) && (href = params[paramName], "string" === typeof href && (as += "; " + paramName.toLowerCase() + '="' + escapeStringForLinkHeaderQuotedParamValueContext(
              href,
              paramName
            ) + '"'));
          return as;
        }
        function escapeHrefForLinkHeaderURLContext(hrefInput) {
          checkAttributeStringCoercion(hrefInput, "href");
          return ("" + hrefInput).replace(
            regexForHrefInLinkHeaderURLContext,
            escapeHrefForLinkHeaderURLContextReplacer
          );
        }
        function escapeHrefForLinkHeaderURLContextReplacer(match) {
          switch (match) {
            case "<":
              return "%3C";
            case ">":
              return "%3E";
            case "\n":
              return "%0A";
            case "\r":
              return "%0D";
            default:
              throw Error(
                "escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
              );
          }
        }
        function escapeStringForLinkHeaderQuotedParamValueContext(value, name) {
          willCoercionThrow(value) && (console.error(
            "The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.",
            name,
            typeName(value)
          ), testStringCoercion(value));
          return ("" + value).replace(
            regexForLinkHeaderQuotedParamValueContext,
            escapeStringForLinkHeaderQuotedParamValueContextReplacer
          );
        }
        function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {
          switch (match) {
            case '"':
              return "%22";
            case "'":
              return "%27";
            case ";":
              return "%3B";
            case ",":
              return "%2C";
            case "\n":
              return "%0A";
            case "\r":
              return "%0D";
            default:
              throw Error(
                "escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
              );
          }
        }
        function hoistStyleQueueDependency(styleQueue) {
          this.styles.add(styleQueue);
        }
        function hoistStylesheetDependency(stylesheet) {
          this.stylesheets.add(stylesheet);
        }
        function hoistHoistables(parentState, childState) {
          childState.styles.forEach(hoistStyleQueueDependency, parentState);
          childState.stylesheets.forEach(hoistStylesheetDependency, parentState);
          childState.suspenseyImages && (parentState.suspenseyImages = true);
        }
        function createRenderState(resumableState, generateStaticMarkup) {
          var idPrefix = resumableState.idPrefix, bootstrapChunks = [], bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;
          void 0 !== bootstrapScriptContent && (bootstrapChunks.push("<script"), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(
            endOfStartTag,
            escapeEntireInlineScriptContent(bootstrapScriptContent),
            endInlineScript
          ));
          idPrefix = {
            placeholderPrefix: idPrefix + "P:",
            segmentPrefix: idPrefix + "S:",
            boundaryPrefix: idPrefix + "B:",
            startInlineScript: "<script",
            startInlineStyle: "<style",
            preamble: { htmlChunks: null, headChunks: null, bodyChunks: null },
            externalRuntimeScript: null,
            bootstrapChunks,
            importMapChunks: [],
            onHeaders: void 0,
            headers: null,
            resets: {
              font: {},
              dns: {},
              connect: { default: {}, anonymous: {}, credentials: {} },
              image: {},
              style: {}
            },
            charsetChunks: [],
            viewportChunks: [],
            hoistableChunks: [],
            preconnects: /* @__PURE__ */ new Set(),
            fontPreloads: /* @__PURE__ */ new Set(),
            highImagePreloads: /* @__PURE__ */ new Set(),
            styles: /* @__PURE__ */ new Map(),
            bootstrapScripts: /* @__PURE__ */ new Set(),
            scripts: /* @__PURE__ */ new Set(),
            bulkPreloads: /* @__PURE__ */ new Set(),
            preloads: {
              images: /* @__PURE__ */ new Map(),
              stylesheets: /* @__PURE__ */ new Map(),
              scripts: /* @__PURE__ */ new Map(),
              moduleScripts: /* @__PURE__ */ new Map()
            },
            nonce: { script: void 0, style: void 0 },
            hoistableState: null,
            stylesToHoist: false
          };
          if (void 0 !== bootstrapScripts)
            for (bootstrapScriptContent = 0; bootstrapScriptContent < bootstrapScripts.length; bootstrapScriptContent++) {
              var scriptConfig = bootstrapScripts[bootstrapScriptContent], src, crossOrigin = void 0, integrity = void 0, props = {
                rel: "preload",
                as: "script",
                fetchPriority: "low",
                nonce: void 0
              };
              "string" === typeof scriptConfig ? props.href = src = scriptConfig : (props.href = src = scriptConfig.src, props.integrity = integrity = "string" === typeof scriptConfig.integrity ? scriptConfig.integrity : void 0, props.crossOrigin = crossOrigin = "string" === typeof scriptConfig || null == scriptConfig.crossOrigin ? void 0 : "use-credentials" === scriptConfig.crossOrigin ? "use-credentials" : "");
              preloadBootstrapScriptOrModule(resumableState, idPrefix, src, props);
              bootstrapChunks.push(
                '<script src="',
                escapeTextForBrowser(src),
                attributeEnd
              );
              "string" === typeof integrity && bootstrapChunks.push(
                ' integrity="',
                escapeTextForBrowser(integrity),
                attributeEnd
              );
              "string" === typeof crossOrigin && bootstrapChunks.push(
                ' crossorigin="',
                escapeTextForBrowser(crossOrigin),
                attributeEnd
              );
              pushCompletedShellIdAttribute(bootstrapChunks, resumableState);
              bootstrapChunks.push(' async=""><\/script>');
            }
          if (void 0 !== bootstrapModules)
            for (bootstrapScripts = 0; bootstrapScripts < bootstrapModules.length; bootstrapScripts++)
              bootstrapScriptContent = bootstrapModules[bootstrapScripts], crossOrigin = src = void 0, integrity = {
                rel: "modulepreload",
                fetchPriority: "low",
                nonce: void 0
              }, "string" === typeof bootstrapScriptContent ? integrity.href = scriptConfig = bootstrapScriptContent : (integrity.href = scriptConfig = bootstrapScriptContent.src, integrity.integrity = crossOrigin = "string" === typeof bootstrapScriptContent.integrity ? bootstrapScriptContent.integrity : void 0, integrity.crossOrigin = src = "string" === typeof bootstrapScriptContent || null == bootstrapScriptContent.crossOrigin ? void 0 : "use-credentials" === bootstrapScriptContent.crossOrigin ? "use-credentials" : ""), preloadBootstrapScriptOrModule(
                resumableState,
                idPrefix,
                scriptConfig,
                integrity
              ), bootstrapChunks.push(
                '<script type="module" src="',
                escapeTextForBrowser(scriptConfig),
                attributeEnd
              ), "string" === typeof crossOrigin && bootstrapChunks.push(
                ' integrity="',
                escapeTextForBrowser(crossOrigin),
                attributeEnd
              ), "string" === typeof src && bootstrapChunks.push(
                ' crossorigin="',
                escapeTextForBrowser(src),
                attributeEnd
              ), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(' async=""><\/script>');
          return {
            placeholderPrefix: idPrefix.placeholderPrefix,
            segmentPrefix: idPrefix.segmentPrefix,
            boundaryPrefix: idPrefix.boundaryPrefix,
            startInlineScript: idPrefix.startInlineScript,
            startInlineStyle: idPrefix.startInlineStyle,
            preamble: idPrefix.preamble,
            externalRuntimeScript: idPrefix.externalRuntimeScript,
            bootstrapChunks: idPrefix.bootstrapChunks,
            importMapChunks: idPrefix.importMapChunks,
            onHeaders: idPrefix.onHeaders,
            headers: idPrefix.headers,
            resets: idPrefix.resets,
            charsetChunks: idPrefix.charsetChunks,
            viewportChunks: idPrefix.viewportChunks,
            hoistableChunks: idPrefix.hoistableChunks,
            preconnects: idPrefix.preconnects,
            fontPreloads: idPrefix.fontPreloads,
            highImagePreloads: idPrefix.highImagePreloads,
            styles: idPrefix.styles,
            bootstrapScripts: idPrefix.bootstrapScripts,
            scripts: idPrefix.scripts,
            bulkPreloads: idPrefix.bulkPreloads,
            preloads: idPrefix.preloads,
            nonce: idPrefix.nonce,
            stylesToHoist: idPrefix.stylesToHoist,
            generateStaticMarkup
          };
        }
        function pushTextInstance(target, text, renderState, textEmbedded) {
          if (renderState.generateStaticMarkup)
            return target.push(escapeTextForBrowser(text)), false;
          "" === text ? target = textEmbedded : (textEmbedded && target.push("<!-- -->"), target.push(escapeTextForBrowser(text)), target = true);
          return target;
        }
        function pushSegmentFinale(target, renderState, lastPushedText, textEmbedded) {
          renderState.generateStaticMarkup || lastPushedText && textEmbedded && target.push("<!-- -->");
        }
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x) {
                }
            }
          return null;
        }
        function popToNearestCommonAncestor(prev, next) {
          if (prev !== next) {
            prev.context._currentValue2 = prev.parentValue;
            prev = prev.parent;
            var parentNext = next.parent;
            if (null === prev) {
              if (null !== parentNext)
                throw Error(
                  "The stacks must reach the root at the same time. This is a bug in React."
                );
            } else {
              if (null === parentNext)
                throw Error(
                  "The stacks must reach the root at the same time. This is a bug in React."
                );
              popToNearestCommonAncestor(prev, parentNext);
            }
            next.context._currentValue2 = next.value;
          }
        }
        function popAllPrevious(prev) {
          prev.context._currentValue2 = prev.parentValue;
          prev = prev.parent;
          null !== prev && popAllPrevious(prev);
        }
        function pushAllNext(next) {
          var parentNext = next.parent;
          null !== parentNext && pushAllNext(parentNext);
          next.context._currentValue2 = next.value;
        }
        function popPreviousToCommonLevel(prev, next) {
          prev.context._currentValue2 = prev.parentValue;
          prev = prev.parent;
          if (null === prev)
            throw Error(
              "The depth must equal at least at zero before reaching the root. This is a bug in React."
            );
          prev.depth === next.depth ? popToNearestCommonAncestor(prev, next) : popPreviousToCommonLevel(prev, next);
        }
        function popNextToCommonLevel(prev, next) {
          var parentNext = next.parent;
          if (null === parentNext)
            throw Error(
              "The depth must equal at least at zero before reaching the root. This is a bug in React."
            );
          prev.depth === parentNext.depth ? popToNearestCommonAncestor(prev, parentNext) : popNextToCommonLevel(prev, parentNext);
          next.context._currentValue2 = next.value;
        }
        function switchContext(newSnapshot) {
          var prev = currentActiveSnapshot;
          prev !== newSnapshot && (null === prev ? pushAllNext(newSnapshot) : null === newSnapshot ? popAllPrevious(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel(prev, newSnapshot) : popNextToCommonLevel(prev, newSnapshot), currentActiveSnapshot = newSnapshot);
        }
        function warnOnInvalidCallback(callback) {
          if (null !== callback && "function" !== typeof callback) {
            var key = String(callback);
            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(
              "Expected the last optional `callback` argument to be a function. Instead received: %s.",
              callback
            ));
          }
        }
        function warnNoop(publicInstance, callerName) {
          publicInstance = (publicInstance = publicInstance.constructor) && getComponentNameFromType(publicInstance) || "ReactClass";
          var warningKey = publicInstance + "." + callerName;
          didWarnAboutNoopUpdateForComponent[warningKey] || (console.error(
            "Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.",
            callerName,
            publicInstance
          ), didWarnAboutNoopUpdateForComponent[warningKey] = true);
        }
        function pushTreeContext(baseContext, totalChildren, index) {
          var baseIdWithLeadingBit = baseContext.id;
          baseContext = baseContext.overflow;
          var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
          baseIdWithLeadingBit &= ~(1 << baseLength);
          index += 1;
          var length = 32 - clz32(totalChildren) + baseLength;
          if (30 < length) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
            baseIdWithLeadingBit >>= numberOfOverflowBits;
            baseLength -= numberOfOverflowBits;
            return {
              id: 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit,
              overflow: length + baseContext
            };
          }
          return {
            id: 1 << length | index << baseLength | baseIdWithLeadingBit,
            overflow: baseContext
          };
        }
        function clz32Fallback(x) {
          x >>>= 0;
          return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
        }
        function noop() {
        }
        function trackUsedThenable(thenableState2, thenable, index) {
          index = thenableState2[index];
          void 0 === index ? thenableState2.push(thenable) : index !== thenable && (thenable.then(noop, noop), thenable = index);
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
            default:
              "string" === typeof thenable.status ? thenable.then(noop, noop) : (thenableState2 = thenable, thenableState2.status = "pending", thenableState2.then(
                function(fulfilledValue) {
                  if ("pending" === thenable.status) {
                    var fulfilledThenable = thenable;
                    fulfilledThenable.status = "fulfilled";
                    fulfilledThenable.value = fulfilledValue;
                  }
                },
                function(error) {
                  if ("pending" === thenable.status) {
                    var rejectedThenable = thenable;
                    rejectedThenable.status = "rejected";
                    rejectedThenable.reason = error;
                  }
                }
              ));
              switch (thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenable.reason;
              }
              suspendedThenable = thenable;
              throw SuspenseException;
          }
        }
        function getSuspendedThenable() {
          if (null === suspendedThenable)
            throw Error(
              "Expected a suspended thenable. This is a bug in React. Please file an issue."
            );
          var thenable = suspendedThenable;
          suspendedThenable = null;
          return thenable;
        }
        function is(x, y) {
          return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
        }
        function resolveCurrentlyRenderingComponent() {
          if (null === currentlyRenderingComponent)
            throw Error(
              "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
            );
          isInHookUserCodeInDev && console.error(
            "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
          );
          return currentlyRenderingComponent;
        }
        function createHook() {
          if (0 < numberOfReRenders)
            throw Error("Rendered more hooks than during the previous render");
          return { memoizedState: null, queue: null, next: null };
        }
        function createWorkInProgressHook() {
          null === workInProgressHook ? null === firstWorkInProgressHook ? (isReRender = false, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = true, workInProgressHook = firstWorkInProgressHook) : null === workInProgressHook.next ? (isReRender = false, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = true, workInProgressHook = workInProgressHook.next);
          return workInProgressHook;
        }
        function getThenableStateAfterSuspending() {
          var state = thenableState;
          thenableState = null;
          return state;
        }
        function resetHooksState() {
          isInHookUserCodeInDev = false;
          currentlyRenderingKeyPath = currentlyRenderingRequest = currentlyRenderingTask = currentlyRenderingComponent = null;
          didScheduleRenderPhaseUpdate = false;
          firstWorkInProgressHook = null;
          numberOfReRenders = 0;
          workInProgressHook = renderPhaseUpdates = null;
        }
        function readContext(context2) {
          isInHookUserCodeInDev && console.error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
          return context2._currentValue2;
        }
        function basicStateReducer(state, action) {
          return "function" === typeof action ? action(state) : action;
        }
        function useReducer3(reducer2, initialArg, init) {
          reducer2 !== basicStateReducer && (currentHookNameInDev = "useReducer");
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          if (isReRender) {
            init = workInProgressHook.queue;
            initialArg = init.dispatch;
            if (null !== renderPhaseUpdates) {
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(init);
              if (void 0 !== firstRenderPhaseUpdate) {
                renderPhaseUpdates.delete(init);
                init = workInProgressHook.memoizedState;
                do {
                  var action = firstRenderPhaseUpdate.action;
                  isInHookUserCodeInDev = true;
                  init = reducer2(init, action);
                  isInHookUserCodeInDev = false;
                  firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;
                } while (null !== firstRenderPhaseUpdate);
                workInProgressHook.memoizedState = init;
                return [init, initialArg];
              }
            }
            return [workInProgressHook.memoizedState, initialArg];
          }
          isInHookUserCodeInDev = true;
          reducer2 = reducer2 === basicStateReducer ? "function" === typeof initialArg ? initialArg() : initialArg : void 0 !== init ? init(initialArg) : initialArg;
          isInHookUserCodeInDev = false;
          workInProgressHook.memoizedState = reducer2;
          reducer2 = workInProgressHook.queue = { last: null, dispatch: null };
          reducer2 = reducer2.dispatch = dispatchAction.bind(
            null,
            currentlyRenderingComponent,
            reducer2
          );
          return [workInProgressHook.memoizedState, reducer2];
        }
        function useMemo3(nextCreate, deps) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          if (null !== workInProgressHook) {
            var prevState = workInProgressHook.memoizedState;
            if (null !== prevState && null !== deps) {
              a: {
                var JSCompiler_inline_result = prevState[1];
                if (null === JSCompiler_inline_result)
                  console.error(
                    "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
                    currentHookNameInDev
                  ), JSCompiler_inline_result = false;
                else {
                  deps.length !== JSCompiler_inline_result.length && console.error(
                    "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
                    currentHookNameInDev,
                    "[" + deps.join(", ") + "]",
                    "[" + JSCompiler_inline_result.join(", ") + "]"
                  );
                  for (var i = 0; i < JSCompiler_inline_result.length && i < deps.length; i++)
                    if (!objectIs(deps[i], JSCompiler_inline_result[i])) {
                      JSCompiler_inline_result = false;
                      break a;
                    }
                  JSCompiler_inline_result = true;
                }
              }
              if (JSCompiler_inline_result) return prevState[0];
            }
          }
          isInHookUserCodeInDev = true;
          nextCreate = nextCreate();
          isInHookUserCodeInDev = false;
          workInProgressHook.memoizedState = [nextCreate, deps];
          return nextCreate;
        }
        function dispatchAction(componentIdentity, queue, action) {
          if (25 <= numberOfReRenders)
            throw Error(
              "Too many re-renders. React limits the number of renders to prevent an infinite loop."
            );
          if (componentIdentity === currentlyRenderingComponent)
            if (didScheduleRenderPhaseUpdate = true, componentIdentity = { action, next: null }, null === renderPhaseUpdates && (renderPhaseUpdates = /* @__PURE__ */ new Map()), action = renderPhaseUpdates.get(queue), void 0 === action)
              renderPhaseUpdates.set(queue, componentIdentity);
            else {
              for (queue = action; null !== queue.next; ) queue = queue.next;
              queue.next = componentIdentity;
            }
        }
        function throwOnUseEffectEventCall() {
          throw Error(
            "A function wrapped in useEffectEvent can't be called during rendering."
          );
        }
        function unsupportedStartTransition() {
          throw Error("startTransition cannot be called during server rendering.");
        }
        function unsupportedSetOptimisticState() {
          throw Error("Cannot update optimistic state while rendering.");
        }
        function useActionState(action, initialState, permalink) {
          resolveCurrentlyRenderingComponent();
          var actionStateHookIndex = actionStateCounter++, request = currentlyRenderingRequest;
          if ("function" === typeof action.$$FORM_ACTION) {
            var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath;
            request = request.formState;
            var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;
            if (null !== request && "function" === typeof isSignatureEqual) {
              var postbackKey = request[1];
              isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(
                JSON.stringify([
                  componentKeyPath,
                  null,
                  actionStateHookIndex
                ]),
                0
              ), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex = actionStateHookIndex, initialState = request[0]));
            }
            var boundAction = action.bind(null, initialState);
            action = function(payload) {
              boundAction(payload);
            };
            "function" === typeof boundAction.$$FORM_ACTION && (action.$$FORM_ACTION = function(prefix2) {
              prefix2 = boundAction.$$FORM_ACTION(prefix2);
              void 0 !== permalink && (checkAttributeStringCoercion(permalink, "target"), permalink += "", prefix2.action = permalink);
              var formData = prefix2.data;
              formData && (null === nextPostbackStateKey && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(
                JSON.stringify([
                  componentKeyPath,
                  null,
                  actionStateHookIndex
                ]),
                0
              )), formData.append("$ACTION_KEY", nextPostbackStateKey));
              return prefix2;
            });
            return [initialState, action, false];
          }
          var _boundAction = action.bind(null, initialState);
          return [
            initialState,
            function(payload) {
              _boundAction(payload);
            },
            false
          ];
        }
        function unwrapThenable(thenable) {
          var index = thenableIndexCounter;
          thenableIndexCounter += 1;
          null === thenableState && (thenableState = []);
          return trackUsedThenable(thenableState, thenable, index);
        }
        function unsupportedRefresh() {
          throw Error("Cache cannot be refreshed during server rendering.");
        }
        function disabledLog() {
        }
        function disableLogs() {
          if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
        function reenableLogs() {
          disabledDepth--;
          if (0 === disabledDepth) {
            var props = { configurable: true, enumerable: true, writable: true };
            Object.defineProperties(console, {
              log: assign2({}, props, { value: prevLog }),
              info: assign2({}, props, { value: prevInfo }),
              warn: assign2({}, props, { value: prevWarn }),
              error: assign2({}, props, { value: prevError }),
              group: assign2({}, props, { value: prevGroup }),
              groupCollapsed: assign2({}, props, { value: prevGroupCollapsed }),
              groupEnd: assign2({}, props, { value: prevGroupEnd })
            });
          }
          0 > disabledDepth && console.error(
            "disabledDepth fell below zero. This is a bug in React. Please file an issue."
          );
        }
        function formatOwnerStack(error) {
          var prevPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          error = error.stack;
          Error.prepareStackTrace = prevPrepareStackTrace;
          error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
          prevPrepareStackTrace = error.indexOf("\n");
          -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
          prevPrepareStackTrace = error.indexOf("react_stack_bottom_frame");
          -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf(
            "\n",
            prevPrepareStackTrace
          ));
          if (-1 !== prevPrepareStackTrace)
            error = error.slice(0, prevPrepareStackTrace);
          else return "";
          return error;
        }
        function describeBuiltInComponentFrame(name) {
          if (void 0 === prefix)
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
              suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
            }
          return "\n" + prefix + name + suffix;
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) return "";
          var frame = componentFrameCache.get(fn);
          if (void 0 !== frame) return frame;
          reentry = true;
          frame = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher2 = null;
          previousDispatcher2 = ReactSharedInternals.H;
          ReactSharedInternals.H = null;
          disableLogs();
          try {
            var RunInRootFrame = {
              DetermineComponentFrameRoot: function() {
                try {
                  if (construct) {
                    var Fake = function() {
                      throw Error();
                    };
                    Object.defineProperty(Fake.prototype, "props", {
                      set: function() {
                        throw Error();
                      }
                    });
                    if ("object" === typeof Reflect && Reflect.construct) {
                      try {
                        Reflect.construct(Fake, []);
                      } catch (x) {
                        var control = x;
                      }
                      Reflect.construct(fn, [], Fake);
                    } else {
                      try {
                        Fake.call();
                      } catch (x$0) {
                        control = x$0;
                      }
                      fn.call(Fake.prototype);
                    }
                  } else {
                    try {
                      throw Error();
                    } catch (x$1) {
                      control = x$1;
                    }
                    (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                    });
                  }
                } catch (sample) {
                  if (sample && control && "string" === typeof sample.stack)
                    return [sample.stack, control.stack];
                }
                return [null, null];
              }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name"
            );
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name",
              { value: "DetermineComponentFrameRoot" }
            );
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
              var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
              for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
                "DetermineComponentFrameRoot"
              ); )
                namePropDescriptor++;
              for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
                "DetermineComponentFrameRoot"
              ); )
                _RunInRootFrame$Deter++;
              if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
                for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                  _RunInRootFrame$Deter--;
              for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
                if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                  if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                    do
                      if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                        var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                          " at new ",
                          " at "
                        );
                        fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                        "function" === typeof fn && componentFrameCache.set(fn, _frame);
                        return _frame;
                      }
                    while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                  }
                  break;
                }
            }
          } finally {
            reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
          }
          sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
          "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
          return sampleLines;
        }
        function describeComponentStackByType(type) {
          if ("string" === typeof type) return describeBuiltInComponentFrame(type);
          if ("function" === typeof type)
            return type.prototype && type.prototype.isReactComponent ? describeNativeComponentFrame(type, true) : describeNativeComponentFrame(type, false);
          if ("object" === typeof type && null !== type) {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeNativeComponentFrame(type.render, false);
              case REACT_MEMO_TYPE:
                return describeNativeComponentFrame(type.type, false);
              case REACT_LAZY_TYPE:
                var lazyComponent = type, payload = lazyComponent._payload;
                lazyComponent = lazyComponent._init;
                try {
                  type = lazyComponent(payload);
                } catch (x) {
                  return describeBuiltInComponentFrame("Lazy");
                }
                return describeComponentStackByType(type);
            }
            if ("string" === typeof type.name) {
              a: {
                payload = type.name;
                lazyComponent = type.env;
                type = type.debugLocation;
                if (null != type) {
                  type = formatOwnerStack(type);
                  var idx = type.lastIndexOf("\n");
                  type = -1 === idx ? type : type.slice(idx + 1);
                  if (-1 !== type.indexOf(payload)) {
                    payload = "\n" + type;
                    break a;
                  }
                }
                payload = describeBuiltInComponentFrame(
                  payload + (lazyComponent ? " [" + lazyComponent + "]" : "")
                );
              }
              return payload;
            }
          }
          switch (type) {
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
          }
          return "";
        }
        function isEligibleForOutlining(request, boundary) {
          return (500 < boundary.byteSize || false) && null === boundary.contentPreamble;
        }
        function defaultErrorHandler(error) {
          if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
            var JSCompiler_inline_result = error.environmentName;
            error = [error].slice(0);
            "string" === typeof error[0] ? error.splice(
              0,
              1,
              "[%s] " + error[0],
              " " + JSCompiler_inline_result + " "
            ) : error.splice(0, 0, "[%s]", " " + JSCompiler_inline_result + " ");
            error.unshift(console);
            JSCompiler_inline_result = bind.apply(console.error, error);
            JSCompiler_inline_result();
          } else console.error(error);
          return null;
        }
        function RequestInstance(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
          var abortSet = /* @__PURE__ */ new Set();
          this.destination = null;
          this.flushScheduled = false;
          this.resumableState = resumableState;
          this.renderState = renderState;
          this.rootFormatContext = rootFormatContext;
          this.progressiveChunkSize = void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;
          this.status = 10;
          this.fatalError = null;
          this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
          this.completedPreambleSegments = this.completedRootSegment = null;
          this.byteSize = 0;
          this.abortableTasks = abortSet;
          this.pingedTasks = [];
          this.clientRenderedBoundaries = [];
          this.completedBoundaries = [];
          this.partialBoundaries = [];
          this.trackedPostpones = null;
          this.onError = void 0 === onError2 ? defaultErrorHandler : onError2;
          this.onPostpone = void 0 === onPostpone ? noop : onPostpone;
          this.onAllReady = void 0 === onAllReady ? noop : onAllReady;
          this.onShellReady = void 0 === onShellReady ? noop : onShellReady;
          this.onShellError = void 0 === onShellError ? noop : onShellError;
          this.onFatalError = void 0 === onFatalError ? noop : onFatalError;
          this.formState = void 0 === formState ? null : formState;
          this.didWarnForKey = null;
        }
        function createRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
          var now = getCurrentTime();
          1e3 < now - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = now);
          resumableState = new RequestInstance(
            resumableState,
            renderState,
            rootFormatContext,
            progressiveChunkSize,
            onError2,
            onAllReady,
            onShellReady,
            onShellError,
            onFatalError,
            onPostpone,
            formState
          );
          renderState = createPendingSegment(
            resumableState,
            0,
            null,
            rootFormatContext,
            false,
            false
          );
          renderState.parentFlushed = true;
          children = createRenderTask(
            resumableState,
            null,
            children,
            -1,
            null,
            renderState,
            null,
            null,
            resumableState.abortableTasks,
            null,
            rootFormatContext,
            null,
            emptyTreeContext,
            null,
            null,
            emptyContextObject,
            null
          );
          pushComponentStack(children);
          resumableState.pingedTasks.push(children);
          return resumableState;
        }
        function pingTask(request, task) {
          request.pingedTasks.push(task);
          1 === request.pingedTasks.length && (request.flushScheduled = null !== request.destination, performWork(request));
        }
        function createSuspenseBoundary(request, row, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {
          fallbackAbortableTasks = {
            status: PENDING,
            rootSegmentID: -1,
            parentFlushed: false,
            pendingTasks: 0,
            row,
            completedSegments: [],
            byteSize: 0,
            fallbackAbortableTasks,
            errorDigest: null,
            contentState: createHoistableState(),
            fallbackState: createHoistableState(),
            contentPreamble,
            fallbackPreamble,
            trackedContentKeyPath: null,
            trackedFallbackNode: null,
            errorMessage: null,
            errorStack: null,
            errorComponentStack: null
          };
          null !== row && (row.pendingTasks++, contentPreamble = row.boundaries, null !== contentPreamble && (request.allPendingTasks++, fallbackAbortableTasks.pendingTasks++, contentPreamble.push(fallbackAbortableTasks)), request = row.inheritedHoistables, null !== request && hoistHoistables(fallbackAbortableTasks.contentState, request));
          return fallbackAbortableTasks;
        }
        function createRenderTask(request, thenableState2, node, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context2, treeContext, row, componentStack, legacyContext, debugTask) {
          request.allPendingTasks++;
          null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
          null !== row && row.pendingTasks++;
          var task = {
            replay: null,
            node,
            childIndex,
            ping: function() {
              return pingTask(request, task);
            },
            blockedBoundary,
            blockedSegment,
            blockedPreamble,
            hoistableState,
            abortSet,
            keyPath,
            formatContext,
            context: context2,
            treeContext,
            row,
            componentStack,
            thenableState: thenableState2
          };
          task.debugTask = debugTask;
          abortSet.add(task);
          return task;
        }
        function createReplayTask(request, thenableState2, replay, node, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context2, treeContext, row, componentStack, legacyContext, debugTask) {
          request.allPendingTasks++;
          null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
          null !== row && row.pendingTasks++;
          replay.pendingTasks++;
          var task = {
            replay,
            node,
            childIndex,
            ping: function() {
              return pingTask(request, task);
            },
            blockedBoundary,
            blockedSegment: null,
            blockedPreamble: null,
            hoistableState,
            abortSet,
            keyPath,
            formatContext,
            context: context2,
            treeContext,
            row,
            componentStack,
            thenableState: thenableState2
          };
          task.debugTask = debugTask;
          abortSet.add(task);
          return task;
        }
        function createPendingSegment(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {
          return {
            status: PENDING,
            parentFlushed: false,
            id: -1,
            index,
            chunks: [],
            children: [],
            preambleChildren: [],
            parentFormatContext,
            boundary,
            lastPushedText,
            textEmbedded
          };
        }
        function getCurrentStackInDEV() {
          if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack)
            return "";
          var componentStack = currentTaskInDEV.componentStack;
          try {
            var info = "";
            if ("string" === typeof componentStack.type)
              info += describeBuiltInComponentFrame(componentStack.type);
            else if ("function" === typeof componentStack.type) {
              if (!componentStack.owner) {
                var JSCompiler_temp_const = info, fn = componentStack.type, name = fn ? fn.displayName || fn.name : "";
                var JSCompiler_inline_result = name ? describeBuiltInComponentFrame(name) : "";
                info = JSCompiler_temp_const + JSCompiler_inline_result;
              }
            } else
              componentStack.owner || (info += describeComponentStackByType(componentStack.type));
            for (; componentStack; )
              JSCompiler_temp_const = null, null != componentStack.debugStack ? JSCompiler_temp_const = formatOwnerStack(
                componentStack.debugStack
              ) : (JSCompiler_inline_result = componentStack, null != JSCompiler_inline_result.stack && (JSCompiler_temp_const = "string" !== typeof JSCompiler_inline_result.stack ? JSCompiler_inline_result.stack = formatOwnerStack(
                JSCompiler_inline_result.stack
              ) : JSCompiler_inline_result.stack)), (componentStack = componentStack.owner) && JSCompiler_temp_const && (info += "\n" + JSCompiler_temp_const);
            var JSCompiler_inline_result$jscomp$0 = info;
          } catch (x) {
            JSCompiler_inline_result$jscomp$0 = "\nError generating stack: " + x.message + "\n" + x.stack;
          }
          return JSCompiler_inline_result$jscomp$0;
        }
        function pushHaltedAwaitOnComponentStack(task, debugInfo) {
          if (null != debugInfo)
            for (var i = debugInfo.length - 1; 0 <= i; i--) {
              var info = debugInfo[i];
              if ("string" === typeof info.name) break;
              if ("number" === typeof info.time) break;
              if (null != info.awaited) {
                var bestStack = null == info.debugStack ? info.awaited : info;
                if (void 0 !== bestStack.debugStack) {
                  task.componentStack = {
                    parent: task.componentStack,
                    type: info,
                    owner: bestStack.owner,
                    stack: bestStack.debugStack
                  };
                  task.debugTask = bestStack.debugTask;
                  break;
                }
              }
            }
        }
        function pushServerComponentStack(task, debugInfo) {
          if (null != debugInfo)
            for (var i = 0; i < debugInfo.length; i++) {
              var componentInfo = debugInfo[i];
              "string" === typeof componentInfo.name && void 0 !== componentInfo.debugStack && (task.componentStack = {
                parent: task.componentStack,
                type: componentInfo,
                owner: componentInfo.owner,
                stack: componentInfo.debugStack
              }, task.debugTask = componentInfo.debugTask);
            }
        }
        function pushComponentStack(task) {
          var node = task.node;
          if ("object" === typeof node && null !== node)
            switch (node.$$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = node.type, owner = node._owner, stack = node._debugStack;
                pushServerComponentStack(task, node._debugInfo);
                task.debugTask = node._debugTask;
                task.componentStack = {
                  parent: task.componentStack,
                  type,
                  owner,
                  stack
                };
                break;
              case REACT_LAZY_TYPE:
                pushServerComponentStack(task, node._debugInfo);
                break;
              default:
                "function" === typeof node.then && pushServerComponentStack(task, node._debugInfo);
            }
        }
        function replaceSuspenseComponentStackWithSuspenseFallbackStack(componentStack) {
          return null === componentStack ? null : {
            parent: componentStack.parent,
            type: "Suspense Fallback",
            owner: componentStack.owner,
            stack: componentStack.stack
          };
        }
        function getThrownInfo(node$jscomp$0) {
          var errorInfo = {};
          node$jscomp$0 && Object.defineProperty(errorInfo, "componentStack", {
            configurable: true,
            enumerable: true,
            get: function() {
              try {
                var info = "", node = node$jscomp$0;
                do
                  info += describeComponentStackByType(node.type), node = node.parent;
                while (node);
                var stack = info;
              } catch (x) {
                stack = "\nError generating stack: " + x.message + "\n" + x.stack;
              }
              Object.defineProperty(errorInfo, "componentStack", {
                value: stack
              });
              return stack;
            }
          });
          return errorInfo;
        }
        function encodeErrorForBoundary(boundary, digest, error, thrownInfo, wasAborted) {
          boundary.errorDigest = digest;
          error instanceof Error ? (digest = String(error.message), error = String(error.stack)) : (digest = "object" === typeof error && null !== error ? describeObjectForErrorMessage(error) : String(error), error = null);
          wasAborted = wasAborted ? "Switched to client rendering because the server rendering aborted due to:\n\n" : "Switched to client rendering because the server rendering errored:\n\n";
          boundary.errorMessage = wasAborted + digest;
          boundary.errorStack = null !== error ? wasAborted + error : null;
          boundary.errorComponentStack = thrownInfo.componentStack;
        }
        function logRecoverableError(request, error, errorInfo, debugTask) {
          request = request.onError;
          error = debugTask ? debugTask.run(request.bind(null, error, errorInfo)) : request(error, errorInfo);
          if (null != error && "string" !== typeof error)
            console.error(
              'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "%s" instead',
              typeof error
            );
          else return error;
        }
        function fatalError(request, error, errorInfo, debugTask) {
          errorInfo = request.onShellError;
          var onFatalError = request.onFatalError;
          debugTask ? (debugTask.run(errorInfo.bind(null, error)), debugTask.run(onFatalError.bind(null, error))) : (errorInfo(error), onFatalError(error));
          null !== request.destination ? (request.status = CLOSED, request.destination.destroy(error)) : (request.status = 13, request.fatalError = error);
        }
        function finishSuspenseListRow(request, row) {
          unblockSuspenseListRow(request, row.next, row.hoistables);
        }
        function unblockSuspenseListRow(request, unblockedRow, inheritedHoistables) {
          for (; null !== unblockedRow; ) {
            null !== inheritedHoistables && (hoistHoistables(unblockedRow.hoistables, inheritedHoistables), unblockedRow.inheritedHoistables = inheritedHoistables);
            var unblockedBoundaries = unblockedRow.boundaries;
            if (null !== unblockedBoundaries) {
              unblockedRow.boundaries = null;
              for (var i = 0; i < unblockedBoundaries.length; i++) {
                var unblockedBoundary = unblockedBoundaries[i];
                null !== inheritedHoistables && hoistHoistables(
                  unblockedBoundary.contentState,
                  inheritedHoistables
                );
                finishedTask(request, unblockedBoundary, null, null);
              }
            }
            unblockedRow.pendingTasks--;
            if (0 < unblockedRow.pendingTasks) break;
            inheritedHoistables = unblockedRow.hoistables;
            unblockedRow = unblockedRow.next;
          }
        }
        function tryToResolveTogetherRow(request, togetherRow) {
          var boundaries = togetherRow.boundaries;
          if (null !== boundaries && togetherRow.pendingTasks === boundaries.length) {
            for (var allCompleteAndInlinable = true, i = 0; i < boundaries.length; i++) {
              var rowBoundary = boundaries[i];
              if (1 !== rowBoundary.pendingTasks || rowBoundary.parentFlushed || isEligibleForOutlining(request, rowBoundary)) {
                allCompleteAndInlinable = false;
                break;
              }
            }
            allCompleteAndInlinable && unblockSuspenseListRow(request, togetherRow, togetherRow.hoistables);
          }
        }
        function createSuspenseListRow(previousRow) {
          var newRow = {
            pendingTasks: 1,
            boundaries: null,
            hoistables: createHoistableState(),
            inheritedHoistables: null,
            together: false,
            next: null
          };
          null !== previousRow && 0 < previousRow.pendingTasks && (newRow.pendingTasks++, newRow.boundaries = [], previousRow.next = newRow);
          return newRow;
        }
        function renderSuspenseListRows(request, task, keyPath, rows, revealOrder) {
          var prevKeyPath = task.keyPath, prevTreeContext = task.treeContext, prevRow = task.row, previousComponentStack = task.componentStack;
          var previousDebugTask = task.debugTask;
          pushServerComponentStack(task, task.node.props.children._debugInfo);
          task.keyPath = keyPath;
          keyPath = rows.length;
          var previousSuspenseListRow = null;
          if (null !== task.replay) {
            var resumeSlots = task.replay.slots;
            if (null !== resumeSlots && "object" === typeof resumeSlots)
              for (var n = 0; n < keyPath; n++) {
                var i = "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder ? n : keyPath - 1 - n, node = rows[i];
                task.row = previousSuspenseListRow = createSuspenseListRow(
                  previousSuspenseListRow
                );
                task.treeContext = pushTreeContext(prevTreeContext, keyPath, i);
                var resumeSegmentID = resumeSlots[i];
                "number" === typeof resumeSegmentID ? (resumeNode(request, task, resumeSegmentID, node, i), delete resumeSlots[i]) : renderNode(request, task, node, i);
                0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow(request, previousSuspenseListRow);
              }
            else
              for (resumeSlots = 0; resumeSlots < keyPath; resumeSlots++)
                n = "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder ? resumeSlots : keyPath - 1 - resumeSlots, i = rows[n], warnForMissingKey(request, task, i), task.row = previousSuspenseListRow = createSuspenseListRow(previousSuspenseListRow), task.treeContext = pushTreeContext(prevTreeContext, keyPath, n), renderNode(request, task, i, n), 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow(request, previousSuspenseListRow);
          } else if ("backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder)
            for (revealOrder = 0; revealOrder < keyPath; revealOrder++)
              resumeSlots = rows[revealOrder], warnForMissingKey(request, task, resumeSlots), task.row = previousSuspenseListRow = createSuspenseListRow(previousSuspenseListRow), task.treeContext = pushTreeContext(
                prevTreeContext,
                keyPath,
                revealOrder
              ), renderNode(request, task, resumeSlots, revealOrder), 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow(request, previousSuspenseListRow);
          else {
            revealOrder = task.blockedSegment;
            resumeSlots = revealOrder.children.length;
            n = revealOrder.chunks.length;
            for (i = keyPath - 1; 0 <= i; i--) {
              node = rows[i];
              task.row = previousSuspenseListRow = createSuspenseListRow(
                previousSuspenseListRow
              );
              task.treeContext = pushTreeContext(prevTreeContext, keyPath, i);
              resumeSegmentID = createPendingSegment(
                request,
                n,
                null,
                task.formatContext,
                0 === i ? revealOrder.lastPushedText : true,
                true
              );
              revealOrder.children.splice(resumeSlots, 0, resumeSegmentID);
              task.blockedSegment = resumeSegmentID;
              warnForMissingKey(request, task, node);
              try {
                renderNode(request, task, node, i), pushSegmentFinale(
                  resumeSegmentID.chunks,
                  request.renderState,
                  resumeSegmentID.lastPushedText,
                  resumeSegmentID.textEmbedded
                ), resumeSegmentID.status = COMPLETED, 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow(request, previousSuspenseListRow);
              } catch (thrownValue) {
                throw resumeSegmentID.status = 12 === request.status ? ABORTED : ERRORED, thrownValue;
              }
            }
            task.blockedSegment = revealOrder;
            revealOrder.lastPushedText = false;
          }
          null !== prevRow && null !== previousSuspenseListRow && 0 < previousSuspenseListRow.pendingTasks && (prevRow.pendingTasks++, previousSuspenseListRow.next = prevRow);
          task.treeContext = prevTreeContext;
          task.row = prevRow;
          task.keyPath = prevKeyPath;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
        }
        function renderWithHooks(request, task, keyPath, Component, props, secondArg) {
          var prevThenableState = task.thenableState;
          task.thenableState = null;
          currentlyRenderingComponent = {};
          currentlyRenderingTask = task;
          currentlyRenderingRequest = request;
          currentlyRenderingKeyPath = keyPath;
          isInHookUserCodeInDev = false;
          actionStateCounter = localIdCounter = 0;
          actionStateMatchingIndex = -1;
          thenableIndexCounter = 0;
          thenableState = prevThenableState;
          for (request = callComponentInDEV(Component, props, secondArg); didScheduleRenderPhaseUpdate; )
            didScheduleRenderPhaseUpdate = false, actionStateCounter = localIdCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, numberOfReRenders += 1, workInProgressHook = null, request = Component(props, secondArg);
          resetHooksState();
          return request;
        }
        function finishFunctionComponent(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex2) {
          var didEmitActionStateMarkers = false;
          if (0 !== actionStateCount && null !== request.formState) {
            var segment = task.blockedSegment;
            if (null !== segment) {
              didEmitActionStateMarkers = true;
              segment = segment.chunks;
              for (var i = 0; i < actionStateCount; i++)
                i === actionStateMatchingIndex2 ? segment.push("<!--F!-->") : segment.push("<!--F-->");
            }
          }
          actionStateCount = task.keyPath;
          task.keyPath = keyPath;
          hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext(keyPath, 1, 0), renderNode(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode(request, task, children, -1) : renderNodeDestructive(request, task, children, -1);
          task.keyPath = actionStateCount;
        }
        function renderElement(request, task, keyPath, type, props, ref) {
          if ("function" === typeof type)
            if (type.prototype && type.prototype.isReactComponent) {
              var newProps = props;
              if ("ref" in props) {
                newProps = {};
                for (var propName in props)
                  "ref" !== propName && (newProps[propName] = props[propName]);
              }
              var defaultProps = type.defaultProps;
              if (defaultProps) {
                newProps === props && (newProps = assign2({}, newProps, props));
                for (var _propName in defaultProps)
                  void 0 === newProps[_propName] && (newProps[_propName] = defaultProps[_propName]);
              }
              var resolvedProps = newProps;
              var context2 = emptyContextObject, contextType = type.contextType;
              if ("contextType" in type && null !== contextType && (void 0 === contextType || contextType.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(type)) {
                didWarnAboutInvalidateContextType.add(type);
                var addendum = void 0 === contextType ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof contextType ? " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                console.error(
                  "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
                  getComponentNameFromType(type) || "Component",
                  addendum
                );
              }
              "object" === typeof contextType && null !== contextType && (context2 = contextType._currentValue2);
              var instance = new type(resolvedProps, context2);
              if ("function" === typeof type.getDerivedStateFromProps && (null === instance.state || void 0 === instance.state)) {
                var componentName = getComponentNameFromType(type) || "Component";
                didWarnAboutUninitializedState.has(componentName) || (didWarnAboutUninitializedState.add(componentName), console.error(
                  "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
                  componentName,
                  null === instance.state ? "null" : "undefined",
                  componentName
                ));
              }
              if ("function" === typeof type.getDerivedStateFromProps || "function" === typeof instance.getSnapshotBeforeUpdate) {
                var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
                "function" === typeof instance.componentWillMount && true !== instance.componentWillMount.__suppressDeprecationWarning ? foundWillMountName = "componentWillMount" : "function" === typeof instance.UNSAFE_componentWillMount && (foundWillMountName = "UNSAFE_componentWillMount");
                "function" === typeof instance.componentWillReceiveProps && true !== instance.componentWillReceiveProps.__suppressDeprecationWarning ? foundWillReceivePropsName = "componentWillReceiveProps" : "function" === typeof instance.UNSAFE_componentWillReceiveProps && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps");
                "function" === typeof instance.componentWillUpdate && true !== instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
                if (null !== foundWillMountName || null !== foundWillReceivePropsName || null !== foundWillUpdateName) {
                  var _componentName = getComponentNameFromType(type) || "Component", newApiName = "function" === typeof type.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                  didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(
                    _componentName
                  ), console.error(
                    "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                    _componentName,
                    newApiName,
                    null !== foundWillMountName ? "\n  " + foundWillMountName : "",
                    null !== foundWillReceivePropsName ? "\n  " + foundWillReceivePropsName : "",
                    null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
                  ));
                }
              }
              var name = getComponentNameFromType(type) || "Component";
              instance.render || (type.prototype && "function" === typeof type.prototype.render ? console.error(
                "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
                name
              ) : console.error(
                "No `render` method found on the %s instance: you may have forgotten to define `render`.",
                name
              ));
              !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state || console.error(
                "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
                name
              );
              instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved && console.error(
                "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
                name
              );
              instance.contextType && console.error(
                "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
                name
              );
              type.childContextTypes && !didWarnAboutChildContextTypes.has(type) && (didWarnAboutChildContextTypes.add(type), console.error(
                "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
                name
              ));
              type.contextTypes && !didWarnAboutContextTypes$1.has(type) && (didWarnAboutContextTypes$1.add(type), console.error(
                "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
                name
              ));
              "function" === typeof instance.componentShouldUpdate && console.error(
                "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
                name
              );
              type.prototype && type.prototype.isPureReactComponent && "undefined" !== typeof instance.shouldComponentUpdate && console.error(
                "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
                getComponentNameFromType(type) || "A pure component"
              );
              "function" === typeof instance.componentDidUnmount && console.error(
                "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
                name
              );
              "function" === typeof instance.componentDidReceiveProps && console.error(
                "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
                name
              );
              "function" === typeof instance.componentWillRecieveProps && console.error(
                "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
                name
              );
              "function" === typeof instance.UNSAFE_componentWillRecieveProps && console.error(
                "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
                name
              );
              var hasMutatedProps = instance.props !== resolvedProps;
              void 0 !== instance.props && hasMutatedProps && console.error(
                "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
                name
              );
              instance.defaultProps && console.error(
                "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
                name,
                name
              );
              "function" !== typeof instance.getSnapshotBeforeUpdate || "function" === typeof instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type), console.error(
                "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
                getComponentNameFromType(type)
              ));
              "function" === typeof instance.getDerivedStateFromProps && console.error(
                "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
                name
              );
              "function" === typeof instance.getDerivedStateFromError && console.error(
                "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
                name
              );
              "function" === typeof type.getSnapshotBeforeUpdate && console.error(
                "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
                name
              );
              var state = instance.state;
              state && ("object" !== typeof state || isArrayImpl(state)) && console.error("%s.state: must be set to an object or null", name);
              "function" === typeof instance.getChildContext && "object" !== typeof type.childContextTypes && console.error(
                "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
                name
              );
              var initialState = void 0 !== instance.state ? instance.state : null;
              instance.updater = classComponentUpdater;
              instance.props = resolvedProps;
              instance.state = initialState;
              var internalInstance = { queue: [], replace: false };
              instance._reactInternals = internalInstance;
              var contextType$jscomp$0 = type.contextType;
              instance.context = "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 ? contextType$jscomp$0._currentValue2 : emptyContextObject;
              if (instance.state === resolvedProps) {
                var componentName$jscomp$0 = getComponentNameFromType(type) || "Component";
                didWarnAboutDirectlyAssigningPropsToState.has(
                  componentName$jscomp$0
                ) || (didWarnAboutDirectlyAssigningPropsToState.add(
                  componentName$jscomp$0
                ), console.error(
                  "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
                  componentName$jscomp$0
                ));
              }
              var getDerivedStateFromProps = type.getDerivedStateFromProps;
              if ("function" === typeof getDerivedStateFromProps) {
                var partialState = getDerivedStateFromProps(
                  resolvedProps,
                  initialState
                );
                if (void 0 === partialState) {
                  var componentName$jscomp$1 = getComponentNameFromType(type) || "Component";
                  didWarnAboutUndefinedDerivedState.has(componentName$jscomp$1) || (didWarnAboutUndefinedDerivedState.add(componentName$jscomp$1), console.error(
                    "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
                    componentName$jscomp$1
                  ));
                }
                var JSCompiler_inline_result = null === partialState || void 0 === partialState ? initialState : assign2({}, initialState, partialState);
                instance.state = JSCompiler_inline_result;
              }
              if ("function" !== typeof type.getDerivedStateFromProps && "function" !== typeof instance.getSnapshotBeforeUpdate && ("function" === typeof instance.UNSAFE_componentWillMount || "function" === typeof instance.componentWillMount)) {
                var oldState = instance.state;
                if ("function" === typeof instance.componentWillMount) {
                  if (true !== instance.componentWillMount.__suppressDeprecationWarning) {
                    var componentName$jscomp$2 = getComponentNameFromType(type) || "Unknown";
                    didWarnAboutDeprecatedWillMount[componentName$jscomp$2] || (console.warn(
                      "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                      componentName$jscomp$2
                    ), didWarnAboutDeprecatedWillMount[componentName$jscomp$2] = true);
                  }
                  instance.componentWillMount();
                }
                "function" === typeof instance.UNSAFE_componentWillMount && instance.UNSAFE_componentWillMount();
                oldState !== instance.state && (console.error(
                  "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
                  getComponentNameFromType(type) || "Component"
                ), classComponentUpdater.enqueueReplaceState(
                  instance,
                  instance.state,
                  null
                ));
                if (null !== internalInstance.queue && 0 < internalInstance.queue.length) {
                  var oldQueue = internalInstance.queue, oldReplace = internalInstance.replace;
                  internalInstance.queue = null;
                  internalInstance.replace = false;
                  if (oldReplace && 1 === oldQueue.length)
                    instance.state = oldQueue[0];
                  else {
                    for (var nextState = oldReplace ? oldQueue[0] : instance.state, dontMutate = true, i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
                      var partial2 = oldQueue[i], partialState$jscomp$0 = "function" === typeof partial2 ? partial2.call(
                        instance,
                        nextState,
                        resolvedProps,
                        void 0
                      ) : partial2;
                      null != partialState$jscomp$0 && (dontMutate ? (dontMutate = false, nextState = assign2(
                        {},
                        nextState,
                        partialState$jscomp$0
                      )) : assign2(nextState, partialState$jscomp$0));
                    }
                    instance.state = nextState;
                  }
                } else internalInstance.queue = null;
              }
              var nextChildren = callRenderInDEV(instance);
              if (12 === request.status) throw null;
              instance.props !== resolvedProps && (didWarnAboutReassigningProps || console.error(
                "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
                getComponentNameFromType(type) || "a component"
              ), didWarnAboutReassigningProps = true);
              var prevKeyPath = task.keyPath;
              task.keyPath = keyPath;
              renderNodeDestructive(request, task, nextChildren, -1);
              task.keyPath = prevKeyPath;
            } else {
              if (type.prototype && "function" === typeof type.prototype.render) {
                var componentName$jscomp$3 = getComponentNameFromType(type) || "Unknown";
                didWarnAboutBadClass[componentName$jscomp$3] || (console.error(
                  "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
                  componentName$jscomp$3,
                  componentName$jscomp$3
                ), didWarnAboutBadClass[componentName$jscomp$3] = true);
              }
              var value = renderWithHooks(
                request,
                task,
                keyPath,
                type,
                props,
                void 0
              );
              if (12 === request.status) throw null;
              var hasId = 0 !== localIdCounter, actionStateCount = actionStateCounter, actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex;
              if (type.contextTypes) {
                var _componentName$jscomp$0 = getComponentNameFromType(type) || "Unknown";
                didWarnAboutContextTypes[_componentName$jscomp$0] || (didWarnAboutContextTypes[_componentName$jscomp$0] = true, console.error(
                  "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
                  _componentName$jscomp$0
                ));
              }
              type && type.childContextTypes && console.error(
                "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
                type.displayName || type.name || "Component"
              );
              if ("function" === typeof type.getDerivedStateFromProps) {
                var componentName$jscomp$4 = getComponentNameFromType(type) || "Unknown";
                didWarnAboutGetDerivedStateOnFunctionComponent[componentName$jscomp$4] || (console.error(
                  "%s: Function components do not support getDerivedStateFromProps.",
                  componentName$jscomp$4
                ), didWarnAboutGetDerivedStateOnFunctionComponent[componentName$jscomp$4] = true);
              }
              if ("object" === typeof type.contextType && null !== type.contextType) {
                var _componentName2 = getComponentNameFromType(type) || "Unknown";
                didWarnAboutContextTypeOnFunctionComponent[_componentName2] || (console.error(
                  "%s: Function components do not support contextType.",
                  _componentName2
                ), didWarnAboutContextTypeOnFunctionComponent[_componentName2] = true);
              }
              finishFunctionComponent(
                request,
                task,
                keyPath,
                value,
                hasId,
                actionStateCount,
                actionStateMatchingIndex$jscomp$0
              );
            }
          else if ("string" === typeof type) {
            var segment = task.blockedSegment;
            if (null === segment) {
              var children = props.children, prevContext = task.formatContext, prevKeyPath$jscomp$0 = task.keyPath;
              task.formatContext = getChildFormatContext(prevContext, type, props);
              task.keyPath = keyPath;
              renderNode(request, task, children, -1);
              task.formatContext = prevContext;
              task.keyPath = prevKeyPath$jscomp$0;
            } else {
              var _children = pushStartInstance(
                segment.chunks,
                type,
                props,
                request.resumableState,
                request.renderState,
                task.blockedPreamble,
                task.hoistableState,
                task.formatContext,
                segment.lastPushedText
              );
              segment.lastPushedText = false;
              var _prevContext2 = task.formatContext, _prevKeyPath3 = task.keyPath;
              task.keyPath = keyPath;
              if ((task.formatContext = getChildFormatContext(
                _prevContext2,
                type,
                props
              )).insertionMode === HTML_HEAD_MODE) {
                var preambleSegment = createPendingSegment(
                  request,
                  0,
                  null,
                  task.formatContext,
                  false,
                  false
                );
                segment.preambleChildren.push(preambleSegment);
                task.blockedSegment = preambleSegment;
                try {
                  preambleSegment.status = 6, renderNode(request, task, _children, -1), pushSegmentFinale(
                    preambleSegment.chunks,
                    request.renderState,
                    preambleSegment.lastPushedText,
                    preambleSegment.textEmbedded
                  ), preambleSegment.status = COMPLETED;
                } finally {
                  task.blockedSegment = segment;
                }
              } else renderNode(request, task, _children, -1);
              task.formatContext = _prevContext2;
              task.keyPath = _prevKeyPath3;
              a: {
                var target = segment.chunks, resumableState = request.resumableState;
                switch (type) {
                  case "title":
                  case "style":
                  case "script":
                  case "area":
                  case "base":
                  case "br":
                  case "col":
                  case "embed":
                  case "hr":
                  case "img":
                  case "input":
                  case "keygen":
                  case "link":
                  case "meta":
                  case "param":
                  case "source":
                  case "track":
                  case "wbr":
                    break a;
                  case "body":
                    if (_prevContext2.insertionMode <= HTML_HTML_MODE) {
                      resumableState.hasBody = true;
                      break a;
                    }
                    break;
                  case "html":
                    if (_prevContext2.insertionMode === ROOT_HTML_MODE) {
                      resumableState.hasHtml = true;
                      break a;
                    }
                    break;
                  case "head":
                    if (_prevContext2.insertionMode <= HTML_HTML_MODE) break a;
                }
                target.push(endChunkForTag(type));
              }
              segment.lastPushedText = false;
            }
          } else {
            switch (type) {
              case REACT_LEGACY_HIDDEN_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_FRAGMENT_TYPE:
                var prevKeyPath$jscomp$1 = task.keyPath;
                task.keyPath = keyPath;
                renderNodeDestructive(request, task, props.children, -1);
                task.keyPath = prevKeyPath$jscomp$1;
                return;
              case REACT_ACTIVITY_TYPE:
                var segment$jscomp$0 = task.blockedSegment;
                if (null === segment$jscomp$0) {
                  if ("hidden" !== props.mode) {
                    var prevKeyPath$jscomp$2 = task.keyPath;
                    task.keyPath = keyPath;
                    renderNode(request, task, props.children, -1);
                    task.keyPath = prevKeyPath$jscomp$2;
                  }
                } else if ("hidden" !== props.mode) {
                  request.renderState.generateStaticMarkup || segment$jscomp$0.chunks.push("<!--&-->");
                  segment$jscomp$0.lastPushedText = false;
                  var _prevKeyPath4 = task.keyPath;
                  task.keyPath = keyPath;
                  renderNode(request, task, props.children, -1);
                  task.keyPath = _prevKeyPath4;
                  request.renderState.generateStaticMarkup || segment$jscomp$0.chunks.push("<!--/&-->");
                  segment$jscomp$0.lastPushedText = false;
                }
                return;
              case REACT_SUSPENSE_LIST_TYPE:
                a: {
                  var children$jscomp$0 = props.children, revealOrder = props.revealOrder;
                  if ("forwards" === revealOrder || "backwards" === revealOrder || "unstable_legacy-backwards" === revealOrder) {
                    if (isArrayImpl(children$jscomp$0)) {
                      renderSuspenseListRows(
                        request,
                        task,
                        keyPath,
                        children$jscomp$0,
                        revealOrder
                      );
                      break a;
                    }
                    var iteratorFn = getIteratorFn(children$jscomp$0);
                    if (iteratorFn) {
                      var iterator = iteratorFn.call(children$jscomp$0);
                      if (iterator) {
                        validateIterable(
                          task,
                          children$jscomp$0,
                          -1,
                          iterator,
                          iteratorFn
                        );
                        var step = iterator.next();
                        if (!step.done) {
                          var rows = [];
                          do
                            rows.push(step.value), step = iterator.next();
                          while (!step.done);
                          renderSuspenseListRows(
                            request,
                            task,
                            keyPath,
                            children$jscomp$0,
                            revealOrder
                          );
                        }
                        break a;
                      }
                    }
                  }
                  if ("together" === revealOrder) {
                    var _prevKeyPath2 = task.keyPath, prevRow = task.row, newRow = task.row = createSuspenseListRow(null);
                    newRow.boundaries = [];
                    newRow.together = true;
                    task.keyPath = keyPath;
                    renderNodeDestructive(request, task, children$jscomp$0, -1);
                    0 === --newRow.pendingTasks && finishSuspenseListRow(request, newRow);
                    task.keyPath = _prevKeyPath2;
                    task.row = prevRow;
                    null !== prevRow && 0 < newRow.pendingTasks && (prevRow.pendingTasks++, newRow.next = prevRow);
                  } else {
                    var prevKeyPath$jscomp$3 = task.keyPath;
                    task.keyPath = keyPath;
                    renderNodeDestructive(request, task, children$jscomp$0, -1);
                    task.keyPath = prevKeyPath$jscomp$3;
                  }
                }
                return;
              case REACT_VIEW_TRANSITION_TYPE:
              case REACT_SCOPE_TYPE:
                throw Error(
                  "ReactDOMServer does not yet support scope components."
                );
              case REACT_SUSPENSE_TYPE:
                a: if (null !== task.replay) {
                  var _prevKeyPath = task.keyPath, _prevContext = task.formatContext, _prevRow = task.row;
                  task.keyPath = keyPath;
                  task.formatContext = getSuspenseContentFormatContext(
                    request.resumableState,
                    _prevContext
                  );
                  task.row = null;
                  var _content = props.children;
                  try {
                    renderNode(request, task, _content, -1);
                  } finally {
                    task.keyPath = _prevKeyPath, task.formatContext = _prevContext, task.row = _prevRow;
                  }
                } else {
                  var prevKeyPath$jscomp$4 = task.keyPath, prevContext$jscomp$0 = task.formatContext, prevRow$jscomp$0 = task.row, parentBoundary = task.blockedBoundary, parentPreamble = task.blockedPreamble, parentHoistableState = task.hoistableState, parentSegment = task.blockedSegment, fallback = props.fallback, content = props.children, fallbackAbortSet = /* @__PURE__ */ new Set();
                  var newBoundary = createSuspenseBoundary(
                    request,
                    task.row,
                    fallbackAbortSet,
                    null,
                    null
                  );
                  null !== request.trackedPostpones && (newBoundary.trackedContentKeyPath = keyPath);
                  var boundarySegment = createPendingSegment(
                    request,
                    parentSegment.chunks.length,
                    newBoundary,
                    task.formatContext,
                    false,
                    false
                  );
                  parentSegment.children.push(boundarySegment);
                  parentSegment.lastPushedText = false;
                  var contentRootSegment = createPendingSegment(
                    request,
                    0,
                    null,
                    task.formatContext,
                    false,
                    false
                  );
                  contentRootSegment.parentFlushed = true;
                  if (null !== request.trackedPostpones) {
                    var suspenseComponentStack = task.componentStack, fallbackKeyPath = [
                      keyPath[0],
                      "Suspense Fallback",
                      keyPath[2]
                    ], fallbackReplayNode = [
                      fallbackKeyPath[1],
                      fallbackKeyPath[2],
                      [],
                      null
                    ];
                    request.trackedPostpones.workingMap.set(
                      fallbackKeyPath,
                      fallbackReplayNode
                    );
                    newBoundary.trackedFallbackNode = fallbackReplayNode;
                    task.blockedSegment = boundarySegment;
                    task.blockedPreamble = newBoundary.fallbackPreamble;
                    task.keyPath = fallbackKeyPath;
                    task.formatContext = getSuspenseFallbackFormatContext(
                      request.resumableState,
                      prevContext$jscomp$0
                    );
                    task.componentStack = replaceSuspenseComponentStackWithSuspenseFallbackStack(
                      suspenseComponentStack
                    );
                    boundarySegment.status = 6;
                    try {
                      renderNode(request, task, fallback, -1), pushSegmentFinale(
                        boundarySegment.chunks,
                        request.renderState,
                        boundarySegment.lastPushedText,
                        boundarySegment.textEmbedded
                      ), boundarySegment.status = COMPLETED;
                    } catch (thrownValue) {
                      throw boundarySegment.status = 12 === request.status ? ABORTED : ERRORED, thrownValue;
                    } finally {
                      task.blockedSegment = parentSegment, task.blockedPreamble = parentPreamble, task.keyPath = prevKeyPath$jscomp$4, task.formatContext = prevContext$jscomp$0;
                    }
                    var suspendedPrimaryTask = createRenderTask(
                      request,
                      null,
                      content,
                      -1,
                      newBoundary,
                      contentRootSegment,
                      newBoundary.contentPreamble,
                      newBoundary.contentState,
                      task.abortSet,
                      keyPath,
                      getSuspenseContentFormatContext(
                        request.resumableState,
                        task.formatContext
                      ),
                      task.context,
                      task.treeContext,
                      null,
                      suspenseComponentStack,
                      emptyContextObject,
                      task.debugTask
                    );
                    pushComponentStack(suspendedPrimaryTask);
                    request.pingedTasks.push(suspendedPrimaryTask);
                  } else {
                    task.blockedBoundary = newBoundary;
                    task.blockedPreamble = newBoundary.contentPreamble;
                    task.hoistableState = newBoundary.contentState;
                    task.blockedSegment = contentRootSegment;
                    task.keyPath = keyPath;
                    task.formatContext = getSuspenseContentFormatContext(
                      request.resumableState,
                      prevContext$jscomp$0
                    );
                    task.row = null;
                    contentRootSegment.status = 6;
                    try {
                      if (renderNode(request, task, content, -1), pushSegmentFinale(
                        contentRootSegment.chunks,
                        request.renderState,
                        contentRootSegment.lastPushedText,
                        contentRootSegment.textEmbedded
                      ), contentRootSegment.status = COMPLETED, queueCompletedSegment(newBoundary, contentRootSegment), 0 === newBoundary.pendingTasks && newBoundary.status === PENDING) {
                        if (newBoundary.status = COMPLETED, !isEligibleForOutlining(request, newBoundary)) {
                          null !== prevRow$jscomp$0 && 0 === --prevRow$jscomp$0.pendingTasks && finishSuspenseListRow(request, prevRow$jscomp$0);
                          0 === request.pendingRootTasks && task.blockedPreamble && preparePreamble(request);
                          break a;
                        }
                      } else
                        null !== prevRow$jscomp$0 && prevRow$jscomp$0.together && tryToResolveTogetherRow(request, prevRow$jscomp$0);
                    } catch (thrownValue$2) {
                      newBoundary.status = CLIENT_RENDERED;
                      if (12 === request.status) {
                        contentRootSegment.status = ABORTED;
                        var error = request.fatalError;
                      } else
                        contentRootSegment.status = ERRORED, error = thrownValue$2;
                      var thrownInfo = getThrownInfo(task.componentStack);
                      var errorDigest = logRecoverableError(
                        request,
                        error,
                        thrownInfo,
                        task.debugTask
                      );
                      encodeErrorForBoundary(
                        newBoundary,
                        errorDigest,
                        error,
                        thrownInfo,
                        false
                      );
                      untrackBoundary(request, newBoundary);
                    } finally {
                      task.blockedBoundary = parentBoundary, task.blockedPreamble = parentPreamble, task.hoistableState = parentHoistableState, task.blockedSegment = parentSegment, task.keyPath = prevKeyPath$jscomp$4, task.formatContext = prevContext$jscomp$0, task.row = prevRow$jscomp$0;
                    }
                    var suspendedFallbackTask = createRenderTask(
                      request,
                      null,
                      fallback,
                      -1,
                      parentBoundary,
                      boundarySegment,
                      newBoundary.fallbackPreamble,
                      newBoundary.fallbackState,
                      fallbackAbortSet,
                      [keyPath[0], "Suspense Fallback", keyPath[2]],
                      getSuspenseFallbackFormatContext(
                        request.resumableState,
                        task.formatContext
                      ),
                      task.context,
                      task.treeContext,
                      task.row,
                      replaceSuspenseComponentStackWithSuspenseFallbackStack(
                        task.componentStack
                      ),
                      emptyContextObject,
                      task.debugTask
                    );
                    pushComponentStack(suspendedFallbackTask);
                    request.pingedTasks.push(suspendedFallbackTask);
                  }
                }
                return;
            }
            if ("object" === typeof type && null !== type)
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  if ("ref" in props) {
                    var propsWithoutRef = {};
                    for (var key in props)
                      "ref" !== key && (propsWithoutRef[key] = props[key]);
                  } else propsWithoutRef = props;
                  var children$jscomp$1 = renderWithHooks(
                    request,
                    task,
                    keyPath,
                    type.render,
                    propsWithoutRef,
                    ref
                  );
                  finishFunctionComponent(
                    request,
                    task,
                    keyPath,
                    children$jscomp$1,
                    0 !== localIdCounter,
                    actionStateCounter,
                    actionStateMatchingIndex
                  );
                  return;
                case REACT_MEMO_TYPE:
                  renderElement(request, task, keyPath, type.type, props, ref);
                  return;
                case REACT_CONTEXT_TYPE:
                  var value$jscomp$0 = props.value, children$jscomp$2 = props.children;
                  var prevSnapshot = task.context;
                  var prevKeyPath$jscomp$5 = task.keyPath;
                  var prevValue = type._currentValue2;
                  type._currentValue2 = value$jscomp$0;
                  void 0 !== type._currentRenderer2 && null !== type._currentRenderer2 && type._currentRenderer2 !== rendererSigil && console.error(
                    "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
                  );
                  type._currentRenderer2 = rendererSigil;
                  var prevNode = currentActiveSnapshot, newNode = {
                    parent: prevNode,
                    depth: null === prevNode ? 0 : prevNode.depth + 1,
                    context: type,
                    parentValue: prevValue,
                    value: value$jscomp$0
                  };
                  currentActiveSnapshot = newNode;
                  task.context = newNode;
                  task.keyPath = keyPath;
                  renderNodeDestructive(request, task, children$jscomp$2, -1);
                  var prevSnapshot$jscomp$0 = currentActiveSnapshot;
                  if (null === prevSnapshot$jscomp$0)
                    throw Error(
                      "Tried to pop a Context at the root of the app. This is a bug in React."
                    );
                  prevSnapshot$jscomp$0.context !== type && console.error(
                    "The parent context is not the expected context. This is probably a bug in React."
                  );
                  prevSnapshot$jscomp$0.context._currentValue2 = prevSnapshot$jscomp$0.parentValue;
                  void 0 !== type._currentRenderer2 && null !== type._currentRenderer2 && type._currentRenderer2 !== rendererSigil && console.error(
                    "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
                  );
                  type._currentRenderer2 = rendererSigil;
                  var JSCompiler_inline_result$jscomp$0 = currentActiveSnapshot = prevSnapshot$jscomp$0.parent;
                  task.context = JSCompiler_inline_result$jscomp$0;
                  task.keyPath = prevKeyPath$jscomp$5;
                  prevSnapshot !== task.context && console.error(
                    "Popping the context provider did not return back to the original snapshot. This is a bug in React."
                  );
                  return;
                case REACT_CONSUMER_TYPE:
                  var context$jscomp$0 = type._context, render = props.children;
                  "function" !== typeof render && console.error(
                    "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
                  );
                  var newChildren = render(context$jscomp$0._currentValue2), prevKeyPath$jscomp$6 = task.keyPath;
                  task.keyPath = keyPath;
                  renderNodeDestructive(request, task, newChildren, -1);
                  task.keyPath = prevKeyPath$jscomp$6;
                  return;
                case REACT_LAZY_TYPE:
                  var Component = callLazyInitInDEV(type);
                  if (12 === request.status) throw null;
                  renderElement(request, task, keyPath, Component, props, ref);
                  return;
              }
            var info = "";
            if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length)
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            throw Error(
              "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((null == type ? type : typeof type) + "." + info)
            );
          }
        }
        function resumeNode(request, task, segmentId, node, childIndex) {
          var prevReplay = task.replay, blockedBoundary = task.blockedBoundary, resumedSegment = createPendingSegment(
            request,
            0,
            null,
            task.formatContext,
            false,
            false
          );
          resumedSegment.id = segmentId;
          resumedSegment.parentFlushed = true;
          try {
            task.replay = null, task.blockedSegment = resumedSegment, renderNode(request, task, node, childIndex), resumedSegment.status = COMPLETED, null === blockedBoundary ? request.completedRootSegment = resumedSegment : (queueCompletedSegment(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));
          } finally {
            task.replay = prevReplay, task.blockedSegment = null;
          }
        }
        function replayElement(request, task, keyPath, name, keyOrIndex, childIndex, type, props, ref, replay) {
          childIndex = replay.nodes;
          for (var i = 0; i < childIndex.length; i++) {
            var node = childIndex[i];
            if (keyOrIndex === node[1]) {
              if (4 === node.length) {
                if (null !== name && name !== node[0])
                  throw Error(
                    "Expected the resume to render <" + node[0] + "> in this slot but instead it rendered <" + name + ">. The tree doesn't match so React will fallback to client rendering."
                  );
                var childNodes = node[2];
                name = node[3];
                keyOrIndex = task.node;
                task.replay = { nodes: childNodes, slots: name, pendingTasks: 1 };
                try {
                  renderElement(request, task, keyPath, type, props, ref);
                  if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                    throw Error(
                      "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                    );
                  task.replay.pendingTasks--;
                } catch (x) {
                  if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then))
                    throw task.node === keyOrIndex ? task.replay = replay : childIndex.splice(i, 1), x;
                  task.replay.pendingTasks--;
                  type = getThrownInfo(task.componentStack);
                  props = request;
                  request = task.blockedBoundary;
                  keyPath = x;
                  ref = name;
                  name = logRecoverableError(props, keyPath, type, task.debugTask);
                  abortRemainingReplayNodes(
                    props,
                    request,
                    childNodes,
                    ref,
                    keyPath,
                    name,
                    type,
                    false
                  );
                }
                task.replay = replay;
              } else {
                if (type !== REACT_SUSPENSE_TYPE)
                  throw Error(
                    "Expected the resume to render <Suspense> in this slot but instead it rendered <" + (getComponentNameFromType(type) || "Unknown") + ">. The tree doesn't match so React will fallback to client rendering."
                  );
                a: {
                  replay = void 0;
                  name = node[5];
                  type = node[2];
                  ref = node[3];
                  keyOrIndex = null === node[4] ? [] : node[4][2];
                  node = null === node[4] ? null : node[4][3];
                  var prevKeyPath = task.keyPath, prevContext = task.formatContext, prevRow = task.row, previousReplaySet = task.replay, parentBoundary = task.blockedBoundary, parentHoistableState = task.hoistableState, content = props.children, fallback = props.fallback, fallbackAbortSet = /* @__PURE__ */ new Set();
                  props = createSuspenseBoundary(
                    request,
                    task.row,
                    fallbackAbortSet,
                    null,
                    null
                  );
                  props.parentFlushed = true;
                  props.rootSegmentID = name;
                  task.blockedBoundary = props;
                  task.hoistableState = props.contentState;
                  task.keyPath = keyPath;
                  task.formatContext = getSuspenseContentFormatContext(
                    request.resumableState,
                    prevContext
                  );
                  task.row = null;
                  task.replay = { nodes: type, slots: ref, pendingTasks: 1 };
                  try {
                    renderNode(request, task, content, -1);
                    if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                      throw Error(
                        "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                      );
                    task.replay.pendingTasks--;
                    if (0 === props.pendingTasks && props.status === PENDING) {
                      props.status = COMPLETED;
                      request.completedBoundaries.push(props);
                      break a;
                    }
                  } catch (error) {
                    props.status = CLIENT_RENDERED, childNodes = getThrownInfo(task.componentStack), replay = logRecoverableError(
                      request,
                      error,
                      childNodes,
                      task.debugTask
                    ), encodeErrorForBoundary(props, replay, error, childNodes, false), task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);
                  } finally {
                    task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath, task.formatContext = prevContext, task.row = prevRow;
                  }
                  props = createReplayTask(
                    request,
                    null,
                    { nodes: keyOrIndex, slots: node, pendingTasks: 0 },
                    fallback,
                    -1,
                    parentBoundary,
                    props.fallbackState,
                    fallbackAbortSet,
                    [keyPath[0], "Suspense Fallback", keyPath[2]],
                    getSuspenseFallbackFormatContext(
                      request.resumableState,
                      task.formatContext
                    ),
                    task.context,
                    task.treeContext,
                    task.row,
                    replaceSuspenseComponentStackWithSuspenseFallbackStack(
                      task.componentStack
                    ),
                    emptyContextObject,
                    task.debugTask
                  );
                  pushComponentStack(props);
                  request.pingedTasks.push(props);
                }
              }
              childIndex.splice(i, 1);
              break;
            }
          }
        }
        function validateIterable(task, iterable, childIndex, iterator, iteratorFn) {
          if (iterator === iterable) {
            if (-1 !== childIndex || null === task.componentStack || "function" !== typeof task.componentStack.type || "[object GeneratorFunction]" !== Object.prototype.toString.call(task.componentStack.type) || "[object Generator]" !== Object.prototype.toString.call(iterator))
              didWarnAboutGenerators || console.error(
                "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
              ), didWarnAboutGenerators = true;
          } else
            iterable.entries !== iteratorFn || didWarnAboutMaps || (console.error(
              "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
            ), didWarnAboutMaps = true);
        }
        function renderNodeDestructive(request, task, node, childIndex) {
          null !== task.replay && "number" === typeof task.replay.slots ? resumeNode(request, task, task.replay.slots, node, childIndex) : (task.node = node, task.childIndex = childIndex, node = task.componentStack, childIndex = task.debugTask, pushComponentStack(task), retryNode(request, task), task.componentStack = node, task.debugTask = childIndex);
        }
        function retryNode(request, task) {
          var node = task.node, childIndex = task.childIndex;
          if (null !== node) {
            if ("object" === typeof node) {
              switch (node.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = node.type, key = node.key;
                  node = node.props;
                  var refProp = node.ref;
                  refProp = void 0 !== refProp ? refProp : null;
                  var debugTask = task.debugTask, name = getComponentNameFromType(type);
                  key = null == key ? -1 === childIndex ? 0 : childIndex : key;
                  var keyPath = [task.keyPath, name, key];
                  null !== task.replay ? debugTask ? debugTask.run(
                    replayElement.bind(
                      null,
                      request,
                      task,
                      keyPath,
                      name,
                      key,
                      childIndex,
                      type,
                      node,
                      refProp,
                      task.replay
                    )
                  ) : replayElement(
                    request,
                    task,
                    keyPath,
                    name,
                    key,
                    childIndex,
                    type,
                    node,
                    refProp,
                    task.replay
                  ) : debugTask ? debugTask.run(
                    renderElement.bind(
                      null,
                      request,
                      task,
                      keyPath,
                      type,
                      node,
                      refProp
                    )
                  ) : renderElement(request, task, keyPath, type, node, refProp);
                  return;
                case REACT_PORTAL_TYPE:
                  throw Error(
                    "Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render."
                  );
                case REACT_LAZY_TYPE:
                  type = callLazyInitInDEV(node);
                  if (12 === request.status) throw null;
                  renderNodeDestructive(request, task, type, childIndex);
                  return;
              }
              if (isArrayImpl(node)) {
                renderChildrenArray(request, task, node, childIndex);
                return;
              }
              if (key = getIteratorFn(node)) {
                if (type = key.call(node)) {
                  validateIterable(task, node, childIndex, type, key);
                  node = type.next();
                  if (!node.done) {
                    key = [];
                    do
                      key.push(node.value), node = type.next();
                    while (!node.done);
                    renderChildrenArray(request, task, key, childIndex);
                  }
                  return;
                }
              }
              if ("function" === typeof node.then)
                return task.thenableState = null, renderNodeDestructive(
                  request,
                  task,
                  unwrapThenable(node),
                  childIndex
                );
              if (node.$$typeof === REACT_CONTEXT_TYPE)
                return renderNodeDestructive(
                  request,
                  task,
                  node._currentValue2,
                  childIndex
                );
              request = Object.prototype.toString.call(node);
              throw Error(
                "Objects are not valid as a React child (found: " + ("[object Object]" === request ? "object with keys {" + Object.keys(node).join(", ") + "}" : request) + "). If you meant to render a collection of children, use an array instead."
              );
            }
            "string" === typeof node ? (task = task.blockedSegment, null !== task && (task.lastPushedText = pushTextInstance(
              task.chunks,
              node,
              request.renderState,
              task.lastPushedText
            ))) : "number" === typeof node || "bigint" === typeof node ? (task = task.blockedSegment, null !== task && (task.lastPushedText = pushTextInstance(
              task.chunks,
              "" + node,
              request.renderState,
              task.lastPushedText
            ))) : ("function" === typeof node && (request = node.displayName || node.name || "Component", console.error(
              "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.",
              request,
              request
            )), "symbol" === typeof node && console.error(
              "Symbols are not valid as a React child.\n  %s",
              String(node)
            ));
          }
        }
        function warnForMissingKey(request, task, child) {
          if (null !== child && "object" === typeof child && (child.$$typeof === REACT_ELEMENT_TYPE || child.$$typeof === REACT_PORTAL_TYPE) && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {
            if ("object" !== typeof child._store)
              throw Error(
                "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
              );
            child._store.validated = 1;
            var didWarnForKey = request.didWarnForKey;
            null == didWarnForKey && (didWarnForKey = request.didWarnForKey = /* @__PURE__ */ new WeakSet());
            request = task.componentStack;
            if (null !== request && !didWarnForKey.has(request)) {
              didWarnForKey.add(request);
              var componentName = getComponentNameFromType(child.type);
              didWarnForKey = child._owner;
              var parentOwner = request.owner;
              request = "";
              if (parentOwner && "undefined" !== typeof parentOwner.type) {
                var name = getComponentNameFromType(parentOwner.type);
                name && (request = "\n\nCheck the render method of `" + name + "`.");
              }
              request || componentName && (request = "\n\nCheck the top-level render call using <" + componentName + ">.");
              componentName = "";
              null != didWarnForKey && parentOwner !== didWarnForKey && (parentOwner = null, "undefined" !== typeof didWarnForKey.type ? parentOwner = getComponentNameFromType(didWarnForKey.type) : "string" === typeof didWarnForKey.name && (parentOwner = didWarnForKey.name), parentOwner && (componentName = " It was passed a child from " + parentOwner + "."));
              didWarnForKey = task.componentStack;
              task.componentStack = {
                parent: task.componentStack,
                type: child.type,
                owner: child._owner,
                stack: child._debugStack
              };
              console.error(
                'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
                request,
                componentName
              );
              task.componentStack = didWarnForKey;
            }
          }
        }
        function renderChildrenArray(request, task, children, childIndex) {
          var prevKeyPath = task.keyPath, previousComponentStack = task.componentStack;
          var previousDebugTask = task.debugTask;
          pushServerComponentStack(task, task.node._debugInfo);
          if (-1 !== childIndex && (task.keyPath = [task.keyPath, "Fragment", childIndex], null !== task.replay)) {
            for (var replay = task.replay, replayNodes = replay.nodes, j = 0; j < replayNodes.length; j++) {
              var node = replayNodes[j];
              if (node[1] === childIndex) {
                childIndex = node[2];
                node = node[3];
                task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };
                try {
                  renderChildrenArray(request, task, children, -1);
                  if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                    throw Error(
                      "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                    );
                  task.replay.pendingTasks--;
                } catch (x) {
                  if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then))
                    throw x;
                  task.replay.pendingTasks--;
                  var thrownInfo = getThrownInfo(task.componentStack);
                  children = task.blockedBoundary;
                  var error = x, resumeSlots = node;
                  node = logRecoverableError(
                    request,
                    error,
                    thrownInfo,
                    task.debugTask
                  );
                  abortRemainingReplayNodes(
                    request,
                    children,
                    childIndex,
                    resumeSlots,
                    error,
                    node,
                    thrownInfo,
                    false
                  );
                }
                task.replay = replay;
                replayNodes.splice(j, 1);
                break;
              }
            }
            task.keyPath = prevKeyPath;
            task.componentStack = previousComponentStack;
            task.debugTask = previousDebugTask;
            return;
          }
          replay = task.treeContext;
          replayNodes = children.length;
          if (null !== task.replay && (j = task.replay.slots, null !== j && "object" === typeof j)) {
            for (childIndex = 0; childIndex < replayNodes; childIndex++)
              node = children[childIndex], task.treeContext = pushTreeContext(
                replay,
                replayNodes,
                childIndex
              ), error = j[childIndex], "number" === typeof error ? (resumeNode(request, task, error, node, childIndex), delete j[childIndex]) : renderNode(request, task, node, childIndex);
            task.treeContext = replay;
            task.keyPath = prevKeyPath;
            task.componentStack = previousComponentStack;
            task.debugTask = previousDebugTask;
            return;
          }
          for (j = 0; j < replayNodes; j++)
            childIndex = children[j], warnForMissingKey(request, task, childIndex), task.treeContext = pushTreeContext(replay, replayNodes, j), renderNode(request, task, childIndex, j);
          task.treeContext = replay;
          task.keyPath = prevKeyPath;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
        }
        function trackPostponedBoundary(request, trackedPostpones, boundary) {
          boundary.status = POSTPONED;
          boundary.rootSegmentID = request.nextSegmentId++;
          request = boundary.trackedContentKeyPath;
          if (null === request)
            throw Error(
              "It should not be possible to postpone at the root. This is a bug in React."
            );
          var fallbackReplayNode = boundary.trackedFallbackNode, children = [], boundaryNode = trackedPostpones.workingMap.get(request);
          if (void 0 === boundaryNode)
            return boundary = [
              request[1],
              request[2],
              children,
              null,
              fallbackReplayNode,
              boundary.rootSegmentID
            ], trackedPostpones.workingMap.set(request, boundary), addToReplayParent(boundary, request[0], trackedPostpones), boundary;
          boundaryNode[4] = fallbackReplayNode;
          boundaryNode[5] = boundary.rootSegmentID;
          return boundaryNode;
        }
        function trackPostpone(request, trackedPostpones, task, segment) {
          segment.status = POSTPONED;
          var keyPath = task.keyPath, boundary = task.blockedBoundary;
          if (null === boundary)
            segment.id = request.nextSegmentId++, trackedPostpones.rootSlots = segment.id, null !== request.completedRootSegment && (request.completedRootSegment.status = POSTPONED);
          else {
            if (null !== boundary && boundary.status === PENDING) {
              var boundaryNode = trackPostponedBoundary(
                request,
                trackedPostpones,
                boundary
              );
              if (boundary.trackedContentKeyPath === keyPath && -1 === task.childIndex) {
                -1 === segment.id && (segment.id = segment.parentFlushed ? boundary.rootSegmentID : request.nextSegmentId++);
                boundaryNode[3] = segment.id;
                return;
              }
            }
            -1 === segment.id && (segment.id = segment.parentFlushed && null !== boundary ? boundary.rootSegmentID : request.nextSegmentId++);
            if (-1 === task.childIndex)
              null === keyPath ? trackedPostpones.rootSlots = segment.id : (task = trackedPostpones.workingMap.get(keyPath), void 0 === task ? (task = [keyPath[1], keyPath[2], [], segment.id], addToReplayParent(task, keyPath[0], trackedPostpones)) : task[3] = segment.id);
            else {
              if (null === keyPath)
                if (request = trackedPostpones.rootSlots, null === request)
                  request = trackedPostpones.rootSlots = {};
                else {
                  if ("number" === typeof request)
                    throw Error(
                      "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
                    );
                }
              else if (boundary = trackedPostpones.workingMap, boundaryNode = boundary.get(keyPath), void 0 === boundaryNode)
                request = {}, boundaryNode = [keyPath[1], keyPath[2], [], request], boundary.set(keyPath, boundaryNode), addToReplayParent(boundaryNode, keyPath[0], trackedPostpones);
              else if (request = boundaryNode[3], null === request)
                request = boundaryNode[3] = {};
              else if ("number" === typeof request)
                throw Error(
                  "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
                );
              request[task.childIndex] = segment.id;
            }
          }
        }
        function untrackBoundary(request, boundary) {
          request = request.trackedPostpones;
          null !== request && (boundary = boundary.trackedContentKeyPath, null !== boundary && (boundary = request.workingMap.get(boundary), void 0 !== boundary && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));
        }
        function spawnNewSuspendedReplayTask(request, task, thenableState2) {
          return createReplayTask(
            request,
            thenableState2,
            task.replay,
            task.node,
            task.childIndex,
            task.blockedBoundary,
            task.hoistableState,
            task.abortSet,
            task.keyPath,
            task.formatContext,
            task.context,
            task.treeContext,
            task.row,
            task.componentStack,
            emptyContextObject,
            task.debugTask
          );
        }
        function spawnNewSuspendedRenderTask(request, task, thenableState2) {
          var segment = task.blockedSegment, newSegment = createPendingSegment(
            request,
            segment.chunks.length,
            null,
            task.formatContext,
            segment.lastPushedText,
            true
          );
          segment.children.push(newSegment);
          segment.lastPushedText = false;
          return createRenderTask(
            request,
            thenableState2,
            task.node,
            task.childIndex,
            task.blockedBoundary,
            newSegment,
            task.blockedPreamble,
            task.hoistableState,
            task.abortSet,
            task.keyPath,
            task.formatContext,
            task.context,
            task.treeContext,
            task.row,
            task.componentStack,
            emptyContextObject,
            task.debugTask
          );
        }
        function renderNode(request, task, node, childIndex) {
          var previousFormatContext = task.formatContext, previousContext = task.context, previousKeyPath = task.keyPath, previousTreeContext = task.treeContext, previousComponentStack = task.componentStack, previousDebugTask = task.debugTask, segment = task.blockedSegment;
          if (null === segment) {
            segment = task.replay;
            try {
              return renderNodeDestructive(request, task, node, childIndex);
            } catch (thrownValue) {
              if (resetHooksState(), node = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue, 12 !== request.status && "object" === typeof node && null !== node) {
                if ("function" === typeof node.then) {
                  childIndex = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
                  request = spawnNewSuspendedReplayTask(
                    request,
                    task,
                    childIndex
                  ).ping;
                  node.then(request, request);
                  task.formatContext = previousFormatContext;
                  task.context = previousContext;
                  task.keyPath = previousKeyPath;
                  task.treeContext = previousTreeContext;
                  task.componentStack = previousComponentStack;
                  task.replay = segment;
                  task.debugTask = previousDebugTask;
                  switchContext(previousContext);
                  return;
                }
                if ("Maximum call stack size exceeded" === node.message) {
                  node = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
                  node = spawnNewSuspendedReplayTask(request, task, node);
                  request.pingedTasks.push(node);
                  task.formatContext = previousFormatContext;
                  task.context = previousContext;
                  task.keyPath = previousKeyPath;
                  task.treeContext = previousTreeContext;
                  task.componentStack = previousComponentStack;
                  task.replay = segment;
                  task.debugTask = previousDebugTask;
                  switchContext(previousContext);
                  return;
                }
              }
            }
          } else {
            var childrenLength = segment.children.length, chunkLength = segment.chunks.length;
            try {
              return renderNodeDestructive(request, task, node, childIndex);
            } catch (thrownValue$3) {
              if (resetHooksState(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node = thrownValue$3 === SuspenseException ? getSuspendedThenable() : thrownValue$3, 12 !== request.status && "object" === typeof node && null !== node) {
                if ("function" === typeof node.then) {
                  segment = node;
                  node = thrownValue$3 === SuspenseException ? getThenableStateAfterSuspending() : null;
                  request = spawnNewSuspendedRenderTask(request, task, node).ping;
                  segment.then(request, request);
                  task.formatContext = previousFormatContext;
                  task.context = previousContext;
                  task.keyPath = previousKeyPath;
                  task.treeContext = previousTreeContext;
                  task.componentStack = previousComponentStack;
                  task.debugTask = previousDebugTask;
                  switchContext(previousContext);
                  return;
                }
                if ("Maximum call stack size exceeded" === node.message) {
                  segment = thrownValue$3 === SuspenseException ? getThenableStateAfterSuspending() : null;
                  segment = spawnNewSuspendedRenderTask(request, task, segment);
                  request.pingedTasks.push(segment);
                  task.formatContext = previousFormatContext;
                  task.context = previousContext;
                  task.keyPath = previousKeyPath;
                  task.treeContext = previousTreeContext;
                  task.componentStack = previousComponentStack;
                  task.debugTask = previousDebugTask;
                  switchContext(previousContext);
                  return;
                }
              }
            }
          }
          task.formatContext = previousFormatContext;
          task.context = previousContext;
          task.keyPath = previousKeyPath;
          task.treeContext = previousTreeContext;
          switchContext(previousContext);
          throw node;
        }
        function abortTaskSoft(task) {
          var boundary = task.blockedBoundary, segment = task.blockedSegment;
          null !== segment && (segment.status = ABORTED, finishedTask(this, boundary, task.row, segment));
        }
        function abortRemainingReplayNodes(request$jscomp$0, boundary, nodes, slots, error$jscomp$0, errorDigest$jscomp$0, errorInfo$jscomp$0, aborted) {
          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (4 === node.length)
              abortRemainingReplayNodes(
                request$jscomp$0,
                boundary,
                node[2],
                node[3],
                error$jscomp$0,
                errorDigest$jscomp$0,
                errorInfo$jscomp$0,
                aborted
              );
            else {
              var request = request$jscomp$0;
              node = node[5];
              var error = error$jscomp$0, errorDigest = errorDigest$jscomp$0, errorInfo = errorInfo$jscomp$0, wasAborted = aborted, resumedBoundary = createSuspenseBoundary(
                request,
                null,
                /* @__PURE__ */ new Set(),
                null,
                null
              );
              resumedBoundary.parentFlushed = true;
              resumedBoundary.rootSegmentID = node;
              resumedBoundary.status = CLIENT_RENDERED;
              encodeErrorForBoundary(
                resumedBoundary,
                errorDigest,
                error,
                errorInfo,
                wasAborted
              );
              resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);
            }
          }
          nodes.length = 0;
          if (null !== slots) {
            if (null === boundary)
              throw Error(
                "We should not have any resumable nodes in the shell. This is a bug in React."
              );
            boundary.status !== CLIENT_RENDERED && (boundary.status = CLIENT_RENDERED, encodeErrorForBoundary(
              boundary,
              errorDigest$jscomp$0,
              error$jscomp$0,
              errorInfo$jscomp$0,
              aborted
            ), boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));
            if ("object" === typeof slots)
              for (var index in slots) delete slots[index];
          }
        }
        function abortTask(task, request, error) {
          var boundary = task.blockedBoundary, segment = task.blockedSegment;
          if (null !== segment) {
            if (6 === segment.status) return;
            segment.status = ABORTED;
          }
          var errorInfo = getThrownInfo(task.componentStack), node = task.node;
          null !== node && "object" === typeof node && pushHaltedAwaitOnComponentStack(task, node._debugInfo);
          if (null === boundary) {
            if (13 !== request.status && request.status !== CLOSED) {
              boundary = task.replay;
              if (null === boundary) {
                null !== request.trackedPostpones && null !== segment ? (boundary = request.trackedPostpones, logRecoverableError(request, error, errorInfo, task.debugTask), trackPostpone(request, boundary, task, segment), finishedTask(request, null, task.row, segment)) : (logRecoverableError(request, error, errorInfo, task.debugTask), fatalError(request, error, errorInfo, task.debugTask));
                return;
              }
              boundary.pendingTasks--;
              0 === boundary.pendingTasks && 0 < boundary.nodes.length && (segment = logRecoverableError(request, error, errorInfo, null), abortRemainingReplayNodes(
                request,
                null,
                boundary.nodes,
                boundary.slots,
                error,
                segment,
                errorInfo,
                true
              ));
              request.pendingRootTasks--;
              0 === request.pendingRootTasks && completeShell(request);
            }
          } else {
            node = request.trackedPostpones;
            if (boundary.status !== CLIENT_RENDERED) {
              if (null !== node && null !== segment)
                return logRecoverableError(request, error, errorInfo, task.debugTask), trackPostpone(request, node, task, segment), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
                  return abortTask(fallbackTask, request, error);
                }), boundary.fallbackAbortableTasks.clear(), finishedTask(request, boundary, task.row, segment);
              boundary.status = CLIENT_RENDERED;
              segment = logRecoverableError(
                request,
                error,
                errorInfo,
                task.debugTask
              );
              boundary.status = CLIENT_RENDERED;
              encodeErrorForBoundary(boundary, segment, error, errorInfo, true);
              untrackBoundary(request, boundary);
              boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);
            }
            boundary.pendingTasks--;
            errorInfo = boundary.row;
            null !== errorInfo && 0 === --errorInfo.pendingTasks && finishSuspenseListRow(request, errorInfo);
            boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
              return abortTask(fallbackTask, request, error);
            });
            boundary.fallbackAbortableTasks.clear();
          }
          task = task.row;
          null !== task && 0 === --task.pendingTasks && finishSuspenseListRow(request, task);
          request.allPendingTasks--;
          0 === request.allPendingTasks && completeAll(request);
        }
        function safelyEmitEarlyPreloads(request, shellComplete) {
          try {
            var renderState = request.renderState, onHeaders = renderState.onHeaders;
            if (onHeaders) {
              var headers = renderState.headers;
              if (headers) {
                renderState.headers = null;
                var linkHeader = headers.preconnects;
                headers.fontPreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.fontPreloads);
                headers.highImagePreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.highImagePreloads);
                if (!shellComplete) {
                  var queueIter = renderState.styles.values(), queueStep = queueIter.next();
                  b: for (; 0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next())
                    for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next(); 0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {
                      var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props;
                      var header = getPreloadAsHeader(
                        props$jscomp$0.href,
                        "style",
                        {
                          crossOrigin: props$jscomp$0.crossOrigin,
                          integrity: props$jscomp$0.integrity,
                          nonce: props$jscomp$0.nonce,
                          type: props$jscomp$0.type,
                          fetchPriority: props$jscomp$0.fetchPriority,
                          referrerPolicy: props$jscomp$0.referrerPolicy,
                          media: props$jscomp$0.media
                        }
                      );
                      if (0 <= (headers.remainingCapacity -= header.length + 2))
                        renderState.resets.style[key] = PRELOAD_NO_CREDS, linkHeader && (linkHeader += ", "), linkHeader += header, renderState.resets.style[key] = "string" === typeof props.crossOrigin || "string" === typeof props.integrity ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS;
                      else break b;
                    }
                }
                linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});
              }
            }
          } catch (error) {
            logRecoverableError(request, error, {}, null);
          }
        }
        function completeShell(request) {
          null === request.trackedPostpones && safelyEmitEarlyPreloads(request, true);
          null === request.trackedPostpones && preparePreamble(request);
          request.onShellError = noop;
          request = request.onShellReady;
          request();
        }
        function completeAll(request) {
          safelyEmitEarlyPreloads(
            request,
            null === request.trackedPostpones ? true : null === request.completedRootSegment || request.completedRootSegment.status !== POSTPONED
          );
          preparePreamble(request);
          request = request.onAllReady;
          request();
        }
        function queueCompletedSegment(boundary, segment) {
          if (0 === segment.chunks.length && 1 === segment.children.length && null === segment.children[0].boundary && -1 === segment.children[0].id) {
            var childSegment = segment.children[0];
            childSegment.id = segment.id;
            childSegment.parentFlushed = true;
            childSegment.status !== COMPLETED && childSegment.status !== ABORTED && childSegment.status !== ERRORED || queueCompletedSegment(boundary, childSegment);
          } else boundary.completedSegments.push(segment);
        }
        function finishedTask(request, boundary, row, segment) {
          null !== row && (0 === --row.pendingTasks ? finishSuspenseListRow(request, row) : row.together && tryToResolveTogetherRow(request, row));
          request.allPendingTasks--;
          if (null === boundary) {
            if (null !== segment && segment.parentFlushed) {
              if (null !== request.completedRootSegment)
                throw Error(
                  "There can only be one root segment. This is a bug in React."
                );
              request.completedRootSegment = segment;
            }
            request.pendingRootTasks--;
            0 === request.pendingRootTasks && completeShell(request);
          } else if (boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED)
            if (0 === boundary.pendingTasks)
              if (boundary.status === PENDING && (boundary.status = COMPLETED), null !== segment && segment.parentFlushed && (segment.status === COMPLETED || segment.status === ABORTED) && queueCompletedSegment(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), boundary.status === COMPLETED)
                row = boundary.row, null !== row && hoistHoistables(row.hoistables, boundary.contentState), isEligibleForOutlining(request, boundary) || (boundary.fallbackAbortableTasks.forEach(
                  abortTaskSoft,
                  request
                ), boundary.fallbackAbortableTasks.clear(), null !== row && 0 === --row.pendingTasks && finishSuspenseListRow(request, row)), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary.contentPreamble && preparePreamble(request);
              else {
                if (boundary.status === POSTPONED && (boundary = boundary.row, null !== boundary)) {
                  if (null !== request.trackedPostpones) {
                    row = request.trackedPostpones;
                    var postponedRow = boundary.next;
                    if (null !== postponedRow && (segment = postponedRow.boundaries, null !== segment))
                      for (postponedRow.boundaries = null, postponedRow = 0; postponedRow < segment.length; postponedRow++) {
                        var postponedBoundary = segment[postponedRow];
                        trackPostponedBoundary(request, row, postponedBoundary);
                        finishedTask(request, postponedBoundary, null, null);
                      }
                  }
                  0 === --boundary.pendingTasks && finishSuspenseListRow(request, boundary);
                }
              }
            else
              null === segment || !segment.parentFlushed || segment.status !== COMPLETED && segment.status !== ABORTED || (queueCompletedSegment(boundary, segment), 1 === boundary.completedSegments.length && boundary.parentFlushed && request.partialBoundaries.push(boundary)), boundary = boundary.row, null !== boundary && boundary.together && tryToResolveTogetherRow(request, boundary);
          0 === request.allPendingTasks && completeAll(request);
        }
        function performWork(request$jscomp$2) {
          if (request$jscomp$2.status !== CLOSED && 13 !== request$jscomp$2.status) {
            var prevContext = currentActiveSnapshot, prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = HooksDispatcher;
            var prevAsyncDispatcher = ReactSharedInternals.A;
            ReactSharedInternals.A = DefaultAsyncDispatcher;
            var prevRequest = currentRequest;
            currentRequest = request$jscomp$2;
            var prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;
            ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;
            var prevResumableState = currentResumableState;
            currentResumableState = request$jscomp$2.resumableState;
            try {
              var pingedTasks = request$jscomp$2.pingedTasks, i;
              for (i = 0; i < pingedTasks.length; i++) {
                var request = request$jscomp$2, task = pingedTasks[i], segment = task.blockedSegment;
                if (null === segment) {
                  var prevTaskInDEV = void 0, request$jscomp$0 = request;
                  request = task;
                  if (0 !== request.replay.pendingTasks) {
                    switchContext(request.context);
                    prevTaskInDEV = currentTaskInDEV;
                    currentTaskInDEV = request;
                    try {
                      "number" === typeof request.replay.slots ? resumeNode(
                        request$jscomp$0,
                        request,
                        request.replay.slots,
                        request.node,
                        request.childIndex
                      ) : retryNode(request$jscomp$0, request);
                      if (1 === request.replay.pendingTasks && 0 < request.replay.nodes.length)
                        throw Error(
                          "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                        );
                      request.replay.pendingTasks--;
                      request.abortSet.delete(request);
                      finishedTask(
                        request$jscomp$0,
                        request.blockedBoundary,
                        request.row,
                        null
                      );
                    } catch (thrownValue) {
                      resetHooksState();
                      var x = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;
                      if ("object" === typeof x && null !== x && "function" === typeof x.then) {
                        var ping = request.ping;
                        x.then(ping, ping);
                        request.thenableState = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
                      } else {
                        request.replay.pendingTasks--;
                        request.abortSet.delete(request);
                        var errorInfo = getThrownInfo(request.componentStack), errorDigest = void 0, request$jscomp$1 = request$jscomp$0, boundary = request.blockedBoundary, error$jscomp$0 = 12 === request$jscomp$0.status ? request$jscomp$0.fatalError : x, errorInfo$jscomp$0 = errorInfo, replayNodes = request.replay.nodes, resumeSlots = request.replay.slots;
                        errorDigest = logRecoverableError(
                          request$jscomp$1,
                          error$jscomp$0,
                          errorInfo$jscomp$0,
                          request.debugTask
                        );
                        abortRemainingReplayNodes(
                          request$jscomp$1,
                          boundary,
                          replayNodes,
                          resumeSlots,
                          error$jscomp$0,
                          errorDigest,
                          errorInfo$jscomp$0,
                          false
                        );
                        request$jscomp$0.pendingRootTasks--;
                        0 === request$jscomp$0.pendingRootTasks && completeShell(request$jscomp$0);
                        request$jscomp$0.allPendingTasks--;
                        0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);
                      }
                    } finally {
                      currentTaskInDEV = prevTaskInDEV;
                    }
                  }
                } else if (request$jscomp$0 = prevTaskInDEV = void 0, errorDigest = task, request$jscomp$1 = segment, request$jscomp$1.status === PENDING) {
                  request$jscomp$1.status = 6;
                  switchContext(errorDigest.context);
                  request$jscomp$0 = currentTaskInDEV;
                  currentTaskInDEV = errorDigest;
                  var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;
                  try {
                    retryNode(request, errorDigest), pushSegmentFinale(
                      request$jscomp$1.chunks,
                      request.renderState,
                      request$jscomp$1.lastPushedText,
                      request$jscomp$1.textEmbedded
                    ), errorDigest.abortSet.delete(errorDigest), request$jscomp$1.status = COMPLETED, finishedTask(
                      request,
                      errorDigest.blockedBoundary,
                      errorDigest.row,
                      request$jscomp$1
                    );
                  } catch (thrownValue) {
                    resetHooksState();
                    request$jscomp$1.children.length = childrenLength;
                    request$jscomp$1.chunks.length = chunkLength;
                    var x$jscomp$0 = thrownValue === SuspenseException ? getSuspendedThenable() : 12 === request.status ? request.fatalError : thrownValue;
                    if (12 === request.status && null !== request.trackedPostpones) {
                      var trackedPostpones = request.trackedPostpones, thrownInfo = getThrownInfo(errorDigest.componentStack);
                      errorDigest.abortSet.delete(errorDigest);
                      logRecoverableError(
                        request,
                        x$jscomp$0,
                        thrownInfo,
                        errorDigest.debugTask
                      );
                      trackPostpone(
                        request,
                        trackedPostpones,
                        errorDigest,
                        request$jscomp$1
                      );
                      finishedTask(
                        request,
                        errorDigest.blockedBoundary,
                        errorDigest.row,
                        request$jscomp$1
                      );
                    } else if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0 && "function" === typeof x$jscomp$0.then) {
                      request$jscomp$1.status = PENDING;
                      errorDigest.thenableState = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
                      var ping$jscomp$0 = errorDigest.ping;
                      x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
                    } else {
                      var errorInfo$jscomp$1 = getThrownInfo(
                        errorDigest.componentStack
                      );
                      errorDigest.abortSet.delete(errorDigest);
                      request$jscomp$1.status = ERRORED;
                      var boundary$jscomp$0 = errorDigest.blockedBoundary, row = errorDigest.row, debugTask = errorDigest.debugTask;
                      null !== row && 0 === --row.pendingTasks && finishSuspenseListRow(request, row);
                      request.allPendingTasks--;
                      prevTaskInDEV = logRecoverableError(
                        request,
                        x$jscomp$0,
                        errorInfo$jscomp$1,
                        debugTask
                      );
                      if (null === boundary$jscomp$0)
                        fatalError(
                          request,
                          x$jscomp$0,
                          errorInfo$jscomp$1,
                          debugTask
                        );
                      else if (boundary$jscomp$0.pendingTasks--, boundary$jscomp$0.status !== CLIENT_RENDERED) {
                        boundary$jscomp$0.status = CLIENT_RENDERED;
                        encodeErrorForBoundary(
                          boundary$jscomp$0,
                          prevTaskInDEV,
                          x$jscomp$0,
                          errorInfo$jscomp$1,
                          false
                        );
                        untrackBoundary(request, boundary$jscomp$0);
                        var boundaryRow = boundary$jscomp$0.row;
                        null !== boundaryRow && 0 === --boundaryRow.pendingTasks && finishSuspenseListRow(request, boundaryRow);
                        boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(boundary$jscomp$0);
                        0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary$jscomp$0.contentPreamble && preparePreamble(request);
                      }
                      0 === request.allPendingTasks && completeAll(request);
                    }
                  } finally {
                    currentTaskInDEV = request$jscomp$0;
                  }
                }
              }
              pingedTasks.splice(0, i);
              null !== request$jscomp$2.destination && flushCompletedQueues(
                request$jscomp$2,
                request$jscomp$2.destination
              );
            } catch (error) {
              pingedTasks = {}, logRecoverableError(request$jscomp$2, error, pingedTasks, null), fatalError(request$jscomp$2, error, pingedTasks, null);
            } finally {
              currentResumableState = prevResumableState, ReactSharedInternals.H = prevDispatcher, ReactSharedInternals.A = prevAsyncDispatcher, ReactSharedInternals.getCurrentStack = prevGetCurrentStackImpl, prevDispatcher === HooksDispatcher && switchContext(prevContext), currentRequest = prevRequest;
            }
          }
        }
        function preparePreambleFromSubtree(request, segment, collectedPreambleSegments) {
          segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);
          for (var pendingPreambles = false, i = 0; i < segment.children.length; i++)
            pendingPreambles = preparePreambleFromSegment(
              request,
              segment.children[i],
              collectedPreambleSegments
            ) || pendingPreambles;
          return pendingPreambles;
        }
        function preparePreambleFromSegment(request, segment, collectedPreambleSegments) {
          var boundary = segment.boundary;
          if (null === boundary)
            return preparePreambleFromSubtree(
              request,
              segment,
              collectedPreambleSegments
            );
          var preamble = boundary.contentPreamble, fallbackPreamble = boundary.fallbackPreamble;
          if (null === preamble || null === fallbackPreamble) return false;
          switch (boundary.status) {
            case COMPLETED:
              hoistPreambleState(request.renderState, preamble);
              request.byteSize += boundary.byteSize;
              segment = boundary.completedSegments[0];
              if (!segment)
                throw Error(
                  "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
                );
              return preparePreambleFromSubtree(
                request,
                segment,
                collectedPreambleSegments
              );
            case POSTPONED:
              if (null !== request.trackedPostpones) return true;
            case CLIENT_RENDERED:
              if (segment.status === COMPLETED)
                return hoistPreambleState(request.renderState, fallbackPreamble), preparePreambleFromSubtree(
                  request,
                  segment,
                  collectedPreambleSegments
                );
            default:
              return true;
          }
        }
        function preparePreamble(request) {
          if (request.completedRootSegment && null === request.completedPreambleSegments) {
            var collectedPreambleSegments = [], originalRequestByteSize = request.byteSize, hasPendingPreambles = preparePreambleFromSegment(
              request,
              request.completedRootSegment,
              collectedPreambleSegments
            ), preamble = request.renderState.preamble;
            false === hasPendingPreambles || preamble.headChunks && preamble.bodyChunks ? request.completedPreambleSegments = collectedPreambleSegments : request.byteSize = originalRequestByteSize;
          }
        }
        function flushSubtree(request, destination, segment, hoistableState) {
          segment.parentFlushed = true;
          switch (segment.status) {
            case PENDING:
              segment.id = request.nextSegmentId++;
            case POSTPONED:
              return hoistableState = segment.id, segment.lastPushedText = false, segment.textEmbedded = false, request = request.renderState, destination.push(placeholder1), destination.push(request.placeholderPrefix), request = hoistableState.toString(16), destination.push(request), destination.push(placeholder2);
            case COMPLETED:
              segment.status = FLUSHED;
              var r = true, chunks = segment.chunks, chunkIdx = 0;
              segment = segment.children;
              for (var childIdx = 0; childIdx < segment.length; childIdx++) {
                for (r = segment[childIdx]; chunkIdx < r.index; chunkIdx++)
                  destination.push(chunks[chunkIdx]);
                r = flushSegment(request, destination, r, hoistableState);
              }
              for (; chunkIdx < chunks.length - 1; chunkIdx++)
                destination.push(chunks[chunkIdx]);
              chunkIdx < chunks.length && (r = destination.push(chunks[chunkIdx]));
              return r;
            case ABORTED:
              return true;
            default:
              throw Error(
                "Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React."
              );
          }
        }
        function flushSegment(request, destination, segment, hoistableState) {
          var boundary = segment.boundary;
          if (null === boundary)
            return flushSubtree(request, destination, segment, hoistableState);
          boundary.parentFlushed = true;
          if (boundary.status === CLIENT_RENDERED) {
            var row = boundary.row;
            null !== row && 0 === --row.pendingTasks && finishSuspenseListRow(request, row);
            if (!request.renderState.generateStaticMarkup) {
              var errorDigest = boundary.errorDigest, errorMessage = boundary.errorMessage;
              row = boundary.errorStack;
              boundary = boundary.errorComponentStack;
              destination.push(startClientRenderedSuspenseBoundary);
              destination.push(clientRenderedSuspenseBoundaryError1);
              errorDigest && (destination.push(clientRenderedSuspenseBoundaryError1A), errorDigest = escapeTextForBrowser(errorDigest), destination.push(errorDigest), destination.push(
                clientRenderedSuspenseBoundaryErrorAttrInterstitial
              ));
              errorMessage && (destination.push(clientRenderedSuspenseBoundaryError1B), errorMessage = escapeTextForBrowser(errorMessage), destination.push(errorMessage), destination.push(
                clientRenderedSuspenseBoundaryErrorAttrInterstitial
              ));
              row && (destination.push(clientRenderedSuspenseBoundaryError1C), row = escapeTextForBrowser(row), destination.push(row), destination.push(
                clientRenderedSuspenseBoundaryErrorAttrInterstitial
              ));
              boundary && (destination.push(clientRenderedSuspenseBoundaryError1D), row = escapeTextForBrowser(boundary), destination.push(row), destination.push(
                clientRenderedSuspenseBoundaryErrorAttrInterstitial
              ));
              destination.push(clientRenderedSuspenseBoundaryError2);
            }
            flushSubtree(request, destination, segment, hoistableState);
            request = request.renderState.generateStaticMarkup ? true : destination.push(endSuspenseBoundary);
            return request;
          }
          if (boundary.status !== COMPLETED)
            return boundary.status === PENDING && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
              destination,
              request.renderState,
              boundary.rootSegmentID
            ), hoistableState && hoistHoistables(hoistableState, boundary.fallbackState), flushSubtree(request, destination, segment, hoistableState), destination.push(endSuspenseBoundary);
          if (!flushingPartialBoundaries && isEligibleForOutlining(request, boundary) && flushedByteSize + boundary.byteSize > request.progressiveChunkSize)
            return boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
              destination,
              request.renderState,
              boundary.rootSegmentID
            ), flushSubtree(request, destination, segment, hoistableState), destination.push(endSuspenseBoundary);
          flushedByteSize += boundary.byteSize;
          hoistableState && hoistHoistables(hoistableState, boundary.contentState);
          segment = boundary.row;
          null !== segment && isEligibleForOutlining(request, boundary) && 0 === --segment.pendingTasks && finishSuspenseListRow(request, segment);
          request.renderState.generateStaticMarkup || destination.push(startCompletedSuspenseBoundary);
          segment = boundary.completedSegments;
          if (1 !== segment.length)
            throw Error(
              "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
            );
          flushSegment(request, destination, segment[0], hoistableState);
          request = request.renderState.generateStaticMarkup ? true : destination.push(endSuspenseBoundary);
          return request;
        }
        function flushSegmentContainer(request, destination, segment, hoistableState) {
          writeStartSegment(
            destination,
            request.renderState,
            segment.parentFormatContext,
            segment.id
          );
          flushSegment(request, destination, segment, hoistableState);
          return writeEndSegment(destination, segment.parentFormatContext);
        }
        function flushCompletedBoundary(request, destination, boundary) {
          flushedByteSize = boundary.byteSize;
          for (var completedSegments = boundary.completedSegments, i = 0; i < completedSegments.length; i++)
            flushPartiallyCompletedSegment(
              request,
              destination,
              boundary,
              completedSegments[i]
            );
          completedSegments.length = 0;
          completedSegments = boundary.row;
          null !== completedSegments && isEligibleForOutlining(request, boundary) && 0 === --completedSegments.pendingTasks && finishSuspenseListRow(request, completedSegments);
          writeHoistablesForBoundary(
            destination,
            boundary.contentState,
            request.renderState
          );
          completedSegments = request.resumableState;
          request = request.renderState;
          i = boundary.rootSegmentID;
          boundary = boundary.contentState;
          var requiresStyleInsertion = request.stylesToHoist;
          request.stylesToHoist = false;
          destination.push(request.startInlineScript);
          destination.push(endOfStartTag);
          requiresStyleInsertion ? ((completedSegments.instructions & SentClientRenderFunction) === NothingSent && (completedSegments.instructions |= SentClientRenderFunction, destination.push(clientRenderScriptFunctionOnly)), (completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent && (completedSegments.instructions |= SentCompleteBoundaryFunction, destination.push(completeBoundaryScriptFunctionOnly)), (completedSegments.instructions & SentStyleInsertionFunction) === NothingSent ? (completedSegments.instructions |= SentStyleInsertionFunction, destination.push(completeBoundaryWithStylesScript1FullPartial)) : destination.push(completeBoundaryWithStylesScript1Partial)) : ((completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent && (completedSegments.instructions |= SentCompleteBoundaryFunction, destination.push(completeBoundaryScriptFunctionOnly)), destination.push(completeBoundaryScript1Partial));
          completedSegments = i.toString(16);
          destination.push(request.boundaryPrefix);
          destination.push(completedSegments);
          destination.push(completeBoundaryScript2);
          destination.push(request.segmentPrefix);
          destination.push(completedSegments);
          requiresStyleInsertion ? (destination.push(completeBoundaryScript3a), writeStyleResourceDependenciesInJS(destination, boundary)) : destination.push(completeBoundaryScript3b);
          boundary = destination.push(completeBoundaryScriptEnd);
          return writeBootstrap(destination, request) && boundary;
        }
        function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
          if (segment.status === FLUSHED) return true;
          var hoistableState = boundary.contentState, segmentID = segment.id;
          if (-1 === segmentID) {
            if (-1 === (segment.id = boundary.rootSegmentID))
              throw Error(
                "A root segment ID must have been assigned by now. This is a bug in React."
              );
            return flushSegmentContainer(
              request,
              destination,
              segment,
              hoistableState
            );
          }
          if (segmentID === boundary.rootSegmentID)
            return flushSegmentContainer(
              request,
              destination,
              segment,
              hoistableState
            );
          flushSegmentContainer(request, destination, segment, hoistableState);
          boundary = request.resumableState;
          request = request.renderState;
          destination.push(request.startInlineScript);
          destination.push(endOfStartTag);
          (boundary.instructions & SentCompleteSegmentFunction) === NothingSent ? (boundary.instructions |= SentCompleteSegmentFunction, destination.push(completeSegmentScript1Full)) : destination.push(completeSegmentScript1Partial);
          destination.push(request.segmentPrefix);
          segmentID = segmentID.toString(16);
          destination.push(segmentID);
          destination.push(completeSegmentScript2);
          destination.push(request.placeholderPrefix);
          destination.push(segmentID);
          destination = destination.push(completeSegmentScriptEnd);
          return destination;
        }
        function flushCompletedQueues(request, destination) {
          try {
            if (!(0 < request.pendingRootTasks)) {
              var i, completedRootSegment = request.completedRootSegment;
              if (null !== completedRootSegment) {
                if (completedRootSegment.status === POSTPONED) return;
                var completedPreambleSegments = request.completedPreambleSegments;
                if (null === completedPreambleSegments) return;
                flushedByteSize = request.byteSize;
                var resumableState = request.resumableState, renderState = request.renderState, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;
                if (htmlChunks) {
                  for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
                    destination.push(htmlChunks[i$jscomp$0]);
                  if (headChunks)
                    for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                      destination.push(headChunks[i$jscomp$0]);
                  else {
                    var chunk = startChunkForTag("head");
                    destination.push(chunk);
                    destination.push(endOfStartTag);
                  }
                } else if (headChunks)
                  for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                    destination.push(headChunks[i$jscomp$0]);
                var charsetChunks = renderState.charsetChunks;
                for (i$jscomp$0 = 0; i$jscomp$0 < charsetChunks.length; i$jscomp$0++)
                  destination.push(charsetChunks[i$jscomp$0]);
                charsetChunks.length = 0;
                renderState.preconnects.forEach(flushResource, destination);
                renderState.preconnects.clear();
                var viewportChunks = renderState.viewportChunks;
                for (i$jscomp$0 = 0; i$jscomp$0 < viewportChunks.length; i$jscomp$0++)
                  destination.push(viewportChunks[i$jscomp$0]);
                viewportChunks.length = 0;
                renderState.fontPreloads.forEach(flushResource, destination);
                renderState.fontPreloads.clear();
                renderState.highImagePreloads.forEach(flushResource, destination);
                renderState.highImagePreloads.clear();
                currentlyFlushingRenderState = renderState;
                renderState.styles.forEach(flushStylesInPreamble, destination);
                currentlyFlushingRenderState = null;
                var importMapChunks = renderState.importMapChunks;
                for (i$jscomp$0 = 0; i$jscomp$0 < importMapChunks.length; i$jscomp$0++)
                  destination.push(importMapChunks[i$jscomp$0]);
                importMapChunks.length = 0;
                renderState.bootstrapScripts.forEach(flushResource, destination);
                renderState.scripts.forEach(flushResource, destination);
                renderState.scripts.clear();
                renderState.bulkPreloads.forEach(flushResource, destination);
                renderState.bulkPreloads.clear();
                resumableState.instructions |= SentCompletedShellId;
                var hoistableChunks = renderState.hoistableChunks;
                for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
                  destination.push(hoistableChunks[i$jscomp$0]);
                for (resumableState = hoistableChunks.length = 0; resumableState < completedPreambleSegments.length; resumableState++) {
                  var segments = completedPreambleSegments[resumableState];
                  for (renderState = 0; renderState < segments.length; renderState++)
                    flushSegment(request, destination, segments[renderState], null);
                }
                var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
                if (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) {
                  var chunk$jscomp$0 = endChunkForTag("head");
                  destination.push(chunk$jscomp$0);
                }
                var bodyChunks = preamble$jscomp$0.bodyChunks;
                if (bodyChunks)
                  for (completedPreambleSegments = 0; completedPreambleSegments < bodyChunks.length; completedPreambleSegments++)
                    destination.push(bodyChunks[completedPreambleSegments]);
                flushSegment(request, destination, completedRootSegment, null);
                request.completedRootSegment = null;
                var renderState$jscomp$0 = request.renderState;
                if (0 !== request.allPendingTasks || 0 !== request.clientRenderedBoundaries.length || 0 !== request.completedBoundaries.length || null !== request.trackedPostpones && (0 !== request.trackedPostpones.rootNodes.length || null !== request.trackedPostpones.rootSlots)) {
                  var resumableState$jscomp$0 = request.resumableState;
                  if ((resumableState$jscomp$0.instructions & SentMarkShellTime) === NothingSent) {
                    resumableState$jscomp$0.instructions |= SentMarkShellTime;
                    destination.push(renderState$jscomp$0.startInlineScript);
                    if ((resumableState$jscomp$0.instructions & SentCompletedShellId) === NothingSent) {
                      resumableState$jscomp$0.instructions |= SentCompletedShellId;
                      var shellId = "_" + resumableState$jscomp$0.idPrefix + "R_";
                      destination.push(completedShellIdAttributeStart);
                      var chunk$jscomp$1 = escapeTextForBrowser(shellId);
                      destination.push(chunk$jscomp$1);
                      destination.push(attributeEnd);
                    }
                    destination.push(endOfStartTag);
                    destination.push(shellTimeRuntimeScript);
                    destination.push(endInlineScript);
                  }
                }
                writeBootstrap(destination, renderState$jscomp$0);
              }
              var renderState$jscomp$1 = request.renderState;
              completedRootSegment = 0;
              var viewportChunks$jscomp$0 = renderState$jscomp$1.viewportChunks;
              for (completedRootSegment = 0; completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++)
                destination.push(viewportChunks$jscomp$0[completedRootSegment]);
              viewportChunks$jscomp$0.length = 0;
              renderState$jscomp$1.preconnects.forEach(flushResource, destination);
              renderState$jscomp$1.preconnects.clear();
              renderState$jscomp$1.fontPreloads.forEach(flushResource, destination);
              renderState$jscomp$1.fontPreloads.clear();
              renderState$jscomp$1.highImagePreloads.forEach(
                flushResource,
                destination
              );
              renderState$jscomp$1.highImagePreloads.clear();
              renderState$jscomp$1.styles.forEach(preloadLateStyles, destination);
              renderState$jscomp$1.scripts.forEach(flushResource, destination);
              renderState$jscomp$1.scripts.clear();
              renderState$jscomp$1.bulkPreloads.forEach(flushResource, destination);
              renderState$jscomp$1.bulkPreloads.clear();
              var hoistableChunks$jscomp$0 = renderState$jscomp$1.hoistableChunks;
              for (completedRootSegment = 0; completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++)
                destination.push(hoistableChunks$jscomp$0[completedRootSegment]);
              hoistableChunks$jscomp$0.length = 0;
              var clientRenderedBoundaries = request.clientRenderedBoundaries;
              for (i = 0; i < clientRenderedBoundaries.length; i++) {
                var boundary = clientRenderedBoundaries[i];
                renderState$jscomp$1 = destination;
                var resumableState$jscomp$1 = request.resumableState, renderState$jscomp$2 = request.renderState, id = boundary.rootSegmentID, errorDigest = boundary.errorDigest, errorMessage = boundary.errorMessage, errorStack = boundary.errorStack, errorComponentStack = boundary.errorComponentStack;
                renderState$jscomp$1.push(renderState$jscomp$2.startInlineScript);
                renderState$jscomp$1.push(endOfStartTag);
                (resumableState$jscomp$1.instructions & SentClientRenderFunction) === NothingSent ? (resumableState$jscomp$1.instructions |= SentClientRenderFunction, renderState$jscomp$1.push(clientRenderScript1Full)) : renderState$jscomp$1.push(clientRenderScript1Partial);
                renderState$jscomp$1.push(renderState$jscomp$2.boundaryPrefix);
                var chunk$jscomp$2 = id.toString(16);
                renderState$jscomp$1.push(chunk$jscomp$2);
                renderState$jscomp$1.push(clientRenderScript1A);
                if (errorDigest || errorMessage || errorStack || errorComponentStack) {
                  renderState$jscomp$1.push(clientRenderErrorScriptArgInterstitial);
                  var chunk$jscomp$3 = escapeJSStringsForInstructionScripts(
                    errorDigest || ""
                  );
                  renderState$jscomp$1.push(chunk$jscomp$3);
                }
                if (errorMessage || errorStack || errorComponentStack) {
                  renderState$jscomp$1.push(clientRenderErrorScriptArgInterstitial);
                  var chunk$jscomp$4 = escapeJSStringsForInstructionScripts(
                    errorMessage || ""
                  );
                  renderState$jscomp$1.push(chunk$jscomp$4);
                }
                if (errorStack || errorComponentStack) {
                  renderState$jscomp$1.push(clientRenderErrorScriptArgInterstitial);
                  var chunk$jscomp$5 = escapeJSStringsForInstructionScripts(
                    errorStack || ""
                  );
                  renderState$jscomp$1.push(chunk$jscomp$5);
                }
                if (errorComponentStack) {
                  renderState$jscomp$1.push(clientRenderErrorScriptArgInterstitial);
                  var chunk$jscomp$6 = escapeJSStringsForInstructionScripts(errorComponentStack);
                  renderState$jscomp$1.push(chunk$jscomp$6);
                }
                var JSCompiler_inline_result = renderState$jscomp$1.push(
                  clientRenderScriptEnd
                );
                if (!JSCompiler_inline_result) {
                  request.destination = null;
                  i++;
                  clientRenderedBoundaries.splice(0, i);
                  return;
                }
              }
              clientRenderedBoundaries.splice(0, i);
              var completedBoundaries = request.completedBoundaries;
              for (i = 0; i < completedBoundaries.length; i++)
                if (!flushCompletedBoundary(
                  request,
                  destination,
                  completedBoundaries[i]
                )) {
                  request.destination = null;
                  i++;
                  completedBoundaries.splice(0, i);
                  return;
                }
              completedBoundaries.splice(0, i);
              flushingPartialBoundaries = true;
              var partialBoundaries = request.partialBoundaries;
              for (i = 0; i < partialBoundaries.length; i++) {
                a: {
                  clientRenderedBoundaries = request;
                  boundary = destination;
                  var boundary$jscomp$0 = partialBoundaries[i];
                  flushedByteSize = boundary$jscomp$0.byteSize;
                  var completedSegments = boundary$jscomp$0.completedSegments;
                  for (JSCompiler_inline_result = 0; JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++)
                    if (!flushPartiallyCompletedSegment(
                      clientRenderedBoundaries,
                      boundary,
                      boundary$jscomp$0,
                      completedSegments[JSCompiler_inline_result]
                    )) {
                      JSCompiler_inline_result++;
                      completedSegments.splice(0, JSCompiler_inline_result);
                      var JSCompiler_inline_result$jscomp$0 = false;
                      break a;
                    }
                  completedSegments.splice(0, JSCompiler_inline_result);
                  var row = boundary$jscomp$0.row;
                  null !== row && row.together && 1 === boundary$jscomp$0.pendingTasks && (1 === row.pendingTasks ? unblockSuspenseListRow(
                    clientRenderedBoundaries,
                    row,
                    row.hoistables
                  ) : row.pendingTasks--);
                  JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(
                    boundary,
                    boundary$jscomp$0.contentState,
                    clientRenderedBoundaries.renderState
                  );
                }
                if (!JSCompiler_inline_result$jscomp$0) {
                  request.destination = null;
                  i++;
                  partialBoundaries.splice(0, i);
                  return;
                }
              }
              partialBoundaries.splice(0, i);
              flushingPartialBoundaries = false;
              var largeBoundaries = request.completedBoundaries;
              for (i = 0; i < largeBoundaries.length; i++)
                if (!flushCompletedBoundary(request, destination, largeBoundaries[i])) {
                  request.destination = null;
                  i++;
                  largeBoundaries.splice(0, i);
                  return;
                }
              largeBoundaries.splice(0, i);
            }
          } finally {
            flushingPartialBoundaries = false, 0 === request.allPendingTasks && 0 === request.clientRenderedBoundaries.length && 0 === request.completedBoundaries.length && (request.flushScheduled = false, i = request.resumableState, i.hasBody && (partialBoundaries = endChunkForTag("body"), destination.push(partialBoundaries)), i.hasHtml && (i = endChunkForTag("html"), destination.push(i)), 0 !== request.abortableTasks.size && console.error(
              "There was still abortable task at the root when we closed. This is a bug in React."
            ), request.status = CLOSED, destination.push(null), request.destination = null);
          }
        }
        function startWork(request) {
          request.flushScheduled = null !== request.destination;
          performWork(request);
          10 === request.status && (request.status = 11);
          null === request.trackedPostpones && safelyEmitEarlyPreloads(request, 0 === request.pendingRootTasks);
        }
        function enqueueFlush(request) {
          if (false === request.flushScheduled && 0 === request.pingedTasks.length && null !== request.destination) {
            request.flushScheduled = true;
            var destination = request.destination;
            destination ? flushCompletedQueues(request, destination) : request.flushScheduled = false;
          }
        }
        function startFlowing(request, destination) {
          if (13 === request.status)
            request.status = CLOSED, destination.destroy(request.fatalError);
          else if (request.status !== CLOSED && null === request.destination) {
            request.destination = destination;
            try {
              flushCompletedQueues(request, destination);
            } catch (error) {
              destination = {}, logRecoverableError(request, error, destination, null), fatalError(request, error, destination, null);
            }
          }
        }
        function abort(request, reason) {
          if (11 === request.status || 10 === request.status) request.status = 12;
          try {
            var abortableTasks = request.abortableTasks;
            if (0 < abortableTasks.size) {
              var error = void 0 === reason ? Error("The render was aborted by the server without a reason.") : "object" === typeof reason && null !== reason && "function" === typeof reason.then ? Error("The render was aborted by the server with a promise.") : reason;
              request.fatalError = error;
              abortableTasks.forEach(function(task) {
                var prevTaskInDEV = currentTaskInDEV, prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;
                currentTaskInDEV = task;
                ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;
                try {
                  abortTask(task, request, error);
                } finally {
                  currentTaskInDEV = prevTaskInDEV, ReactSharedInternals.getCurrentStack = prevGetCurrentStackImpl;
                }
              });
              abortableTasks.clear();
            }
            null !== request.destination && flushCompletedQueues(request, request.destination);
          } catch (error$4) {
            reason = {}, logRecoverableError(request, error$4, reason, null), fatalError(request, error$4, reason, null);
          }
        }
        function addToReplayParent(node, parentKeyPath, trackedPostpones) {
          if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);
          else {
            var workingMap = trackedPostpones.workingMap, parentNode = workingMap.get(parentKeyPath);
            void 0 === parentNode && (parentNode = [parentKeyPath[1], parentKeyPath[2], [], null], workingMap.set(parentKeyPath, parentNode), addToReplayParent(parentNode, parentKeyPath[0], trackedPostpones));
            parentNode[2].push(node);
          }
        }
        function onError() {
        }
        function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {
          var didFatal = false, fatalError2 = null, result = "", readyToStream = false;
          options = createResumableState(
            options ? options.identifierPrefix : void 0
          );
          children = createRequest(
            children,
            options,
            createRenderState(options, generateStaticMarkup),
            createFormatContext(ROOT_HTML_MODE, null, 0, null),
            Infinity,
            onError,
            void 0,
            function() {
              readyToStream = true;
            },
            void 0,
            void 0,
            void 0
          );
          startWork(children);
          abort(children, abortReason);
          startFlowing(children, {
            push: function(chunk) {
              null !== chunk && (result += chunk);
              return true;
            },
            destroy: function(error) {
              didFatal = true;
              fatalError2 = error;
            }
          });
          if (didFatal && fatalError2 !== abortReason) throw fatalError2;
          if (!readyToStream)
            throw Error(
              "A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition."
            );
          return result;
        }
        var React9 = require_react(), ReactDOM2 = require_react_dom(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_SCOPE_TYPE = Symbol.for("react.scope"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"), REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, isArrayImpl = Array.isArray, jsxPropsParents = /* @__PURE__ */ new WeakMap(), jsxChildrenParents = /* @__PURE__ */ new WeakMap(), CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"), assign2 = Object.assign, hasOwnProperty = Object.prototype.hasOwnProperty, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
          "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, unitlessNumbers = new Set(
          "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
            " "
          )
        ), aliases = /* @__PURE__ */ new Map([
          ["acceptCharset", "accept-charset"],
          ["htmlFor", "for"],
          ["httpEquiv", "http-equiv"],
          ["crossOrigin", "crossorigin"],
          ["accentHeight", "accent-height"],
          ["alignmentBaseline", "alignment-baseline"],
          ["arabicForm", "arabic-form"],
          ["baselineShift", "baseline-shift"],
          ["capHeight", "cap-height"],
          ["clipPath", "clip-path"],
          ["clipRule", "clip-rule"],
          ["colorInterpolation", "color-interpolation"],
          ["colorInterpolationFilters", "color-interpolation-filters"],
          ["colorProfile", "color-profile"],
          ["colorRendering", "color-rendering"],
          ["dominantBaseline", "dominant-baseline"],
          ["enableBackground", "enable-background"],
          ["fillOpacity", "fill-opacity"],
          ["fillRule", "fill-rule"],
          ["floodColor", "flood-color"],
          ["floodOpacity", "flood-opacity"],
          ["fontFamily", "font-family"],
          ["fontSize", "font-size"],
          ["fontSizeAdjust", "font-size-adjust"],
          ["fontStretch", "font-stretch"],
          ["fontStyle", "font-style"],
          ["fontVariant", "font-variant"],
          ["fontWeight", "font-weight"],
          ["glyphName", "glyph-name"],
          ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
          ["glyphOrientationVertical", "glyph-orientation-vertical"],
          ["horizAdvX", "horiz-adv-x"],
          ["horizOriginX", "horiz-origin-x"],
          ["imageRendering", "image-rendering"],
          ["letterSpacing", "letter-spacing"],
          ["lightingColor", "lighting-color"],
          ["markerEnd", "marker-end"],
          ["markerMid", "marker-mid"],
          ["markerStart", "marker-start"],
          ["overlinePosition", "overline-position"],
          ["overlineThickness", "overline-thickness"],
          ["paintOrder", "paint-order"],
          ["panose-1", "panose-1"],
          ["pointerEvents", "pointer-events"],
          ["renderingIntent", "rendering-intent"],
          ["shapeRendering", "shape-rendering"],
          ["stopColor", "stop-color"],
          ["stopOpacity", "stop-opacity"],
          ["strikethroughPosition", "strikethrough-position"],
          ["strikethroughThickness", "strikethrough-thickness"],
          ["strokeDasharray", "stroke-dasharray"],
          ["strokeDashoffset", "stroke-dashoffset"],
          ["strokeLinecap", "stroke-linecap"],
          ["strokeLinejoin", "stroke-linejoin"],
          ["strokeMiterlimit", "stroke-miterlimit"],
          ["strokeOpacity", "stroke-opacity"],
          ["strokeWidth", "stroke-width"],
          ["textAnchor", "text-anchor"],
          ["textDecoration", "text-decoration"],
          ["textRendering", "text-rendering"],
          ["transformOrigin", "transform-origin"],
          ["underlinePosition", "underline-position"],
          ["underlineThickness", "underline-thickness"],
          ["unicodeBidi", "unicode-bidi"],
          ["unicodeRange", "unicode-range"],
          ["unitsPerEm", "units-per-em"],
          ["vAlphabetic", "v-alphabetic"],
          ["vHanging", "v-hanging"],
          ["vIdeographic", "v-ideographic"],
          ["vMathematical", "v-mathematical"],
          ["vectorEffect", "vector-effect"],
          ["vertAdvY", "vert-adv-y"],
          ["vertOriginX", "vert-origin-x"],
          ["vertOriginY", "vert-origin-y"],
          ["wordSpacing", "word-spacing"],
          ["writingMode", "writing-mode"],
          ["xmlnsXlink", "xmlns:xlink"],
          ["xHeight", "x-height"]
        ]), hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        }, ariaProperties = {
          "aria-current": 0,
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0,
          "aria-braillelabel": 0,
          "aria-brailleroledescription": 0,
          "aria-colindextext": 0,
          "aria-rowindextext": 0
        }, warnedProperties$1 = {}, rARIA$1 = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel$1 = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), didWarnValueNull = false, possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          fetchpriority: "fetchPriority",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          inert: "inert",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          popover: "popover",
          popovertarget: "popoverTarget",
          popovertargetaction: "popoverTargetAction",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          transformorigin: "transformOrigin",
          "transform-origin": "transformOrigin",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        }, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern$1 = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, matchHtmlRegExp = /["'&<>]/, uppercasePattern = /([A-Z])/g, msPattern = /^ms-/, isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, ReactSharedInternals = React9.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
          pending: false,
          data: null,
          method: null,
          action: null
        }), previousDispatcher = ReactDOMSharedInternals.d;
        ReactDOMSharedInternals.d = {
          f: previousDispatcher.f,
          r: previousDispatcher.r,
          D: function(href) {
            var request = currentRequest ? currentRequest : null;
            if (request) {
              var resumableState = request.resumableState, renderState = request.renderState;
              if ("string" === typeof href && href) {
                if (!resumableState.dnsResources.hasOwnProperty(href)) {
                  resumableState.dnsResources[href] = EXISTS;
                  resumableState = renderState.headers;
                  var header, JSCompiler_temp;
                  if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity)
                    JSCompiler_temp = (header = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=dns-prefetch", 0 <= (resumableState.remainingCapacity -= header.length + 2));
                  JSCompiler_temp ? (renderState.resets.dns[href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (header = [], pushLinkImpl(header, { href, rel: "dns-prefetch" }), renderState.preconnects.add(header));
                }
                enqueueFlush(request);
              }
            } else previousDispatcher.D(href);
          },
          C: function(href, crossOrigin) {
            var request = currentRequest ? currentRequest : null;
            if (request) {
              var resumableState = request.resumableState, renderState = request.renderState;
              if ("string" === typeof href && href) {
                var bucket = "use-credentials" === crossOrigin ? "credentials" : "string" === typeof crossOrigin ? "anonymous" : "default";
                if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {
                  resumableState.connectResources[bucket][href] = EXISTS;
                  resumableState = renderState.headers;
                  var header, JSCompiler_temp;
                  if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {
                    JSCompiler_temp = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=preconnect";
                    if ("string" === typeof crossOrigin) {
                      var escapedCrossOrigin = escapeStringForLinkHeaderQuotedParamValueContext(
                        crossOrigin,
                        "crossOrigin"
                      );
                      JSCompiler_temp += '; crossorigin="' + escapedCrossOrigin + '"';
                    }
                    JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));
                  }
                  JSCompiler_temp ? (renderState.resets.connect[bucket][href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (bucket = [], pushLinkImpl(bucket, {
                    rel: "preconnect",
                    href,
                    crossOrigin
                  }), renderState.preconnects.add(bucket));
                }
                enqueueFlush(request);
              }
            } else previousDispatcher.C(href, crossOrigin);
          },
          L: function(href, as, options) {
            var request = currentRequest ? currentRequest : null;
            if (request) {
              var resumableState = request.resumableState, renderState = request.renderState;
              if (as && href) {
                switch (as) {
                  case "image":
                    if (options) {
                      var imageSrcSet = options.imageSrcSet;
                      var imageSizes = options.imageSizes;
                      var fetchPriority = options.fetchPriority;
                    }
                    var key = imageSrcSet ? imageSrcSet + "\n" + (imageSizes || "") : href;
                    if (resumableState.imageResources.hasOwnProperty(key)) return;
                    resumableState.imageResources[key] = PRELOAD_NO_CREDS;
                    resumableState = renderState.headers;
                    var header;
                    resumableState && 0 < resumableState.remainingCapacity && "string" !== typeof imageSrcSet && "high" === fetchPriority && (header = getPreloadAsHeader(href, as, options), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS, resumableState.highImagePreloads && (resumableState.highImagePreloads += ", "), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl(
                      resumableState,
                      assign2(
                        {
                          rel: "preload",
                          href: imageSrcSet ? void 0 : href,
                          as
                        },
                        options
                      )
                    ), "high" === fetchPriority ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));
                    break;
                  case "style":
                    if (resumableState.styleResources.hasOwnProperty(href)) return;
                    imageSrcSet = [];
                    pushLinkImpl(
                      imageSrcSet,
                      assign2({ rel: "preload", href, as }, options)
                    );
                    resumableState.styleResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
                    renderState.preloads.stylesheets.set(href, imageSrcSet);
                    renderState.bulkPreloads.add(imageSrcSet);
                    break;
                  case "script":
                    if (resumableState.scriptResources.hasOwnProperty(href)) return;
                    imageSrcSet = [];
                    renderState.preloads.scripts.set(href, imageSrcSet);
                    renderState.bulkPreloads.add(imageSrcSet);
                    pushLinkImpl(
                      imageSrcSet,
                      assign2({ rel: "preload", href, as }, options)
                    );
                    resumableState.scriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
                    break;
                  default:
                    if (resumableState.unknownResources.hasOwnProperty(as)) {
                      if (imageSrcSet = resumableState.unknownResources[as], imageSrcSet.hasOwnProperty(href))
                        return;
                    } else
                      imageSrcSet = {}, resumableState.unknownResources[as] = imageSrcSet;
                    imageSrcSet[href] = PRELOAD_NO_CREDS;
                    if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && "font" === as && (key = getPreloadAsHeader(href, as, options), 0 <= (resumableState.remainingCapacity -= key.length + 2)))
                      renderState.resets.font[href] = PRELOAD_NO_CREDS, resumableState.fontPreloads && (resumableState.fontPreloads += ", "), resumableState.fontPreloads += key;
                    else
                      switch (resumableState = [], href = assign2(
                        { rel: "preload", href, as },
                        options
                      ), pushLinkImpl(resumableState, href), as) {
                        case "font":
                          renderState.fontPreloads.add(resumableState);
                          break;
                        default:
                          renderState.bulkPreloads.add(resumableState);
                      }
                }
                enqueueFlush(request);
              }
            } else previousDispatcher.L(href, as, options);
          },
          m: function(href, options) {
            var request = currentRequest ? currentRequest : null;
            if (request) {
              var resumableState = request.resumableState, renderState = request.renderState;
              if (href) {
                var as = options && "string" === typeof options.as ? options.as : "script";
                switch (as) {
                  case "script":
                    if (resumableState.moduleScriptResources.hasOwnProperty(href))
                      return;
                    as = [];
                    resumableState.moduleScriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
                    renderState.preloads.moduleScripts.set(href, as);
                    break;
                  default:
                    if (resumableState.moduleUnknownResources.hasOwnProperty(as)) {
                      var resources = resumableState.unknownResources[as];
                      if (resources.hasOwnProperty(href)) return;
                    } else
                      resources = {}, resumableState.moduleUnknownResources[as] = resources;
                    as = [];
                    resources[href] = PRELOAD_NO_CREDS;
                }
                pushLinkImpl(
                  as,
                  assign2({ rel: "modulepreload", href }, options)
                );
                renderState.bulkPreloads.add(as);
                enqueueFlush(request);
              }
            } else previousDispatcher.m(href, options);
          },
          X: function(src, options) {
            var request = currentRequest ? currentRequest : null;
            if (request) {
              var resumableState = request.resumableState, renderState = request.renderState;
              if (src) {
                var resourceState = resumableState.scriptResources.hasOwnProperty(
                  src
                ) ? resumableState.scriptResources[src] : void 0;
                resourceState !== EXISTS && (resumableState.scriptResources[src] = EXISTS, options = assign2({ src, async: true }, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
              }
            } else previousDispatcher.X(src, options);
          },
          S: function(href, precedence, options) {
            var request = currentRequest ? currentRequest : null;
            if (request) {
              var resumableState = request.resumableState, renderState = request.renderState;
              if (href) {
                precedence = precedence || "default";
                var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
                resourceState !== EXISTS && (resumableState.styleResources[href] = EXISTS, styleQueue || (styleQueue = {
                  precedence: escapeTextForBrowser(precedence),
                  rules: [],
                  hrefs: [],
                  sheets: /* @__PURE__ */ new Map()
                }, renderState.styles.set(precedence, styleQueue)), precedence = {
                  state: PENDING$1,
                  props: assign2(
                    {
                      rel: "stylesheet",
                      href,
                      "data-precedence": precedence
                    },
                    options
                  )
                }, resourceState && (2 === resourceState.length && adoptPreloadCredentials(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = PRELOADED), styleQueue.sheets.set(href, precedence), enqueueFlush(request));
              }
            } else previousDispatcher.S(href, precedence, options);
          },
          M: function(src, options) {
            var request = currentRequest ? currentRequest : null;
            if (request) {
              var resumableState = request.resumableState, renderState = request.renderState;
              if (src) {
                var resourceState = resumableState.moduleScriptResources.hasOwnProperty(src) ? resumableState.moduleScriptResources[src] : void 0;
                resourceState !== EXISTS && (resumableState.moduleScriptResources[src] = EXISTS, options = assign2(
                  { src, type: "module", async: true },
                  options
                ), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
              }
            } else previousDispatcher.M(src, options);
          }
        };
        var NothingSent = 0, SentCompleteSegmentFunction = 1, SentCompleteBoundaryFunction = 2, SentClientRenderFunction = 4, SentStyleInsertionFunction = 8, SentCompletedShellId = 32, SentMarkShellTime = 64, EXISTS = null, PRELOAD_NO_CREDS = [];
        Object.freeze(PRELOAD_NO_CREDS);
        var currentlyFlushingRenderState = null, endInlineScript = "<\/script>", scriptRegex = /(<\/|<)(s)(cript)/gi;
        var didWarnForNewBooleanPropsWithEmptyValue = {};
        var ROOT_HTML_MODE = 0, HTML_HTML_MODE = 1, HTML_MODE = 2, HTML_HEAD_MODE = 3, SVG_MODE = 4, MATHML_MODE = 5, HTML_TABLE_MODE = 6, HTML_TABLE_BODY_MODE = 7, HTML_TABLE_ROW_MODE = 8, HTML_COLGROUP_MODE = 9, styleNameCache = /* @__PURE__ */ new Map(), styleAttributeStart = ' style="', styleAssign = ":", styleSeparator = ";", attributeSeparator = " ", attributeAssign = '="', attributeEnd = '"', attributeEmptyString = '=""', actionJavaScriptURL = escapeTextForBrowser(
          "javascript:throw new Error('React form unexpectedly submitted.')"
        ), endOfStartTag = ">", endOfStartTagSelfClosing = "/>", didWarnDefaultInputValue = false, didWarnDefaultChecked = false, didWarnDefaultSelectValue = false, didWarnDefaultTextareaValue = false, didWarnInvalidOptionChildren = false, didWarnInvalidOptionInnerHTML = false, didWarnSelectedSetOnOption = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, formReplayingRuntimeScript = `addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error('React form unexpectedly submitted.')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});`, styleRegex = /(<\/|<)(s)(tyle)/gi, leadingNewline = "\n", VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache = /* @__PURE__ */ new Map(), endTagCache = /* @__PURE__ */ new Map(), shellTimeRuntimeScript = "requestAnimationFrame(function(){$RT=performance.now()});", placeholder1 = '<template id="', placeholder2 = '"></template>', startCompletedSuspenseBoundary = "<!--$-->", startPendingSuspenseBoundary1 = '<!--$?--><template id="', startPendingSuspenseBoundary2 = '"></template>', startClientRenderedSuspenseBoundary = "<!--$!-->", endSuspenseBoundary = "<!--/$-->", clientRenderedSuspenseBoundaryError1 = "<template", clientRenderedSuspenseBoundaryErrorAttrInterstitial = '"', clientRenderedSuspenseBoundaryError1A = ' data-dgst="', clientRenderedSuspenseBoundaryError1B = ' data-msg="', clientRenderedSuspenseBoundaryError1C = ' data-stck="', clientRenderedSuspenseBoundaryError1D = ' data-cstck="', clientRenderedSuspenseBoundaryError2 = "></template>", startSegmentHTML = '<div hidden id="', startSegmentHTML2 = '">', endSegmentHTML = "</div>", startSegmentSVG = '<svg aria-hidden="true" style="display:none" id="', startSegmentSVG2 = '">', endSegmentSVG = "</svg>", startSegmentMathML = '<math aria-hidden="true" style="display:none" id="', startSegmentMathML2 = '">', endSegmentMathML = "</math>", startSegmentTable = '<table hidden id="', startSegmentTable2 = '">', endSegmentTable = "</table>", startSegmentTableBody = '<table hidden><tbody id="', startSegmentTableBody2 = '">', endSegmentTableBody = "</tbody></table>", startSegmentTableRow = '<table hidden><tr id="', startSegmentTableRow2 = '">', endSegmentTableRow = "</tr></table>", startSegmentColGroup = '<table hidden><colgroup id="', startSegmentColGroup2 = '">', endSegmentColGroup = "</colgroup></table>", completeSegmentScript1Full = '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("', completeSegmentScript1Partial = '$RS("', completeSegmentScript2 = '","', completeSegmentScriptEnd = '")<\/script>', completeBoundaryScriptFunctionOnly = '$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};\n$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};', completeBoundaryScript1Partial = '$RC("', completeBoundaryWithStylesScript1FullPartial = '$RM=new Map;$RR=function(n,w,p){function u(q){this._p=null;q()}for(var r=new Map,t=document,h,b,e=t.querySelectorAll("link[data-precedence],style[data-precedence]"),v=[],k=0;b=e[k++];)"not all"===b.getAttribute("media")?v.push(b):("LINK"===b.tagName&&$RM.set(b.getAttribute("href"),b),r.set(b.dataset.precedence,h=b));e=0;b=[];var l,a;for(k=!0;;){if(k){var f=p[e++];if(!f){k=!1;e=0;continue}var c=!1,m=0;var d=f[m++];if(a=$RM.get(d)){var g=a._p;c=!0}else{a=t.createElement("link");a.href=d;a.rel=\n"stylesheet";for(a.dataset.precedence=l=f[m++];g=f[m++];)a.setAttribute(g,f[m++]);g=a._p=new Promise(function(q,x){a.onload=u.bind(a,q);a.onerror=u.bind(a,x)});$RM.set(d,a)}d=a.getAttribute("media");!g||d&&!matchMedia(d).matches||b.push(g);if(c)continue}else{a=v[e++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=r.get(l)||h;c===h&&(h=a);r.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=t.head,c.insertBefore(a,c.firstChild))}if(p=document.getElementById(n))p.previousSibling.data=\n"$~";Promise.all(b).then($RC.bind(null,n,w),$RX.bind(null,n,"CSS failed to load"))};$RR("', completeBoundaryWithStylesScript1Partial = '$RR("', completeBoundaryScript2 = '","', completeBoundaryScript3a = '",', completeBoundaryScript3b = '"', completeBoundaryScriptEnd = ")<\/script>", clientRenderScriptFunctionOnly = '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};', clientRenderScript1Full = '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("', clientRenderScript1Partial = '$RX("', clientRenderScript1A = '"', clientRenderErrorScriptArgInterstitial = ",", clientRenderScriptEnd = ")<\/script>", regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g, regexForJSStringsInScripts = /[&><\u2028\u2029]/g, lateStyleTagResourceOpen1 = ' media="not all" data-precedence="', lateStyleTagResourceOpen2 = '" data-href="', lateStyleTagResourceOpen3 = '">', lateStyleTagTemplateClose = "</style>", currentlyRenderingBoundaryHasStylesToHoist = false, destinationHasCapacity = true, stylesheetFlushingQueue = [], styleTagResourceOpen1 = ' data-precedence="', styleTagResourceOpen2 = '" data-href="', spaceSeparator = " ", styleTagResourceOpen3 = '">', styleTagResourceClose = "</style>", completedShellIdAttributeStart = ' id="', arrayFirstOpenBracket = "[", arraySubsequentOpenBracket = ",[", arrayInterstitial = ",", arrayCloseBracket = "]", PENDING$1 = 0, PRELOADED = 1, PREAMBLE = 2, LATE = 3, regexForHrefInLinkHeaderURLContext = /[<>\r\n]/g, regexForLinkHeaderQuotedParamValueContext = /["';,\r\n]/g, doctypeChunk = "", bind = Function.prototype.bind, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), emptyContextObject = {};
        Object.freeze(emptyContextObject);
        var rendererSigil = {};
        var currentActiveSnapshot = null, didWarnAboutNoopUpdateForComponent = {}, didWarnAboutDeprecatedWillMount = {};
        var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
        var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
        var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
        var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
        var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        var classComponentUpdater = {
          enqueueSetState: function(inst, payload, callback) {
            var internals = inst._reactInternals;
            null === internals.queue ? warnNoop(inst, "setState") : (internals.queue.push(payload), void 0 !== callback && null !== callback && warnOnInvalidCallback(callback));
          },
          enqueueReplaceState: function(inst, payload, callback) {
            inst = inst._reactInternals;
            inst.replace = true;
            inst.queue = [payload];
            void 0 !== callback && null !== callback && warnOnInvalidCallback(callback);
          },
          enqueueForceUpdate: function(inst, callback) {
            null === inst._reactInternals.queue ? warnNoop(inst, "forceUpdate") : void 0 !== callback && null !== callback && warnOnInvalidCallback(callback);
          }
        }, emptyTreeContext = { id: 1, overflow: "" }, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2, SuspenseException = Error(
          "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
        ), suspendedThenable = null, objectIs = "function" === typeof Object.is ? Object.is : is, currentlyRenderingComponent = null, currentlyRenderingTask = null, currentlyRenderingRequest = null, currentlyRenderingKeyPath = null, firstWorkInProgressHook = null, workInProgressHook = null, isReRender = false, didScheduleRenderPhaseUpdate = false, localIdCounter = 0, actionStateCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, thenableState = null, renderPhaseUpdates = null, numberOfReRenders = 0, isInHookUserCodeInDev = false, currentHookNameInDev, HooksDispatcher = {
          readContext,
          use: function(usable) {
            if (null !== usable && "object" === typeof usable) {
              if ("function" === typeof usable.then)
                return unwrapThenable(usable);
              if (usable.$$typeof === REACT_CONTEXT_TYPE)
                return readContext(usable);
            }
            throw Error(
              "An unsupported type was passed to use(): " + String(usable)
            );
          },
          useContext: function(context2) {
            currentHookNameInDev = "useContext";
            resolveCurrentlyRenderingComponent();
            return context2._currentValue2;
          },
          useMemo: useMemo3,
          useReducer: useReducer3,
          useRef: function(initialValue) {
            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
            workInProgressHook = createWorkInProgressHook();
            var previousRef = workInProgressHook.memoizedState;
            return null === previousRef ? (initialValue = { current: initialValue }, Object.seal(initialValue), workInProgressHook.memoizedState = initialValue) : previousRef;
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            return useReducer3(basicStateReducer, initialState);
          },
          useInsertionEffect: noop,
          useLayoutEffect: noop,
          useCallback: function(callback, deps) {
            return useMemo3(function() {
              return callback;
            }, deps);
          },
          useImperativeHandle: noop,
          useEffect: noop,
          useDebugValue: noop,
          useDeferredValue: function(value, initialValue) {
            resolveCurrentlyRenderingComponent();
            return void 0 !== initialValue ? initialValue : value;
          },
          useTransition: function() {
            resolveCurrentlyRenderingComponent();
            return [false, unsupportedStartTransition];
          },
          useId: function() {
            var treeId = currentlyRenderingTask.treeContext;
            var overflow = treeId.overflow;
            treeId = treeId.id;
            treeId = (treeId & ~(1 << 32 - clz32(treeId) - 1)).toString(32) + overflow;
            var resumableState = currentResumableState;
            if (null === resumableState)
              throw Error(
                "Invalid hook call. Hooks can only be called inside of the body of a function component."
              );
            overflow = localIdCounter++;
            treeId = "_" + resumableState.idPrefix + "R_" + treeId;
            0 < overflow && (treeId += "H" + overflow.toString(32));
            return treeId + "_";
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            if (void 0 === getServerSnapshot)
              throw Error(
                "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
              );
            return getServerSnapshot();
          },
          useOptimistic: function(passthrough) {
            resolveCurrentlyRenderingComponent();
            return [passthrough, unsupportedSetOptimisticState];
          },
          useActionState,
          useFormState: useActionState,
          useHostTransitionStatus: function() {
            resolveCurrentlyRenderingComponent();
            return NotPending;
          },
          useMemoCache: function(size) {
            for (var data = Array(size), i = 0; i < size; i++)
              data[i] = REACT_MEMO_CACHE_SENTINEL;
            return data;
          },
          useCacheRefresh: function() {
            return unsupportedRefresh;
          },
          useEffectEvent: function() {
            return throwOnUseEffectEventCall;
          }
        }, currentResumableState = null, currentTaskInDEV = null, DefaultAsyncDispatcher = {
          getCacheForType: function() {
            throw Error("Not implemented.");
          },
          cacheSignal: function() {
            throw Error("Not implemented.");
          },
          getOwner: function() {
            return null === currentTaskInDEV ? null : currentTaskInDEV.componentStack;
          }
        }, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
        disabledLog.__reactDisabledLog = true;
        var prefix, suffix, reentry = false;
        var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
        var callComponent = {
          react_stack_bottom_frame: function(Component, props, secondArg) {
            return Component(props, secondArg);
          }
        }, callComponentInDEV = callComponent.react_stack_bottom_frame.bind(callComponent), callRender = {
          react_stack_bottom_frame: function(instance) {
            return instance.render();
          }
        }, callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender), callLazyInit = {
          react_stack_bottom_frame: function(lazy) {
            var init = lazy._init;
            return init(lazy._payload);
          }
        }, callLazyInitInDEV = callLazyInit.react_stack_bottom_frame.bind(callLazyInit), lastResetTime = 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          var getCurrentTime = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          getCurrentTime = function() {
            return localDate.now();
          };
        }
        var CLIENT_RENDERED = 4, PENDING = 0, COMPLETED = 1, FLUSHED = 2, ABORTED = 3, ERRORED = 4, POSTPONED = 5, CLOSED = 14, currentRequest = null, didWarnAboutBadClass = {}, didWarnAboutContextTypes = {}, didWarnAboutContextTypeOnFunctionComponent = {}, didWarnAboutGetDerivedStateOnFunctionComponent = {}, didWarnAboutReassigningProps = false, didWarnAboutGenerators = false, didWarnAboutMaps = false, flushedByteSize = 0, flushingPartialBoundaries = false;
        exports2.renderToStaticMarkup = function(children, options) {
          return renderToStringImpl(
            children,
            options,
            true,
            'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server'
          );
        };
        exports2.renderToString = function(children, options) {
          return renderToStringImpl(
            children,
            options,
            false,
            'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server'
          );
        };
        exports2.version = "19.2.0";
      })();
    }
  });

  // node_modules/react-dom/cjs/react-dom-server.browser.development.js
  var require_react_dom_server_browser_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom-server.browser.development.js"(exports2) {
      "use strict";
      (function() {
        function styleReplacer(match, prefix2, s, suffix2) {
          return "" + prefix2 + ("s" === s ? "\\73 " : "\\53 ") + suffix2;
        }
        function scriptReplacer(match, prefix2, s, suffix2) {
          return "" + prefix2 + ("s" === s ? "\\u0073" : "\\u0053") + suffix2;
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function objectName(object) {
          object = Object.prototype.toString.call(object);
          return object.slice(8, object.length - 1);
        }
        function describeKeyForErrorMessage(key) {
          var encodedKey = JSON.stringify(key);
          return '"' + key + '"' === encodedKey ? key : encodedKey;
        }
        function describeValueForErrorMessage(value) {
          switch (typeof value) {
            case "string":
              return JSON.stringify(
                10 >= value.length ? value : value.slice(0, 10) + "..."
              );
            case "object":
              if (isArrayImpl(value)) return "[...]";
              if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
                return "client";
              value = objectName(value);
              return "Object" === value ? "{...}" : value;
            case "function":
              return value.$$typeof === CLIENT_REFERENCE_TAG ? "client" : (value = value.displayName || value.name) ? "function " + value : "function";
            default:
              return String(value);
          }
        }
        function describeElementType(type) {
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if ("object" === typeof type)
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeElementType(type.render);
              case REACT_MEMO_TYPE:
                return describeElementType(type.type);
              case REACT_LAZY_TYPE:
                var payload = type._payload;
                type = type._init;
                try {
                  return describeElementType(type(payload));
                } catch (x) {
                }
            }
          return "";
        }
        function describeObjectForErrorMessage(objectOrArray, expandedName) {
          var objKind = objectName(objectOrArray);
          if ("Object" !== objKind && "Array" !== objKind) return objKind;
          var start = -1, length = 0;
          if (isArrayImpl(objectOrArray))
            if (jsxChildrenParents.has(objectOrArray)) {
              var type = jsxChildrenParents.get(objectOrArray);
              objKind = "<" + describeElementType(type) + ">";
              for (var i = 0; i < objectOrArray.length; i++) {
                var value = objectOrArray[i];
                value = "string" === typeof value ? value : "object" === typeof value && null !== value ? "{" + describeObjectForErrorMessage(value) + "}" : "{" + describeValueForErrorMessage(value) + "}";
                "" + i === expandedName ? (start = objKind.length, length = value.length, objKind += value) : objKind = 15 > value.length && 40 > objKind.length + value.length ? objKind + value : objKind + "{...}";
              }
              objKind += "</" + describeElementType(type) + ">";
            } else {
              objKind = "[";
              for (type = 0; type < objectOrArray.length; type++)
                0 < type && (objKind += ", "), i = objectOrArray[type], i = "object" === typeof i && null !== i ? describeObjectForErrorMessage(i) : describeValueForErrorMessage(i), "" + type === expandedName ? (start = objKind.length, length = i.length, objKind += i) : objKind = 10 > i.length && 40 > objKind.length + i.length ? objKind + i : objKind + "...";
              objKind += "]";
            }
          else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
            objKind = "<" + describeElementType(objectOrArray.type) + "/>";
          else {
            if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
            if (jsxPropsParents.has(objectOrArray)) {
              objKind = jsxPropsParents.get(objectOrArray);
              objKind = "<" + (describeElementType(objKind) || "...");
              type = Object.keys(objectOrArray);
              for (i = 0; i < type.length; i++) {
                objKind += " ";
                value = type[i];
                objKind += describeKeyForErrorMessage(value) + "=";
                var _value2 = objectOrArray[value];
                var _substr2 = value === expandedName && "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2);
                "string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
                value === expandedName ? (start = objKind.length, length = _substr2.length, objKind += _substr2) : objKind = 10 > _substr2.length && 40 > objKind.length + _substr2.length ? objKind + _substr2 : objKind + "...";
              }
              objKind += ">";
            } else {
              objKind = "{";
              type = Object.keys(objectOrArray);
              for (i = 0; i < type.length; i++)
                0 < i && (objKind += ", "), value = type[i], objKind += describeKeyForErrorMessage(value) + ": ", _value2 = objectOrArray[value], _value2 = "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2), value === expandedName ? (start = objKind.length, length = _value2.length, objKind += _value2) : objKind = 10 > _value2.length && 40 > objKind.length + _value2.length ? objKind + _value2 : objKind + "...";
              objKind += "}";
            }
          }
          return void 0 === expandedName ? objKind : -1 < start && 0 < length ? (objectOrArray = " ".repeat(start) + "^".repeat(length), "\n  " + objKind + "\n  " + objectOrArray) : "\n  " + objKind;
        }
        function murmurhash3_32_gc(key, seed) {
          var remainder = key.length & 3;
          var bytes = key.length - remainder;
          var h1 = seed;
          for (seed = 0; seed < bytes; ) {
            var k1 = key.charCodeAt(seed) & 255 | (key.charCodeAt(++seed) & 255) << 8 | (key.charCodeAt(++seed) & 255) << 16 | (key.charCodeAt(++seed) & 255) << 24;
            ++seed;
            k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295;
            k1 = k1 << 15 | k1 >>> 17;
            k1 = 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
            h1 ^= k1;
            h1 = h1 << 13 | h1 >>> 19;
            h1 = 5 * (h1 & 65535) + ((5 * (h1 >>> 16) & 65535) << 16) & 4294967295;
            h1 = (h1 & 65535) + 27492 + (((h1 >>> 16) + 58964 & 65535) << 16);
          }
          k1 = 0;
          switch (remainder) {
            case 3:
              k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;
            case 2:
              k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;
            case 1:
              k1 ^= key.charCodeAt(seed) & 255, k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295, k1 = k1 << 15 | k1 >>> 17, h1 ^= 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
          }
          h1 ^= key.length;
          h1 ^= h1 >>> 16;
          h1 = 2246822507 * (h1 & 65535) + ((2246822507 * (h1 >>> 16) & 65535) << 16) & 4294967295;
          h1 ^= h1 >>> 13;
          h1 = 3266489909 * (h1 & 65535) + ((3266489909 * (h1 >>> 16) & 65535) << 16) & 4294967295;
          return (h1 ^ h1 >>> 16) >>> 0;
        }
        function scheduleWork(callback) {
          taskQueue.push(callback);
          channel.port2.postMessage(null);
        }
        function handleErrorInNextTick(error) {
          setTimeout(function() {
            throw error;
          });
        }
        function writeChunk(destination, chunk) {
          if (0 !== chunk.byteLength)
            if (2048 < chunk.byteLength)
              0 < writtenBytes && (destination.enqueue(
                new Uint8Array(currentView.buffer, 0, writtenBytes)
              ), currentView = new Uint8Array(2048), writtenBytes = 0), destination.enqueue(chunk);
            else {
              var allowableBytes = currentView.length - writtenBytes;
              allowableBytes < chunk.byteLength && (0 === allowableBytes ? destination.enqueue(currentView) : (currentView.set(
                chunk.subarray(0, allowableBytes),
                writtenBytes
              ), destination.enqueue(currentView), chunk = chunk.subarray(allowableBytes)), currentView = new Uint8Array(2048), writtenBytes = 0);
              currentView.set(chunk, writtenBytes);
              writtenBytes += chunk.byteLength;
            }
        }
        function writeChunkAndReturn(destination, chunk) {
          writeChunk(destination, chunk);
          return true;
        }
        function completeWriting(destination) {
          currentView && 0 < writtenBytes && (destination.enqueue(
            new Uint8Array(currentView.buffer, 0, writtenBytes)
          ), currentView = null, writtenBytes = 0);
        }
        function stringToChunk(content) {
          return textEncoder.encode(content);
        }
        function stringToPrecomputedChunk(content) {
          content = textEncoder.encode(content);
          2048 < content.byteLength && console.error(
            "precomputed chunks must be smaller than the view size configured for this host. This is a bug in React."
          );
          return content;
        }
        function byteLengthOfChunk(chunk) {
          return chunk.byteLength;
        }
        function closeWithError(destination, error) {
          "function" === typeof destination.error ? destination.error(error) : destination.close();
        }
        function typeName(value) {
          return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        }
        function willCoercionThrow(value) {
          try {
            return testStringCoercion(value), false;
          } catch (e) {
            return true;
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
              attributeName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
              propName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkHtmlStringCoercion(value) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
              typeName(value)
            ), testStringCoercion(value);
        }
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
            return true;
          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
            return false;
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
            return validatedAttributeNameCache[attributeName] = true;
          illegalAttributeNameCache[attributeName] = true;
          console.error("Invalid attribute name: `%s`", attributeName);
          return false;
        }
        function checkControlledValueProps(tagName, props) {
          hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
          ) : console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
          ));
          props.onChange || props.readOnly || props.disabled || null == props.checked || console.error(
            "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
          );
        }
        function validateProperty$1(tagName, name) {
          if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
            return true;
          if (rARIACamel$1.test(name)) {
            tagName = "aria-" + name.slice(4).toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
                name
              ), warnedProperties$1[name] = true;
            if (name !== tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. Did you mean `%s`?",
                name,
                tagName
              ), warnedProperties$1[name] = true;
          }
          if (rARIA$1.test(name)) {
            tagName = name.toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName) return warnedProperties$1[name] = true, false;
            name !== tagName && (console.error(
              "Unknown ARIA attribute `%s`. Did you mean `%s`?",
              name,
              tagName
            ), warnedProperties$1[name] = true);
          }
          return true;
        }
        function validateProperties$2(type, props) {
          var invalidProps = [], key;
          for (key in props)
            validateProperty$1(type, key) || invalidProps.push(key);
          props = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === invalidProps.length ? console.error(
            "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          ) : 1 < invalidProps.length && console.error(
            "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          );
        }
        function validateProperty(tagName, name, value, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
            return true;
          var lowerCasedName = name.toLowerCase();
          if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
            return console.error(
              "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
            ), warnedProperties[name] = true;
          if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name))
            return true;
          if (null != eventRegistry) {
            tagName = eventRegistry.possibleRegistrationNames;
            if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
              return true;
            eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
            if (null != eventRegistry)
              return console.error(
                "Invalid event handler property `%s`. Did you mean `%s`?",
                name,
                eventRegistry
              ), warnedProperties[name] = true;
            if (EVENT_NAME_REGEX.test(name))
              return console.error(
                "Unknown event handler property `%s`. It will be ignored.",
                name
              ), warnedProperties[name] = true;
          } else if (EVENT_NAME_REGEX.test(name))
            return INVALID_EVENT_NAME_REGEX.test(name) && console.error(
              "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
              name
            ), warnedProperties[name] = true;
          if (rARIA.test(name) || rARIACamel.test(name)) return true;
          if ("innerhtml" === lowerCasedName)
            return console.error(
              "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
            ), warnedProperties[name] = true;
          if ("aria" === lowerCasedName)
            return console.error(
              "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
            ), warnedProperties[name] = true;
          if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value)
            return console.error(
              "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
              typeof value
            ), warnedProperties[name] = true;
          if ("number" === typeof value && isNaN(value))
            return console.error(
              "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
              name
            ), warnedProperties[name] = true;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name)
              return console.error(
                "Invalid DOM property `%s`. Did you mean `%s`?",
                name,
                lowerCasedName
              ), warnedProperties[name] = true;
          } else if (name !== lowerCasedName)
            return console.error(
              "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
              name,
              lowerCasedName
            ), warnedProperties[name] = true;
          switch (name) {
            case "dangerouslySetInnerHTML":
            case "children":
            case "style":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              return true;
            case "innerText":
            case "textContent":
              return true;
          }
          switch (typeof value) {
            case "boolean":
              switch (name) {
                case "autoFocus":
                case "checked":
                case "multiple":
                case "muted":
                case "selected":
                case "contentEditable":
                case "spellCheck":
                case "draggable":
                case "value":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                case "capture":
                case "download":
                case "inert":
                  return true;
                default:
                  lowerCasedName = name.toLowerCase().slice(0, 5);
                  if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                    return true;
                  value ? console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                    value,
                    name,
                    name,
                    value,
                    name
                  ) : console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                    value,
                    name,
                    name,
                    value,
                    name,
                    name,
                    name
                  );
                  return warnedProperties[name] = true;
              }
            case "function":
            case "symbol":
              return warnedProperties[name] = true, false;
            case "string":
              if ("false" === value || "true" === value) {
                switch (name) {
                  case "checked":
                  case "selected":
                  case "multiple":
                  case "muted":
                  case "allowFullScreen":
                  case "async":
                  case "autoPlay":
                  case "controls":
                  case "default":
                  case "defer":
                  case "disabled":
                  case "disablePictureInPicture":
                  case "disableRemotePlayback":
                  case "formNoValidate":
                  case "hidden":
                  case "loop":
                  case "noModule":
                  case "noValidate":
                  case "open":
                  case "playsInline":
                  case "readOnly":
                  case "required":
                  case "reversed":
                  case "scoped":
                  case "seamless":
                  case "itemScope":
                  case "inert":
                    break;
                  default:
                    return true;
                }
                console.error(
                  "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
                  value,
                  name,
                  "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
                  name,
                  value
                );
                warnedProperties[name] = true;
              }
          }
          return true;
        }
        function warnUnknownProperties(type, props, eventRegistry) {
          var unknownProps = [], key;
          for (key in props)
            validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
          props = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === unknownProps.length ? console.error(
            "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          ) : 1 < unknownProps.length && console.error(
            "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          );
        }
        function camelize(string) {
          return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
          });
        }
        function escapeTextForBrowser(text) {
          if ("boolean" === typeof text || "number" === typeof text || "bigint" === typeof text)
            return "" + text;
          checkHtmlStringCoercion(text);
          text = "" + text;
          var match = matchHtmlRegExp.exec(text);
          if (match) {
            var html = "", index, lastIndex = 0;
            for (index = match.index; index < text.length; index++) {
              switch (text.charCodeAt(index)) {
                case 34:
                  match = "&quot;";
                  break;
                case 38:
                  match = "&amp;";
                  break;
                case 39:
                  match = "&#x27;";
                  break;
                case 60:
                  match = "&lt;";
                  break;
                case 62:
                  match = "&gt;";
                  break;
                default:
                  continue;
              }
              lastIndex !== index && (html += text.slice(lastIndex, index));
              lastIndex = index + 1;
              html += match;
            }
            text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;
          }
          return text;
        }
        function sanitizeURL(url) {
          return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
        }
        function escapeEntireInlineScriptContent(scriptText) {
          checkHtmlStringCoercion(scriptText);
          return ("" + scriptText).replace(scriptRegex, scriptReplacer);
        }
        function createRenderState(resumableState, nonce, externalRuntimeConfig, importMap, onHeaders, maxHeadersLength) {
          externalRuntimeConfig = "string" === typeof nonce ? nonce : nonce && nonce.script;
          var inlineScriptWithNonce = void 0 === externalRuntimeConfig ? startInlineScript : stringToPrecomputedChunk(
            '<script nonce="' + escapeTextForBrowser(externalRuntimeConfig) + '"'
          ), nonceStyle = "string" === typeof nonce ? void 0 : nonce && nonce.style, inlineStyleWithNonce = void 0 === nonceStyle ? startInlineStyle : stringToPrecomputedChunk(
            '<style nonce="' + escapeTextForBrowser(nonceStyle) + '"'
          ), idPrefix = resumableState.idPrefix, bootstrapChunks = [], bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;
          void 0 !== bootstrapScriptContent && (bootstrapChunks.push(inlineScriptWithNonce), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(
            endOfStartTag,
            stringToChunk(
              escapeEntireInlineScriptContent(bootstrapScriptContent)
            ),
            endInlineScript
          ));
          bootstrapScriptContent = [];
          void 0 !== importMap && (bootstrapScriptContent.push(importMapScriptStart), bootstrapScriptContent.push(
            stringToChunk(
              escapeEntireInlineScriptContent(JSON.stringify(importMap))
            )
          ), bootstrapScriptContent.push(importMapScriptEnd));
          onHeaders && "number" === typeof maxHeadersLength && 0 >= maxHeadersLength && console.error(
            "React expected a positive non-zero `maxHeadersLength` option but found %s instead. When using the `onHeaders` option you may supply an optional `maxHeadersLength` option as well however, when setting this value to zero or less no headers will be captured.",
            0 === maxHeadersLength ? "zero" : maxHeadersLength
          );
          importMap = onHeaders ? {
            preconnects: "",
            fontPreloads: "",
            highImagePreloads: "",
            remainingCapacity: 2 + ("number" === typeof maxHeadersLength ? maxHeadersLength : 2e3)
          } : null;
          onHeaders = {
            placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
            segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
            boundaryPrefix: stringToPrecomputedChunk(idPrefix + "B:"),
            startInlineScript: inlineScriptWithNonce,
            startInlineStyle: inlineStyleWithNonce,
            preamble: createPreambleState(),
            externalRuntimeScript: null,
            bootstrapChunks,
            importMapChunks: bootstrapScriptContent,
            onHeaders,
            headers: importMap,
            resets: {
              font: {},
              dns: {},
              connect: { default: {}, anonymous: {}, credentials: {} },
              image: {},
              style: {}
            },
            charsetChunks: [],
            viewportChunks: [],
            hoistableChunks: [],
            preconnects: /* @__PURE__ */ new Set(),
            fontPreloads: /* @__PURE__ */ new Set(),
            highImagePreloads: /* @__PURE__ */ new Set(),
            styles: /* @__PURE__ */ new Map(),
            bootstrapScripts: /* @__PURE__ */ new Set(),
            scripts: /* @__PURE__ */ new Set(),
            bulkPreloads: /* @__PURE__ */ new Set(),
            preloads: {
              images: /* @__PURE__ */ new Map(),
              stylesheets: /* @__PURE__ */ new Map(),
              scripts: /* @__PURE__ */ new Map(),
              moduleScripts: /* @__PURE__ */ new Map()
            },
            nonce: { script: externalRuntimeConfig, style: nonceStyle },
            hoistableState: null,
            stylesToHoist: false
          };
          if (void 0 !== bootstrapScripts)
            for (importMap = 0; importMap < bootstrapScripts.length; importMap++)
              maxHeadersLength = bootstrapScripts[importMap], inlineStyleWithNonce = nonceStyle = void 0, idPrefix = {
                rel: "preload",
                as: "script",
                fetchPriority: "low",
                nonce
              }, "string" === typeof maxHeadersLength ? idPrefix.href = inlineScriptWithNonce = maxHeadersLength : (idPrefix.href = inlineScriptWithNonce = maxHeadersLength.src, idPrefix.integrity = inlineStyleWithNonce = "string" === typeof maxHeadersLength.integrity ? maxHeadersLength.integrity : void 0, idPrefix.crossOrigin = nonceStyle = "string" === typeof maxHeadersLength || null == maxHeadersLength.crossOrigin ? void 0 : "use-credentials" === maxHeadersLength.crossOrigin ? "use-credentials" : ""), preloadBootstrapScriptOrModule(
                resumableState,
                onHeaders,
                inlineScriptWithNonce,
                idPrefix
              ), bootstrapChunks.push(
                startScriptSrc,
                stringToChunk(escapeTextForBrowser(inlineScriptWithNonce)),
                attributeEnd
              ), externalRuntimeConfig && bootstrapChunks.push(
                scriptNonce,
                stringToChunk(escapeTextForBrowser(externalRuntimeConfig)),
                attributeEnd
              ), "string" === typeof inlineStyleWithNonce && bootstrapChunks.push(
                scriptIntegirty,
                stringToChunk(escapeTextForBrowser(inlineStyleWithNonce)),
                attributeEnd
              ), "string" === typeof nonceStyle && bootstrapChunks.push(
                scriptCrossOrigin,
                stringToChunk(escapeTextForBrowser(nonceStyle)),
                attributeEnd
              ), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(endAsyncScript);
          if (void 0 !== bootstrapModules)
            for (nonce = 0; nonce < bootstrapModules.length; nonce++)
              bootstrapScripts = bootstrapModules[nonce], inlineScriptWithNonce = maxHeadersLength = void 0, nonceStyle = {
                rel: "modulepreload",
                fetchPriority: "low",
                nonce: externalRuntimeConfig
              }, "string" === typeof bootstrapScripts ? nonceStyle.href = importMap = bootstrapScripts : (nonceStyle.href = importMap = bootstrapScripts.src, nonceStyle.integrity = inlineScriptWithNonce = "string" === typeof bootstrapScripts.integrity ? bootstrapScripts.integrity : void 0, nonceStyle.crossOrigin = maxHeadersLength = "string" === typeof bootstrapScripts || null == bootstrapScripts.crossOrigin ? void 0 : "use-credentials" === bootstrapScripts.crossOrigin ? "use-credentials" : ""), preloadBootstrapScriptOrModule(
                resumableState,
                onHeaders,
                importMap,
                nonceStyle
              ), bootstrapChunks.push(
                startModuleSrc,
                stringToChunk(escapeTextForBrowser(importMap)),
                attributeEnd
              ), externalRuntimeConfig && bootstrapChunks.push(
                scriptNonce,
                stringToChunk(escapeTextForBrowser(externalRuntimeConfig)),
                attributeEnd
              ), "string" === typeof inlineScriptWithNonce && bootstrapChunks.push(
                scriptIntegirty,
                stringToChunk(escapeTextForBrowser(inlineScriptWithNonce)),
                attributeEnd
              ), "string" === typeof maxHeadersLength && bootstrapChunks.push(
                scriptCrossOrigin,
                stringToChunk(escapeTextForBrowser(maxHeadersLength)),
                attributeEnd
              ), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(endAsyncScript);
          return onHeaders;
        }
        function createResumableState(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
          return {
            idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
            nextFormID: 0,
            streamingFormat: 0,
            bootstrapScriptContent,
            bootstrapScripts,
            bootstrapModules,
            instructions: NothingSent,
            hasBody: false,
            hasHtml: false,
            unknownResources: {},
            dnsResources: {},
            connectResources: { default: {}, anonymous: {}, credentials: {} },
            imageResources: {},
            styleResources: {},
            scriptResources: {},
            moduleUnknownResources: {},
            moduleScriptResources: {}
          };
        }
        function createPreambleState() {
          return { htmlChunks: null, headChunks: null, bodyChunks: null };
        }
        function createFormatContext(insertionMode, selectedValue, tagScope, viewTransition) {
          return {
            insertionMode,
            selectedValue,
            tagScope,
            viewTransition
          };
        }
        function createRootFormatContext(namespaceURI) {
          return createFormatContext(
            "http://www.w3.org/2000/svg" === namespaceURI ? SVG_MODE : "http://www.w3.org/1998/Math/MathML" === namespaceURI ? MATHML_MODE : ROOT_HTML_MODE,
            null,
            0,
            null
          );
        }
        function getChildFormatContext(parentContext, type, props) {
          var subtreeScope = parentContext.tagScope & -25;
          switch (type) {
            case "noscript":
              return createFormatContext(HTML_MODE, null, subtreeScope | 1, null);
            case "select":
              return createFormatContext(
                HTML_MODE,
                null != props.value ? props.value : props.defaultValue,
                subtreeScope,
                null
              );
            case "svg":
              return createFormatContext(SVG_MODE, null, subtreeScope, null);
            case "picture":
              return createFormatContext(HTML_MODE, null, subtreeScope | 2, null);
            case "math":
              return createFormatContext(MATHML_MODE, null, subtreeScope, null);
            case "foreignObject":
              return createFormatContext(HTML_MODE, null, subtreeScope, null);
            case "table":
              return createFormatContext(HTML_TABLE_MODE, null, subtreeScope, null);
            case "thead":
            case "tbody":
            case "tfoot":
              return createFormatContext(
                HTML_TABLE_BODY_MODE,
                null,
                subtreeScope,
                null
              );
            case "colgroup":
              return createFormatContext(
                HTML_COLGROUP_MODE,
                null,
                subtreeScope,
                null
              );
            case "tr":
              return createFormatContext(
                HTML_TABLE_ROW_MODE,
                null,
                subtreeScope,
                null
              );
            case "head":
              if (parentContext.insertionMode < HTML_MODE)
                return createFormatContext(
                  HTML_HEAD_MODE,
                  null,
                  subtreeScope,
                  null
                );
              break;
            case "html":
              if (parentContext.insertionMode === ROOT_HTML_MODE)
                return createFormatContext(
                  HTML_HTML_MODE,
                  null,
                  subtreeScope,
                  null
                );
          }
          return parentContext.insertionMode >= HTML_TABLE_MODE || parentContext.insertionMode < HTML_MODE ? createFormatContext(HTML_MODE, null, subtreeScope, null) : parentContext.tagScope !== subtreeScope ? createFormatContext(
            parentContext.insertionMode,
            parentContext.selectedValue,
            subtreeScope,
            null
          ) : parentContext;
        }
        function getSuspenseViewTransition(parentViewTransition) {
          return null === parentViewTransition ? null : {
            update: parentViewTransition.update,
            enter: "none",
            exit: "none",
            share: parentViewTransition.update,
            name: parentViewTransition.autoName,
            autoName: parentViewTransition.autoName,
            nameIdx: 0
          };
        }
        function getSuspenseFallbackFormatContext(resumableState, parentContext) {
          parentContext.tagScope & 32 && (resumableState.instructions |= 128);
          return createFormatContext(
            parentContext.insertionMode,
            parentContext.selectedValue,
            parentContext.tagScope | 12,
            getSuspenseViewTransition(parentContext.viewTransition)
          );
        }
        function getSuspenseContentFormatContext(resumableState, parentContext) {
          resumableState = getSuspenseViewTransition(parentContext.viewTransition);
          var subtreeScope = parentContext.tagScope | 16;
          null !== resumableState && "none" !== resumableState.share && (subtreeScope |= 64);
          return createFormatContext(
            parentContext.insertionMode,
            parentContext.selectedValue,
            subtreeScope,
            resumableState
          );
        }
        function pushTextInstance(target, text, renderState, textEmbedded) {
          if ("" === text) return textEmbedded;
          textEmbedded && target.push(textSeparator);
          target.push(stringToChunk(escapeTextForBrowser(text)));
          return true;
        }
        function pushStyleAttribute(target, style2) {
          if ("object" !== typeof style2)
            throw Error(
              "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
            );
          var isFirst = true, styleName;
          for (styleName in style2)
            if (hasOwnProperty.call(style2, styleName)) {
              var styleValue = style2[styleName];
              if (null != styleValue && "boolean" !== typeof styleValue && "" !== styleValue) {
                if (0 === styleName.indexOf("--")) {
                  var nameChunk = stringToChunk(escapeTextForBrowser(styleName));
                  checkCSSPropertyStringCoercion(styleValue, styleName);
                  styleValue = stringToChunk(
                    escapeTextForBrowser(("" + styleValue).trim())
                  );
                } else {
                  nameChunk = styleName;
                  var value = styleValue;
                  if (-1 < nameChunk.indexOf("-")) {
                    var name = nameChunk;
                    warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = true, console.error(
                      "Unsupported style property %s. Did you mean %s?",
                      name,
                      camelize(name.replace(msPattern$1, "ms-"))
                    ));
                  } else if (badVendoredStyleNamePattern.test(nameChunk))
                    name = nameChunk, warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = true, console.error(
                      "Unsupported vendor-prefixed style property %s. Did you mean %s?",
                      name,
                      name.charAt(0).toUpperCase() + name.slice(1)
                    ));
                  else if (badStyleValueWithSemicolonPattern.test(value)) {
                    name = nameChunk;
                    var value$jscomp$0 = value;
                    warnedStyleValues.hasOwnProperty(value$jscomp$0) && warnedStyleValues[value$jscomp$0] || (warnedStyleValues[value$jscomp$0] = true, console.error(
                      `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
                      name,
                      value$jscomp$0.replace(
                        badStyleValueWithSemicolonPattern,
                        ""
                      )
                    ));
                  }
                  "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error(
                    "`NaN` is an invalid value for the `%s` css style property.",
                    nameChunk
                  )) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error(
                    "`Infinity` is an invalid value for the `%s` css style property.",
                    nameChunk
                  )));
                  nameChunk = styleName;
                  value = styleNameCache.get(nameChunk);
                  void 0 !== value ? nameChunk = value : (value = stringToPrecomputedChunk(
                    escapeTextForBrowser(
                      nameChunk.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-")
                    )
                  ), styleNameCache.set(nameChunk, value), nameChunk = value);
                  "number" === typeof styleValue ? styleValue = 0 === styleValue || unitlessNumbers.has(styleName) ? stringToChunk("" + styleValue) : stringToChunk(styleValue + "px") : (checkCSSPropertyStringCoercion(styleValue, styleName), styleValue = stringToChunk(
                    escapeTextForBrowser(("" + styleValue).trim())
                  ));
                }
                isFirst ? (isFirst = false, target.push(
                  styleAttributeStart,
                  nameChunk,
                  styleAssign,
                  styleValue
                )) : target.push(styleSeparator, nameChunk, styleAssign, styleValue);
              }
            }
          isFirst || target.push(attributeEnd);
        }
        function pushBooleanAttribute(target, name, value) {
          value && "function" !== typeof value && "symbol" !== typeof value && target.push(
            attributeSeparator,
            stringToChunk(name),
            attributeEmptyString
          );
        }
        function pushStringAttribute(target, name, value) {
          "function" !== typeof value && "symbol" !== typeof value && "boolean" !== typeof value && target.push(
            attributeSeparator,
            stringToChunk(name),
            attributeAssign,
            stringToChunk(escapeTextForBrowser(value)),
            attributeEnd
          );
        }
        function pushAdditionalFormField(value, key) {
          this.push(startHiddenInputChunk);
          validateAdditionalFormField(value);
          pushStringAttribute(this, "name", key);
          pushStringAttribute(this, "value", value);
          this.push(endOfStartTagSelfClosing);
        }
        function validateAdditionalFormField(value) {
          if ("string" !== typeof value)
            throw Error(
              "File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration."
            );
        }
        function getCustomFormFields(resumableState, formAction) {
          if ("function" === typeof formAction.$$FORM_ACTION) {
            var id = resumableState.nextFormID++;
            resumableState = resumableState.idPrefix + id;
            try {
              var customFields = formAction.$$FORM_ACTION(resumableState);
              if (customFields) {
                var formData = customFields.data;
                null != formData && formData.forEach(validateAdditionalFormField);
              }
              return customFields;
            } catch (x) {
              if ("object" === typeof x && null !== x && "function" === typeof x.then)
                throw x;
              console.error(
                "Failed to serialize an action for progressive enhancement:\n%s",
                x
              );
            }
          }
          return null;
        }
        function pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name) {
          var formData = null;
          if ("function" === typeof formAction) {
            null === name || didWarnFormActionName || (didWarnFormActionName = true, console.error(
              'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
            ));
            null === formEncType && null === formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
              "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
            ));
            null === formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
              "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
            ));
            var customFields = getCustomFormFields(resumableState, formAction);
            null !== customFields ? (name = customFields.name, formAction = customFields.action || "", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(
              attributeSeparator,
              stringToChunk("formAction"),
              attributeAssign,
              actionJavaScriptURL,
              attributeEnd
            ), formTarget = formMethod = formEncType = formAction = name = null, injectFormReplayingRuntime(resumableState, renderState));
          }
          null != name && pushAttribute(target, "name", name);
          null != formAction && pushAttribute(target, "formAction", formAction);
          null != formEncType && pushAttribute(target, "formEncType", formEncType);
          null != formMethod && pushAttribute(target, "formMethod", formMethod);
          null != formTarget && pushAttribute(target, "formTarget", formTarget);
          return formData;
        }
        function pushAttribute(target, name, value) {
          switch (name) {
            case "className":
              pushStringAttribute(target, "class", value);
              break;
            case "tabIndex":
              pushStringAttribute(target, "tabindex", value);
              break;
            case "dir":
            case "role":
            case "viewBox":
            case "width":
            case "height":
              pushStringAttribute(target, name, value);
              break;
            case "style":
              pushStyleAttribute(target, value);
              break;
            case "src":
            case "href":
              if ("" === value) {
                "src" === name ? console.error(
                  'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  name,
                  name
                ) : console.error(
                  'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  name,
                  name
                );
                break;
              }
            case "action":
            case "formAction":
              if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
                break;
              checkAttributeStringCoercion(value, name);
              value = sanitizeURL("" + value);
              target.push(
                attributeSeparator,
                stringToChunk(name),
                attributeAssign,
                stringToChunk(escapeTextForBrowser(value)),
                attributeEnd
              );
              break;
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "ref":
              break;
            case "autoFocus":
            case "multiple":
            case "muted":
              pushBooleanAttribute(target, name.toLowerCase(), value);
              break;
            case "xlinkHref":
              if ("function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
                break;
              checkAttributeStringCoercion(value, name);
              value = sanitizeURL("" + value);
              target.push(
                attributeSeparator,
                stringToChunk("xlink:href"),
                attributeAssign,
                stringToChunk(escapeTextForBrowser(value)),
                attributeEnd
              );
              break;
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
              "function" !== typeof value && "symbol" !== typeof value && target.push(
                attributeSeparator,
                stringToChunk(name),
                attributeAssign,
                stringToChunk(escapeTextForBrowser(value)),
                attributeEnd
              );
              break;
            case "inert":
              "" !== value || didWarnForNewBooleanPropsWithEmptyValue[name] || (didWarnForNewBooleanPropsWithEmptyValue[name] = true, console.error(
                "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                name
              ));
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
              value && "function" !== typeof value && "symbol" !== typeof value && target.push(
                attributeSeparator,
                stringToChunk(name),
                attributeEmptyString
              );
              break;
            case "capture":
            case "download":
              true === value ? target.push(
                attributeSeparator,
                stringToChunk(name),
                attributeEmptyString
              ) : false !== value && "function" !== typeof value && "symbol" !== typeof value && target.push(
                attributeSeparator,
                stringToChunk(name),
                attributeAssign,
                stringToChunk(escapeTextForBrowser(value)),
                attributeEnd
              );
              break;
            case "cols":
            case "rows":
            case "size":
            case "span":
              "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value && target.push(
                attributeSeparator,
                stringToChunk(name),
                attributeAssign,
                stringToChunk(escapeTextForBrowser(value)),
                attributeEnd
              );
              break;
            case "rowSpan":
            case "start":
              "function" === typeof value || "symbol" === typeof value || isNaN(value) || target.push(
                attributeSeparator,
                stringToChunk(name),
                attributeAssign,
                stringToChunk(escapeTextForBrowser(value)),
                attributeEnd
              );
              break;
            case "xlinkActuate":
              pushStringAttribute(target, "xlink:actuate", value);
              break;
            case "xlinkArcrole":
              pushStringAttribute(target, "xlink:arcrole", value);
              break;
            case "xlinkRole":
              pushStringAttribute(target, "xlink:role", value);
              break;
            case "xlinkShow":
              pushStringAttribute(target, "xlink:show", value);
              break;
            case "xlinkTitle":
              pushStringAttribute(target, "xlink:title", value);
              break;
            case "xlinkType":
              pushStringAttribute(target, "xlink:type", value);
              break;
            case "xmlBase":
              pushStringAttribute(target, "xml:base", value);
              break;
            case "xmlLang":
              pushStringAttribute(target, "xml:lang", value);
              break;
            case "xmlSpace":
              pushStringAttribute(target, "xml:space", value);
              break;
            default:
              if (!(2 < name.length) || "o" !== name[0] && "O" !== name[0] || "n" !== name[1] && "N" !== name[1]) {
                if (name = aliases.get(name) || name, isAttributeNameSafe(name)) {
                  switch (typeof value) {
                    case "function":
                    case "symbol":
                      return;
                    case "boolean":
                      var prefix2 = name.toLowerCase().slice(0, 5);
                      if ("data-" !== prefix2 && "aria-" !== prefix2) return;
                  }
                  target.push(
                    attributeSeparator,
                    stringToChunk(name),
                    attributeAssign,
                    stringToChunk(escapeTextForBrowser(value)),
                    attributeEnd
                  );
                }
              }
          }
        }
        function pushInnerHTML(target, innerHTML, children) {
          if (null != innerHTML) {
            if (null != children)
              throw Error(
                "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
              );
            if ("object" !== typeof innerHTML || !("__html" in innerHTML))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            innerHTML = innerHTML.__html;
            null !== innerHTML && void 0 !== innerHTML && (checkHtmlStringCoercion(innerHTML), target.push(stringToChunk("" + innerHTML)));
          }
        }
        function checkSelectProp(props, propName) {
          var value = props[propName];
          null != value && (value = isArrayImpl(value), props.multiple && !value ? console.error(
            "The `%s` prop supplied to <select> must be an array if `multiple` is true.",
            propName
          ) : !props.multiple && value && console.error(
            "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.",
            propName
          ));
        }
        function flattenOptionChildren(children) {
          var content = "";
          React9.Children.forEach(children, function(child) {
            null != child && (content += child, didWarnInvalidOptionChildren || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || (didWarnInvalidOptionChildren = true, console.error(
              "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
            )));
          });
          return content;
        }
        function injectFormReplayingRuntime(resumableState, renderState) {
          if ((resumableState.instructions & 16) === NothingSent) {
            resumableState.instructions |= 16;
            var preamble = renderState.preamble, bootstrapChunks = renderState.bootstrapChunks;
            (preamble.htmlChunks || preamble.headChunks) && 0 === bootstrapChunks.length ? (bootstrapChunks.push(renderState.startInlineScript), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(
              endOfStartTag,
              formReplayingRuntimeScript,
              endInlineScript
            )) : bootstrapChunks.unshift(
              renderState.startInlineScript,
              endOfStartTag,
              formReplayingRuntimeScript,
              endInlineScript
            );
          }
        }
        function pushLinkImpl(target, props) {
          target.push(startChunkForTag("link"));
          for (var propKey in props)
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  default:
                    pushAttribute(target, propKey, propValue);
                }
            }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function escapeStyleTextContent(styleText) {
          checkHtmlStringCoercion(styleText);
          return ("" + styleText).replace(styleRegex, styleReplacer);
        }
        function pushSelfClosing(target, props, tag) {
          target.push(startChunkForTag(tag));
          for (var propKey in props)
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  default:
                    pushAttribute(target, propKey, propValue);
                }
            }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushTitleImpl(target, props) {
          target.push(startChunkForTag("title"));
          var children = null, innerHTML = null, propKey;
          for (propKey in props)
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  default:
                    pushAttribute(target, propKey, propValue);
                }
            }
          target.push(endOfStartTag);
          props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;
          "function" !== typeof props && "symbol" !== typeof props && null !== props && void 0 !== props && target.push(stringToChunk(escapeTextForBrowser("" + props)));
          pushInnerHTML(target, innerHTML, children);
          target.push(endChunkForTag("title"));
          return null;
        }
        function pushScriptImpl(target, props) {
          target.push(startChunkForTag("script"));
          var children = null, innerHTML = null, propKey;
          for (propKey in props)
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  default:
                    pushAttribute(target, propKey, propValue);
                }
            }
          target.push(endOfStartTag);
          null != children && "string" !== typeof children && (props = "number" === typeof children ? "a number for children" : Array.isArray(children) ? "an array for children" : "something unexpected for children", console.error(
            "A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.",
            props
          ));
          pushInnerHTML(target, innerHTML, children);
          "string" === typeof children && target.push(stringToChunk(escapeEntireInlineScriptContent(children)));
          target.push(endChunkForTag("script"));
          return null;
        }
        function pushStartSingletonElement(target, props, tag) {
          target.push(startChunkForTag(tag));
          var innerHTML = tag = null, propKey;
          for (propKey in props)
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "children":
                    tag = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  default:
                    pushAttribute(target, propKey, propValue);
                }
            }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, tag);
          return tag;
        }
        function pushStartGenericElement(target, props, tag) {
          target.push(startChunkForTag(tag));
          var innerHTML = tag = null, propKey;
          for (propKey in props)
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "children":
                    tag = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  default:
                    pushAttribute(target, propKey, propValue);
                }
            }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, tag);
          return "string" === typeof tag ? (target.push(stringToChunk(escapeTextForBrowser(tag))), null) : tag;
        }
        function startChunkForTag(tag) {
          var tagStartChunk = validatedTagCache.get(tag);
          if (void 0 === tagStartChunk) {
            if (!VALID_TAG_REGEX.test(tag)) throw Error("Invalid tag: " + tag);
            tagStartChunk = stringToPrecomputedChunk("<" + tag);
            validatedTagCache.set(tag, tagStartChunk);
          }
          return tagStartChunk;
        }
        function pushStartInstance(target$jscomp$0, type, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded) {
          validateProperties$2(type, props);
          "input" !== type && "textarea" !== type && "select" !== type || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = true, "select" === type && props.multiple ? console.error(
            "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
            type
          ) : console.error(
            "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
            type
          ));
          b: if (-1 === type.indexOf("-")) var JSCompiler_inline_result = false;
          else
            switch (type) {
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                JSCompiler_inline_result = false;
                break b;
              default:
                JSCompiler_inline_result = true;
            }
          JSCompiler_inline_result || "string" === typeof props.is || warnUnknownProperties(type, props, null);
          !props.suppressContentEditableWarning && props.contentEditable && null != props.children && console.error(
            "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
          );
          formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE && -1 === type.indexOf("-") && type.toLowerCase() !== type && console.error(
            "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
            type
          );
          switch (type) {
            case "div":
            case "span":
            case "svg":
            case "path":
              break;
            case "a":
              target$jscomp$0.push(startChunkForTag("a"));
              var children = null, innerHTML = null, propKey;
              for (propKey in props)
                if (hasOwnProperty.call(props, propKey)) {
                  var propValue = props[propKey];
                  if (null != propValue)
                    switch (propKey) {
                      case "children":
                        children = propValue;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML = propValue;
                        break;
                      case "href":
                        "" === propValue ? pushStringAttribute(target$jscomp$0, "href", "") : pushAttribute(target$jscomp$0, propKey, propValue);
                        break;
                      default:
                        pushAttribute(target$jscomp$0, propKey, propValue);
                    }
                }
              target$jscomp$0.push(endOfStartTag);
              pushInnerHTML(target$jscomp$0, innerHTML, children);
              if ("string" === typeof children) {
                target$jscomp$0.push(stringToChunk(escapeTextForBrowser(children)));
                var JSCompiler_inline_result$jscomp$0 = null;
              } else JSCompiler_inline_result$jscomp$0 = children;
              return JSCompiler_inline_result$jscomp$0;
            case "g":
            case "p":
            case "li":
              break;
            case "select":
              checkControlledValueProps("select", props);
              checkSelectProp(props, "value");
              checkSelectProp(props, "defaultValue");
              void 0 === props.value || void 0 === props.defaultValue || didWarnDefaultSelectValue || (console.error(
                "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
              ), didWarnDefaultSelectValue = true);
              target$jscomp$0.push(startChunkForTag("select"));
              var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;
              for (propKey$jscomp$0 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$0)) {
                  var propValue$jscomp$0 = props[propKey$jscomp$0];
                  if (null != propValue$jscomp$0)
                    switch (propKey$jscomp$0) {
                      case "children":
                        children$jscomp$0 = propValue$jscomp$0;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$0 = propValue$jscomp$0;
                        break;
                      case "defaultValue":
                      case "value":
                        break;
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$0,
                          propValue$jscomp$0
                        );
                    }
                }
              target$jscomp$0.push(endOfStartTag);
              pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);
              return children$jscomp$0;
            case "option":
              var selectedValue = formatContext.selectedValue;
              target$jscomp$0.push(startChunkForTag("option"));
              var children$jscomp$1 = null, value = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;
              for (propKey$jscomp$1 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$1)) {
                  var propValue$jscomp$1 = props[propKey$jscomp$1];
                  if (null != propValue$jscomp$1)
                    switch (propKey$jscomp$1) {
                      case "children":
                        children$jscomp$1 = propValue$jscomp$1;
                        break;
                      case "selected":
                        selected = propValue$jscomp$1;
                        didWarnSelectedSetOnOption || (console.error(
                          "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
                        ), didWarnSelectedSetOnOption = true);
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$1 = propValue$jscomp$1;
                        break;
                      case "value":
                        value = propValue$jscomp$1;
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$1,
                          propValue$jscomp$1
                        );
                    }
                }
              if (null != selectedValue) {
                if (null !== value) {
                  checkAttributeStringCoercion(value, "value");
                  var stringValue = "" + value;
                } else
                  null === innerHTML$jscomp$1 || didWarnInvalidOptionInnerHTML || (didWarnInvalidOptionInnerHTML = true, console.error(
                    "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
                  )), stringValue = flattenOptionChildren(children$jscomp$1);
                if (isArrayImpl(selectedValue))
                  for (var i = 0; i < selectedValue.length; i++) {
                    if (checkAttributeStringCoercion(selectedValue[i], "value"), "" + selectedValue[i] === stringValue) {
                      target$jscomp$0.push(selectedMarkerAttribute);
                      break;
                    }
                  }
                else
                  checkAttributeStringCoercion(selectedValue, "select.value"), "" + selectedValue === stringValue && target$jscomp$0.push(selectedMarkerAttribute);
              } else selected && target$jscomp$0.push(selectedMarkerAttribute);
              target$jscomp$0.push(endOfStartTag);
              pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);
              return children$jscomp$1;
            case "textarea":
              checkControlledValueProps("textarea", props);
              void 0 === props.value || void 0 === props.defaultValue || didWarnDefaultTextareaValue || (console.error(
                "Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components"
              ), didWarnDefaultTextareaValue = true);
              target$jscomp$0.push(startChunkForTag("textarea"));
              var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;
              for (propKey$jscomp$2 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$2)) {
                  var propValue$jscomp$2 = props[propKey$jscomp$2];
                  if (null != propValue$jscomp$2)
                    switch (propKey$jscomp$2) {
                      case "children":
                        children$jscomp$2 = propValue$jscomp$2;
                        break;
                      case "value":
                        value$jscomp$0 = propValue$jscomp$2;
                        break;
                      case "defaultValue":
                        defaultValue = propValue$jscomp$2;
                        break;
                      case "dangerouslySetInnerHTML":
                        throw Error(
                          "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                        );
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$2,
                          propValue$jscomp$2
                        );
                    }
                }
              null === value$jscomp$0 && null !== defaultValue && (value$jscomp$0 = defaultValue);
              target$jscomp$0.push(endOfStartTag);
              if (null != children$jscomp$2) {
                console.error(
                  "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
                );
                if (null != value$jscomp$0)
                  throw Error(
                    "If you supply `defaultValue` on a <textarea>, do not pass children."
                  );
                if (isArrayImpl(children$jscomp$2)) {
                  if (1 < children$jscomp$2.length)
                    throw Error("<textarea> can only have at most one child.");
                  checkHtmlStringCoercion(children$jscomp$2[0]);
                  value$jscomp$0 = "" + children$jscomp$2[0];
                }
                checkHtmlStringCoercion(children$jscomp$2);
                value$jscomp$0 = "" + children$jscomp$2;
              }
              "string" === typeof value$jscomp$0 && "\n" === value$jscomp$0[0] && target$jscomp$0.push(leadingNewline);
              null !== value$jscomp$0 && (checkAttributeStringCoercion(value$jscomp$0, "value"), target$jscomp$0.push(
                stringToChunk(escapeTextForBrowser("" + value$jscomp$0))
              ));
              return null;
            case "input":
              checkControlledValueProps("input", props);
              target$jscomp$0.push(startChunkForTag("input"));
              var name = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;
              for (propKey$jscomp$3 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$3)) {
                  var propValue$jscomp$3 = props[propKey$jscomp$3];
                  if (null != propValue$jscomp$3)
                    switch (propKey$jscomp$3) {
                      case "children":
                      case "dangerouslySetInnerHTML":
                        throw Error(
                          "input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      case "name":
                        name = propValue$jscomp$3;
                        break;
                      case "formAction":
                        formAction = propValue$jscomp$3;
                        break;
                      case "formEncType":
                        formEncType = propValue$jscomp$3;
                        break;
                      case "formMethod":
                        formMethod = propValue$jscomp$3;
                        break;
                      case "formTarget":
                        formTarget = propValue$jscomp$3;
                        break;
                      case "defaultChecked":
                        defaultChecked = propValue$jscomp$3;
                        break;
                      case "defaultValue":
                        defaultValue$jscomp$0 = propValue$jscomp$3;
                        break;
                      case "checked":
                        checked = propValue$jscomp$3;
                        break;
                      case "value":
                        value$jscomp$1 = propValue$jscomp$3;
                        break;
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$3,
                          propValue$jscomp$3
                        );
                    }
                }
              null === formAction || "image" === props.type || "submit" === props.type || didWarnFormActionType || (didWarnFormActionType = true, console.error(
                'An input can only specify a formAction along with type="submit" or type="image".'
              ));
              var formData = pushFormActionAttribute(
                target$jscomp$0,
                resumableState,
                renderState,
                formAction,
                formEncType,
                formMethod,
                formTarget,
                name
              );
              null === checked || null === defaultChecked || didWarnDefaultChecked || (console.error(
                "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
                "A component",
                props.type
              ), didWarnDefaultChecked = true);
              null === value$jscomp$1 || null === defaultValue$jscomp$0 || didWarnDefaultInputValue || (console.error(
                "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
                "A component",
                props.type
              ), didWarnDefaultInputValue = true);
              null !== checked ? pushBooleanAttribute(target$jscomp$0, "checked", checked) : null !== defaultChecked && pushBooleanAttribute(target$jscomp$0, "checked", defaultChecked);
              null !== value$jscomp$1 ? pushAttribute(target$jscomp$0, "value", value$jscomp$1) : null !== defaultValue$jscomp$0 && pushAttribute(target$jscomp$0, "value", defaultValue$jscomp$0);
              target$jscomp$0.push(endOfStartTagSelfClosing);
              null != formData && formData.forEach(pushAdditionalFormField, target$jscomp$0);
              return null;
            case "button":
              target$jscomp$0.push(startChunkForTag("button"));
              var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;
              for (propKey$jscomp$4 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$4)) {
                  var propValue$jscomp$4 = props[propKey$jscomp$4];
                  if (null != propValue$jscomp$4)
                    switch (propKey$jscomp$4) {
                      case "children":
                        children$jscomp$3 = propValue$jscomp$4;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$2 = propValue$jscomp$4;
                        break;
                      case "name":
                        name$jscomp$0 = propValue$jscomp$4;
                        break;
                      case "formAction":
                        formAction$jscomp$0 = propValue$jscomp$4;
                        break;
                      case "formEncType":
                        formEncType$jscomp$0 = propValue$jscomp$4;
                        break;
                      case "formMethod":
                        formMethod$jscomp$0 = propValue$jscomp$4;
                        break;
                      case "formTarget":
                        formTarget$jscomp$0 = propValue$jscomp$4;
                        break;
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$4,
                          propValue$jscomp$4
                        );
                    }
                }
              null === formAction$jscomp$0 || null == props.type || "submit" === props.type || didWarnFormActionType || (didWarnFormActionType = true, console.error(
                'A button can only specify a formAction along with type="submit" or no type.'
              ));
              var formData$jscomp$0 = pushFormActionAttribute(
                target$jscomp$0,
                resumableState,
                renderState,
                formAction$jscomp$0,
                formEncType$jscomp$0,
                formMethod$jscomp$0,
                formTarget$jscomp$0,
                name$jscomp$0
              );
              target$jscomp$0.push(endOfStartTag);
              null != formData$jscomp$0 && formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);
              pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);
              if ("string" === typeof children$jscomp$3) {
                target$jscomp$0.push(
                  stringToChunk(escapeTextForBrowser(children$jscomp$3))
                );
                var JSCompiler_inline_result$jscomp$1 = null;
              } else JSCompiler_inline_result$jscomp$1 = children$jscomp$3;
              return JSCompiler_inline_result$jscomp$1;
            case "form":
              target$jscomp$0.push(startChunkForTag("form"));
              var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;
              for (propKey$jscomp$5 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$5)) {
                  var propValue$jscomp$5 = props[propKey$jscomp$5];
                  if (null != propValue$jscomp$5)
                    switch (propKey$jscomp$5) {
                      case "children":
                        children$jscomp$4 = propValue$jscomp$5;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$3 = propValue$jscomp$5;
                        break;
                      case "action":
                        formAction$jscomp$1 = propValue$jscomp$5;
                        break;
                      case "encType":
                        formEncType$jscomp$1 = propValue$jscomp$5;
                        break;
                      case "method":
                        formMethod$jscomp$1 = propValue$jscomp$5;
                        break;
                      case "target":
                        formTarget$jscomp$1 = propValue$jscomp$5;
                        break;
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$5,
                          propValue$jscomp$5
                        );
                    }
                }
              var formData$jscomp$1 = null, formActionName = null;
              if ("function" === typeof formAction$jscomp$1) {
                null === formEncType$jscomp$1 && null === formMethod$jscomp$1 || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                  "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
                ));
                null === formTarget$jscomp$1 || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                  "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
                ));
                var customFields = getCustomFormFields(
                  resumableState,
                  formAction$jscomp$1
                );
                null !== customFields ? (formAction$jscomp$1 = customFields.action || "", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(
                  attributeSeparator,
                  stringToChunk("action"),
                  attributeAssign,
                  actionJavaScriptURL,
                  attributeEnd
                ), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime(resumableState, renderState));
              }
              null != formAction$jscomp$1 && pushAttribute(target$jscomp$0, "action", formAction$jscomp$1);
              null != formEncType$jscomp$1 && pushAttribute(target$jscomp$0, "encType", formEncType$jscomp$1);
              null != formMethod$jscomp$1 && pushAttribute(target$jscomp$0, "method", formMethod$jscomp$1);
              null != formTarget$jscomp$1 && pushAttribute(target$jscomp$0, "target", formTarget$jscomp$1);
              target$jscomp$0.push(endOfStartTag);
              null !== formActionName && (target$jscomp$0.push(startHiddenInputChunk), pushStringAttribute(target$jscomp$0, "name", formActionName), target$jscomp$0.push(endOfStartTagSelfClosing), null != formData$jscomp$1 && formData$jscomp$1.forEach(
                pushAdditionalFormField,
                target$jscomp$0
              ));
              pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);
              if ("string" === typeof children$jscomp$4) {
                target$jscomp$0.push(
                  stringToChunk(escapeTextForBrowser(children$jscomp$4))
                );
                var JSCompiler_inline_result$jscomp$2 = null;
              } else JSCompiler_inline_result$jscomp$2 = children$jscomp$4;
              return JSCompiler_inline_result$jscomp$2;
            case "menuitem":
              target$jscomp$0.push(startChunkForTag("menuitem"));
              for (var propKey$jscomp$6 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$6)) {
                  var propValue$jscomp$6 = props[propKey$jscomp$6];
                  if (null != propValue$jscomp$6)
                    switch (propKey$jscomp$6) {
                      case "children":
                      case "dangerouslySetInnerHTML":
                        throw Error(
                          "menuitems cannot have `children` nor `dangerouslySetInnerHTML`."
                        );
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$6,
                          propValue$jscomp$6
                        );
                    }
                }
              target$jscomp$0.push(endOfStartTag);
              return null;
            case "object":
              target$jscomp$0.push(startChunkForTag("object"));
              var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;
              for (propKey$jscomp$7 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$7)) {
                  var propValue$jscomp$7 = props[propKey$jscomp$7];
                  if (null != propValue$jscomp$7)
                    switch (propKey$jscomp$7) {
                      case "children":
                        children$jscomp$5 = propValue$jscomp$7;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$4 = propValue$jscomp$7;
                        break;
                      case "data":
                        checkAttributeStringCoercion(propValue$jscomp$7, "data");
                        var sanitizedValue = sanitizeURL("" + propValue$jscomp$7);
                        if ("" === sanitizedValue) {
                          console.error(
                            'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                            propKey$jscomp$7,
                            propKey$jscomp$7
                          );
                          break;
                        }
                        target$jscomp$0.push(
                          attributeSeparator,
                          stringToChunk("data"),
                          attributeAssign,
                          stringToChunk(escapeTextForBrowser(sanitizedValue)),
                          attributeEnd
                        );
                        break;
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$7,
                          propValue$jscomp$7
                        );
                    }
                }
              target$jscomp$0.push(endOfStartTag);
              pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);
              if ("string" === typeof children$jscomp$5) {
                target$jscomp$0.push(
                  stringToChunk(escapeTextForBrowser(children$jscomp$5))
                );
                var JSCompiler_inline_result$jscomp$3 = null;
              } else JSCompiler_inline_result$jscomp$3 = children$jscomp$5;
              return JSCompiler_inline_result$jscomp$3;
            case "title":
              var noscriptTagInScope = formatContext.tagScope & 1, isFallback = formatContext.tagScope & 4;
              if (hasOwnProperty.call(props, "children")) {
                var children$jscomp$6 = props.children, child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;
                Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length ? console.error(
                  "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be common to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.",
                  children$jscomp$6.length
                ) : "function" === typeof child || "symbol" === typeof child ? console.error(
                  "React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.",
                  "function" === typeof child ? "a Function" : "a Sybmol"
                ) : child && child.toString === {}.toString && (null != child.$$typeof ? console.error(
                  "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML."
                ) : console.error(
                  "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>."
                ));
              }
              if (formatContext.insertionMode === SVG_MODE || noscriptTagInScope || null != props.itemProp)
                var JSCompiler_inline_result$jscomp$4 = pushTitleImpl(
                  target$jscomp$0,
                  props
                );
              else
                isFallback ? JSCompiler_inline_result$jscomp$4 = null : (pushTitleImpl(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$4 = void 0);
              return JSCompiler_inline_result$jscomp$4;
            case "link":
              var noscriptTagInScope$jscomp$0 = formatContext.tagScope & 1, isFallback$jscomp$0 = formatContext.tagScope & 4, rel = props.rel, href = props.href, precedence = props.precedence;
              if (formatContext.insertionMode === SVG_MODE || noscriptTagInScope$jscomp$0 || null != props.itemProp || "string" !== typeof rel || "string" !== typeof href || "" === href) {
                "stylesheet" === rel && "string" === typeof props.precedence && ("string" === typeof href && href || console.error(
                  'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.',
                  null === href ? "`null`" : void 0 === href ? "`undefined`" : "" === href ? "an empty string" : 'something with type "' + typeof href + '"'
                ));
                pushLinkImpl(target$jscomp$0, props);
                var JSCompiler_inline_result$jscomp$5 = null;
              } else if ("stylesheet" === props.rel)
                if ("string" !== typeof precedence || null != props.disabled || props.onLoad || props.onError) {
                  if ("string" === typeof precedence) {
                    if (null != props.disabled)
                      console.error(
                        'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.'
                      );
                    else if (props.onLoad || props.onError) {
                      var propDescription = props.onLoad && props.onError ? "`onLoad` and `onError` props" : props.onLoad ? "`onLoad` prop" : "`onError` prop";
                      console.error(
                        'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                        propDescription,
                        propDescription
                      );
                    }
                  }
                  JSCompiler_inline_result$jscomp$5 = pushLinkImpl(
                    target$jscomp$0,
                    props
                  );
                } else {
                  var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(
                    href
                  ) ? resumableState.styleResources[href] : void 0;
                  if (resourceState !== EXISTS) {
                    resumableState.styleResources[href] = EXISTS;
                    styleQueue || (styleQueue = {
                      precedence: stringToChunk(escapeTextForBrowser(precedence)),
                      rules: [],
                      hrefs: [],
                      sheets: /* @__PURE__ */ new Map()
                    }, renderState.styles.set(precedence, styleQueue));
                    var resource = {
                      state: PENDING$1,
                      props: assign2({}, props, {
                        "data-precedence": props.precedence,
                        precedence: null
                      })
                    };
                    if (resourceState) {
                      2 === resourceState.length && adoptPreloadCredentials(resource.props, resourceState);
                      var preloadResource = renderState.preloads.stylesheets.get(href);
                      preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = PRELOADED;
                    }
                    styleQueue.sheets.set(href, resource);
                    hoistableState && hoistableState.stylesheets.add(resource);
                  } else if (styleQueue) {
                    var _resource = styleQueue.sheets.get(href);
                    _resource && hoistableState && hoistableState.stylesheets.add(_resource);
                  }
                  textEmbedded && target$jscomp$0.push(textSeparator);
                  JSCompiler_inline_result$jscomp$5 = null;
                }
              else
                props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$5 = pushLinkImpl(
                  target$jscomp$0,
                  props
                ) : (textEmbedded && target$jscomp$0.push(textSeparator), JSCompiler_inline_result$jscomp$5 = isFallback$jscomp$0 ? null : pushLinkImpl(renderState.hoistableChunks, props));
              return JSCompiler_inline_result$jscomp$5;
            case "script":
              var noscriptTagInScope$jscomp$1 = formatContext.tagScope & 1, asyncProp = props.async;
              if ("string" !== typeof props.src || !props.src || !asyncProp || "function" === typeof asyncProp || "symbol" === typeof asyncProp || props.onLoad || props.onError || formatContext.insertionMode === SVG_MODE || noscriptTagInScope$jscomp$1 || null != props.itemProp)
                var JSCompiler_inline_result$jscomp$6 = pushScriptImpl(
                  target$jscomp$0,
                  props
                );
              else {
                var key = props.src;
                if ("module" === props.type) {
                  var resources = resumableState.moduleScriptResources;
                  var preloads = renderState.preloads.moduleScripts;
                } else
                  resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;
                var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : void 0;
                if (resourceState$jscomp$0 !== EXISTS) {
                  resources[key] = EXISTS;
                  var scriptProps = props;
                  if (resourceState$jscomp$0) {
                    2 === resourceState$jscomp$0.length && (scriptProps = assign2({}, props), adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));
                    var preloadResource$jscomp$0 = preloads.get(key);
                    preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);
                  }
                  var resource$jscomp$0 = [];
                  renderState.scripts.add(resource$jscomp$0);
                  pushScriptImpl(resource$jscomp$0, scriptProps);
                }
                textEmbedded && target$jscomp$0.push(textSeparator);
                JSCompiler_inline_result$jscomp$6 = null;
              }
              return JSCompiler_inline_result$jscomp$6;
            case "style":
              var noscriptTagInScope$jscomp$2 = formatContext.tagScope & 1;
              if (hasOwnProperty.call(props, "children")) {
                var children$jscomp$7 = props.children, child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;
                ("function" === typeof child$jscomp$0 || "symbol" === typeof child$jscomp$0 || Array.isArray(child$jscomp$0)) && console.error(
                  "React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.",
                  "function" === typeof child$jscomp$0 ? "a Function" : "symbol" === typeof child$jscomp$0 ? "a Sybmol" : "an Array"
                );
              }
              var precedence$jscomp$0 = props.precedence, href$jscomp$0 = props.href, nonce = props.nonce;
              if (formatContext.insertionMode === SVG_MODE || noscriptTagInScope$jscomp$2 || null != props.itemProp || "string" !== typeof precedence$jscomp$0 || "string" !== typeof href$jscomp$0 || "" === href$jscomp$0) {
                target$jscomp$0.push(startChunkForTag("style"));
                var children$jscomp$8 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;
                for (propKey$jscomp$8 in props)
                  if (hasOwnProperty.call(props, propKey$jscomp$8)) {
                    var propValue$jscomp$8 = props[propKey$jscomp$8];
                    if (null != propValue$jscomp$8)
                      switch (propKey$jscomp$8) {
                        case "children":
                          children$jscomp$8 = propValue$jscomp$8;
                          break;
                        case "dangerouslySetInnerHTML":
                          innerHTML$jscomp$5 = propValue$jscomp$8;
                          break;
                        default:
                          pushAttribute(
                            target$jscomp$0,
                            propKey$jscomp$8,
                            propValue$jscomp$8
                          );
                      }
                  }
                target$jscomp$0.push(endOfStartTag);
                var child$jscomp$1 = Array.isArray(children$jscomp$8) ? 2 > children$jscomp$8.length ? children$jscomp$8[0] : null : children$jscomp$8;
                "function" !== typeof child$jscomp$1 && "symbol" !== typeof child$jscomp$1 && null !== child$jscomp$1 && void 0 !== child$jscomp$1 && target$jscomp$0.push(
                  stringToChunk(escapeStyleTextContent(child$jscomp$1))
                );
                pushInnerHTML(
                  target$jscomp$0,
                  innerHTML$jscomp$5,
                  children$jscomp$8
                );
                target$jscomp$0.push(endChunkForTag("style"));
                var JSCompiler_inline_result$jscomp$7 = null;
              } else {
                href$jscomp$0.includes(" ") && console.error(
                  'React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is "%s".',
                  href$jscomp$0
                );
                var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0), resourceState$jscomp$1 = resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : void 0;
                if (resourceState$jscomp$1 !== EXISTS) {
                  resumableState.styleResources[href$jscomp$0] = EXISTS;
                  resourceState$jscomp$1 && console.error(
                    'React encountered a hoistable style tag for the same href as a preload: "%s". When using a style tag to inline styles you should not also preload it as a stylsheet.',
                    href$jscomp$0
                  );
                  styleQueue$jscomp$0 || (styleQueue$jscomp$0 = {
                    precedence: stringToChunk(
                      escapeTextForBrowser(precedence$jscomp$0)
                    ),
                    rules: [],
                    hrefs: [],
                    sheets: /* @__PURE__ */ new Map()
                  }, renderState.styles.set(
                    precedence$jscomp$0,
                    styleQueue$jscomp$0
                  ));
                  var nonceStyle = renderState.nonce.style;
                  if (nonceStyle && nonceStyle !== nonce)
                    console.error(
                      'React encountered a style tag with `precedence` "%s" and `nonce` "%s". When React manages style rules using `precedence` it will only include rules if the nonce matches the style nonce "%s" that was included with this render.',
                      precedence$jscomp$0,
                      nonce,
                      nonceStyle
                    );
                  else {
                    !nonceStyle && nonce && console.error(
                      'React encountered a style tag with `precedence` "%s" and `nonce` "%s". When React manages style rules using `precedence` it will only include a nonce attributes if you also provide the same style nonce value as a render option.',
                      precedence$jscomp$0,
                      nonce
                    );
                    styleQueue$jscomp$0.hrefs.push(
                      stringToChunk(escapeTextForBrowser(href$jscomp$0))
                    );
                    var target = styleQueue$jscomp$0.rules, children$jscomp$9 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;
                    for (propKey$jscomp$9 in props)
                      if (hasOwnProperty.call(props, propKey$jscomp$9)) {
                        var propValue$jscomp$9 = props[propKey$jscomp$9];
                        if (null != propValue$jscomp$9)
                          switch (propKey$jscomp$9) {
                            case "children":
                              children$jscomp$9 = propValue$jscomp$9;
                              break;
                            case "dangerouslySetInnerHTML":
                              innerHTML$jscomp$6 = propValue$jscomp$9;
                          }
                      }
                    var child$jscomp$2 = Array.isArray(children$jscomp$9) ? 2 > children$jscomp$9.length ? children$jscomp$9[0] : null : children$jscomp$9;
                    "function" !== typeof child$jscomp$2 && "symbol" !== typeof child$jscomp$2 && null !== child$jscomp$2 && void 0 !== child$jscomp$2 && target.push(
                      stringToChunk(escapeStyleTextContent(child$jscomp$2))
                    );
                    pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$9);
                  }
                }
                styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);
                textEmbedded && target$jscomp$0.push(textSeparator);
                JSCompiler_inline_result$jscomp$7 = void 0;
              }
              return JSCompiler_inline_result$jscomp$7;
            case "meta":
              var noscriptTagInScope$jscomp$3 = formatContext.tagScope & 1, isFallback$jscomp$1 = formatContext.tagScope & 4;
              if (formatContext.insertionMode === SVG_MODE || noscriptTagInScope$jscomp$3 || null != props.itemProp)
                var JSCompiler_inline_result$jscomp$8 = pushSelfClosing(
                  target$jscomp$0,
                  props,
                  "meta"
                );
              else
                textEmbedded && target$jscomp$0.push(textSeparator), JSCompiler_inline_result$jscomp$8 = isFallback$jscomp$1 ? null : "string" === typeof props.charSet ? pushSelfClosing(renderState.charsetChunks, props, "meta") : "viewport" === props.name ? pushSelfClosing(renderState.viewportChunks, props, "meta") : pushSelfClosing(
                  renderState.hoistableChunks,
                  props,
                  "meta"
                );
              return JSCompiler_inline_result$jscomp$8;
            case "listing":
            case "pre":
              target$jscomp$0.push(startChunkForTag(type));
              var children$jscomp$10 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;
              for (propKey$jscomp$10 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$10)) {
                  var propValue$jscomp$10 = props[propKey$jscomp$10];
                  if (null != propValue$jscomp$10)
                    switch (propKey$jscomp$10) {
                      case "children":
                        children$jscomp$10 = propValue$jscomp$10;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$7 = propValue$jscomp$10;
                        break;
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$10,
                          propValue$jscomp$10
                        );
                    }
                }
              target$jscomp$0.push(endOfStartTag);
              if (null != innerHTML$jscomp$7) {
                if (null != children$jscomp$10)
                  throw Error(
                    "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                  );
                if ("object" !== typeof innerHTML$jscomp$7 || !("__html" in innerHTML$jscomp$7))
                  throw Error(
                    "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                  );
                var html = innerHTML$jscomp$7.__html;
                null !== html && void 0 !== html && ("string" === typeof html && 0 < html.length && "\n" === html[0] ? target$jscomp$0.push(leadingNewline, stringToChunk(html)) : (checkHtmlStringCoercion(html), target$jscomp$0.push(stringToChunk("" + html))));
              }
              "string" === typeof children$jscomp$10 && "\n" === children$jscomp$10[0] && target$jscomp$0.push(leadingNewline);
              return children$jscomp$10;
            case "img":
              var pictureOrNoScriptTagInScope = formatContext.tagScope & 3, src = props.src, srcSet = props.srcSet;
              if (!("lazy" === props.loading || !src && !srcSet || "string" !== typeof src && null != src || "string" !== typeof srcSet && null != srcSet || "low" === props.fetchPriority || pictureOrNoScriptTagInScope) && ("string" !== typeof src || ":" !== src[4] || "d" !== src[0] && "D" !== src[0] || "a" !== src[1] && "A" !== src[1] || "t" !== src[2] && "T" !== src[2] || "a" !== src[3] && "A" !== src[3]) && ("string" !== typeof srcSet || ":" !== srcSet[4] || "d" !== srcSet[0] && "D" !== srcSet[0] || "a" !== srcSet[1] && "A" !== srcSet[1] || "t" !== srcSet[2] && "T" !== srcSet[2] || "a" !== srcSet[3] && "A" !== srcSet[3])) {
                null !== hoistableState && formatContext.tagScope & 64 && (hoistableState.suspenseyImages = true);
                var sizes = "string" === typeof props.sizes ? props.sizes : void 0, key$jscomp$0 = srcSet ? srcSet + "\n" + (sizes || "") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);
                if (resource$jscomp$1) {
                  if ("high" === props.fetchPriority || 10 > renderState.highImagePreloads.size)
                    promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);
                } else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {
                  resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;
                  var input = props.crossOrigin;
                  var crossOrigin = "string" === typeof input ? "use-credentials" === input ? input : "" : void 0;
                  var headers = renderState.headers, header;
                  headers && 0 < headers.remainingCapacity && "string" !== typeof props.srcSet && ("high" === props.fetchPriority || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader(src, "image", {
                    imageSrcSet: props.srcSet,
                    imageSizes: props.sizes,
                    crossOrigin,
                    integrity: props.integrity,
                    nonce: props.nonce,
                    type: props.type,
                    fetchPriority: props.fetchPriority,
                    referrerPolicy: props.refererPolicy
                  }), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS, headers.highImagePreloads && (headers.highImagePreloads += ", "), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl(resource$jscomp$1, {
                    rel: "preload",
                    as: "image",
                    href: srcSet ? void 0 : src,
                    imageSrcSet: srcSet,
                    imageSizes: sizes,
                    crossOrigin,
                    integrity: props.integrity,
                    type: props.type,
                    fetchPriority: props.fetchPriority,
                    referrerPolicy: props.referrerPolicy
                  }), "high" === props.fetchPriority || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));
                }
              }
              return pushSelfClosing(target$jscomp$0, props, "img");
            case "base":
            case "area":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "keygen":
            case "param":
            case "source":
            case "track":
            case "wbr":
              return pushSelfClosing(target$jscomp$0, props, type);
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              break;
            case "head":
              if (formatContext.insertionMode < HTML_MODE) {
                var preamble = preambleState || renderState.preamble;
                if (preamble.headChunks)
                  throw Error("The `<head>` tag may only be rendered once.");
                null !== preambleState && target$jscomp$0.push(headPreambleContributionChunk);
                preamble.headChunks = [];
                var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(
                  preamble.headChunks,
                  props,
                  "head"
                );
              } else
                JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
                  target$jscomp$0,
                  props,
                  "head"
                );
              return JSCompiler_inline_result$jscomp$9;
            case "body":
              if (formatContext.insertionMode < HTML_MODE) {
                var preamble$jscomp$0 = preambleState || renderState.preamble;
                if (preamble$jscomp$0.bodyChunks)
                  throw Error("The `<body>` tag may only be rendered once.");
                null !== preambleState && target$jscomp$0.push(bodyPreambleContributionChunk);
                preamble$jscomp$0.bodyChunks = [];
                var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(
                  preamble$jscomp$0.bodyChunks,
                  props,
                  "body"
                );
              } else
                JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
                  target$jscomp$0,
                  props,
                  "body"
                );
              return JSCompiler_inline_result$jscomp$10;
            case "html":
              if (formatContext.insertionMode === ROOT_HTML_MODE) {
                var preamble$jscomp$1 = preambleState || renderState.preamble;
                if (preamble$jscomp$1.htmlChunks)
                  throw Error("The `<html>` tag may only be rendered once.");
                null !== preambleState && target$jscomp$0.push(htmlPreambleContributionChunk);
                preamble$jscomp$1.htmlChunks = [doctypeChunk];
                var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(
                  preamble$jscomp$1.htmlChunks,
                  props,
                  "html"
                );
              } else
                JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
                  target$jscomp$0,
                  props,
                  "html"
                );
              return JSCompiler_inline_result$jscomp$11;
            default:
              if (-1 !== type.indexOf("-")) {
                target$jscomp$0.push(startChunkForTag(type));
                var children$jscomp$11 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;
                for (propKey$jscomp$11 in props)
                  if (hasOwnProperty.call(props, propKey$jscomp$11)) {
                    var propValue$jscomp$11 = props[propKey$jscomp$11];
                    if (null != propValue$jscomp$11) {
                      var attributeName = propKey$jscomp$11;
                      switch (propKey$jscomp$11) {
                        case "children":
                          children$jscomp$11 = propValue$jscomp$11;
                          break;
                        case "dangerouslySetInnerHTML":
                          innerHTML$jscomp$8 = propValue$jscomp$11;
                          break;
                        case "style":
                          pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);
                          break;
                        case "suppressContentEditableWarning":
                        case "suppressHydrationWarning":
                        case "ref":
                          break;
                        case "className":
                          attributeName = "class";
                        default:
                          if (isAttributeNameSafe(propKey$jscomp$11) && "function" !== typeof propValue$jscomp$11 && "symbol" !== typeof propValue$jscomp$11 && false !== propValue$jscomp$11) {
                            if (true === propValue$jscomp$11)
                              propValue$jscomp$11 = "";
                            else if ("object" === typeof propValue$jscomp$11)
                              continue;
                            target$jscomp$0.push(
                              attributeSeparator,
                              stringToChunk(attributeName),
                              attributeAssign,
                              stringToChunk(
                                escapeTextForBrowser(propValue$jscomp$11)
                              ),
                              attributeEnd
                            );
                          }
                      }
                    }
                  }
                target$jscomp$0.push(endOfStartTag);
                pushInnerHTML(
                  target$jscomp$0,
                  innerHTML$jscomp$8,
                  children$jscomp$11
                );
                return children$jscomp$11;
              }
          }
          return pushStartGenericElement(target$jscomp$0, props, type);
        }
        function endChunkForTag(tag) {
          var chunk = endTagCache.get(tag);
          void 0 === chunk && (chunk = stringToPrecomputedChunk("</" + tag + ">"), endTagCache.set(tag, chunk));
          return chunk;
        }
        function hoistPreambleState(renderState, preambleState) {
          renderState = renderState.preamble;
          null === renderState.htmlChunks && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks);
          null === renderState.headChunks && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks);
          null === renderState.bodyChunks && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks);
        }
        function writeBootstrap(destination, renderState) {
          renderState = renderState.bootstrapChunks;
          for (var i = 0; i < renderState.length - 1; i++)
            writeChunk(destination, renderState[i]);
          return i < renderState.length ? (i = renderState[i], renderState.length = 0, writeChunkAndReturn(destination, i)) : true;
        }
        function writeStartPendingSuspenseBoundary(destination, renderState, id) {
          writeChunk(destination, startPendingSuspenseBoundary1);
          if (null === id)
            throw Error(
              "An ID must have been assigned before we can complete the boundary."
            );
          writeChunk(destination, renderState.boundaryPrefix);
          writeChunk(destination, stringToChunk(id.toString(16)));
          return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
        }
        function writeStartSegment(destination, renderState, formatContext, id) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_HTML_MODE:
            case HTML_HEAD_MODE:
            case HTML_MODE:
              return writeChunk(destination, startSegmentHTML), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id.toString(16))), writeChunkAndReturn(destination, startSegmentHTML2);
            case SVG_MODE:
              return writeChunk(destination, startSegmentSVG), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id.toString(16))), writeChunkAndReturn(destination, startSegmentSVG2);
            case MATHML_MODE:
              return writeChunk(destination, startSegmentMathML), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id.toString(16))), writeChunkAndReturn(destination, startSegmentMathML2);
            case HTML_TABLE_MODE:
              return writeChunk(destination, startSegmentTable), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id.toString(16))), writeChunkAndReturn(destination, startSegmentTable2);
            case HTML_TABLE_BODY_MODE:
              return writeChunk(destination, startSegmentTableBody), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id.toString(16))), writeChunkAndReturn(destination, startSegmentTableBody2);
            case HTML_TABLE_ROW_MODE:
              return writeChunk(destination, startSegmentTableRow), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id.toString(16))), writeChunkAndReturn(destination, startSegmentTableRow2);
            case HTML_COLGROUP_MODE:
              return writeChunk(destination, startSegmentColGroup), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id.toString(16))), writeChunkAndReturn(destination, startSegmentColGroup2);
            default:
              throw Error("Unknown insertion mode. This is a bug in React.");
          }
        }
        function writeEndSegment(destination, formatContext) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_HTML_MODE:
            case HTML_HEAD_MODE:
            case HTML_MODE:
              return writeChunkAndReturn(destination, endSegmentHTML);
            case SVG_MODE:
              return writeChunkAndReturn(destination, endSegmentSVG);
            case MATHML_MODE:
              return writeChunkAndReturn(destination, endSegmentMathML);
            case HTML_TABLE_MODE:
              return writeChunkAndReturn(destination, endSegmentTable);
            case HTML_TABLE_BODY_MODE:
              return writeChunkAndReturn(destination, endSegmentTableBody);
            case HTML_TABLE_ROW_MODE:
              return writeChunkAndReturn(destination, endSegmentTableRow);
            case HTML_COLGROUP_MODE:
              return writeChunkAndReturn(destination, endSegmentColGroup);
            default:
              throw Error("Unknown insertion mode. This is a bug in React.");
          }
        }
        function escapeJSStringsForInstructionScripts(input) {
          return JSON.stringify(input).replace(
            regexForJSStringsInInstructionScripts,
            function(match) {
              switch (match) {
                case "<":
                  return "\\u003c";
                case "\u2028":
                  return "\\u2028";
                case "\u2029":
                  return "\\u2029";
                default:
                  throw Error(
                    "escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
                  );
              }
            }
          );
        }
        function escapeJSObjectForInstructionScripts(input) {
          return JSON.stringify(input).replace(
            regexForJSStringsInScripts,
            function(match) {
              switch (match) {
                case "&":
                  return "\\u0026";
                case ">":
                  return "\\u003e";
                case "<":
                  return "\\u003c";
                case "\u2028":
                  return "\\u2028";
                case "\u2029":
                  return "\\u2029";
                default:
                  throw Error(
                    "escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
                  );
              }
            }
          );
        }
        function flushStyleTagsLateForBoundary(styleQueue) {
          var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
          0 < rules.length && 0 === hrefs.length && console.error(
            "React expected to have at least one href for an a hoistable style but found none. This is a bug in React."
          );
          var i = 0;
          if (hrefs.length) {
            writeChunk(this, currentlyFlushingRenderState.startInlineStyle);
            writeChunk(this, lateStyleTagResourceOpen1);
            writeChunk(this, styleQueue.precedence);
            for (writeChunk(this, lateStyleTagResourceOpen2); i < hrefs.length - 1; i++)
              writeChunk(this, hrefs[i]), writeChunk(this, spaceSeparator);
            writeChunk(this, hrefs[i]);
            writeChunk(this, lateStyleTagResourceOpen3);
            for (i = 0; i < rules.length; i++) writeChunk(this, rules[i]);
            destinationHasCapacity = writeChunkAndReturn(
              this,
              lateStyleTagTemplateClose
            );
            currentlyRenderingBoundaryHasStylesToHoist = true;
            rules.length = 0;
            hrefs.length = 0;
          }
        }
        function hasStylesToHoist(stylesheet) {
          return stylesheet.state !== PREAMBLE ? currentlyRenderingBoundaryHasStylesToHoist = true : false;
        }
        function writeHoistablesForBoundary(destination, hoistableState, renderState) {
          currentlyRenderingBoundaryHasStylesToHoist = false;
          destinationHasCapacity = true;
          currentlyFlushingRenderState = renderState;
          hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);
          currentlyFlushingRenderState = null;
          hoistableState.stylesheets.forEach(hasStylesToHoist);
          currentlyRenderingBoundaryHasStylesToHoist && (renderState.stylesToHoist = true);
          return destinationHasCapacity;
        }
        function flushResource(resource) {
          for (var i = 0; i < resource.length; i++) writeChunk(this, resource[i]);
          resource.length = 0;
        }
        function flushStyleInPreamble(stylesheet) {
          pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);
          for (var i = 0; i < stylesheetFlushingQueue.length; i++)
            writeChunk(this, stylesheetFlushingQueue[i]);
          stylesheetFlushingQueue.length = 0;
          stylesheet.state = PREAMBLE;
        }
        function flushStylesInPreamble(styleQueue) {
          var hasStylesheets = 0 < styleQueue.sheets.size;
          styleQueue.sheets.forEach(flushStyleInPreamble, this);
          styleQueue.sheets.clear();
          var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
          if (!hasStylesheets || hrefs.length) {
            writeChunk(this, currentlyFlushingRenderState.startInlineStyle);
            writeChunk(this, styleTagResourceOpen1);
            writeChunk(this, styleQueue.precedence);
            styleQueue = 0;
            if (hrefs.length) {
              for (writeChunk(this, styleTagResourceOpen2); styleQueue < hrefs.length - 1; styleQueue++)
                writeChunk(this, hrefs[styleQueue]), writeChunk(this, spaceSeparator);
              writeChunk(this, hrefs[styleQueue]);
            }
            writeChunk(this, styleTagResourceOpen3);
            for (styleQueue = 0; styleQueue < rules.length; styleQueue++)
              writeChunk(this, rules[styleQueue]);
            writeChunk(this, styleTagResourceClose);
            rules.length = 0;
            hrefs.length = 0;
          }
        }
        function preloadLateStyle(stylesheet) {
          if (stylesheet.state === PENDING$1) {
            stylesheet.state = PRELOADED;
            var props = stylesheet.props;
            pushLinkImpl(stylesheetFlushingQueue, {
              rel: "preload",
              as: "style",
              href: stylesheet.props.href,
              crossOrigin: props.crossOrigin,
              fetchPriority: props.fetchPriority,
              integrity: props.integrity,
              media: props.media,
              hrefLang: props.hrefLang,
              referrerPolicy: props.referrerPolicy
            });
            for (stylesheet = 0; stylesheet < stylesheetFlushingQueue.length; stylesheet++)
              writeChunk(this, stylesheetFlushingQueue[stylesheet]);
            stylesheetFlushingQueue.length = 0;
          }
        }
        function preloadLateStyles(styleQueue) {
          styleQueue.sheets.forEach(preloadLateStyle, this);
          styleQueue.sheets.clear();
        }
        function pushCompletedShellIdAttribute(target, resumableState) {
          (resumableState.instructions & SentCompletedShellId) === NothingSent && (resumableState.instructions |= SentCompletedShellId, target.push(
            completedShellIdAttributeStart,
            stringToChunk(
              escapeTextForBrowser("_" + resumableState.idPrefix + "R_")
            ),
            attributeEnd
          ));
        }
        function writeStyleResourceDependenciesInJS(destination, hoistableState) {
          writeChunk(destination, arrayFirstOpenBracket);
          var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
          hoistableState.stylesheets.forEach(function(resource) {
            if (resource.state !== PREAMBLE)
              if (resource.state === LATE)
                writeChunk(destination, nextArrayOpenBrackChunk), resource = resource.props.href, checkAttributeStringCoercion(resource, "href"), writeChunk(
                  destination,
                  stringToChunk(
                    escapeJSObjectForInstructionScripts("" + resource)
                  )
                ), writeChunk(destination, arrayCloseBracket), nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
              else {
                writeChunk(destination, nextArrayOpenBrackChunk);
                var precedence = resource.props["data-precedence"], props = resource.props, coercedHref = sanitizeURL("" + resource.props.href);
                writeChunk(
                  destination,
                  stringToChunk(escapeJSObjectForInstructionScripts(coercedHref))
                );
                checkAttributeStringCoercion(precedence, "precedence");
                precedence = "" + precedence;
                writeChunk(destination, arrayInterstitial);
                writeChunk(
                  destination,
                  stringToChunk(escapeJSObjectForInstructionScripts(precedence))
                );
                for (var propKey in props)
                  if (hasOwnProperty.call(props, propKey) && (precedence = props[propKey], null != precedence))
                    switch (propKey) {
                      case "href":
                      case "rel":
                      case "precedence":
                      case "data-precedence":
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        throw Error(
                          "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      default:
                        writeStyleResourceAttributeInJS(
                          destination,
                          propKey,
                          precedence
                        );
                    }
                writeChunk(destination, arrayCloseBracket);
                nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
                resource.state = LATE;
              }
          });
          writeChunk(destination, arrayCloseBracket);
        }
        function writeStyleResourceAttributeInJS(destination, name, value) {
          var attributeName = name.toLowerCase();
          switch (typeof value) {
            case "function":
            case "symbol":
              return;
          }
          switch (name) {
            case "innerHTML":
            case "dangerouslySetInnerHTML":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "style":
            case "ref":
              return;
            case "className":
              attributeName = "class";
              checkAttributeStringCoercion(value, attributeName);
              name = "" + value;
              break;
            case "hidden":
              if (false === value) return;
              name = "";
              break;
            case "src":
            case "href":
              value = sanitizeURL(value);
              checkAttributeStringCoercion(value, attributeName);
              name = "" + value;
              break;
            default:
              if (2 < name.length && ("o" === name[0] || "O" === name[0]) && ("n" === name[1] || "N" === name[1]) || !isAttributeNameSafe(name))
                return;
              checkAttributeStringCoercion(value, attributeName);
              name = "" + value;
          }
          writeChunk(destination, arrayInterstitial);
          writeChunk(
            destination,
            stringToChunk(escapeJSObjectForInstructionScripts(attributeName))
          );
          writeChunk(destination, arrayInterstitial);
          writeChunk(
            destination,
            stringToChunk(escapeJSObjectForInstructionScripts(name))
          );
        }
        function createHoistableState() {
          return { styles: /* @__PURE__ */ new Set(), stylesheets: /* @__PURE__ */ new Set(), suspenseyImages: false };
        }
        function preloadBootstrapScriptOrModule(resumableState, renderState, href, props) {
          (resumableState.scriptResources.hasOwnProperty(href) || resumableState.moduleScriptResources.hasOwnProperty(href)) && console.error(
            'Internal React Error: React expected bootstrap script or module with src "%s" to not have been preloaded already. please file an issue',
            href
          );
          resumableState.scriptResources[href] = EXISTS;
          resumableState.moduleScriptResources[href] = EXISTS;
          resumableState = [];
          pushLinkImpl(resumableState, props);
          renderState.bootstrapScripts.add(resumableState);
        }
        function adoptPreloadCredentials(target, preloadState) {
          null == target.crossOrigin && (target.crossOrigin = preloadState[0]);
          null == target.integrity && (target.integrity = preloadState[1]);
        }
        function getPreloadAsHeader(href, as, params) {
          href = escapeHrefForLinkHeaderURLContext(href);
          as = escapeStringForLinkHeaderQuotedParamValueContext(as, "as");
          as = "<" + href + '>; rel=preload; as="' + as + '"';
          for (var paramName in params)
            hasOwnProperty.call(params, paramName) && (href = params[paramName], "string" === typeof href && (as += "; " + paramName.toLowerCase() + '="' + escapeStringForLinkHeaderQuotedParamValueContext(
              href,
              paramName
            ) + '"'));
          return as;
        }
        function escapeHrefForLinkHeaderURLContext(hrefInput) {
          checkAttributeStringCoercion(hrefInput, "href");
          return ("" + hrefInput).replace(
            regexForHrefInLinkHeaderURLContext,
            escapeHrefForLinkHeaderURLContextReplacer
          );
        }
        function escapeHrefForLinkHeaderURLContextReplacer(match) {
          switch (match) {
            case "<":
              return "%3C";
            case ">":
              return "%3E";
            case "\n":
              return "%0A";
            case "\r":
              return "%0D";
            default:
              throw Error(
                "escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
              );
          }
        }
        function escapeStringForLinkHeaderQuotedParamValueContext(value, name) {
          willCoercionThrow(value) && (console.error(
            "The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.",
            name,
            typeName(value)
          ), testStringCoercion(value));
          return ("" + value).replace(
            regexForLinkHeaderQuotedParamValueContext,
            escapeStringForLinkHeaderQuotedParamValueContextReplacer
          );
        }
        function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {
          switch (match) {
            case '"':
              return "%22";
            case "'":
              return "%27";
            case ";":
              return "%3B";
            case ",":
              return "%2C";
            case "\n":
              return "%0A";
            case "\r":
              return "%0D";
            default:
              throw Error(
                "escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
              );
          }
        }
        function hoistStyleQueueDependency(styleQueue) {
          this.styles.add(styleQueue);
        }
        function hoistStylesheetDependency(stylesheet) {
          this.stylesheets.add(stylesheet);
        }
        function hoistHoistables(parentState, childState) {
          childState.styles.forEach(hoistStyleQueueDependency, parentState);
          childState.stylesheets.forEach(hoistStylesheetDependency, parentState);
          childState.suspenseyImages && (parentState.suspenseyImages = true);
        }
        function hasSuspenseyContent(hoistableState) {
          return 0 < hoistableState.stylesheets.size || hoistableState.suspenseyImages;
        }
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x) {
                }
            }
          return null;
        }
        function popToNearestCommonAncestor(prev, next) {
          if (prev !== next) {
            prev.context._currentValue = prev.parentValue;
            prev = prev.parent;
            var parentNext = next.parent;
            if (null === prev) {
              if (null !== parentNext)
                throw Error(
                  "The stacks must reach the root at the same time. This is a bug in React."
                );
            } else {
              if (null === parentNext)
                throw Error(
                  "The stacks must reach the root at the same time. This is a bug in React."
                );
              popToNearestCommonAncestor(prev, parentNext);
            }
            next.context._currentValue = next.value;
          }
        }
        function popAllPrevious(prev) {
          prev.context._currentValue = prev.parentValue;
          prev = prev.parent;
          null !== prev && popAllPrevious(prev);
        }
        function pushAllNext(next) {
          var parentNext = next.parent;
          null !== parentNext && pushAllNext(parentNext);
          next.context._currentValue = next.value;
        }
        function popPreviousToCommonLevel(prev, next) {
          prev.context._currentValue = prev.parentValue;
          prev = prev.parent;
          if (null === prev)
            throw Error(
              "The depth must equal at least at zero before reaching the root. This is a bug in React."
            );
          prev.depth === next.depth ? popToNearestCommonAncestor(prev, next) : popPreviousToCommonLevel(prev, next);
        }
        function popNextToCommonLevel(prev, next) {
          var parentNext = next.parent;
          if (null === parentNext)
            throw Error(
              "The depth must equal at least at zero before reaching the root. This is a bug in React."
            );
          prev.depth === parentNext.depth ? popToNearestCommonAncestor(prev, parentNext) : popNextToCommonLevel(prev, parentNext);
          next.context._currentValue = next.value;
        }
        function switchContext(newSnapshot) {
          var prev = currentActiveSnapshot;
          prev !== newSnapshot && (null === prev ? pushAllNext(newSnapshot) : null === newSnapshot ? popAllPrevious(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel(prev, newSnapshot) : popNextToCommonLevel(prev, newSnapshot), currentActiveSnapshot = newSnapshot);
        }
        function warnOnInvalidCallback(callback) {
          if (null !== callback && "function" !== typeof callback) {
            var key = String(callback);
            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(
              "Expected the last optional `callback` argument to be a function. Instead received: %s.",
              callback
            ));
          }
        }
        function warnNoop(publicInstance, callerName) {
          publicInstance = (publicInstance = publicInstance.constructor) && getComponentNameFromType(publicInstance) || "ReactClass";
          var warningKey = publicInstance + "." + callerName;
          didWarnAboutNoopUpdateForComponent[warningKey] || (console.error(
            "Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.",
            callerName,
            publicInstance
          ), didWarnAboutNoopUpdateForComponent[warningKey] = true);
        }
        function pushTreeContext(baseContext, totalChildren, index) {
          var baseIdWithLeadingBit = baseContext.id;
          baseContext = baseContext.overflow;
          var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
          baseIdWithLeadingBit &= ~(1 << baseLength);
          index += 1;
          var length = 32 - clz32(totalChildren) + baseLength;
          if (30 < length) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
            baseIdWithLeadingBit >>= numberOfOverflowBits;
            baseLength -= numberOfOverflowBits;
            return {
              id: 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit,
              overflow: length + baseContext
            };
          }
          return {
            id: 1 << length | index << baseLength | baseIdWithLeadingBit,
            overflow: baseContext
          };
        }
        function clz32Fallback(x) {
          x >>>= 0;
          return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
        }
        function noop() {
        }
        function trackUsedThenable(thenableState2, thenable, index) {
          index = thenableState2[index];
          void 0 === index ? thenableState2.push(thenable) : index !== thenable && (thenable.then(noop, noop), thenable = index);
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
            default:
              "string" === typeof thenable.status ? thenable.then(noop, noop) : (thenableState2 = thenable, thenableState2.status = "pending", thenableState2.then(
                function(fulfilledValue) {
                  if ("pending" === thenable.status) {
                    var fulfilledThenable = thenable;
                    fulfilledThenable.status = "fulfilled";
                    fulfilledThenable.value = fulfilledValue;
                  }
                },
                function(error) {
                  if ("pending" === thenable.status) {
                    var rejectedThenable = thenable;
                    rejectedThenable.status = "rejected";
                    rejectedThenable.reason = error;
                  }
                }
              ));
              switch (thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenable.reason;
              }
              suspendedThenable = thenable;
              throw SuspenseException;
          }
        }
        function getSuspendedThenable() {
          if (null === suspendedThenable)
            throw Error(
              "Expected a suspended thenable. This is a bug in React. Please file an issue."
            );
          var thenable = suspendedThenable;
          suspendedThenable = null;
          return thenable;
        }
        function is(x, y) {
          return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
        }
        function resolveCurrentlyRenderingComponent() {
          if (null === currentlyRenderingComponent)
            throw Error(
              "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
            );
          isInHookUserCodeInDev && console.error(
            "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
          );
          return currentlyRenderingComponent;
        }
        function createHook() {
          if (0 < numberOfReRenders)
            throw Error("Rendered more hooks than during the previous render");
          return { memoizedState: null, queue: null, next: null };
        }
        function createWorkInProgressHook() {
          null === workInProgressHook ? null === firstWorkInProgressHook ? (isReRender = false, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = true, workInProgressHook = firstWorkInProgressHook) : null === workInProgressHook.next ? (isReRender = false, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = true, workInProgressHook = workInProgressHook.next);
          return workInProgressHook;
        }
        function getThenableStateAfterSuspending() {
          var state = thenableState;
          thenableState = null;
          return state;
        }
        function resetHooksState() {
          isInHookUserCodeInDev = false;
          currentlyRenderingKeyPath = currentlyRenderingRequest = currentlyRenderingTask = currentlyRenderingComponent = null;
          didScheduleRenderPhaseUpdate = false;
          firstWorkInProgressHook = null;
          numberOfReRenders = 0;
          workInProgressHook = renderPhaseUpdates = null;
        }
        function readContext(context2) {
          isInHookUserCodeInDev && console.error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
          return context2._currentValue;
        }
        function basicStateReducer(state, action) {
          return "function" === typeof action ? action(state) : action;
        }
        function useReducer3(reducer2, initialArg, init) {
          reducer2 !== basicStateReducer && (currentHookNameInDev = "useReducer");
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          if (isReRender) {
            init = workInProgressHook.queue;
            initialArg = init.dispatch;
            if (null !== renderPhaseUpdates) {
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(init);
              if (void 0 !== firstRenderPhaseUpdate) {
                renderPhaseUpdates.delete(init);
                init = workInProgressHook.memoizedState;
                do {
                  var action = firstRenderPhaseUpdate.action;
                  isInHookUserCodeInDev = true;
                  init = reducer2(init, action);
                  isInHookUserCodeInDev = false;
                  firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;
                } while (null !== firstRenderPhaseUpdate);
                workInProgressHook.memoizedState = init;
                return [init, initialArg];
              }
            }
            return [workInProgressHook.memoizedState, initialArg];
          }
          isInHookUserCodeInDev = true;
          reducer2 = reducer2 === basicStateReducer ? "function" === typeof initialArg ? initialArg() : initialArg : void 0 !== init ? init(initialArg) : initialArg;
          isInHookUserCodeInDev = false;
          workInProgressHook.memoizedState = reducer2;
          reducer2 = workInProgressHook.queue = { last: null, dispatch: null };
          reducer2 = reducer2.dispatch = dispatchAction.bind(
            null,
            currentlyRenderingComponent,
            reducer2
          );
          return [workInProgressHook.memoizedState, reducer2];
        }
        function useMemo3(nextCreate, deps) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          if (null !== workInProgressHook) {
            var prevState = workInProgressHook.memoizedState;
            if (null !== prevState && null !== deps) {
              a: {
                var JSCompiler_inline_result = prevState[1];
                if (null === JSCompiler_inline_result)
                  console.error(
                    "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
                    currentHookNameInDev
                  ), JSCompiler_inline_result = false;
                else {
                  deps.length !== JSCompiler_inline_result.length && console.error(
                    "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
                    currentHookNameInDev,
                    "[" + deps.join(", ") + "]",
                    "[" + JSCompiler_inline_result.join(", ") + "]"
                  );
                  for (var i = 0; i < JSCompiler_inline_result.length && i < deps.length; i++)
                    if (!objectIs(deps[i], JSCompiler_inline_result[i])) {
                      JSCompiler_inline_result = false;
                      break a;
                    }
                  JSCompiler_inline_result = true;
                }
              }
              if (JSCompiler_inline_result) return prevState[0];
            }
          }
          isInHookUserCodeInDev = true;
          nextCreate = nextCreate();
          isInHookUserCodeInDev = false;
          workInProgressHook.memoizedState = [nextCreate, deps];
          return nextCreate;
        }
        function dispatchAction(componentIdentity, queue, action) {
          if (25 <= numberOfReRenders)
            throw Error(
              "Too many re-renders. React limits the number of renders to prevent an infinite loop."
            );
          if (componentIdentity === currentlyRenderingComponent)
            if (didScheduleRenderPhaseUpdate = true, componentIdentity = { action, next: null }, null === renderPhaseUpdates && (renderPhaseUpdates = /* @__PURE__ */ new Map()), action = renderPhaseUpdates.get(queue), void 0 === action)
              renderPhaseUpdates.set(queue, componentIdentity);
            else {
              for (queue = action; null !== queue.next; ) queue = queue.next;
              queue.next = componentIdentity;
            }
        }
        function throwOnUseEffectEventCall() {
          throw Error(
            "A function wrapped in useEffectEvent can't be called during rendering."
          );
        }
        function unsupportedStartTransition() {
          throw Error("startTransition cannot be called during server rendering.");
        }
        function unsupportedSetOptimisticState() {
          throw Error("Cannot update optimistic state while rendering.");
        }
        function useActionState(action, initialState, permalink) {
          resolveCurrentlyRenderingComponent();
          var actionStateHookIndex = actionStateCounter++, request = currentlyRenderingRequest;
          if ("function" === typeof action.$$FORM_ACTION) {
            var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath;
            request = request.formState;
            var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;
            if (null !== request && "function" === typeof isSignatureEqual) {
              var postbackKey = request[1];
              isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(
                JSON.stringify([
                  componentKeyPath,
                  null,
                  actionStateHookIndex
                ]),
                0
              ), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex = actionStateHookIndex, initialState = request[0]));
            }
            var boundAction = action.bind(null, initialState);
            action = function(payload) {
              boundAction(payload);
            };
            "function" === typeof boundAction.$$FORM_ACTION && (action.$$FORM_ACTION = function(prefix2) {
              prefix2 = boundAction.$$FORM_ACTION(prefix2);
              void 0 !== permalink && (checkAttributeStringCoercion(permalink, "target"), permalink += "", prefix2.action = permalink);
              var formData = prefix2.data;
              formData && (null === nextPostbackStateKey && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(
                JSON.stringify([
                  componentKeyPath,
                  null,
                  actionStateHookIndex
                ]),
                0
              )), formData.append("$ACTION_KEY", nextPostbackStateKey));
              return prefix2;
            });
            return [initialState, action, false];
          }
          var _boundAction = action.bind(null, initialState);
          return [
            initialState,
            function(payload) {
              _boundAction(payload);
            },
            false
          ];
        }
        function unwrapThenable(thenable) {
          var index = thenableIndexCounter;
          thenableIndexCounter += 1;
          null === thenableState && (thenableState = []);
          return trackUsedThenable(thenableState, thenable, index);
        }
        function unsupportedRefresh() {
          throw Error("Cache cannot be refreshed during server rendering.");
        }
        function disabledLog() {
        }
        function disableLogs() {
          if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
        function reenableLogs() {
          disabledDepth--;
          if (0 === disabledDepth) {
            var props = { configurable: true, enumerable: true, writable: true };
            Object.defineProperties(console, {
              log: assign2({}, props, { value: prevLog }),
              info: assign2({}, props, { value: prevInfo }),
              warn: assign2({}, props, { value: prevWarn }),
              error: assign2({}, props, { value: prevError }),
              group: assign2({}, props, { value: prevGroup }),
              groupCollapsed: assign2({}, props, { value: prevGroupCollapsed }),
              groupEnd: assign2({}, props, { value: prevGroupEnd })
            });
          }
          0 > disabledDepth && console.error(
            "disabledDepth fell below zero. This is a bug in React. Please file an issue."
          );
        }
        function formatOwnerStack(error) {
          var prevPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          error = error.stack;
          Error.prepareStackTrace = prevPrepareStackTrace;
          error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
          prevPrepareStackTrace = error.indexOf("\n");
          -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
          prevPrepareStackTrace = error.indexOf("react_stack_bottom_frame");
          -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf(
            "\n",
            prevPrepareStackTrace
          ));
          if (-1 !== prevPrepareStackTrace)
            error = error.slice(0, prevPrepareStackTrace);
          else return "";
          return error;
        }
        function describeBuiltInComponentFrame(name) {
          if (void 0 === prefix)
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
              suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
            }
          return "\n" + prefix + name + suffix;
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) return "";
          var frame = componentFrameCache.get(fn);
          if (void 0 !== frame) return frame;
          reentry = true;
          frame = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher2 = null;
          previousDispatcher2 = ReactSharedInternals.H;
          ReactSharedInternals.H = null;
          disableLogs();
          try {
            var RunInRootFrame = {
              DetermineComponentFrameRoot: function() {
                try {
                  if (construct) {
                    var Fake = function() {
                      throw Error();
                    };
                    Object.defineProperty(Fake.prototype, "props", {
                      set: function() {
                        throw Error();
                      }
                    });
                    if ("object" === typeof Reflect && Reflect.construct) {
                      try {
                        Reflect.construct(Fake, []);
                      } catch (x) {
                        var control = x;
                      }
                      Reflect.construct(fn, [], Fake);
                    } else {
                      try {
                        Fake.call();
                      } catch (x$0) {
                        control = x$0;
                      }
                      fn.call(Fake.prototype);
                    }
                  } else {
                    try {
                      throw Error();
                    } catch (x$1) {
                      control = x$1;
                    }
                    (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                    });
                  }
                } catch (sample) {
                  if (sample && control && "string" === typeof sample.stack)
                    return [sample.stack, control.stack];
                }
                return [null, null];
              }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name"
            );
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name",
              { value: "DetermineComponentFrameRoot" }
            );
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
              var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
              for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
                "DetermineComponentFrameRoot"
              ); )
                namePropDescriptor++;
              for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
                "DetermineComponentFrameRoot"
              ); )
                _RunInRootFrame$Deter++;
              if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
                for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                  _RunInRootFrame$Deter--;
              for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
                if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                  if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                    do
                      if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                        var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                          " at new ",
                          " at "
                        );
                        fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                        "function" === typeof fn && componentFrameCache.set(fn, _frame);
                        return _frame;
                      }
                    while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                  }
                  break;
                }
            }
          } finally {
            reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
          }
          sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
          "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
          return sampleLines;
        }
        function describeComponentStackByType(type) {
          if ("string" === typeof type) return describeBuiltInComponentFrame(type);
          if ("function" === typeof type)
            return type.prototype && type.prototype.isReactComponent ? describeNativeComponentFrame(type, true) : describeNativeComponentFrame(type, false);
          if ("object" === typeof type && null !== type) {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeNativeComponentFrame(type.render, false);
              case REACT_MEMO_TYPE:
                return describeNativeComponentFrame(type.type, false);
              case REACT_LAZY_TYPE:
                var lazyComponent = type, payload = lazyComponent._payload;
                lazyComponent = lazyComponent._init;
                try {
                  type = lazyComponent(payload);
                } catch (x) {
                  return describeBuiltInComponentFrame("Lazy");
                }
                return describeComponentStackByType(type);
            }
            if ("string" === typeof type.name) {
              a: {
                payload = type.name;
                lazyComponent = type.env;
                type = type.debugLocation;
                if (null != type) {
                  type = formatOwnerStack(type);
                  var idx = type.lastIndexOf("\n");
                  type = -1 === idx ? type : type.slice(idx + 1);
                  if (-1 !== type.indexOf(payload)) {
                    payload = "\n" + type;
                    break a;
                  }
                }
                payload = describeBuiltInComponentFrame(
                  payload + (lazyComponent ? " [" + lazyComponent + "]" : "")
                );
              }
              return payload;
            }
          }
          switch (type) {
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
          }
          return "";
        }
        function resetOwnerStackLimit() {
          var now = getCurrentTime();
          1e3 < now - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = now);
        }
        function isEligibleForOutlining(request, boundary) {
          return (500 < boundary.byteSize || hasSuspenseyContent(boundary.contentState)) && null === boundary.contentPreamble;
        }
        function defaultErrorHandler(error) {
          if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
            var JSCompiler_inline_result = error.environmentName;
            error = [error].slice(0);
            "string" === typeof error[0] ? error.splice(
              0,
              1,
              "%c%s%c " + error[0],
              "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
              " " + JSCompiler_inline_result + " ",
              ""
            ) : error.splice(
              0,
              0,
              "%c%s%c",
              "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
              " " + JSCompiler_inline_result + " ",
              ""
            );
            error.unshift(console);
            JSCompiler_inline_result = bind.apply(console.error, error);
            JSCompiler_inline_result();
          } else console.error(error);
          return null;
        }
        function RequestInstance(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
          var abortSet = /* @__PURE__ */ new Set();
          this.destination = null;
          this.flushScheduled = false;
          this.resumableState = resumableState;
          this.renderState = renderState;
          this.rootFormatContext = rootFormatContext;
          this.progressiveChunkSize = void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;
          this.status = 10;
          this.fatalError = null;
          this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
          this.completedPreambleSegments = this.completedRootSegment = null;
          this.byteSize = 0;
          this.abortableTasks = abortSet;
          this.pingedTasks = [];
          this.clientRenderedBoundaries = [];
          this.completedBoundaries = [];
          this.partialBoundaries = [];
          this.trackedPostpones = null;
          this.onError = void 0 === onError ? defaultErrorHandler : onError;
          this.onPostpone = void 0 === onPostpone ? noop : onPostpone;
          this.onAllReady = void 0 === onAllReady ? noop : onAllReady;
          this.onShellReady = void 0 === onShellReady ? noop : onShellReady;
          this.onShellError = void 0 === onShellError ? noop : onShellError;
          this.onFatalError = void 0 === onFatalError ? noop : onFatalError;
          this.formState = void 0 === formState ? null : formState;
          this.didWarnForKey = null;
        }
        function createRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
          resetOwnerStackLimit();
          resumableState = new RequestInstance(
            resumableState,
            renderState,
            rootFormatContext,
            progressiveChunkSize,
            onError,
            onAllReady,
            onShellReady,
            onShellError,
            onFatalError,
            onPostpone,
            formState
          );
          renderState = createPendingSegment(
            resumableState,
            0,
            null,
            rootFormatContext,
            false,
            false
          );
          renderState.parentFlushed = true;
          children = createRenderTask(
            resumableState,
            null,
            children,
            -1,
            null,
            renderState,
            null,
            null,
            resumableState.abortableTasks,
            null,
            rootFormatContext,
            null,
            emptyTreeContext,
            null,
            null,
            emptyContextObject,
            null
          );
          pushComponentStack(children);
          resumableState.pingedTasks.push(children);
          return resumableState;
        }
        function createPrerenderRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone) {
          children = createRequest(
            children,
            resumableState,
            renderState,
            rootFormatContext,
            progressiveChunkSize,
            onError,
            onAllReady,
            onShellReady,
            onShellError,
            onFatalError,
            onPostpone,
            void 0
          );
          children.trackedPostpones = {
            workingMap: /* @__PURE__ */ new Map(),
            rootNodes: [],
            rootSlots: null
          };
          return children;
        }
        function resumeRequest(children, postponedState, renderState, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone) {
          resetOwnerStackLimit();
          renderState = new RequestInstance(
            postponedState.resumableState,
            renderState,
            postponedState.rootFormatContext,
            postponedState.progressiveChunkSize,
            onError,
            onAllReady,
            onShellReady,
            onShellError,
            onFatalError,
            onPostpone,
            null
          );
          renderState.nextSegmentId = postponedState.nextSegmentId;
          if ("number" === typeof postponedState.replaySlots)
            return onError = createPendingSegment(
              renderState,
              0,
              null,
              postponedState.rootFormatContext,
              false,
              false
            ), onError.parentFlushed = true, children = createRenderTask(
              renderState,
              null,
              children,
              -1,
              null,
              onError,
              null,
              null,
              renderState.abortableTasks,
              null,
              postponedState.rootFormatContext,
              null,
              emptyTreeContext,
              null,
              null,
              emptyContextObject,
              null
            ), pushComponentStack(children), renderState.pingedTasks.push(children), renderState;
          children = createReplayTask(
            renderState,
            null,
            {
              nodes: postponedState.replayNodes,
              slots: postponedState.replaySlots,
              pendingTasks: 0
            },
            children,
            -1,
            null,
            null,
            renderState.abortableTasks,
            null,
            postponedState.rootFormatContext,
            null,
            emptyTreeContext,
            null,
            null,
            emptyContextObject,
            null
          );
          pushComponentStack(children);
          renderState.pingedTasks.push(children);
          return renderState;
        }
        function resumeAndPrerenderRequest(children, postponedState, renderState, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone) {
          children = resumeRequest(
            children,
            postponedState,
            renderState,
            onError,
            onAllReady,
            onShellReady,
            onShellError,
            onFatalError,
            onPostpone
          );
          children.trackedPostpones = {
            workingMap: /* @__PURE__ */ new Map(),
            rootNodes: [],
            rootSlots: null
          };
          return children;
        }
        function pingTask(request, task) {
          request.pingedTasks.push(task);
          1 === request.pingedTasks.length && (request.flushScheduled = null !== request.destination, null !== request.trackedPostpones || 10 === request.status ? scheduleMicrotask(function() {
            return performWork(request);
          }) : scheduleWork(function() {
            return performWork(request);
          }));
        }
        function createSuspenseBoundary(request, row, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {
          fallbackAbortableTasks = {
            status: PENDING,
            rootSegmentID: -1,
            parentFlushed: false,
            pendingTasks: 0,
            row,
            completedSegments: [],
            byteSize: 0,
            fallbackAbortableTasks,
            errorDigest: null,
            contentState: createHoistableState(),
            fallbackState: createHoistableState(),
            contentPreamble,
            fallbackPreamble,
            trackedContentKeyPath: null,
            trackedFallbackNode: null,
            errorMessage: null,
            errorStack: null,
            errorComponentStack: null
          };
          null !== row && (row.pendingTasks++, contentPreamble = row.boundaries, null !== contentPreamble && (request.allPendingTasks++, fallbackAbortableTasks.pendingTasks++, contentPreamble.push(fallbackAbortableTasks)), request = row.inheritedHoistables, null !== request && hoistHoistables(fallbackAbortableTasks.contentState, request));
          return fallbackAbortableTasks;
        }
        function createRenderTask(request, thenableState2, node, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context2, treeContext, row, componentStack, legacyContext, debugTask) {
          request.allPendingTasks++;
          null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
          null !== row && row.pendingTasks++;
          var task = {
            replay: null,
            node,
            childIndex,
            ping: function() {
              return pingTask(request, task);
            },
            blockedBoundary,
            blockedSegment,
            blockedPreamble,
            hoistableState,
            abortSet,
            keyPath,
            formatContext,
            context: context2,
            treeContext,
            row,
            componentStack,
            thenableState: thenableState2
          };
          task.debugTask = debugTask;
          abortSet.add(task);
          return task;
        }
        function createReplayTask(request, thenableState2, replay, node, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context2, treeContext, row, componentStack, legacyContext, debugTask) {
          request.allPendingTasks++;
          null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
          null !== row && row.pendingTasks++;
          replay.pendingTasks++;
          var task = {
            replay,
            node,
            childIndex,
            ping: function() {
              return pingTask(request, task);
            },
            blockedBoundary,
            blockedSegment: null,
            blockedPreamble: null,
            hoistableState,
            abortSet,
            keyPath,
            formatContext,
            context: context2,
            treeContext,
            row,
            componentStack,
            thenableState: thenableState2
          };
          task.debugTask = debugTask;
          abortSet.add(task);
          return task;
        }
        function createPendingSegment(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {
          return {
            status: PENDING,
            parentFlushed: false,
            id: -1,
            index,
            chunks: [],
            children: [],
            preambleChildren: [],
            parentFormatContext,
            boundary,
            lastPushedText,
            textEmbedded
          };
        }
        function getCurrentStackInDEV() {
          if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack)
            return "";
          var componentStack = currentTaskInDEV.componentStack;
          try {
            var info = "";
            if ("string" === typeof componentStack.type)
              info += describeBuiltInComponentFrame(componentStack.type);
            else if ("function" === typeof componentStack.type) {
              if (!componentStack.owner) {
                var JSCompiler_temp_const = info, fn = componentStack.type, name = fn ? fn.displayName || fn.name : "";
                var JSCompiler_inline_result = name ? describeBuiltInComponentFrame(name) : "";
                info = JSCompiler_temp_const + JSCompiler_inline_result;
              }
            } else
              componentStack.owner || (info += describeComponentStackByType(componentStack.type));
            for (; componentStack; )
              JSCompiler_temp_const = null, null != componentStack.debugStack ? JSCompiler_temp_const = formatOwnerStack(
                componentStack.debugStack
              ) : (JSCompiler_inline_result = componentStack, null != JSCompiler_inline_result.stack && (JSCompiler_temp_const = "string" !== typeof JSCompiler_inline_result.stack ? JSCompiler_inline_result.stack = formatOwnerStack(
                JSCompiler_inline_result.stack
              ) : JSCompiler_inline_result.stack)), (componentStack = componentStack.owner) && JSCompiler_temp_const && (info += "\n" + JSCompiler_temp_const);
            var JSCompiler_inline_result$jscomp$0 = info;
          } catch (x) {
            JSCompiler_inline_result$jscomp$0 = "\nError generating stack: " + x.message + "\n" + x.stack;
          }
          return JSCompiler_inline_result$jscomp$0;
        }
        function pushHaltedAwaitOnComponentStack(task, debugInfo) {
          if (null != debugInfo)
            for (var i = debugInfo.length - 1; 0 <= i; i--) {
              var info = debugInfo[i];
              if ("string" === typeof info.name) break;
              if ("number" === typeof info.time) break;
              if (null != info.awaited) {
                var bestStack = null == info.debugStack ? info.awaited : info;
                if (void 0 !== bestStack.debugStack) {
                  task.componentStack = {
                    parent: task.componentStack,
                    type: info,
                    owner: bestStack.owner,
                    stack: bestStack.debugStack
                  };
                  task.debugTask = bestStack.debugTask;
                  break;
                }
              }
            }
        }
        function pushServerComponentStack(task, debugInfo) {
          if (null != debugInfo)
            for (var i = 0; i < debugInfo.length; i++) {
              var componentInfo = debugInfo[i];
              "string" === typeof componentInfo.name && void 0 !== componentInfo.debugStack && (task.componentStack = {
                parent: task.componentStack,
                type: componentInfo,
                owner: componentInfo.owner,
                stack: componentInfo.debugStack
              }, task.debugTask = componentInfo.debugTask);
            }
        }
        function pushComponentStack(task) {
          var node = task.node;
          if ("object" === typeof node && null !== node)
            switch (node.$$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = node.type, owner = node._owner, stack = node._debugStack;
                pushServerComponentStack(task, node._debugInfo);
                task.debugTask = node._debugTask;
                task.componentStack = {
                  parent: task.componentStack,
                  type,
                  owner,
                  stack
                };
                break;
              case REACT_LAZY_TYPE:
                pushServerComponentStack(task, node._debugInfo);
                break;
              default:
                "function" === typeof node.then && pushServerComponentStack(task, node._debugInfo);
            }
        }
        function replaceSuspenseComponentStackWithSuspenseFallbackStack(componentStack) {
          return null === componentStack ? null : {
            parent: componentStack.parent,
            type: "Suspense Fallback",
            owner: componentStack.owner,
            stack: componentStack.stack
          };
        }
        function getThrownInfo(node$jscomp$0) {
          var errorInfo = {};
          node$jscomp$0 && Object.defineProperty(errorInfo, "componentStack", {
            configurable: true,
            enumerable: true,
            get: function() {
              try {
                var info = "", node = node$jscomp$0;
                do
                  info += describeComponentStackByType(node.type), node = node.parent;
                while (node);
                var stack = info;
              } catch (x) {
                stack = "\nError generating stack: " + x.message + "\n" + x.stack;
              }
              Object.defineProperty(errorInfo, "componentStack", {
                value: stack
              });
              return stack;
            }
          });
          return errorInfo;
        }
        function encodeErrorForBoundary(boundary, digest, error, thrownInfo, wasAborted) {
          boundary.errorDigest = digest;
          error instanceof Error ? (digest = String(error.message), error = String(error.stack)) : (digest = "object" === typeof error && null !== error ? describeObjectForErrorMessage(error) : String(error), error = null);
          wasAborted = wasAborted ? "Switched to client rendering because the server rendering aborted due to:\n\n" : "Switched to client rendering because the server rendering errored:\n\n";
          boundary.errorMessage = wasAborted + digest;
          boundary.errorStack = null !== error ? wasAborted + error : null;
          boundary.errorComponentStack = thrownInfo.componentStack;
        }
        function logRecoverableError(request, error, errorInfo, debugTask) {
          request = request.onError;
          error = debugTask ? debugTask.run(request.bind(null, error, errorInfo)) : request(error, errorInfo);
          if (null != error && "string" !== typeof error)
            console.error(
              'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "%s" instead',
              typeof error
            );
          else return error;
        }
        function fatalError(request, error, errorInfo, debugTask) {
          errorInfo = request.onShellError;
          var onFatalError = request.onFatalError;
          debugTask ? (debugTask.run(errorInfo.bind(null, error)), debugTask.run(onFatalError.bind(null, error))) : (errorInfo(error), onFatalError(error));
          null !== request.destination ? (request.status = CLOSED, closeWithError(request.destination, error)) : (request.status = 13, request.fatalError = error);
        }
        function finishSuspenseListRow(request, row) {
          unblockSuspenseListRow(request, row.next, row.hoistables);
        }
        function unblockSuspenseListRow(request, unblockedRow, inheritedHoistables) {
          for (; null !== unblockedRow; ) {
            null !== inheritedHoistables && (hoistHoistables(unblockedRow.hoistables, inheritedHoistables), unblockedRow.inheritedHoistables = inheritedHoistables);
            var unblockedBoundaries = unblockedRow.boundaries;
            if (null !== unblockedBoundaries) {
              unblockedRow.boundaries = null;
              for (var i = 0; i < unblockedBoundaries.length; i++) {
                var unblockedBoundary = unblockedBoundaries[i];
                null !== inheritedHoistables && hoistHoistables(
                  unblockedBoundary.contentState,
                  inheritedHoistables
                );
                finishedTask(request, unblockedBoundary, null, null);
              }
            }
            unblockedRow.pendingTasks--;
            if (0 < unblockedRow.pendingTasks) break;
            inheritedHoistables = unblockedRow.hoistables;
            unblockedRow = unblockedRow.next;
          }
        }
        function tryToResolveTogetherRow(request, togetherRow) {
          var boundaries = togetherRow.boundaries;
          if (null !== boundaries && togetherRow.pendingTasks === boundaries.length) {
            for (var allCompleteAndInlinable = true, i = 0; i < boundaries.length; i++) {
              var rowBoundary = boundaries[i];
              if (1 !== rowBoundary.pendingTasks || rowBoundary.parentFlushed || isEligibleForOutlining(request, rowBoundary)) {
                allCompleteAndInlinable = false;
                break;
              }
            }
            allCompleteAndInlinable && unblockSuspenseListRow(request, togetherRow, togetherRow.hoistables);
          }
        }
        function createSuspenseListRow(previousRow) {
          var newRow = {
            pendingTasks: 1,
            boundaries: null,
            hoistables: createHoistableState(),
            inheritedHoistables: null,
            together: false,
            next: null
          };
          null !== previousRow && 0 < previousRow.pendingTasks && (newRow.pendingTasks++, newRow.boundaries = [], previousRow.next = newRow);
          return newRow;
        }
        function renderSuspenseListRows(request, task, keyPath, rows, revealOrder) {
          var prevKeyPath = task.keyPath, prevTreeContext = task.treeContext, prevRow = task.row, previousComponentStack = task.componentStack;
          var previousDebugTask = task.debugTask;
          pushServerComponentStack(task, task.node.props.children._debugInfo);
          task.keyPath = keyPath;
          keyPath = rows.length;
          var previousSuspenseListRow = null;
          if (null !== task.replay) {
            var resumeSlots = task.replay.slots;
            if (null !== resumeSlots && "object" === typeof resumeSlots)
              for (var n = 0; n < keyPath; n++) {
                var i = "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder ? n : keyPath - 1 - n, node = rows[i];
                task.row = previousSuspenseListRow = createSuspenseListRow(
                  previousSuspenseListRow
                );
                task.treeContext = pushTreeContext(prevTreeContext, keyPath, i);
                var resumeSegmentID = resumeSlots[i];
                "number" === typeof resumeSegmentID ? (resumeNode(request, task, resumeSegmentID, node, i), delete resumeSlots[i]) : renderNode(request, task, node, i);
                0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow(request, previousSuspenseListRow);
              }
            else
              for (resumeSlots = 0; resumeSlots < keyPath; resumeSlots++)
                n = "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder ? resumeSlots : keyPath - 1 - resumeSlots, i = rows[n], warnForMissingKey(request, task, i), task.row = previousSuspenseListRow = createSuspenseListRow(previousSuspenseListRow), task.treeContext = pushTreeContext(prevTreeContext, keyPath, n), renderNode(request, task, i, n), 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow(request, previousSuspenseListRow);
          } else if ("backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder)
            for (revealOrder = 0; revealOrder < keyPath; revealOrder++)
              resumeSlots = rows[revealOrder], warnForMissingKey(request, task, resumeSlots), task.row = previousSuspenseListRow = createSuspenseListRow(previousSuspenseListRow), task.treeContext = pushTreeContext(
                prevTreeContext,
                keyPath,
                revealOrder
              ), renderNode(request, task, resumeSlots, revealOrder), 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow(request, previousSuspenseListRow);
          else {
            revealOrder = task.blockedSegment;
            resumeSlots = revealOrder.children.length;
            n = revealOrder.chunks.length;
            for (i = keyPath - 1; 0 <= i; i--) {
              node = rows[i];
              task.row = previousSuspenseListRow = createSuspenseListRow(
                previousSuspenseListRow
              );
              task.treeContext = pushTreeContext(prevTreeContext, keyPath, i);
              resumeSegmentID = createPendingSegment(
                request,
                n,
                null,
                task.formatContext,
                0 === i ? revealOrder.lastPushedText : true,
                true
              );
              revealOrder.children.splice(resumeSlots, 0, resumeSegmentID);
              task.blockedSegment = resumeSegmentID;
              warnForMissingKey(request, task, node);
              try {
                renderNode(request, task, node, i), resumeSegmentID.lastPushedText && resumeSegmentID.textEmbedded && resumeSegmentID.chunks.push(textSeparator), resumeSegmentID.status = COMPLETED, finishedSegment(request, task.blockedBoundary, resumeSegmentID), 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow(request, previousSuspenseListRow);
              } catch (thrownValue) {
                throw resumeSegmentID.status = 12 === request.status ? ABORTED : ERRORED, thrownValue;
              }
            }
            task.blockedSegment = revealOrder;
            revealOrder.lastPushedText = false;
          }
          null !== prevRow && null !== previousSuspenseListRow && 0 < previousSuspenseListRow.pendingTasks && (prevRow.pendingTasks++, previousSuspenseListRow.next = prevRow);
          task.treeContext = prevTreeContext;
          task.row = prevRow;
          task.keyPath = prevKeyPath;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
        }
        function renderWithHooks(request, task, keyPath, Component, props, secondArg) {
          var prevThenableState = task.thenableState;
          task.thenableState = null;
          currentlyRenderingComponent = {};
          currentlyRenderingTask = task;
          currentlyRenderingRequest = request;
          currentlyRenderingKeyPath = keyPath;
          isInHookUserCodeInDev = false;
          actionStateCounter = localIdCounter = 0;
          actionStateMatchingIndex = -1;
          thenableIndexCounter = 0;
          thenableState = prevThenableState;
          for (request = callComponentInDEV(Component, props, secondArg); didScheduleRenderPhaseUpdate; )
            didScheduleRenderPhaseUpdate = false, actionStateCounter = localIdCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, numberOfReRenders += 1, workInProgressHook = null, request = Component(props, secondArg);
          resetHooksState();
          return request;
        }
        function finishFunctionComponent(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex2) {
          var didEmitActionStateMarkers = false;
          if (0 !== actionStateCount && null !== request.formState) {
            var segment = task.blockedSegment;
            if (null !== segment) {
              didEmitActionStateMarkers = true;
              segment = segment.chunks;
              for (var i = 0; i < actionStateCount; i++)
                i === actionStateMatchingIndex2 ? segment.push(formStateMarkerIsMatching) : segment.push(formStateMarkerIsNotMatching);
            }
          }
          actionStateCount = task.keyPath;
          task.keyPath = keyPath;
          hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext(keyPath, 1, 0), renderNode(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode(request, task, children, -1) : renderNodeDestructive(request, task, children, -1);
          task.keyPath = actionStateCount;
        }
        function renderElement(request, task, keyPath, type, props, ref) {
          if ("function" === typeof type)
            if (type.prototype && type.prototype.isReactComponent) {
              var newProps = props;
              if ("ref" in props) {
                newProps = {};
                for (var propName in props)
                  "ref" !== propName && (newProps[propName] = props[propName]);
              }
              var defaultProps = type.defaultProps;
              if (defaultProps) {
                newProps === props && (newProps = assign2({}, newProps, props));
                for (var _propName in defaultProps)
                  void 0 === newProps[_propName] && (newProps[_propName] = defaultProps[_propName]);
              }
              var resolvedProps = newProps;
              var context2 = emptyContextObject, contextType = type.contextType;
              if ("contextType" in type && null !== contextType && (void 0 === contextType || contextType.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(type)) {
                didWarnAboutInvalidateContextType.add(type);
                var addendum = void 0 === contextType ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof contextType ? " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                console.error(
                  "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
                  getComponentNameFromType(type) || "Component",
                  addendum
                );
              }
              "object" === typeof contextType && null !== contextType && (context2 = contextType._currentValue);
              var instance = new type(resolvedProps, context2);
              if ("function" === typeof type.getDerivedStateFromProps && (null === instance.state || void 0 === instance.state)) {
                var componentName = getComponentNameFromType(type) || "Component";
                didWarnAboutUninitializedState.has(componentName) || (didWarnAboutUninitializedState.add(componentName), console.error(
                  "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
                  componentName,
                  null === instance.state ? "null" : "undefined",
                  componentName
                ));
              }
              if ("function" === typeof type.getDerivedStateFromProps || "function" === typeof instance.getSnapshotBeforeUpdate) {
                var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
                "function" === typeof instance.componentWillMount && true !== instance.componentWillMount.__suppressDeprecationWarning ? foundWillMountName = "componentWillMount" : "function" === typeof instance.UNSAFE_componentWillMount && (foundWillMountName = "UNSAFE_componentWillMount");
                "function" === typeof instance.componentWillReceiveProps && true !== instance.componentWillReceiveProps.__suppressDeprecationWarning ? foundWillReceivePropsName = "componentWillReceiveProps" : "function" === typeof instance.UNSAFE_componentWillReceiveProps && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps");
                "function" === typeof instance.componentWillUpdate && true !== instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
                if (null !== foundWillMountName || null !== foundWillReceivePropsName || null !== foundWillUpdateName) {
                  var _componentName = getComponentNameFromType(type) || "Component", newApiName = "function" === typeof type.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                  didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(
                    _componentName
                  ), console.error(
                    "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                    _componentName,
                    newApiName,
                    null !== foundWillMountName ? "\n  " + foundWillMountName : "",
                    null !== foundWillReceivePropsName ? "\n  " + foundWillReceivePropsName : "",
                    null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
                  ));
                }
              }
              var name = getComponentNameFromType(type) || "Component";
              instance.render || (type.prototype && "function" === typeof type.prototype.render ? console.error(
                "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
                name
              ) : console.error(
                "No `render` method found on the %s instance: you may have forgotten to define `render`.",
                name
              ));
              !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state || console.error(
                "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
                name
              );
              instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved && console.error(
                "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
                name
              );
              instance.contextType && console.error(
                "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
                name
              );
              type.childContextTypes && !didWarnAboutChildContextTypes.has(type) && (didWarnAboutChildContextTypes.add(type), console.error(
                "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
                name
              ));
              type.contextTypes && !didWarnAboutContextTypes$1.has(type) && (didWarnAboutContextTypes$1.add(type), console.error(
                "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
                name
              ));
              "function" === typeof instance.componentShouldUpdate && console.error(
                "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
                name
              );
              type.prototype && type.prototype.isPureReactComponent && "undefined" !== typeof instance.shouldComponentUpdate && console.error(
                "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
                getComponentNameFromType(type) || "A pure component"
              );
              "function" === typeof instance.componentDidUnmount && console.error(
                "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
                name
              );
              "function" === typeof instance.componentDidReceiveProps && console.error(
                "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
                name
              );
              "function" === typeof instance.componentWillRecieveProps && console.error(
                "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
                name
              );
              "function" === typeof instance.UNSAFE_componentWillRecieveProps && console.error(
                "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
                name
              );
              var hasMutatedProps = instance.props !== resolvedProps;
              void 0 !== instance.props && hasMutatedProps && console.error(
                "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
                name
              );
              instance.defaultProps && console.error(
                "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
                name,
                name
              );
              "function" !== typeof instance.getSnapshotBeforeUpdate || "function" === typeof instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type), console.error(
                "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
                getComponentNameFromType(type)
              ));
              "function" === typeof instance.getDerivedStateFromProps && console.error(
                "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
                name
              );
              "function" === typeof instance.getDerivedStateFromError && console.error(
                "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
                name
              );
              "function" === typeof type.getSnapshotBeforeUpdate && console.error(
                "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
                name
              );
              var state = instance.state;
              state && ("object" !== typeof state || isArrayImpl(state)) && console.error("%s.state: must be set to an object or null", name);
              "function" === typeof instance.getChildContext && "object" !== typeof type.childContextTypes && console.error(
                "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
                name
              );
              var initialState = void 0 !== instance.state ? instance.state : null;
              instance.updater = classComponentUpdater;
              instance.props = resolvedProps;
              instance.state = initialState;
              var internalInstance = { queue: [], replace: false };
              instance._reactInternals = internalInstance;
              var contextType$jscomp$0 = type.contextType;
              instance.context = "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 ? contextType$jscomp$0._currentValue : emptyContextObject;
              if (instance.state === resolvedProps) {
                var componentName$jscomp$0 = getComponentNameFromType(type) || "Component";
                didWarnAboutDirectlyAssigningPropsToState.has(
                  componentName$jscomp$0
                ) || (didWarnAboutDirectlyAssigningPropsToState.add(
                  componentName$jscomp$0
                ), console.error(
                  "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
                  componentName$jscomp$0
                ));
              }
              var getDerivedStateFromProps = type.getDerivedStateFromProps;
              if ("function" === typeof getDerivedStateFromProps) {
                var partialState = getDerivedStateFromProps(
                  resolvedProps,
                  initialState
                );
                if (void 0 === partialState) {
                  var componentName$jscomp$1 = getComponentNameFromType(type) || "Component";
                  didWarnAboutUndefinedDerivedState.has(componentName$jscomp$1) || (didWarnAboutUndefinedDerivedState.add(componentName$jscomp$1), console.error(
                    "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
                    componentName$jscomp$1
                  ));
                }
                var JSCompiler_inline_result = null === partialState || void 0 === partialState ? initialState : assign2({}, initialState, partialState);
                instance.state = JSCompiler_inline_result;
              }
              if ("function" !== typeof type.getDerivedStateFromProps && "function" !== typeof instance.getSnapshotBeforeUpdate && ("function" === typeof instance.UNSAFE_componentWillMount || "function" === typeof instance.componentWillMount)) {
                var oldState = instance.state;
                if ("function" === typeof instance.componentWillMount) {
                  if (true !== instance.componentWillMount.__suppressDeprecationWarning) {
                    var componentName$jscomp$2 = getComponentNameFromType(type) || "Unknown";
                    didWarnAboutDeprecatedWillMount[componentName$jscomp$2] || (console.warn(
                      "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                      componentName$jscomp$2
                    ), didWarnAboutDeprecatedWillMount[componentName$jscomp$2] = true);
                  }
                  instance.componentWillMount();
                }
                "function" === typeof instance.UNSAFE_componentWillMount && instance.UNSAFE_componentWillMount();
                oldState !== instance.state && (console.error(
                  "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
                  getComponentNameFromType(type) || "Component"
                ), classComponentUpdater.enqueueReplaceState(
                  instance,
                  instance.state,
                  null
                ));
                if (null !== internalInstance.queue && 0 < internalInstance.queue.length) {
                  var oldQueue = internalInstance.queue, oldReplace = internalInstance.replace;
                  internalInstance.queue = null;
                  internalInstance.replace = false;
                  if (oldReplace && 1 === oldQueue.length)
                    instance.state = oldQueue[0];
                  else {
                    for (var nextState = oldReplace ? oldQueue[0] : instance.state, dontMutate = true, i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
                      var partial2 = oldQueue[i], partialState$jscomp$0 = "function" === typeof partial2 ? partial2.call(
                        instance,
                        nextState,
                        resolvedProps,
                        void 0
                      ) : partial2;
                      null != partialState$jscomp$0 && (dontMutate ? (dontMutate = false, nextState = assign2(
                        {},
                        nextState,
                        partialState$jscomp$0
                      )) : assign2(nextState, partialState$jscomp$0));
                    }
                    instance.state = nextState;
                  }
                } else internalInstance.queue = null;
              }
              var nextChildren = callRenderInDEV(instance);
              if (12 === request.status) throw null;
              instance.props !== resolvedProps && (didWarnAboutReassigningProps || console.error(
                "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
                getComponentNameFromType(type) || "a component"
              ), didWarnAboutReassigningProps = true);
              var prevKeyPath = task.keyPath;
              task.keyPath = keyPath;
              renderNodeDestructive(request, task, nextChildren, -1);
              task.keyPath = prevKeyPath;
            } else {
              if (type.prototype && "function" === typeof type.prototype.render) {
                var componentName$jscomp$3 = getComponentNameFromType(type) || "Unknown";
                didWarnAboutBadClass[componentName$jscomp$3] || (console.error(
                  "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
                  componentName$jscomp$3,
                  componentName$jscomp$3
                ), didWarnAboutBadClass[componentName$jscomp$3] = true);
              }
              var value = renderWithHooks(
                request,
                task,
                keyPath,
                type,
                props,
                void 0
              );
              if (12 === request.status) throw null;
              var hasId = 0 !== localIdCounter, actionStateCount = actionStateCounter, actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex;
              if (type.contextTypes) {
                var _componentName$jscomp$0 = getComponentNameFromType(type) || "Unknown";
                didWarnAboutContextTypes[_componentName$jscomp$0] || (didWarnAboutContextTypes[_componentName$jscomp$0] = true, console.error(
                  "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
                  _componentName$jscomp$0
                ));
              }
              type && type.childContextTypes && console.error(
                "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
                type.displayName || type.name || "Component"
              );
              if ("function" === typeof type.getDerivedStateFromProps) {
                var componentName$jscomp$4 = getComponentNameFromType(type) || "Unknown";
                didWarnAboutGetDerivedStateOnFunctionComponent[componentName$jscomp$4] || (console.error(
                  "%s: Function components do not support getDerivedStateFromProps.",
                  componentName$jscomp$4
                ), didWarnAboutGetDerivedStateOnFunctionComponent[componentName$jscomp$4] = true);
              }
              if ("object" === typeof type.contextType && null !== type.contextType) {
                var _componentName2 = getComponentNameFromType(type) || "Unknown";
                didWarnAboutContextTypeOnFunctionComponent[_componentName2] || (console.error(
                  "%s: Function components do not support contextType.",
                  _componentName2
                ), didWarnAboutContextTypeOnFunctionComponent[_componentName2] = true);
              }
              finishFunctionComponent(
                request,
                task,
                keyPath,
                value,
                hasId,
                actionStateCount,
                actionStateMatchingIndex$jscomp$0
              );
            }
          else if ("string" === typeof type) {
            var segment = task.blockedSegment;
            if (null === segment) {
              var children = props.children, prevContext = task.formatContext, prevKeyPath$jscomp$0 = task.keyPath;
              task.formatContext = getChildFormatContext(prevContext, type, props);
              task.keyPath = keyPath;
              renderNode(request, task, children, -1);
              task.formatContext = prevContext;
              task.keyPath = prevKeyPath$jscomp$0;
            } else {
              var _children = pushStartInstance(
                segment.chunks,
                type,
                props,
                request.resumableState,
                request.renderState,
                task.blockedPreamble,
                task.hoistableState,
                task.formatContext,
                segment.lastPushedText
              );
              segment.lastPushedText = false;
              var _prevContext2 = task.formatContext, _prevKeyPath3 = task.keyPath;
              task.keyPath = keyPath;
              if ((task.formatContext = getChildFormatContext(
                _prevContext2,
                type,
                props
              )).insertionMode === HTML_HEAD_MODE) {
                var preambleSegment = createPendingSegment(
                  request,
                  0,
                  null,
                  task.formatContext,
                  false,
                  false
                );
                segment.preambleChildren.push(preambleSegment);
                task.blockedSegment = preambleSegment;
                try {
                  preambleSegment.status = 6, renderNode(request, task, _children, -1), preambleSegment.lastPushedText && preambleSegment.textEmbedded && preambleSegment.chunks.push(textSeparator), preambleSegment.status = COMPLETED, finishedSegment(request, task.blockedBoundary, preambleSegment);
                } finally {
                  task.blockedSegment = segment;
                }
              } else renderNode(request, task, _children, -1);
              task.formatContext = _prevContext2;
              task.keyPath = _prevKeyPath3;
              a: {
                var target = segment.chunks, resumableState = request.resumableState;
                switch (type) {
                  case "title":
                  case "style":
                  case "script":
                  case "area":
                  case "base":
                  case "br":
                  case "col":
                  case "embed":
                  case "hr":
                  case "img":
                  case "input":
                  case "keygen":
                  case "link":
                  case "meta":
                  case "param":
                  case "source":
                  case "track":
                  case "wbr":
                    break a;
                  case "body":
                    if (_prevContext2.insertionMode <= HTML_HTML_MODE) {
                      resumableState.hasBody = true;
                      break a;
                    }
                    break;
                  case "html":
                    if (_prevContext2.insertionMode === ROOT_HTML_MODE) {
                      resumableState.hasHtml = true;
                      break a;
                    }
                    break;
                  case "head":
                    if (_prevContext2.insertionMode <= HTML_HTML_MODE) break a;
                }
                target.push(endChunkForTag(type));
              }
              segment.lastPushedText = false;
            }
          } else {
            switch (type) {
              case REACT_LEGACY_HIDDEN_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_FRAGMENT_TYPE:
                var prevKeyPath$jscomp$1 = task.keyPath;
                task.keyPath = keyPath;
                renderNodeDestructive(request, task, props.children, -1);
                task.keyPath = prevKeyPath$jscomp$1;
                return;
              case REACT_ACTIVITY_TYPE:
                var segment$jscomp$0 = task.blockedSegment;
                if (null === segment$jscomp$0) {
                  if ("hidden" !== props.mode) {
                    var prevKeyPath$jscomp$2 = task.keyPath;
                    task.keyPath = keyPath;
                    renderNode(request, task, props.children, -1);
                    task.keyPath = prevKeyPath$jscomp$2;
                  }
                } else if ("hidden" !== props.mode) {
                  segment$jscomp$0.chunks.push(startActivityBoundary);
                  segment$jscomp$0.lastPushedText = false;
                  var _prevKeyPath4 = task.keyPath;
                  task.keyPath = keyPath;
                  renderNode(request, task, props.children, -1);
                  task.keyPath = _prevKeyPath4;
                  segment$jscomp$0.chunks.push(endActivityBoundary);
                  segment$jscomp$0.lastPushedText = false;
                }
                return;
              case REACT_SUSPENSE_LIST_TYPE:
                a: {
                  var children$jscomp$0 = props.children, revealOrder = props.revealOrder;
                  if ("forwards" === revealOrder || "backwards" === revealOrder || "unstable_legacy-backwards" === revealOrder) {
                    if (isArrayImpl(children$jscomp$0)) {
                      renderSuspenseListRows(
                        request,
                        task,
                        keyPath,
                        children$jscomp$0,
                        revealOrder
                      );
                      break a;
                    }
                    var iteratorFn = getIteratorFn(children$jscomp$0);
                    if (iteratorFn) {
                      var iterator = iteratorFn.call(children$jscomp$0);
                      if (iterator) {
                        validateIterable(
                          task,
                          children$jscomp$0,
                          -1,
                          iterator,
                          iteratorFn
                        );
                        var step = iterator.next();
                        if (!step.done) {
                          var rows = [];
                          do
                            rows.push(step.value), step = iterator.next();
                          while (!step.done);
                          renderSuspenseListRows(
                            request,
                            task,
                            keyPath,
                            children$jscomp$0,
                            revealOrder
                          );
                        }
                        break a;
                      }
                    }
                  }
                  if ("together" === revealOrder) {
                    var _prevKeyPath2 = task.keyPath, prevRow = task.row, newRow = task.row = createSuspenseListRow(null);
                    newRow.boundaries = [];
                    newRow.together = true;
                    task.keyPath = keyPath;
                    renderNodeDestructive(request, task, children$jscomp$0, -1);
                    0 === --newRow.pendingTasks && finishSuspenseListRow(request, newRow);
                    task.keyPath = _prevKeyPath2;
                    task.row = prevRow;
                    null !== prevRow && 0 < newRow.pendingTasks && (prevRow.pendingTasks++, newRow.next = prevRow);
                  } else {
                    var prevKeyPath$jscomp$3 = task.keyPath;
                    task.keyPath = keyPath;
                    renderNodeDestructive(request, task, children$jscomp$0, -1);
                    task.keyPath = prevKeyPath$jscomp$3;
                  }
                }
                return;
              case REACT_VIEW_TRANSITION_TYPE:
              case REACT_SCOPE_TYPE:
                throw Error(
                  "ReactDOMServer does not yet support scope components."
                );
              case REACT_SUSPENSE_TYPE:
                a: if (null !== task.replay) {
                  var _prevKeyPath = task.keyPath, _prevContext = task.formatContext, _prevRow = task.row;
                  task.keyPath = keyPath;
                  task.formatContext = getSuspenseContentFormatContext(
                    request.resumableState,
                    _prevContext
                  );
                  task.row = null;
                  var _content = props.children;
                  try {
                    renderNode(request, task, _content, -1);
                  } finally {
                    task.keyPath = _prevKeyPath, task.formatContext = _prevContext, task.row = _prevRow;
                  }
                } else {
                  var prevKeyPath$jscomp$4 = task.keyPath, prevContext$jscomp$0 = task.formatContext, prevRow$jscomp$0 = task.row, parentBoundary = task.blockedBoundary, parentPreamble = task.blockedPreamble, parentHoistableState = task.hoistableState, parentSegment = task.blockedSegment, fallback = props.fallback, content = props.children, fallbackAbortSet = /* @__PURE__ */ new Set();
                  var newBoundary = task.formatContext.insertionMode < HTML_MODE ? createSuspenseBoundary(
                    request,
                    task.row,
                    fallbackAbortSet,
                    createPreambleState(),
                    createPreambleState()
                  ) : createSuspenseBoundary(
                    request,
                    task.row,
                    fallbackAbortSet,
                    null,
                    null
                  );
                  null !== request.trackedPostpones && (newBoundary.trackedContentKeyPath = keyPath);
                  var boundarySegment = createPendingSegment(
                    request,
                    parentSegment.chunks.length,
                    newBoundary,
                    task.formatContext,
                    false,
                    false
                  );
                  parentSegment.children.push(boundarySegment);
                  parentSegment.lastPushedText = false;
                  var contentRootSegment = createPendingSegment(
                    request,
                    0,
                    null,
                    task.formatContext,
                    false,
                    false
                  );
                  contentRootSegment.parentFlushed = true;
                  if (null !== request.trackedPostpones) {
                    var suspenseComponentStack = task.componentStack, fallbackKeyPath = [
                      keyPath[0],
                      "Suspense Fallback",
                      keyPath[2]
                    ], fallbackReplayNode = [
                      fallbackKeyPath[1],
                      fallbackKeyPath[2],
                      [],
                      null
                    ];
                    request.trackedPostpones.workingMap.set(
                      fallbackKeyPath,
                      fallbackReplayNode
                    );
                    newBoundary.trackedFallbackNode = fallbackReplayNode;
                    task.blockedSegment = boundarySegment;
                    task.blockedPreamble = newBoundary.fallbackPreamble;
                    task.keyPath = fallbackKeyPath;
                    task.formatContext = getSuspenseFallbackFormatContext(
                      request.resumableState,
                      prevContext$jscomp$0
                    );
                    task.componentStack = replaceSuspenseComponentStackWithSuspenseFallbackStack(
                      suspenseComponentStack
                    );
                    boundarySegment.status = 6;
                    try {
                      renderNode(request, task, fallback, -1), boundarySegment.lastPushedText && boundarySegment.textEmbedded && boundarySegment.chunks.push(textSeparator), boundarySegment.status = COMPLETED, finishedSegment(request, parentBoundary, boundarySegment);
                    } catch (thrownValue) {
                      throw boundarySegment.status = 12 === request.status ? ABORTED : ERRORED, thrownValue;
                    } finally {
                      task.blockedSegment = parentSegment, task.blockedPreamble = parentPreamble, task.keyPath = prevKeyPath$jscomp$4, task.formatContext = prevContext$jscomp$0;
                    }
                    var suspendedPrimaryTask = createRenderTask(
                      request,
                      null,
                      content,
                      -1,
                      newBoundary,
                      contentRootSegment,
                      newBoundary.contentPreamble,
                      newBoundary.contentState,
                      task.abortSet,
                      keyPath,
                      getSuspenseContentFormatContext(
                        request.resumableState,
                        task.formatContext
                      ),
                      task.context,
                      task.treeContext,
                      null,
                      suspenseComponentStack,
                      emptyContextObject,
                      task.debugTask
                    );
                    pushComponentStack(suspendedPrimaryTask);
                    request.pingedTasks.push(suspendedPrimaryTask);
                  } else {
                    task.blockedBoundary = newBoundary;
                    task.blockedPreamble = newBoundary.contentPreamble;
                    task.hoistableState = newBoundary.contentState;
                    task.blockedSegment = contentRootSegment;
                    task.keyPath = keyPath;
                    task.formatContext = getSuspenseContentFormatContext(
                      request.resumableState,
                      prevContext$jscomp$0
                    );
                    task.row = null;
                    contentRootSegment.status = 6;
                    try {
                      if (renderNode(request, task, content, -1), contentRootSegment.lastPushedText && contentRootSegment.textEmbedded && contentRootSegment.chunks.push(textSeparator), contentRootSegment.status = COMPLETED, finishedSegment(request, newBoundary, contentRootSegment), queueCompletedSegment(newBoundary, contentRootSegment), 0 === newBoundary.pendingTasks && newBoundary.status === PENDING) {
                        if (newBoundary.status = COMPLETED, !isEligibleForOutlining(request, newBoundary)) {
                          null !== prevRow$jscomp$0 && 0 === --prevRow$jscomp$0.pendingTasks && finishSuspenseListRow(request, prevRow$jscomp$0);
                          0 === request.pendingRootTasks && task.blockedPreamble && preparePreamble(request);
                          break a;
                        }
                      } else
                        null !== prevRow$jscomp$0 && prevRow$jscomp$0.together && tryToResolveTogetherRow(request, prevRow$jscomp$0);
                    } catch (thrownValue$2) {
                      newBoundary.status = CLIENT_RENDERED;
                      if (12 === request.status) {
                        contentRootSegment.status = ABORTED;
                        var error = request.fatalError;
                      } else
                        contentRootSegment.status = ERRORED, error = thrownValue$2;
                      var thrownInfo = getThrownInfo(task.componentStack);
                      var errorDigest = logRecoverableError(
                        request,
                        error,
                        thrownInfo,
                        task.debugTask
                      );
                      encodeErrorForBoundary(
                        newBoundary,
                        errorDigest,
                        error,
                        thrownInfo,
                        false
                      );
                      untrackBoundary(request, newBoundary);
                    } finally {
                      task.blockedBoundary = parentBoundary, task.blockedPreamble = parentPreamble, task.hoistableState = parentHoistableState, task.blockedSegment = parentSegment, task.keyPath = prevKeyPath$jscomp$4, task.formatContext = prevContext$jscomp$0, task.row = prevRow$jscomp$0;
                    }
                    var suspendedFallbackTask = createRenderTask(
                      request,
                      null,
                      fallback,
                      -1,
                      parentBoundary,
                      boundarySegment,
                      newBoundary.fallbackPreamble,
                      newBoundary.fallbackState,
                      fallbackAbortSet,
                      [keyPath[0], "Suspense Fallback", keyPath[2]],
                      getSuspenseFallbackFormatContext(
                        request.resumableState,
                        task.formatContext
                      ),
                      task.context,
                      task.treeContext,
                      task.row,
                      replaceSuspenseComponentStackWithSuspenseFallbackStack(
                        task.componentStack
                      ),
                      emptyContextObject,
                      task.debugTask
                    );
                    pushComponentStack(suspendedFallbackTask);
                    request.pingedTasks.push(suspendedFallbackTask);
                  }
                }
                return;
            }
            if ("object" === typeof type && null !== type)
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  if ("ref" in props) {
                    var propsWithoutRef = {};
                    for (var key in props)
                      "ref" !== key && (propsWithoutRef[key] = props[key]);
                  } else propsWithoutRef = props;
                  var children$jscomp$1 = renderWithHooks(
                    request,
                    task,
                    keyPath,
                    type.render,
                    propsWithoutRef,
                    ref
                  );
                  finishFunctionComponent(
                    request,
                    task,
                    keyPath,
                    children$jscomp$1,
                    0 !== localIdCounter,
                    actionStateCounter,
                    actionStateMatchingIndex
                  );
                  return;
                case REACT_MEMO_TYPE:
                  renderElement(request, task, keyPath, type.type, props, ref);
                  return;
                case REACT_CONTEXT_TYPE:
                  var value$jscomp$0 = props.value, children$jscomp$2 = props.children;
                  var prevSnapshot = task.context;
                  var prevKeyPath$jscomp$5 = task.keyPath;
                  var prevValue = type._currentValue;
                  type._currentValue = value$jscomp$0;
                  void 0 !== type._currentRenderer && null !== type._currentRenderer && type._currentRenderer !== rendererSigil && console.error(
                    "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
                  );
                  type._currentRenderer = rendererSigil;
                  var prevNode = currentActiveSnapshot, newNode = {
                    parent: prevNode,
                    depth: null === prevNode ? 0 : prevNode.depth + 1,
                    context: type,
                    parentValue: prevValue,
                    value: value$jscomp$0
                  };
                  currentActiveSnapshot = newNode;
                  task.context = newNode;
                  task.keyPath = keyPath;
                  renderNodeDestructive(request, task, children$jscomp$2, -1);
                  var prevSnapshot$jscomp$0 = currentActiveSnapshot;
                  if (null === prevSnapshot$jscomp$0)
                    throw Error(
                      "Tried to pop a Context at the root of the app. This is a bug in React."
                    );
                  prevSnapshot$jscomp$0.context !== type && console.error(
                    "The parent context is not the expected context. This is probably a bug in React."
                  );
                  prevSnapshot$jscomp$0.context._currentValue = prevSnapshot$jscomp$0.parentValue;
                  void 0 !== type._currentRenderer && null !== type._currentRenderer && type._currentRenderer !== rendererSigil && console.error(
                    "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
                  );
                  type._currentRenderer = rendererSigil;
                  var JSCompiler_inline_result$jscomp$0 = currentActiveSnapshot = prevSnapshot$jscomp$0.parent;
                  task.context = JSCompiler_inline_result$jscomp$0;
                  task.keyPath = prevKeyPath$jscomp$5;
                  prevSnapshot !== task.context && console.error(
                    "Popping the context provider did not return back to the original snapshot. This is a bug in React."
                  );
                  return;
                case REACT_CONSUMER_TYPE:
                  var context$jscomp$0 = type._context, render = props.children;
                  "function" !== typeof render && console.error(
                    "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
                  );
                  var newChildren = render(context$jscomp$0._currentValue), prevKeyPath$jscomp$6 = task.keyPath;
                  task.keyPath = keyPath;
                  renderNodeDestructive(request, task, newChildren, -1);
                  task.keyPath = prevKeyPath$jscomp$6;
                  return;
                case REACT_LAZY_TYPE:
                  var Component = callLazyInitInDEV(type);
                  if (12 === request.status) throw null;
                  renderElement(request, task, keyPath, Component, props, ref);
                  return;
              }
            var info = "";
            if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length)
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            throw Error(
              "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((null == type ? type : typeof type) + "." + info)
            );
          }
        }
        function resumeNode(request, task, segmentId, node, childIndex) {
          var prevReplay = task.replay, blockedBoundary = task.blockedBoundary, resumedSegment = createPendingSegment(
            request,
            0,
            null,
            task.formatContext,
            false,
            false
          );
          resumedSegment.id = segmentId;
          resumedSegment.parentFlushed = true;
          try {
            task.replay = null, task.blockedSegment = resumedSegment, renderNode(request, task, node, childIndex), resumedSegment.status = COMPLETED, finishedSegment(request, blockedBoundary, resumedSegment), null === blockedBoundary ? request.completedRootSegment = resumedSegment : (queueCompletedSegment(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));
          } finally {
            task.replay = prevReplay, task.blockedSegment = null;
          }
        }
        function replayElement(request, task, keyPath, name, keyOrIndex, childIndex, type, props, ref, replay) {
          childIndex = replay.nodes;
          for (var i = 0; i < childIndex.length; i++) {
            var node = childIndex[i];
            if (keyOrIndex === node[1]) {
              if (4 === node.length) {
                if (null !== name && name !== node[0])
                  throw Error(
                    "Expected the resume to render <" + node[0] + "> in this slot but instead it rendered <" + name + ">. The tree doesn't match so React will fallback to client rendering."
                  );
                var childNodes = node[2];
                name = node[3];
                keyOrIndex = task.node;
                task.replay = { nodes: childNodes, slots: name, pendingTasks: 1 };
                try {
                  renderElement(request, task, keyPath, type, props, ref);
                  if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                    throw Error(
                      "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                    );
                  task.replay.pendingTasks--;
                } catch (x) {
                  if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then))
                    throw task.node === keyOrIndex ? task.replay = replay : childIndex.splice(i, 1), x;
                  task.replay.pendingTasks--;
                  type = getThrownInfo(task.componentStack);
                  props = request;
                  request = task.blockedBoundary;
                  keyPath = x;
                  ref = name;
                  name = logRecoverableError(props, keyPath, type, task.debugTask);
                  abortRemainingReplayNodes(
                    props,
                    request,
                    childNodes,
                    ref,
                    keyPath,
                    name,
                    type,
                    false
                  );
                }
                task.replay = replay;
              } else {
                if (type !== REACT_SUSPENSE_TYPE)
                  throw Error(
                    "Expected the resume to render <Suspense> in this slot but instead it rendered <" + (getComponentNameFromType(type) || "Unknown") + ">. The tree doesn't match so React will fallback to client rendering."
                  );
                a: {
                  replay = void 0;
                  name = node[5];
                  type = node[2];
                  ref = node[3];
                  keyOrIndex = null === node[4] ? [] : node[4][2];
                  node = null === node[4] ? null : node[4][3];
                  var prevKeyPath = task.keyPath, prevContext = task.formatContext, prevRow = task.row, previousReplaySet = task.replay, parentBoundary = task.blockedBoundary, parentHoistableState = task.hoistableState, content = props.children, fallback = props.fallback, fallbackAbortSet = /* @__PURE__ */ new Set();
                  props = task.formatContext.insertionMode < HTML_MODE ? createSuspenseBoundary(
                    request,
                    task.row,
                    fallbackAbortSet,
                    createPreambleState(),
                    createPreambleState()
                  ) : createSuspenseBoundary(
                    request,
                    task.row,
                    fallbackAbortSet,
                    null,
                    null
                  );
                  props.parentFlushed = true;
                  props.rootSegmentID = name;
                  task.blockedBoundary = props;
                  task.hoistableState = props.contentState;
                  task.keyPath = keyPath;
                  task.formatContext = getSuspenseContentFormatContext(
                    request.resumableState,
                    prevContext
                  );
                  task.row = null;
                  task.replay = { nodes: type, slots: ref, pendingTasks: 1 };
                  try {
                    renderNode(request, task, content, -1);
                    if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                      throw Error(
                        "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                      );
                    task.replay.pendingTasks--;
                    if (0 === props.pendingTasks && props.status === PENDING) {
                      props.status = COMPLETED;
                      request.completedBoundaries.push(props);
                      break a;
                    }
                  } catch (error) {
                    props.status = CLIENT_RENDERED, childNodes = getThrownInfo(task.componentStack), replay = logRecoverableError(
                      request,
                      error,
                      childNodes,
                      task.debugTask
                    ), encodeErrorForBoundary(props, replay, error, childNodes, false), task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);
                  } finally {
                    task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath, task.formatContext = prevContext, task.row = prevRow;
                  }
                  props = createReplayTask(
                    request,
                    null,
                    { nodes: keyOrIndex, slots: node, pendingTasks: 0 },
                    fallback,
                    -1,
                    parentBoundary,
                    props.fallbackState,
                    fallbackAbortSet,
                    [keyPath[0], "Suspense Fallback", keyPath[2]],
                    getSuspenseFallbackFormatContext(
                      request.resumableState,
                      task.formatContext
                    ),
                    task.context,
                    task.treeContext,
                    task.row,
                    replaceSuspenseComponentStackWithSuspenseFallbackStack(
                      task.componentStack
                    ),
                    emptyContextObject,
                    task.debugTask
                  );
                  pushComponentStack(props);
                  request.pingedTasks.push(props);
                }
              }
              childIndex.splice(i, 1);
              break;
            }
          }
        }
        function validateIterable(task, iterable, childIndex, iterator, iteratorFn) {
          if (iterator === iterable) {
            if (-1 !== childIndex || null === task.componentStack || "function" !== typeof task.componentStack.type || "[object GeneratorFunction]" !== Object.prototype.toString.call(task.componentStack.type) || "[object Generator]" !== Object.prototype.toString.call(iterator))
              didWarnAboutGenerators || console.error(
                "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
              ), didWarnAboutGenerators = true;
          } else
            iterable.entries !== iteratorFn || didWarnAboutMaps || (console.error(
              "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
            ), didWarnAboutMaps = true);
        }
        function renderNodeDestructive(request, task, node, childIndex) {
          null !== task.replay && "number" === typeof task.replay.slots ? resumeNode(request, task, task.replay.slots, node, childIndex) : (task.node = node, task.childIndex = childIndex, node = task.componentStack, childIndex = task.debugTask, pushComponentStack(task), retryNode(request, task), task.componentStack = node, task.debugTask = childIndex);
        }
        function retryNode(request, task) {
          var node = task.node, childIndex = task.childIndex;
          if (null !== node) {
            if ("object" === typeof node) {
              switch (node.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = node.type, key = node.key;
                  node = node.props;
                  var refProp = node.ref;
                  refProp = void 0 !== refProp ? refProp : null;
                  var debugTask = task.debugTask, name = getComponentNameFromType(type);
                  key = null == key ? -1 === childIndex ? 0 : childIndex : key;
                  var keyPath = [task.keyPath, name, key];
                  null !== task.replay ? debugTask ? debugTask.run(
                    replayElement.bind(
                      null,
                      request,
                      task,
                      keyPath,
                      name,
                      key,
                      childIndex,
                      type,
                      node,
                      refProp,
                      task.replay
                    )
                  ) : replayElement(
                    request,
                    task,
                    keyPath,
                    name,
                    key,
                    childIndex,
                    type,
                    node,
                    refProp,
                    task.replay
                  ) : debugTask ? debugTask.run(
                    renderElement.bind(
                      null,
                      request,
                      task,
                      keyPath,
                      type,
                      node,
                      refProp
                    )
                  ) : renderElement(request, task, keyPath, type, node, refProp);
                  return;
                case REACT_PORTAL_TYPE:
                  throw Error(
                    "Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render."
                  );
                case REACT_LAZY_TYPE:
                  type = callLazyInitInDEV(node);
                  if (12 === request.status) throw null;
                  renderNodeDestructive(request, task, type, childIndex);
                  return;
              }
              if (isArrayImpl(node)) {
                renderChildrenArray(request, task, node, childIndex);
                return;
              }
              if (key = getIteratorFn(node)) {
                if (type = key.call(node)) {
                  validateIterable(task, node, childIndex, type, key);
                  node = type.next();
                  if (!node.done) {
                    key = [];
                    do
                      key.push(node.value), node = type.next();
                    while (!node.done);
                    renderChildrenArray(request, task, key, childIndex);
                  }
                  return;
                }
              }
              if ("function" === typeof node.then)
                return task.thenableState = null, renderNodeDestructive(
                  request,
                  task,
                  unwrapThenable(node),
                  childIndex
                );
              if (node.$$typeof === REACT_CONTEXT_TYPE)
                return renderNodeDestructive(
                  request,
                  task,
                  node._currentValue,
                  childIndex
                );
              request = Object.prototype.toString.call(node);
              throw Error(
                "Objects are not valid as a React child (found: " + ("[object Object]" === request ? "object with keys {" + Object.keys(node).join(", ") + "}" : request) + "). If you meant to render a collection of children, use an array instead."
              );
            }
            "string" === typeof node ? (task = task.blockedSegment, null !== task && (task.lastPushedText = pushTextInstance(
              task.chunks,
              node,
              request.renderState,
              task.lastPushedText
            ))) : "number" === typeof node || "bigint" === typeof node ? (task = task.blockedSegment, null !== task && (task.lastPushedText = pushTextInstance(
              task.chunks,
              "" + node,
              request.renderState,
              task.lastPushedText
            ))) : ("function" === typeof node && (request = node.displayName || node.name || "Component", console.error(
              "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.",
              request,
              request
            )), "symbol" === typeof node && console.error(
              "Symbols are not valid as a React child.\n  %s",
              String(node)
            ));
          }
        }
        function warnForMissingKey(request, task, child) {
          if (null !== child && "object" === typeof child && (child.$$typeof === REACT_ELEMENT_TYPE || child.$$typeof === REACT_PORTAL_TYPE) && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {
            if ("object" !== typeof child._store)
              throw Error(
                "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
              );
            child._store.validated = 1;
            var didWarnForKey = request.didWarnForKey;
            null == didWarnForKey && (didWarnForKey = request.didWarnForKey = /* @__PURE__ */ new WeakSet());
            request = task.componentStack;
            if (null !== request && !didWarnForKey.has(request)) {
              didWarnForKey.add(request);
              var componentName = getComponentNameFromType(child.type);
              didWarnForKey = child._owner;
              var parentOwner = request.owner;
              request = "";
              if (parentOwner && "undefined" !== typeof parentOwner.type) {
                var name = getComponentNameFromType(parentOwner.type);
                name && (request = "\n\nCheck the render method of `" + name + "`.");
              }
              request || componentName && (request = "\n\nCheck the top-level render call using <" + componentName + ">.");
              componentName = "";
              null != didWarnForKey && parentOwner !== didWarnForKey && (parentOwner = null, "undefined" !== typeof didWarnForKey.type ? parentOwner = getComponentNameFromType(didWarnForKey.type) : "string" === typeof didWarnForKey.name && (parentOwner = didWarnForKey.name), parentOwner && (componentName = " It was passed a child from " + parentOwner + "."));
              didWarnForKey = task.componentStack;
              task.componentStack = {
                parent: task.componentStack,
                type: child.type,
                owner: child._owner,
                stack: child._debugStack
              };
              console.error(
                'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
                request,
                componentName
              );
              task.componentStack = didWarnForKey;
            }
          }
        }
        function renderChildrenArray(request, task, children, childIndex) {
          var prevKeyPath = task.keyPath, previousComponentStack = task.componentStack;
          var previousDebugTask = task.debugTask;
          pushServerComponentStack(task, task.node._debugInfo);
          if (-1 !== childIndex && (task.keyPath = [task.keyPath, "Fragment", childIndex], null !== task.replay)) {
            for (var replay = task.replay, replayNodes = replay.nodes, j = 0; j < replayNodes.length; j++) {
              var node = replayNodes[j];
              if (node[1] === childIndex) {
                childIndex = node[2];
                node = node[3];
                task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };
                try {
                  renderChildrenArray(request, task, children, -1);
                  if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                    throw Error(
                      "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                    );
                  task.replay.pendingTasks--;
                } catch (x) {
                  if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then))
                    throw x;
                  task.replay.pendingTasks--;
                  var thrownInfo = getThrownInfo(task.componentStack);
                  children = task.blockedBoundary;
                  var error = x, resumeSlots = node;
                  node = logRecoverableError(
                    request,
                    error,
                    thrownInfo,
                    task.debugTask
                  );
                  abortRemainingReplayNodes(
                    request,
                    children,
                    childIndex,
                    resumeSlots,
                    error,
                    node,
                    thrownInfo,
                    false
                  );
                }
                task.replay = replay;
                replayNodes.splice(j, 1);
                break;
              }
            }
            task.keyPath = prevKeyPath;
            task.componentStack = previousComponentStack;
            task.debugTask = previousDebugTask;
            return;
          }
          replay = task.treeContext;
          replayNodes = children.length;
          if (null !== task.replay && (j = task.replay.slots, null !== j && "object" === typeof j)) {
            for (childIndex = 0; childIndex < replayNodes; childIndex++)
              node = children[childIndex], task.treeContext = pushTreeContext(
                replay,
                replayNodes,
                childIndex
              ), error = j[childIndex], "number" === typeof error ? (resumeNode(request, task, error, node, childIndex), delete j[childIndex]) : renderNode(request, task, node, childIndex);
            task.treeContext = replay;
            task.keyPath = prevKeyPath;
            task.componentStack = previousComponentStack;
            task.debugTask = previousDebugTask;
            return;
          }
          for (j = 0; j < replayNodes; j++)
            childIndex = children[j], warnForMissingKey(request, task, childIndex), task.treeContext = pushTreeContext(replay, replayNodes, j), renderNode(request, task, childIndex, j);
          task.treeContext = replay;
          task.keyPath = prevKeyPath;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
        }
        function trackPostponedBoundary(request, trackedPostpones, boundary) {
          boundary.status = POSTPONED;
          boundary.rootSegmentID = request.nextSegmentId++;
          request = boundary.trackedContentKeyPath;
          if (null === request)
            throw Error(
              "It should not be possible to postpone at the root. This is a bug in React."
            );
          var fallbackReplayNode = boundary.trackedFallbackNode, children = [], boundaryNode = trackedPostpones.workingMap.get(request);
          if (void 0 === boundaryNode)
            return boundary = [
              request[1],
              request[2],
              children,
              null,
              fallbackReplayNode,
              boundary.rootSegmentID
            ], trackedPostpones.workingMap.set(request, boundary), addToReplayParent(boundary, request[0], trackedPostpones), boundary;
          boundaryNode[4] = fallbackReplayNode;
          boundaryNode[5] = boundary.rootSegmentID;
          return boundaryNode;
        }
        function trackPostpone(request, trackedPostpones, task, segment) {
          segment.status = POSTPONED;
          var keyPath = task.keyPath, boundary = task.blockedBoundary;
          if (null === boundary)
            segment.id = request.nextSegmentId++, trackedPostpones.rootSlots = segment.id, null !== request.completedRootSegment && (request.completedRootSegment.status = POSTPONED);
          else {
            if (null !== boundary && boundary.status === PENDING) {
              var boundaryNode = trackPostponedBoundary(
                request,
                trackedPostpones,
                boundary
              );
              if (boundary.trackedContentKeyPath === keyPath && -1 === task.childIndex) {
                -1 === segment.id && (segment.id = segment.parentFlushed ? boundary.rootSegmentID : request.nextSegmentId++);
                boundaryNode[3] = segment.id;
                return;
              }
            }
            -1 === segment.id && (segment.id = segment.parentFlushed && null !== boundary ? boundary.rootSegmentID : request.nextSegmentId++);
            if (-1 === task.childIndex)
              null === keyPath ? trackedPostpones.rootSlots = segment.id : (task = trackedPostpones.workingMap.get(keyPath), void 0 === task ? (task = [keyPath[1], keyPath[2], [], segment.id], addToReplayParent(task, keyPath[0], trackedPostpones)) : task[3] = segment.id);
            else {
              if (null === keyPath)
                if (request = trackedPostpones.rootSlots, null === request)
                  request = trackedPostpones.rootSlots = {};
                else {
                  if ("number" === typeof request)
                    throw Error(
                      "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
                    );
                }
              else if (boundary = trackedPostpones.workingMap, boundaryNode = boundary.get(keyPath), void 0 === boundaryNode)
                request = {}, boundaryNode = [keyPath[1], keyPath[2], [], request], boundary.set(keyPath, boundaryNode), addToReplayParent(boundaryNode, keyPath[0], trackedPostpones);
              else if (request = boundaryNode[3], null === request)
                request = boundaryNode[3] = {};
              else if ("number" === typeof request)
                throw Error(
                  "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
                );
              request[task.childIndex] = segment.id;
            }
          }
        }
        function untrackBoundary(request, boundary) {
          request = request.trackedPostpones;
          null !== request && (boundary = boundary.trackedContentKeyPath, null !== boundary && (boundary = request.workingMap.get(boundary), void 0 !== boundary && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));
        }
        function spawnNewSuspendedReplayTask(request, task, thenableState2) {
          return createReplayTask(
            request,
            thenableState2,
            task.replay,
            task.node,
            task.childIndex,
            task.blockedBoundary,
            task.hoistableState,
            task.abortSet,
            task.keyPath,
            task.formatContext,
            task.context,
            task.treeContext,
            task.row,
            task.componentStack,
            emptyContextObject,
            task.debugTask
          );
        }
        function spawnNewSuspendedRenderTask(request, task, thenableState2) {
          var segment = task.blockedSegment, newSegment = createPendingSegment(
            request,
            segment.chunks.length,
            null,
            task.formatContext,
            segment.lastPushedText,
            true
          );
          segment.children.push(newSegment);
          segment.lastPushedText = false;
          return createRenderTask(
            request,
            thenableState2,
            task.node,
            task.childIndex,
            task.blockedBoundary,
            newSegment,
            task.blockedPreamble,
            task.hoistableState,
            task.abortSet,
            task.keyPath,
            task.formatContext,
            task.context,
            task.treeContext,
            task.row,
            task.componentStack,
            emptyContextObject,
            task.debugTask
          );
        }
        function renderNode(request, task, node, childIndex) {
          var previousFormatContext = task.formatContext, previousContext = task.context, previousKeyPath = task.keyPath, previousTreeContext = task.treeContext, previousComponentStack = task.componentStack, previousDebugTask = task.debugTask, segment = task.blockedSegment;
          if (null === segment) {
            segment = task.replay;
            try {
              return renderNodeDestructive(request, task, node, childIndex);
            } catch (thrownValue) {
              if (resetHooksState(), node = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue, 12 !== request.status && "object" === typeof node && null !== node) {
                if ("function" === typeof node.then) {
                  childIndex = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
                  request = spawnNewSuspendedReplayTask(
                    request,
                    task,
                    childIndex
                  ).ping;
                  node.then(request, request);
                  task.formatContext = previousFormatContext;
                  task.context = previousContext;
                  task.keyPath = previousKeyPath;
                  task.treeContext = previousTreeContext;
                  task.componentStack = previousComponentStack;
                  task.replay = segment;
                  task.debugTask = previousDebugTask;
                  switchContext(previousContext);
                  return;
                }
                if ("Maximum call stack size exceeded" === node.message) {
                  node = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
                  node = spawnNewSuspendedReplayTask(request, task, node);
                  request.pingedTasks.push(node);
                  task.formatContext = previousFormatContext;
                  task.context = previousContext;
                  task.keyPath = previousKeyPath;
                  task.treeContext = previousTreeContext;
                  task.componentStack = previousComponentStack;
                  task.replay = segment;
                  task.debugTask = previousDebugTask;
                  switchContext(previousContext);
                  return;
                }
              }
            }
          } else {
            var childrenLength = segment.children.length, chunkLength = segment.chunks.length;
            try {
              return renderNodeDestructive(request, task, node, childIndex);
            } catch (thrownValue$3) {
              if (resetHooksState(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node = thrownValue$3 === SuspenseException ? getSuspendedThenable() : thrownValue$3, 12 !== request.status && "object" === typeof node && null !== node) {
                if ("function" === typeof node.then) {
                  segment = node;
                  node = thrownValue$3 === SuspenseException ? getThenableStateAfterSuspending() : null;
                  request = spawnNewSuspendedRenderTask(request, task, node).ping;
                  segment.then(request, request);
                  task.formatContext = previousFormatContext;
                  task.context = previousContext;
                  task.keyPath = previousKeyPath;
                  task.treeContext = previousTreeContext;
                  task.componentStack = previousComponentStack;
                  task.debugTask = previousDebugTask;
                  switchContext(previousContext);
                  return;
                }
                if ("Maximum call stack size exceeded" === node.message) {
                  segment = thrownValue$3 === SuspenseException ? getThenableStateAfterSuspending() : null;
                  segment = spawnNewSuspendedRenderTask(request, task, segment);
                  request.pingedTasks.push(segment);
                  task.formatContext = previousFormatContext;
                  task.context = previousContext;
                  task.keyPath = previousKeyPath;
                  task.treeContext = previousTreeContext;
                  task.componentStack = previousComponentStack;
                  task.debugTask = previousDebugTask;
                  switchContext(previousContext);
                  return;
                }
              }
            }
          }
          task.formatContext = previousFormatContext;
          task.context = previousContext;
          task.keyPath = previousKeyPath;
          task.treeContext = previousTreeContext;
          switchContext(previousContext);
          throw node;
        }
        function abortTaskSoft(task) {
          var boundary = task.blockedBoundary, segment = task.blockedSegment;
          null !== segment && (segment.status = ABORTED, finishedTask(this, boundary, task.row, segment));
        }
        function abortRemainingReplayNodes(request$jscomp$0, boundary, nodes, slots, error$jscomp$0, errorDigest$jscomp$0, errorInfo$jscomp$0, aborted) {
          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (4 === node.length)
              abortRemainingReplayNodes(
                request$jscomp$0,
                boundary,
                node[2],
                node[3],
                error$jscomp$0,
                errorDigest$jscomp$0,
                errorInfo$jscomp$0,
                aborted
              );
            else {
              var request = request$jscomp$0;
              node = node[5];
              var error = error$jscomp$0, errorDigest = errorDigest$jscomp$0, errorInfo = errorInfo$jscomp$0, wasAborted = aborted, resumedBoundary = createSuspenseBoundary(
                request,
                null,
                /* @__PURE__ */ new Set(),
                null,
                null
              );
              resumedBoundary.parentFlushed = true;
              resumedBoundary.rootSegmentID = node;
              resumedBoundary.status = CLIENT_RENDERED;
              encodeErrorForBoundary(
                resumedBoundary,
                errorDigest,
                error,
                errorInfo,
                wasAborted
              );
              resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);
            }
          }
          nodes.length = 0;
          if (null !== slots) {
            if (null === boundary)
              throw Error(
                "We should not have any resumable nodes in the shell. This is a bug in React."
              );
            boundary.status !== CLIENT_RENDERED && (boundary.status = CLIENT_RENDERED, encodeErrorForBoundary(
              boundary,
              errorDigest$jscomp$0,
              error$jscomp$0,
              errorInfo$jscomp$0,
              aborted
            ), boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));
            if ("object" === typeof slots)
              for (var index in slots) delete slots[index];
          }
        }
        function abortTask(task, request, error) {
          var boundary = task.blockedBoundary, segment = task.blockedSegment;
          if (null !== segment) {
            if (6 === segment.status) return;
            segment.status = ABORTED;
          }
          var errorInfo = getThrownInfo(task.componentStack), node = task.node;
          null !== node && "object" === typeof node && pushHaltedAwaitOnComponentStack(task, node._debugInfo);
          if (null === boundary) {
            if (13 !== request.status && request.status !== CLOSED) {
              boundary = task.replay;
              if (null === boundary) {
                null !== request.trackedPostpones && null !== segment ? (boundary = request.trackedPostpones, logRecoverableError(request, error, errorInfo, task.debugTask), trackPostpone(request, boundary, task, segment), finishedTask(request, null, task.row, segment)) : (logRecoverableError(request, error, errorInfo, task.debugTask), fatalError(request, error, errorInfo, task.debugTask));
                return;
              }
              boundary.pendingTasks--;
              0 === boundary.pendingTasks && 0 < boundary.nodes.length && (segment = logRecoverableError(request, error, errorInfo, null), abortRemainingReplayNodes(
                request,
                null,
                boundary.nodes,
                boundary.slots,
                error,
                segment,
                errorInfo,
                true
              ));
              request.pendingRootTasks--;
              0 === request.pendingRootTasks && completeShell(request);
            }
          } else {
            node = request.trackedPostpones;
            if (boundary.status !== CLIENT_RENDERED) {
              if (null !== node && null !== segment)
                return logRecoverableError(request, error, errorInfo, task.debugTask), trackPostpone(request, node, task, segment), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
                  return abortTask(fallbackTask, request, error);
                }), boundary.fallbackAbortableTasks.clear(), finishedTask(request, boundary, task.row, segment);
              boundary.status = CLIENT_RENDERED;
              segment = logRecoverableError(
                request,
                error,
                errorInfo,
                task.debugTask
              );
              boundary.status = CLIENT_RENDERED;
              encodeErrorForBoundary(boundary, segment, error, errorInfo, true);
              untrackBoundary(request, boundary);
              boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);
            }
            boundary.pendingTasks--;
            errorInfo = boundary.row;
            null !== errorInfo && 0 === --errorInfo.pendingTasks && finishSuspenseListRow(request, errorInfo);
            boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
              return abortTask(fallbackTask, request, error);
            });
            boundary.fallbackAbortableTasks.clear();
          }
          task = task.row;
          null !== task && 0 === --task.pendingTasks && finishSuspenseListRow(request, task);
          request.allPendingTasks--;
          0 === request.allPendingTasks && completeAll(request);
        }
        function safelyEmitEarlyPreloads(request, shellComplete) {
          try {
            var renderState = request.renderState, onHeaders = renderState.onHeaders;
            if (onHeaders) {
              var headers = renderState.headers;
              if (headers) {
                renderState.headers = null;
                var linkHeader = headers.preconnects;
                headers.fontPreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.fontPreloads);
                headers.highImagePreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.highImagePreloads);
                if (!shellComplete) {
                  var queueIter = renderState.styles.values(), queueStep = queueIter.next();
                  b: for (; 0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next())
                    for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next(); 0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {
                      var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props;
                      var header = getPreloadAsHeader(
                        props$jscomp$0.href,
                        "style",
                        {
                          crossOrigin: props$jscomp$0.crossOrigin,
                          integrity: props$jscomp$0.integrity,
                          nonce: props$jscomp$0.nonce,
                          type: props$jscomp$0.type,
                          fetchPriority: props$jscomp$0.fetchPriority,
                          referrerPolicy: props$jscomp$0.referrerPolicy,
                          media: props$jscomp$0.media
                        }
                      );
                      if (0 <= (headers.remainingCapacity -= header.length + 2))
                        renderState.resets.style[key] = PRELOAD_NO_CREDS, linkHeader && (linkHeader += ", "), linkHeader += header, renderState.resets.style[key] = "string" === typeof props.crossOrigin || "string" === typeof props.integrity ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS;
                      else break b;
                    }
                }
                linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});
              }
            }
          } catch (error) {
            logRecoverableError(request, error, {}, null);
          }
        }
        function completeShell(request) {
          null === request.trackedPostpones && safelyEmitEarlyPreloads(request, true);
          null === request.trackedPostpones && preparePreamble(request);
          request.onShellError = noop;
          request = request.onShellReady;
          request();
        }
        function completeAll(request) {
          safelyEmitEarlyPreloads(
            request,
            null === request.trackedPostpones ? true : null === request.completedRootSegment || request.completedRootSegment.status !== POSTPONED
          );
          preparePreamble(request);
          request = request.onAllReady;
          request();
        }
        function queueCompletedSegment(boundary, segment) {
          if (0 === segment.chunks.length && 1 === segment.children.length && null === segment.children[0].boundary && -1 === segment.children[0].id) {
            var childSegment = segment.children[0];
            childSegment.id = segment.id;
            childSegment.parentFlushed = true;
            childSegment.status !== COMPLETED && childSegment.status !== ABORTED && childSegment.status !== ERRORED || queueCompletedSegment(boundary, childSegment);
          } else boundary.completedSegments.push(segment);
        }
        function finishedSegment(request, boundary, segment) {
          if (null !== byteLengthOfChunk) {
            segment = segment.chunks;
            for (var segmentByteSize = 0, i = 0; i < segment.length; i++)
              segmentByteSize += segment[i].byteLength;
            null === boundary ? request.byteSize += segmentByteSize : boundary.byteSize += segmentByteSize;
          }
        }
        function finishedTask(request, boundary, row, segment) {
          null !== row && (0 === --row.pendingTasks ? finishSuspenseListRow(request, row) : row.together && tryToResolveTogetherRow(request, row));
          request.allPendingTasks--;
          if (null === boundary) {
            if (null !== segment && segment.parentFlushed) {
              if (null !== request.completedRootSegment)
                throw Error(
                  "There can only be one root segment. This is a bug in React."
                );
              request.completedRootSegment = segment;
            }
            request.pendingRootTasks--;
            0 === request.pendingRootTasks && completeShell(request);
          } else if (boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED)
            if (0 === boundary.pendingTasks)
              if (boundary.status === PENDING && (boundary.status = COMPLETED), null !== segment && segment.parentFlushed && (segment.status === COMPLETED || segment.status === ABORTED) && queueCompletedSegment(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), boundary.status === COMPLETED)
                row = boundary.row, null !== row && hoistHoistables(row.hoistables, boundary.contentState), isEligibleForOutlining(request, boundary) || (boundary.fallbackAbortableTasks.forEach(
                  abortTaskSoft,
                  request
                ), boundary.fallbackAbortableTasks.clear(), null !== row && 0 === --row.pendingTasks && finishSuspenseListRow(request, row)), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary.contentPreamble && preparePreamble(request);
              else {
                if (boundary.status === POSTPONED && (boundary = boundary.row, null !== boundary)) {
                  if (null !== request.trackedPostpones) {
                    row = request.trackedPostpones;
                    var postponedRow = boundary.next;
                    if (null !== postponedRow && (segment = postponedRow.boundaries, null !== segment))
                      for (postponedRow.boundaries = null, postponedRow = 0; postponedRow < segment.length; postponedRow++) {
                        var postponedBoundary = segment[postponedRow];
                        trackPostponedBoundary(request, row, postponedBoundary);
                        finishedTask(request, postponedBoundary, null, null);
                      }
                  }
                  0 === --boundary.pendingTasks && finishSuspenseListRow(request, boundary);
                }
              }
            else
              null === segment || !segment.parentFlushed || segment.status !== COMPLETED && segment.status !== ABORTED || (queueCompletedSegment(boundary, segment), 1 === boundary.completedSegments.length && boundary.parentFlushed && request.partialBoundaries.push(boundary)), boundary = boundary.row, null !== boundary && boundary.together && tryToResolveTogetherRow(request, boundary);
          0 === request.allPendingTasks && completeAll(request);
        }
        function performWork(request$jscomp$2) {
          if (request$jscomp$2.status !== CLOSED && 13 !== request$jscomp$2.status) {
            var prevContext = currentActiveSnapshot, prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = HooksDispatcher;
            var prevAsyncDispatcher = ReactSharedInternals.A;
            ReactSharedInternals.A = DefaultAsyncDispatcher;
            var prevRequest = currentRequest;
            currentRequest = request$jscomp$2;
            var prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;
            ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;
            var prevResumableState = currentResumableState;
            currentResumableState = request$jscomp$2.resumableState;
            try {
              var pingedTasks = request$jscomp$2.pingedTasks, i;
              for (i = 0; i < pingedTasks.length; i++) {
                var request = request$jscomp$2, task = pingedTasks[i], segment = task.blockedSegment;
                if (null === segment) {
                  var prevTaskInDEV = void 0, request$jscomp$0 = request;
                  request = task;
                  if (0 !== request.replay.pendingTasks) {
                    switchContext(request.context);
                    prevTaskInDEV = currentTaskInDEV;
                    currentTaskInDEV = request;
                    try {
                      "number" === typeof request.replay.slots ? resumeNode(
                        request$jscomp$0,
                        request,
                        request.replay.slots,
                        request.node,
                        request.childIndex
                      ) : retryNode(request$jscomp$0, request);
                      if (1 === request.replay.pendingTasks && 0 < request.replay.nodes.length)
                        throw Error(
                          "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                        );
                      request.replay.pendingTasks--;
                      request.abortSet.delete(request);
                      finishedTask(
                        request$jscomp$0,
                        request.blockedBoundary,
                        request.row,
                        null
                      );
                    } catch (thrownValue) {
                      resetHooksState();
                      var x = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;
                      if ("object" === typeof x && null !== x && "function" === typeof x.then) {
                        var ping = request.ping;
                        x.then(ping, ping);
                        request.thenableState = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
                      } else {
                        request.replay.pendingTasks--;
                        request.abortSet.delete(request);
                        var errorInfo = getThrownInfo(request.componentStack), errorDigest = void 0, request$jscomp$1 = request$jscomp$0, boundary = request.blockedBoundary, error$jscomp$0 = 12 === request$jscomp$0.status ? request$jscomp$0.fatalError : x, errorInfo$jscomp$0 = errorInfo, replayNodes = request.replay.nodes, resumeSlots = request.replay.slots;
                        errorDigest = logRecoverableError(
                          request$jscomp$1,
                          error$jscomp$0,
                          errorInfo$jscomp$0,
                          request.debugTask
                        );
                        abortRemainingReplayNodes(
                          request$jscomp$1,
                          boundary,
                          replayNodes,
                          resumeSlots,
                          error$jscomp$0,
                          errorDigest,
                          errorInfo$jscomp$0,
                          false
                        );
                        request$jscomp$0.pendingRootTasks--;
                        0 === request$jscomp$0.pendingRootTasks && completeShell(request$jscomp$0);
                        request$jscomp$0.allPendingTasks--;
                        0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);
                      }
                    } finally {
                      currentTaskInDEV = prevTaskInDEV;
                    }
                  }
                } else if (request$jscomp$0 = prevTaskInDEV = void 0, errorDigest = task, request$jscomp$1 = segment, request$jscomp$1.status === PENDING) {
                  request$jscomp$1.status = 6;
                  switchContext(errorDigest.context);
                  request$jscomp$0 = currentTaskInDEV;
                  currentTaskInDEV = errorDigest;
                  var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;
                  try {
                    retryNode(request, errorDigest), request$jscomp$1.lastPushedText && request$jscomp$1.textEmbedded && request$jscomp$1.chunks.push(textSeparator), errorDigest.abortSet.delete(errorDigest), request$jscomp$1.status = COMPLETED, finishedSegment(
                      request,
                      errorDigest.blockedBoundary,
                      request$jscomp$1
                    ), finishedTask(
                      request,
                      errorDigest.blockedBoundary,
                      errorDigest.row,
                      request$jscomp$1
                    );
                  } catch (thrownValue) {
                    resetHooksState();
                    request$jscomp$1.children.length = childrenLength;
                    request$jscomp$1.chunks.length = chunkLength;
                    var x$jscomp$0 = thrownValue === SuspenseException ? getSuspendedThenable() : 12 === request.status ? request.fatalError : thrownValue;
                    if (12 === request.status && null !== request.trackedPostpones) {
                      var trackedPostpones = request.trackedPostpones, thrownInfo = getThrownInfo(errorDigest.componentStack);
                      errorDigest.abortSet.delete(errorDigest);
                      logRecoverableError(
                        request,
                        x$jscomp$0,
                        thrownInfo,
                        errorDigest.debugTask
                      );
                      trackPostpone(
                        request,
                        trackedPostpones,
                        errorDigest,
                        request$jscomp$1
                      );
                      finishedTask(
                        request,
                        errorDigest.blockedBoundary,
                        errorDigest.row,
                        request$jscomp$1
                      );
                    } else if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0 && "function" === typeof x$jscomp$0.then) {
                      request$jscomp$1.status = PENDING;
                      errorDigest.thenableState = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
                      var ping$jscomp$0 = errorDigest.ping;
                      x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
                    } else {
                      var errorInfo$jscomp$1 = getThrownInfo(
                        errorDigest.componentStack
                      );
                      errorDigest.abortSet.delete(errorDigest);
                      request$jscomp$1.status = ERRORED;
                      var boundary$jscomp$0 = errorDigest.blockedBoundary, row = errorDigest.row, debugTask = errorDigest.debugTask;
                      null !== row && 0 === --row.pendingTasks && finishSuspenseListRow(request, row);
                      request.allPendingTasks--;
                      prevTaskInDEV = logRecoverableError(
                        request,
                        x$jscomp$0,
                        errorInfo$jscomp$1,
                        debugTask
                      );
                      if (null === boundary$jscomp$0)
                        fatalError(
                          request,
                          x$jscomp$0,
                          errorInfo$jscomp$1,
                          debugTask
                        );
                      else if (boundary$jscomp$0.pendingTasks--, boundary$jscomp$0.status !== CLIENT_RENDERED) {
                        boundary$jscomp$0.status = CLIENT_RENDERED;
                        encodeErrorForBoundary(
                          boundary$jscomp$0,
                          prevTaskInDEV,
                          x$jscomp$0,
                          errorInfo$jscomp$1,
                          false
                        );
                        untrackBoundary(request, boundary$jscomp$0);
                        var boundaryRow = boundary$jscomp$0.row;
                        null !== boundaryRow && 0 === --boundaryRow.pendingTasks && finishSuspenseListRow(request, boundaryRow);
                        boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(boundary$jscomp$0);
                        0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary$jscomp$0.contentPreamble && preparePreamble(request);
                      }
                      0 === request.allPendingTasks && completeAll(request);
                    }
                  } finally {
                    currentTaskInDEV = request$jscomp$0;
                  }
                }
              }
              pingedTasks.splice(0, i);
              null !== request$jscomp$2.destination && flushCompletedQueues(
                request$jscomp$2,
                request$jscomp$2.destination
              );
            } catch (error) {
              pingedTasks = {}, logRecoverableError(request$jscomp$2, error, pingedTasks, null), fatalError(request$jscomp$2, error, pingedTasks, null);
            } finally {
              currentResumableState = prevResumableState, ReactSharedInternals.H = prevDispatcher, ReactSharedInternals.A = prevAsyncDispatcher, ReactSharedInternals.getCurrentStack = prevGetCurrentStackImpl, prevDispatcher === HooksDispatcher && switchContext(prevContext), currentRequest = prevRequest;
            }
          }
        }
        function preparePreambleFromSubtree(request, segment, collectedPreambleSegments) {
          segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);
          for (var pendingPreambles = false, i = 0; i < segment.children.length; i++)
            pendingPreambles = preparePreambleFromSegment(
              request,
              segment.children[i],
              collectedPreambleSegments
            ) || pendingPreambles;
          return pendingPreambles;
        }
        function preparePreambleFromSegment(request, segment, collectedPreambleSegments) {
          var boundary = segment.boundary;
          if (null === boundary)
            return preparePreambleFromSubtree(
              request,
              segment,
              collectedPreambleSegments
            );
          var preamble = boundary.contentPreamble, fallbackPreamble = boundary.fallbackPreamble;
          if (null === preamble || null === fallbackPreamble) return false;
          switch (boundary.status) {
            case COMPLETED:
              hoistPreambleState(request.renderState, preamble);
              request.byteSize += boundary.byteSize;
              segment = boundary.completedSegments[0];
              if (!segment)
                throw Error(
                  "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
                );
              return preparePreambleFromSubtree(
                request,
                segment,
                collectedPreambleSegments
              );
            case POSTPONED:
              if (null !== request.trackedPostpones) return true;
            case CLIENT_RENDERED:
              if (segment.status === COMPLETED)
                return hoistPreambleState(request.renderState, fallbackPreamble), preparePreambleFromSubtree(
                  request,
                  segment,
                  collectedPreambleSegments
                );
            default:
              return true;
          }
        }
        function preparePreamble(request) {
          if (request.completedRootSegment && null === request.completedPreambleSegments) {
            var collectedPreambleSegments = [], originalRequestByteSize = request.byteSize, hasPendingPreambles = preparePreambleFromSegment(
              request,
              request.completedRootSegment,
              collectedPreambleSegments
            ), preamble = request.renderState.preamble;
            false === hasPendingPreambles || preamble.headChunks && preamble.bodyChunks ? request.completedPreambleSegments = collectedPreambleSegments : request.byteSize = originalRequestByteSize;
          }
        }
        function flushSubtree(request, destination, segment, hoistableState) {
          segment.parentFlushed = true;
          switch (segment.status) {
            case PENDING:
              segment.id = request.nextSegmentId++;
            case POSTPONED:
              return hoistableState = segment.id, segment.lastPushedText = false, segment.textEmbedded = false, request = request.renderState, writeChunk(destination, placeholder1), writeChunk(destination, request.placeholderPrefix), request = stringToChunk(hoistableState.toString(16)), writeChunk(destination, request), writeChunkAndReturn(destination, placeholder2);
            case COMPLETED:
              segment.status = FLUSHED;
              var r = true, chunks = segment.chunks, chunkIdx = 0;
              segment = segment.children;
              for (var childIdx = 0; childIdx < segment.length; childIdx++) {
                for (r = segment[childIdx]; chunkIdx < r.index; chunkIdx++)
                  writeChunk(destination, chunks[chunkIdx]);
                r = flushSegment(request, destination, r, hoistableState);
              }
              for (; chunkIdx < chunks.length - 1; chunkIdx++)
                writeChunk(destination, chunks[chunkIdx]);
              chunkIdx < chunks.length && (r = writeChunkAndReturn(destination, chunks[chunkIdx]));
              return r;
            case ABORTED:
              return true;
            default:
              throw Error(
                "Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React."
              );
          }
        }
        function flushSegment(request, destination, segment, hoistableState) {
          var boundary = segment.boundary;
          if (null === boundary)
            return flushSubtree(request, destination, segment, hoistableState);
          boundary.parentFlushed = true;
          if (boundary.status === CLIENT_RENDERED) {
            var row = boundary.row;
            null !== row && 0 === --row.pendingTasks && finishSuspenseListRow(request, row);
            row = boundary.errorDigest;
            var errorMessage = boundary.errorMessage, errorStack = boundary.errorStack;
            boundary = boundary.errorComponentStack;
            writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
            writeChunk(destination, clientRenderedSuspenseBoundaryError1);
            row && (writeChunk(destination, clientRenderedSuspenseBoundaryError1A), writeChunk(destination, stringToChunk(escapeTextForBrowser(row))), writeChunk(
              destination,
              clientRenderedSuspenseBoundaryErrorAttrInterstitial
            ));
            errorMessage && (writeChunk(destination, clientRenderedSuspenseBoundaryError1B), writeChunk(
              destination,
              stringToChunk(escapeTextForBrowser(errorMessage))
            ), writeChunk(
              destination,
              clientRenderedSuspenseBoundaryErrorAttrInterstitial
            ));
            errorStack && (writeChunk(destination, clientRenderedSuspenseBoundaryError1C), writeChunk(
              destination,
              stringToChunk(escapeTextForBrowser(errorStack))
            ), writeChunk(
              destination,
              clientRenderedSuspenseBoundaryErrorAttrInterstitial
            ));
            boundary && (writeChunk(destination, clientRenderedSuspenseBoundaryError1D), writeChunk(
              destination,
              stringToChunk(escapeTextForBrowser(boundary))
            ), writeChunk(
              destination,
              clientRenderedSuspenseBoundaryErrorAttrInterstitial
            ));
            writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
            flushSubtree(request, destination, segment, hoistableState);
          } else if (boundary.status !== COMPLETED)
            boundary.status === PENDING && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
              destination,
              request.renderState,
              boundary.rootSegmentID
            ), hoistableState && hoistHoistables(hoistableState, boundary.fallbackState), flushSubtree(request, destination, segment, hoistableState);
          else if (!flushingPartialBoundaries && isEligibleForOutlining(request, boundary) && (flushedByteSize + boundary.byteSize > request.progressiveChunkSize || hasSuspenseyContent(boundary.contentState)))
            boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
              destination,
              request.renderState,
              boundary.rootSegmentID
            ), flushSubtree(request, destination, segment, hoistableState);
          else {
            flushedByteSize += boundary.byteSize;
            hoistableState && hoistHoistables(hoistableState, boundary.contentState);
            segment = boundary.row;
            null !== segment && isEligibleForOutlining(request, boundary) && 0 === --segment.pendingTasks && finishSuspenseListRow(request, segment);
            writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
            segment = boundary.completedSegments;
            if (1 !== segment.length)
              throw Error(
                "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
              );
            flushSegment(request, destination, segment[0], hoistableState);
          }
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        function flushSegmentContainer(request, destination, segment, hoistableState) {
          writeStartSegment(
            destination,
            request.renderState,
            segment.parentFormatContext,
            segment.id
          );
          flushSegment(request, destination, segment, hoistableState);
          return writeEndSegment(destination, segment.parentFormatContext);
        }
        function flushCompletedBoundary(request, destination, boundary) {
          flushedByteSize = boundary.byteSize;
          for (var completedSegments = boundary.completedSegments, i = 0; i < completedSegments.length; i++)
            flushPartiallyCompletedSegment(
              request,
              destination,
              boundary,
              completedSegments[i]
            );
          completedSegments.length = 0;
          completedSegments = boundary.row;
          null !== completedSegments && isEligibleForOutlining(request, boundary) && 0 === --completedSegments.pendingTasks && finishSuspenseListRow(request, completedSegments);
          writeHoistablesForBoundary(
            destination,
            boundary.contentState,
            request.renderState
          );
          completedSegments = request.resumableState;
          request = request.renderState;
          i = boundary.rootSegmentID;
          boundary = boundary.contentState;
          var requiresStyleInsertion = request.stylesToHoist;
          request.stylesToHoist = false;
          writeChunk(destination, request.startInlineScript);
          writeChunk(destination, endOfStartTag);
          requiresStyleInsertion ? ((completedSegments.instructions & SentClientRenderFunction) === NothingSent && (completedSegments.instructions |= SentClientRenderFunction, writeChunk(destination, clientRenderScriptFunctionOnly)), (completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent && (completedSegments.instructions |= SentCompleteBoundaryFunction, writeChunk(destination, completeBoundaryScriptFunctionOnly)), (completedSegments.instructions & SentStyleInsertionFunction) === NothingSent ? (completedSegments.instructions |= SentStyleInsertionFunction, writeChunk(
            destination,
            completeBoundaryWithStylesScript1FullPartial
          )) : writeChunk(destination, completeBoundaryWithStylesScript1Partial)) : ((completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent && (completedSegments.instructions |= SentCompleteBoundaryFunction, writeChunk(destination, completeBoundaryScriptFunctionOnly)), writeChunk(destination, completeBoundaryScript1Partial));
          completedSegments = stringToChunk(i.toString(16));
          writeChunk(destination, request.boundaryPrefix);
          writeChunk(destination, completedSegments);
          writeChunk(destination, completeBoundaryScript2);
          writeChunk(destination, request.segmentPrefix);
          writeChunk(destination, completedSegments);
          requiresStyleInsertion ? (writeChunk(destination, completeBoundaryScript3a), writeStyleResourceDependenciesInJS(destination, boundary)) : writeChunk(destination, completeBoundaryScript3b);
          boundary = writeChunkAndReturn(destination, completeBoundaryScriptEnd);
          return writeBootstrap(destination, request) && boundary;
        }
        function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
          if (segment.status === FLUSHED) return true;
          var hoistableState = boundary.contentState, segmentID = segment.id;
          if (-1 === segmentID) {
            if (-1 === (segment.id = boundary.rootSegmentID))
              throw Error(
                "A root segment ID must have been assigned by now. This is a bug in React."
              );
            return flushSegmentContainer(
              request,
              destination,
              segment,
              hoistableState
            );
          }
          if (segmentID === boundary.rootSegmentID)
            return flushSegmentContainer(
              request,
              destination,
              segment,
              hoistableState
            );
          flushSegmentContainer(request, destination, segment, hoistableState);
          boundary = request.resumableState;
          request = request.renderState;
          writeChunk(destination, request.startInlineScript);
          writeChunk(destination, endOfStartTag);
          (boundary.instructions & SentCompleteSegmentFunction) === NothingSent ? (boundary.instructions |= SentCompleteSegmentFunction, writeChunk(destination, completeSegmentScript1Full)) : writeChunk(destination, completeSegmentScript1Partial);
          writeChunk(destination, request.segmentPrefix);
          segmentID = stringToChunk(segmentID.toString(16));
          writeChunk(destination, segmentID);
          writeChunk(destination, completeSegmentScript2);
          writeChunk(destination, request.placeholderPrefix);
          writeChunk(destination, segmentID);
          destination = writeChunkAndReturn(destination, completeSegmentScriptEnd);
          return destination;
        }
        function flushCompletedQueues(request, destination) {
          currentView = new Uint8Array(2048);
          writtenBytes = 0;
          try {
            if (!(0 < request.pendingRootTasks)) {
              var i, completedRootSegment = request.completedRootSegment;
              if (null !== completedRootSegment) {
                if (completedRootSegment.status === POSTPONED) return;
                var completedPreambleSegments = request.completedPreambleSegments;
                if (null === completedPreambleSegments) return;
                flushedByteSize = request.byteSize;
                var resumableState = request.resumableState, renderState = request.renderState, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;
                if (htmlChunks) {
                  for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
                    writeChunk(destination, htmlChunks[i$jscomp$0]);
                  if (headChunks)
                    for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                      writeChunk(destination, headChunks[i$jscomp$0]);
                  else
                    writeChunk(destination, startChunkForTag("head")), writeChunk(destination, endOfStartTag);
                } else if (headChunks)
                  for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                    writeChunk(destination, headChunks[i$jscomp$0]);
                var charsetChunks = renderState.charsetChunks;
                for (i$jscomp$0 = 0; i$jscomp$0 < charsetChunks.length; i$jscomp$0++)
                  writeChunk(destination, charsetChunks[i$jscomp$0]);
                charsetChunks.length = 0;
                renderState.preconnects.forEach(flushResource, destination);
                renderState.preconnects.clear();
                var viewportChunks = renderState.viewportChunks;
                for (i$jscomp$0 = 0; i$jscomp$0 < viewportChunks.length; i$jscomp$0++)
                  writeChunk(destination, viewportChunks[i$jscomp$0]);
                viewportChunks.length = 0;
                renderState.fontPreloads.forEach(flushResource, destination);
                renderState.fontPreloads.clear();
                renderState.highImagePreloads.forEach(flushResource, destination);
                renderState.highImagePreloads.clear();
                currentlyFlushingRenderState = renderState;
                renderState.styles.forEach(flushStylesInPreamble, destination);
                currentlyFlushingRenderState = null;
                var importMapChunks = renderState.importMapChunks;
                for (i$jscomp$0 = 0; i$jscomp$0 < importMapChunks.length; i$jscomp$0++)
                  writeChunk(destination, importMapChunks[i$jscomp$0]);
                importMapChunks.length = 0;
                renderState.bootstrapScripts.forEach(flushResource, destination);
                renderState.scripts.forEach(flushResource, destination);
                renderState.scripts.clear();
                renderState.bulkPreloads.forEach(flushResource, destination);
                renderState.bulkPreloads.clear();
                htmlChunks || headChunks || (resumableState.instructions |= SentCompletedShellId);
                var hoistableChunks = renderState.hoistableChunks;
                for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
                  writeChunk(destination, hoistableChunks[i$jscomp$0]);
                for (resumableState = hoistableChunks.length = 0; resumableState < completedPreambleSegments.length; resumableState++) {
                  var segments = completedPreambleSegments[resumableState];
                  for (renderState = 0; renderState < segments.length; renderState++)
                    flushSegment(request, destination, segments[renderState], null);
                }
                var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
                (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) && writeChunk(destination, endChunkForTag("head"));
                var bodyChunks = preamble$jscomp$0.bodyChunks;
                if (bodyChunks)
                  for (completedPreambleSegments = 0; completedPreambleSegments < bodyChunks.length; completedPreambleSegments++)
                    writeChunk(destination, bodyChunks[completedPreambleSegments]);
                flushSegment(request, destination, completedRootSegment, null);
                request.completedRootSegment = null;
                var renderState$jscomp$0 = request.renderState;
                if (0 !== request.allPendingTasks || 0 !== request.clientRenderedBoundaries.length || 0 !== request.completedBoundaries.length || null !== request.trackedPostpones && (0 !== request.trackedPostpones.rootNodes.length || null !== request.trackedPostpones.rootSlots)) {
                  var resumableState$jscomp$0 = request.resumableState;
                  if ((resumableState$jscomp$0.instructions & SentMarkShellTime) === NothingSent) {
                    resumableState$jscomp$0.instructions |= SentMarkShellTime;
                    writeChunk(destination, renderState$jscomp$0.startInlineScript);
                    if ((resumableState$jscomp$0.instructions & SentCompletedShellId) === NothingSent) {
                      resumableState$jscomp$0.instructions |= SentCompletedShellId;
                      var shellId = "_" + resumableState$jscomp$0.idPrefix + "R_";
                      writeChunk(destination, completedShellIdAttributeStart);
                      writeChunk(
                        destination,
                        stringToChunk(escapeTextForBrowser(shellId))
                      );
                      writeChunk(destination, attributeEnd);
                    }
                    writeChunk(destination, endOfStartTag);
                    writeChunk(destination, shellTimeRuntimeScript);
                    writeChunkAndReturn(destination, endInlineScript);
                  }
                }
                writeBootstrap(destination, renderState$jscomp$0);
              }
              var renderState$jscomp$1 = request.renderState;
              completedRootSegment = 0;
              var viewportChunks$jscomp$0 = renderState$jscomp$1.viewportChunks;
              for (completedRootSegment = 0; completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++)
                writeChunk(
                  destination,
                  viewportChunks$jscomp$0[completedRootSegment]
                );
              viewportChunks$jscomp$0.length = 0;
              renderState$jscomp$1.preconnects.forEach(flushResource, destination);
              renderState$jscomp$1.preconnects.clear();
              renderState$jscomp$1.fontPreloads.forEach(flushResource, destination);
              renderState$jscomp$1.fontPreloads.clear();
              renderState$jscomp$1.highImagePreloads.forEach(
                flushResource,
                destination
              );
              renderState$jscomp$1.highImagePreloads.clear();
              renderState$jscomp$1.styles.forEach(preloadLateStyles, destination);
              renderState$jscomp$1.scripts.forEach(flushResource, destination);
              renderState$jscomp$1.scripts.clear();
              renderState$jscomp$1.bulkPreloads.forEach(flushResource, destination);
              renderState$jscomp$1.bulkPreloads.clear();
              var hoistableChunks$jscomp$0 = renderState$jscomp$1.hoistableChunks;
              for (completedRootSegment = 0; completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++)
                writeChunk(
                  destination,
                  hoistableChunks$jscomp$0[completedRootSegment]
                );
              hoistableChunks$jscomp$0.length = 0;
              var clientRenderedBoundaries = request.clientRenderedBoundaries;
              for (i = 0; i < clientRenderedBoundaries.length; i++) {
                var boundary = clientRenderedBoundaries[i];
                renderState$jscomp$1 = destination;
                var resumableState$jscomp$1 = request.resumableState, renderState$jscomp$2 = request.renderState, id = boundary.rootSegmentID, errorDigest = boundary.errorDigest, errorMessage = boundary.errorMessage, errorStack = boundary.errorStack, errorComponentStack = boundary.errorComponentStack;
                writeChunk(
                  renderState$jscomp$1,
                  renderState$jscomp$2.startInlineScript
                );
                writeChunk(renderState$jscomp$1, endOfStartTag);
                (resumableState$jscomp$1.instructions & SentClientRenderFunction) === NothingSent ? (resumableState$jscomp$1.instructions |= SentClientRenderFunction, writeChunk(renderState$jscomp$1, clientRenderScript1Full)) : writeChunk(renderState$jscomp$1, clientRenderScript1Partial);
                writeChunk(
                  renderState$jscomp$1,
                  renderState$jscomp$2.boundaryPrefix
                );
                writeChunk(renderState$jscomp$1, stringToChunk(id.toString(16)));
                writeChunk(renderState$jscomp$1, clientRenderScript1A);
                if (errorDigest || errorMessage || errorStack || errorComponentStack)
                  writeChunk(
                    renderState$jscomp$1,
                    clientRenderErrorScriptArgInterstitial
                  ), writeChunk(
                    renderState$jscomp$1,
                    stringToChunk(
                      escapeJSStringsForInstructionScripts(errorDigest || "")
                    )
                  );
                if (errorMessage || errorStack || errorComponentStack)
                  writeChunk(
                    renderState$jscomp$1,
                    clientRenderErrorScriptArgInterstitial
                  ), writeChunk(
                    renderState$jscomp$1,
                    stringToChunk(
                      escapeJSStringsForInstructionScripts(errorMessage || "")
                    )
                  );
                if (errorStack || errorComponentStack)
                  writeChunk(
                    renderState$jscomp$1,
                    clientRenderErrorScriptArgInterstitial
                  ), writeChunk(
                    renderState$jscomp$1,
                    stringToChunk(
                      escapeJSStringsForInstructionScripts(errorStack || "")
                    )
                  );
                errorComponentStack && (writeChunk(
                  renderState$jscomp$1,
                  clientRenderErrorScriptArgInterstitial
                ), writeChunk(
                  renderState$jscomp$1,
                  stringToChunk(
                    escapeJSStringsForInstructionScripts(errorComponentStack)
                  )
                ));
                var JSCompiler_inline_result = writeChunkAndReturn(
                  renderState$jscomp$1,
                  clientRenderScriptEnd
                );
                if (!JSCompiler_inline_result) {
                  request.destination = null;
                  i++;
                  clientRenderedBoundaries.splice(0, i);
                  return;
                }
              }
              clientRenderedBoundaries.splice(0, i);
              var completedBoundaries = request.completedBoundaries;
              for (i = 0; i < completedBoundaries.length; i++)
                if (!flushCompletedBoundary(
                  request,
                  destination,
                  completedBoundaries[i]
                )) {
                  request.destination = null;
                  i++;
                  completedBoundaries.splice(0, i);
                  return;
                }
              completedBoundaries.splice(0, i);
              completeWriting(destination);
              currentView = new Uint8Array(2048);
              writtenBytes = 0;
              flushingPartialBoundaries = true;
              var partialBoundaries = request.partialBoundaries;
              for (i = 0; i < partialBoundaries.length; i++) {
                a: {
                  clientRenderedBoundaries = request;
                  boundary = destination;
                  var boundary$jscomp$0 = partialBoundaries[i];
                  flushedByteSize = boundary$jscomp$0.byteSize;
                  var completedSegments = boundary$jscomp$0.completedSegments;
                  for (JSCompiler_inline_result = 0; JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++)
                    if (!flushPartiallyCompletedSegment(
                      clientRenderedBoundaries,
                      boundary,
                      boundary$jscomp$0,
                      completedSegments[JSCompiler_inline_result]
                    )) {
                      JSCompiler_inline_result++;
                      completedSegments.splice(0, JSCompiler_inline_result);
                      var JSCompiler_inline_result$jscomp$0 = false;
                      break a;
                    }
                  completedSegments.splice(0, JSCompiler_inline_result);
                  var row = boundary$jscomp$0.row;
                  null !== row && row.together && 1 === boundary$jscomp$0.pendingTasks && (1 === row.pendingTasks ? unblockSuspenseListRow(
                    clientRenderedBoundaries,
                    row,
                    row.hoistables
                  ) : row.pendingTasks--);
                  JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(
                    boundary,
                    boundary$jscomp$0.contentState,
                    clientRenderedBoundaries.renderState
                  );
                }
                if (!JSCompiler_inline_result$jscomp$0) {
                  request.destination = null;
                  i++;
                  partialBoundaries.splice(0, i);
                  return;
                }
              }
              partialBoundaries.splice(0, i);
              flushingPartialBoundaries = false;
              var largeBoundaries = request.completedBoundaries;
              for (i = 0; i < largeBoundaries.length; i++)
                if (!flushCompletedBoundary(request, destination, largeBoundaries[i])) {
                  request.destination = null;
                  i++;
                  largeBoundaries.splice(0, i);
                  return;
                }
              largeBoundaries.splice(0, i);
            }
          } finally {
            flushingPartialBoundaries = false, 0 === request.allPendingTasks && 0 === request.clientRenderedBoundaries.length && 0 === request.completedBoundaries.length ? (request.flushScheduled = false, i = request.resumableState, i.hasBody && writeChunk(destination, endChunkForTag("body")), i.hasHtml && writeChunk(destination, endChunkForTag("html")), completeWriting(destination), 0 !== request.abortableTasks.size && console.error(
              "There was still abortable task at the root when we closed. This is a bug in React."
            ), request.status = CLOSED, destination.close(), request.destination = null) : completeWriting(destination);
          }
        }
        function startWork(request) {
          request.flushScheduled = null !== request.destination;
          scheduleMicrotask(function() {
            return performWork(request);
          });
          scheduleWork(function() {
            10 === request.status && (request.status = 11);
            null === request.trackedPostpones && safelyEmitEarlyPreloads(request, 0 === request.pendingRootTasks);
          });
        }
        function enqueueFlush(request) {
          false === request.flushScheduled && 0 === request.pingedTasks.length && null !== request.destination && (request.flushScheduled = true, scheduleWork(function() {
            var destination = request.destination;
            destination ? flushCompletedQueues(request, destination) : request.flushScheduled = false;
          }));
        }
        function startFlowing(request, destination) {
          if (13 === request.status)
            request.status = CLOSED, closeWithError(destination, request.fatalError);
          else if (request.status !== CLOSED && null === request.destination) {
            request.destination = destination;
            try {
              flushCompletedQueues(request, destination);
            } catch (error) {
              destination = {}, logRecoverableError(request, error, destination, null), fatalError(request, error, destination, null);
            }
          }
        }
        function abort(request, reason) {
          if (11 === request.status || 10 === request.status) request.status = 12;
          try {
            var abortableTasks = request.abortableTasks;
            if (0 < abortableTasks.size) {
              var error = void 0 === reason ? Error("The render was aborted by the server without a reason.") : "object" === typeof reason && null !== reason && "function" === typeof reason.then ? Error("The render was aborted by the server with a promise.") : reason;
              request.fatalError = error;
              abortableTasks.forEach(function(task) {
                var prevTaskInDEV = currentTaskInDEV, prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;
                currentTaskInDEV = task;
                ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;
                try {
                  abortTask(task, request, error);
                } finally {
                  currentTaskInDEV = prevTaskInDEV, ReactSharedInternals.getCurrentStack = prevGetCurrentStackImpl;
                }
              });
              abortableTasks.clear();
            }
            null !== request.destination && flushCompletedQueues(request, request.destination);
          } catch (error$4) {
            reason = {}, logRecoverableError(request, error$4, reason, null), fatalError(request, error$4, reason, null);
          }
        }
        function addToReplayParent(node, parentKeyPath, trackedPostpones) {
          if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);
          else {
            var workingMap = trackedPostpones.workingMap, parentNode = workingMap.get(parentKeyPath);
            void 0 === parentNode && (parentNode = [parentKeyPath[1], parentKeyPath[2], [], null], workingMap.set(parentKeyPath, parentNode), addToReplayParent(parentNode, parentKeyPath[0], trackedPostpones));
            parentNode[2].push(node);
          }
        }
        function getPostponedState(request) {
          var trackedPostpones = request.trackedPostpones;
          if (null === trackedPostpones || 0 === trackedPostpones.rootNodes.length && null === trackedPostpones.rootSlots)
            return request.trackedPostpones = null;
          if (null === request.completedRootSegment || request.completedRootSegment.status !== POSTPONED && null !== request.completedPreambleSegments) {
            var nextSegmentId = request.nextSegmentId;
            var replaySlots = trackedPostpones.rootSlots;
            var resumableState = request.resumableState;
            resumableState.bootstrapScriptContent = void 0;
            resumableState.bootstrapScripts = void 0;
            resumableState.bootstrapModules = void 0;
          } else {
            nextSegmentId = 0;
            replaySlots = -1;
            resumableState = request.resumableState;
            var renderState = request.renderState;
            resumableState.nextFormID = 0;
            resumableState.hasBody = false;
            resumableState.hasHtml = false;
            resumableState.unknownResources = { font: renderState.resets.font };
            resumableState.dnsResources = renderState.resets.dns;
            resumableState.connectResources = renderState.resets.connect;
            resumableState.imageResources = renderState.resets.image;
            resumableState.styleResources = renderState.resets.style;
            resumableState.scriptResources = {};
            resumableState.moduleUnknownResources = {};
            resumableState.moduleScriptResources = {};
            resumableState.instructions = NothingSent;
          }
          return {
            nextSegmentId,
            rootFormatContext: request.rootFormatContext,
            progressiveChunkSize: request.progressiveChunkSize,
            resumableState: request.resumableState,
            replayNodes: trackedPostpones.rootNodes,
            replaySlots
          };
        }
        function ensureCorrectIsomorphicReactVersion() {
          var isomorphicReactPackageVersion = React9.version;
          if ("19.2.0" !== isomorphicReactPackageVersion)
            throw Error(
              'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' + (isomorphicReactPackageVersion + "\n  - react-dom:  19.2.0\nLearn more: https://react.dev/warnings/version-mismatch")
            );
        }
        var React9 = require_react(), ReactDOM2 = require_react_dom(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_SCOPE_TYPE = Symbol.for("react.scope"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"), REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, isArrayImpl = Array.isArray, jsxPropsParents = /* @__PURE__ */ new WeakMap(), jsxChildrenParents = /* @__PURE__ */ new WeakMap(), CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"), channel = new MessageChannel(), taskQueue = [];
        channel.port1.onmessage = function() {
          var task = taskQueue.shift();
          task && task();
        };
        var LocalPromise = Promise, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : function(callback) {
          LocalPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
        }, currentView = null, writtenBytes = 0, textEncoder = new TextEncoder(), assign2 = Object.assign, hasOwnProperty = Object.prototype.hasOwnProperty, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
          "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, unitlessNumbers = new Set(
          "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
            " "
          )
        ), aliases = /* @__PURE__ */ new Map([
          ["acceptCharset", "accept-charset"],
          ["htmlFor", "for"],
          ["httpEquiv", "http-equiv"],
          ["crossOrigin", "crossorigin"],
          ["accentHeight", "accent-height"],
          ["alignmentBaseline", "alignment-baseline"],
          ["arabicForm", "arabic-form"],
          ["baselineShift", "baseline-shift"],
          ["capHeight", "cap-height"],
          ["clipPath", "clip-path"],
          ["clipRule", "clip-rule"],
          ["colorInterpolation", "color-interpolation"],
          ["colorInterpolationFilters", "color-interpolation-filters"],
          ["colorProfile", "color-profile"],
          ["colorRendering", "color-rendering"],
          ["dominantBaseline", "dominant-baseline"],
          ["enableBackground", "enable-background"],
          ["fillOpacity", "fill-opacity"],
          ["fillRule", "fill-rule"],
          ["floodColor", "flood-color"],
          ["floodOpacity", "flood-opacity"],
          ["fontFamily", "font-family"],
          ["fontSize", "font-size"],
          ["fontSizeAdjust", "font-size-adjust"],
          ["fontStretch", "font-stretch"],
          ["fontStyle", "font-style"],
          ["fontVariant", "font-variant"],
          ["fontWeight", "font-weight"],
          ["glyphName", "glyph-name"],
          ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
          ["glyphOrientationVertical", "glyph-orientation-vertical"],
          ["horizAdvX", "horiz-adv-x"],
          ["horizOriginX", "horiz-origin-x"],
          ["imageRendering", "image-rendering"],
          ["letterSpacing", "letter-spacing"],
          ["lightingColor", "lighting-color"],
          ["markerEnd", "marker-end"],
          ["markerMid", "marker-mid"],
          ["markerStart", "marker-start"],
          ["overlinePosition", "overline-position"],
          ["overlineThickness", "overline-thickness"],
          ["paintOrder", "paint-order"],
          ["panose-1", "panose-1"],
          ["pointerEvents", "pointer-events"],
          ["renderingIntent", "rendering-intent"],
          ["shapeRendering", "shape-rendering"],
          ["stopColor", "stop-color"],
          ["stopOpacity", "stop-opacity"],
          ["strikethroughPosition", "strikethrough-position"],
          ["strikethroughThickness", "strikethrough-thickness"],
          ["strokeDasharray", "stroke-dasharray"],
          ["strokeDashoffset", "stroke-dashoffset"],
          ["strokeLinecap", "stroke-linecap"],
          ["strokeLinejoin", "stroke-linejoin"],
          ["strokeMiterlimit", "stroke-miterlimit"],
          ["strokeOpacity", "stroke-opacity"],
          ["strokeWidth", "stroke-width"],
          ["textAnchor", "text-anchor"],
          ["textDecoration", "text-decoration"],
          ["textRendering", "text-rendering"],
          ["transformOrigin", "transform-origin"],
          ["underlinePosition", "underline-position"],
          ["underlineThickness", "underline-thickness"],
          ["unicodeBidi", "unicode-bidi"],
          ["unicodeRange", "unicode-range"],
          ["unitsPerEm", "units-per-em"],
          ["vAlphabetic", "v-alphabetic"],
          ["vHanging", "v-hanging"],
          ["vIdeographic", "v-ideographic"],
          ["vMathematical", "v-mathematical"],
          ["vectorEffect", "vector-effect"],
          ["vertAdvY", "vert-adv-y"],
          ["vertOriginX", "vert-origin-x"],
          ["vertOriginY", "vert-origin-y"],
          ["wordSpacing", "word-spacing"],
          ["writingMode", "writing-mode"],
          ["xmlnsXlink", "xmlns:xlink"],
          ["xHeight", "x-height"]
        ]), hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        }, ariaProperties = {
          "aria-current": 0,
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0,
          "aria-braillelabel": 0,
          "aria-brailleroledescription": 0,
          "aria-colindextext": 0,
          "aria-rowindextext": 0
        }, warnedProperties$1 = {}, rARIA$1 = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel$1 = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), didWarnValueNull = false, possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          fetchpriority: "fetchPriority",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          inert: "inert",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          popover: "popover",
          popovertarget: "popoverTarget",
          popovertargetaction: "popoverTargetAction",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          transformorigin: "transformOrigin",
          "transform-origin": "transformOrigin",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        }, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern$1 = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, matchHtmlRegExp = /["'&<>]/, uppercasePattern = /([A-Z])/g, msPattern = /^ms-/, isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, ReactSharedInternals = React9.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
          pending: false,
          data: null,
          method: null,
          action: null
        }), previousDispatcher = ReactDOMSharedInternals.d;
        ReactDOMSharedInternals.d = {
          f: previousDispatcher.f,
          r: previousDispatcher.r,
          D: function(href) {
            var request = currentRequest ? currentRequest : null;
            if (request) {
              var resumableState = request.resumableState, renderState = request.renderState;
              if ("string" === typeof href && href) {
                if (!resumableState.dnsResources.hasOwnProperty(href)) {
                  resumableState.dnsResources[href] = EXISTS;
                  resumableState = renderState.headers;
                  var header, JSCompiler_temp;
                  if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity)
                    JSCompiler_temp = (header = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=dns-prefetch", 0 <= (resumableState.remainingCapacity -= header.length + 2));
                  JSCompiler_temp ? (renderState.resets.dns[href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (header = [], pushLinkImpl(header, { href, rel: "dns-prefetch" }), renderState.preconnects.add(header));
                }
                enqueueFlush(request);
              }
            } else previousDispatcher.D(href);
          },
          C: function(href, crossOrigin) {
            var request = currentRequest ? currentRequest : null;
            if (request) {
              var resumableState = request.resumableState, renderState = request.renderState;
              if ("string" === typeof href && href) {
                var bucket = "use-credentials" === crossOrigin ? "credentials" : "string" === typeof crossOrigin ? "anonymous" : "default";
                if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {
                  resumableState.connectResources[bucket][href] = EXISTS;
                  resumableState = renderState.headers;
                  var header, JSCompiler_temp;
                  if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {
                    JSCompiler_temp = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=preconnect";
                    if ("string" === typeof crossOrigin) {
                      var escapedCrossOrigin = escapeStringForLinkHeaderQuotedParamValueContext(
                        crossOrigin,
                        "crossOrigin"
                      );
                      JSCompiler_temp += '; crossorigin="' + escapedCrossOrigin + '"';
                    }
                    JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));
                  }
                  JSCompiler_temp ? (renderState.resets.connect[bucket][href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (bucket = [], pushLinkImpl(bucket, {
                    rel: "preconnect",
                    href,
                    crossOrigin
                  }), renderState.preconnects.add(bucket));
                }
                enqueueFlush(request);
              }
            } else previousDispatcher.C(href, crossOrigin);
          },
          L: function(href, as, options) {
            var request = currentRequest ? currentRequest : null;
            if (request) {
              var resumableState = request.resumableState, renderState = request.renderState;
              if (as && href) {
                switch (as) {
                  case "image":
                    if (options) {
                      var imageSrcSet = options.imageSrcSet;
                      var imageSizes = options.imageSizes;
                      var fetchPriority = options.fetchPriority;
                    }
                    var key = imageSrcSet ? imageSrcSet + "\n" + (imageSizes || "") : href;
                    if (resumableState.imageResources.hasOwnProperty(key)) return;
                    resumableState.imageResources[key] = PRELOAD_NO_CREDS;
                    resumableState = renderState.headers;
                    var header;
                    resumableState && 0 < resumableState.remainingCapacity && "string" !== typeof imageSrcSet && "high" === fetchPriority && (header = getPreloadAsHeader(href, as, options), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS, resumableState.highImagePreloads && (resumableState.highImagePreloads += ", "), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl(
                      resumableState,
                      assign2(
                        {
                          rel: "preload",
                          href: imageSrcSet ? void 0 : href,
                          as
                        },
                        options
                      )
                    ), "high" === fetchPriority ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));
                    break;
                  case "style":
                    if (resumableState.styleResources.hasOwnProperty(href)) return;
                    imageSrcSet = [];
                    pushLinkImpl(
                      imageSrcSet,
                      assign2({ rel: "preload", href, as }, options)
                    );
                    resumableState.styleResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
                    renderState.preloads.stylesheets.set(href, imageSrcSet);
                    renderState.bulkPreloads.add(imageSrcSet);
                    break;
                  case "script":
                    if (resumableState.scriptResources.hasOwnProperty(href)) return;
                    imageSrcSet = [];
                    renderState.preloads.scripts.set(href, imageSrcSet);
                    renderState.bulkPreloads.add(imageSrcSet);
                    pushLinkImpl(
                      imageSrcSet,
                      assign2({ rel: "preload", href, as }, options)
                    );
                    resumableState.scriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
                    break;
                  default:
                    if (resumableState.unknownResources.hasOwnProperty(as)) {
                      if (imageSrcSet = resumableState.unknownResources[as], imageSrcSet.hasOwnProperty(href))
                        return;
                    } else
                      imageSrcSet = {}, resumableState.unknownResources[as] = imageSrcSet;
                    imageSrcSet[href] = PRELOAD_NO_CREDS;
                    if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && "font" === as && (key = getPreloadAsHeader(href, as, options), 0 <= (resumableState.remainingCapacity -= key.length + 2)))
                      renderState.resets.font[href] = PRELOAD_NO_CREDS, resumableState.fontPreloads && (resumableState.fontPreloads += ", "), resumableState.fontPreloads += key;
                    else
                      switch (resumableState = [], href = assign2(
                        { rel: "preload", href, as },
                        options
                      ), pushLinkImpl(resumableState, href), as) {
                        case "font":
                          renderState.fontPreloads.add(resumableState);
                          break;
                        default:
                          renderState.bulkPreloads.add(resumableState);
                      }
                }
                enqueueFlush(request);
              }
            } else previousDispatcher.L(href, as, options);
          },
          m: function(href, options) {
            var request = currentRequest ? currentRequest : null;
            if (request) {
              var resumableState = request.resumableState, renderState = request.renderState;
              if (href) {
                var as = options && "string" === typeof options.as ? options.as : "script";
                switch (as) {
                  case "script":
                    if (resumableState.moduleScriptResources.hasOwnProperty(href))
                      return;
                    as = [];
                    resumableState.moduleScriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
                    renderState.preloads.moduleScripts.set(href, as);
                    break;
                  default:
                    if (resumableState.moduleUnknownResources.hasOwnProperty(as)) {
                      var resources = resumableState.unknownResources[as];
                      if (resources.hasOwnProperty(href)) return;
                    } else
                      resources = {}, resumableState.moduleUnknownResources[as] = resources;
                    as = [];
                    resources[href] = PRELOAD_NO_CREDS;
                }
                pushLinkImpl(
                  as,
                  assign2({ rel: "modulepreload", href }, options)
                );
                renderState.bulkPreloads.add(as);
                enqueueFlush(request);
              }
            } else previousDispatcher.m(href, options);
          },
          X: function(src, options) {
            var request = currentRequest ? currentRequest : null;
            if (request) {
              var resumableState = request.resumableState, renderState = request.renderState;
              if (src) {
                var resourceState = resumableState.scriptResources.hasOwnProperty(
                  src
                ) ? resumableState.scriptResources[src] : void 0;
                resourceState !== EXISTS && (resumableState.scriptResources[src] = EXISTS, options = assign2({ src, async: true }, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
              }
            } else previousDispatcher.X(src, options);
          },
          S: function(href, precedence, options) {
            var request = currentRequest ? currentRequest : null;
            if (request) {
              var resumableState = request.resumableState, renderState = request.renderState;
              if (href) {
                precedence = precedence || "default";
                var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
                resourceState !== EXISTS && (resumableState.styleResources[href] = EXISTS, styleQueue || (styleQueue = {
                  precedence: stringToChunk(escapeTextForBrowser(precedence)),
                  rules: [],
                  hrefs: [],
                  sheets: /* @__PURE__ */ new Map()
                }, renderState.styles.set(precedence, styleQueue)), precedence = {
                  state: PENDING$1,
                  props: assign2(
                    {
                      rel: "stylesheet",
                      href,
                      "data-precedence": precedence
                    },
                    options
                  )
                }, resourceState && (2 === resourceState.length && adoptPreloadCredentials(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = PRELOADED), styleQueue.sheets.set(href, precedence), enqueueFlush(request));
              }
            } else previousDispatcher.S(href, precedence, options);
          },
          M: function(src, options) {
            var request = currentRequest ? currentRequest : null;
            if (request) {
              var resumableState = request.resumableState, renderState = request.renderState;
              if (src) {
                var resourceState = resumableState.moduleScriptResources.hasOwnProperty(src) ? resumableState.moduleScriptResources[src] : void 0;
                resourceState !== EXISTS && (resumableState.moduleScriptResources[src] = EXISTS, options = assign2(
                  { src, type: "module", async: true },
                  options
                ), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
              }
            } else previousDispatcher.M(src, options);
          }
        };
        var NothingSent = 0, SentCompleteSegmentFunction = 1, SentCompleteBoundaryFunction = 2, SentClientRenderFunction = 4, SentStyleInsertionFunction = 8, SentCompletedShellId = 32, SentMarkShellTime = 64, EXISTS = null, PRELOAD_NO_CREDS = [];
        Object.freeze(PRELOAD_NO_CREDS);
        var currentlyFlushingRenderState = null;
        stringToPrecomputedChunk('"></template>');
        var startInlineScript = stringToPrecomputedChunk("<script"), endInlineScript = stringToPrecomputedChunk("<\/script>"), startScriptSrc = stringToPrecomputedChunk('<script src="'), startModuleSrc = stringToPrecomputedChunk('<script type="module" src="'), scriptNonce = stringToPrecomputedChunk(' nonce="'), scriptIntegirty = stringToPrecomputedChunk(' integrity="'), scriptCrossOrigin = stringToPrecomputedChunk(' crossorigin="'), endAsyncScript = stringToPrecomputedChunk(' async=""><\/script>'), startInlineStyle = stringToPrecomputedChunk("<style"), scriptRegex = /(<\/|<)(s)(cript)/gi, importMapScriptStart = stringToPrecomputedChunk(
          '<script type="importmap">'
        ), importMapScriptEnd = stringToPrecomputedChunk("<\/script>");
        var didWarnForNewBooleanPropsWithEmptyValue = {};
        var ROOT_HTML_MODE = 0, HTML_HTML_MODE = 1, HTML_MODE = 2, HTML_HEAD_MODE = 3, SVG_MODE = 4, MATHML_MODE = 5, HTML_TABLE_MODE = 6, HTML_TABLE_BODY_MODE = 7, HTML_TABLE_ROW_MODE = 8, HTML_COLGROUP_MODE = 9, textSeparator = stringToPrecomputedChunk("<!-- -->"), styleNameCache = /* @__PURE__ */ new Map(), styleAttributeStart = stringToPrecomputedChunk(' style="'), styleAssign = stringToPrecomputedChunk(":"), styleSeparator = stringToPrecomputedChunk(";"), attributeSeparator = stringToPrecomputedChunk(" "), attributeAssign = stringToPrecomputedChunk('="'), attributeEnd = stringToPrecomputedChunk('"'), attributeEmptyString = stringToPrecomputedChunk('=""'), actionJavaScriptURL = stringToPrecomputedChunk(
          escapeTextForBrowser(
            "javascript:throw new Error('React form unexpectedly submitted.')"
          )
        ), startHiddenInputChunk = stringToPrecomputedChunk('<input type="hidden"'), endOfStartTag = stringToPrecomputedChunk(">"), endOfStartTagSelfClosing = stringToPrecomputedChunk("/>"), didWarnDefaultInputValue = false, didWarnDefaultChecked = false, didWarnDefaultSelectValue = false, didWarnDefaultTextareaValue = false, didWarnInvalidOptionChildren = false, didWarnInvalidOptionInnerHTML = false, didWarnSelectedSetOnOption = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""'), formReplayingRuntimeScript = stringToPrecomputedChunk(
          `addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error('React form unexpectedly submitted.')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});`
        ), formStateMarkerIsMatching = stringToPrecomputedChunk("<!--F!-->"), formStateMarkerIsNotMatching = stringToPrecomputedChunk("<!--F-->"), styleRegex = /(<\/|<)(s)(tyle)/gi, headPreambleContributionChunk = stringToPrecomputedChunk("<!--head-->"), bodyPreambleContributionChunk = stringToPrecomputedChunk("<!--body-->"), htmlPreambleContributionChunk = stringToPrecomputedChunk("<!--html-->"), leadingNewline = stringToPrecomputedChunk("\n"), VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache = /* @__PURE__ */ new Map(), doctypeChunk = stringToPrecomputedChunk("<!DOCTYPE html>"), endTagCache = /* @__PURE__ */ new Map(), shellTimeRuntimeScript = stringToPrecomputedChunk(
          "requestAnimationFrame(function(){$RT=performance.now()});"
        ), placeholder1 = stringToPrecomputedChunk('<template id="'), placeholder2 = stringToPrecomputedChunk('"></template>'), startActivityBoundary = stringToPrecomputedChunk("<!--&-->"), endActivityBoundary = stringToPrecomputedChunk("<!--/&-->"), startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->"), startPendingSuspenseBoundary1 = stringToPrecomputedChunk(
          '<!--$?--><template id="'
        ), startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>'), startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->"), endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->"), clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template"), clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"'), clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="'), clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="'), clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="'), clientRenderedSuspenseBoundaryError1D = stringToPrecomputedChunk(' data-cstck="'), clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>"), startSegmentHTML = stringToPrecomputedChunk('<div hidden id="'), startSegmentHTML2 = stringToPrecomputedChunk('">'), endSegmentHTML = stringToPrecomputedChunk("</div>"), startSegmentSVG = stringToPrecomputedChunk(
          '<svg aria-hidden="true" style="display:none" id="'
        ), startSegmentSVG2 = stringToPrecomputedChunk('">'), endSegmentSVG = stringToPrecomputedChunk("</svg>"), startSegmentMathML = stringToPrecomputedChunk(
          '<math aria-hidden="true" style="display:none" id="'
        ), startSegmentMathML2 = stringToPrecomputedChunk('">'), endSegmentMathML = stringToPrecomputedChunk("</math>"), startSegmentTable = stringToPrecomputedChunk('<table hidden id="'), startSegmentTable2 = stringToPrecomputedChunk('">'), endSegmentTable = stringToPrecomputedChunk("</table>"), startSegmentTableBody = stringToPrecomputedChunk(
          '<table hidden><tbody id="'
        ), startSegmentTableBody2 = stringToPrecomputedChunk('">'), endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>"), startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="'), startSegmentTableRow2 = stringToPrecomputedChunk('">'), endSegmentTableRow = stringToPrecomputedChunk("</tr></table>"), startSegmentColGroup = stringToPrecomputedChunk(
          '<table hidden><colgroup id="'
        ), startSegmentColGroup2 = stringToPrecomputedChunk('">'), endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>"), completeSegmentScript1Full = stringToPrecomputedChunk(
          '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'
        ), completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("'), completeSegmentScript2 = stringToPrecomputedChunk('","'), completeSegmentScriptEnd = stringToPrecomputedChunk('")<\/script>');
        stringToPrecomputedChunk('<template data-rsi="" data-sid="');
        stringToPrecomputedChunk('" data-pid="');
        var completeBoundaryScriptFunctionOnly = stringToPrecomputedChunk(
          '$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};\n$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};'
        );
        stringToChunk(
          `$RV=function(A,g){function k(a,b){var e=a.getAttribute(b);e&&(b=a.style,l.push(a,b.viewTransitionName,b.viewTransitionClass),"auto"!==e&&(b.viewTransitionClass=e),(a=a.getAttribute("vt-name"))||(a="_T_"+K++ +"_"),b.viewTransitionName=a,B=!0)}var B=!1,K=0,l=[];try{var f=document.__reactViewTransition;if(f){f.finished.finally($RV.bind(null,g));return}var m=new Map;for(f=1;f<g.length;f+=2)for(var h=g[f].querySelectorAll("[vt-share]"),d=0;d<h.length;d++){var c=h[d];m.set(c.getAttribute("vt-name"),c)}var u=[];for(h=0;h<g.length;h+=2){var C=g[h],x=C.parentNode;if(x){var v=x.getBoundingClientRect();if(v.left||v.top||v.width||v.height){c=C;for(f=0;c;){if(8===c.nodeType){var r=c.data;if("/$"===r)if(0===f)break;else f--;else"$"!==r&&"$?"!==r&&"$~"!==r&&"$!"!==r||f++}else if(1===c.nodeType){d=c;var D=d.getAttribute("vt-name"),y=m.get(D);k(d,y?"vt-share":"vt-exit");y&&(k(y,"vt-share"),m.set(D,null));var E=d.querySelectorAll("[vt-share]");for(d=0;d<E.length;d++){var F=E[d],G=F.getAttribute("vt-name"),
H=m.get(G);H&&(k(F,"vt-share"),k(H,"vt-share"),m.set(G,null))}}c=c.nextSibling}for(var I=g[h+1],t=I.firstElementChild;t;)null!==m.get(t.getAttribute("vt-name"))&&k(t,"vt-enter"),t=t.nextElementSibling;c=x;do for(var n=c.firstElementChild;n;){var J=n.getAttribute("vt-update");J&&"none"!==J&&!l.includes(n)&&k(n,"vt-update");n=n.nextElementSibling}while((c=c.parentNode)&&1===c.nodeType&&"none"!==c.getAttribute("vt-update"));u.push.apply(u,I.querySelectorAll('img[src]:not([loading="lazy"])'))}}}if(B){var z=
document.__reactViewTransition=document.startViewTransition({update:function(){A(g);for(var a=[document.documentElement.clientHeight,document.fonts.ready],b={},e=0;e<u.length;b={g:b.g},e++)if(b.g=u[e],!b.g.complete){var p=b.g.getBoundingClientRect();0<p.bottom&&0<p.right&&p.top<window.innerHeight&&p.left<window.innerWidth&&(p=new Promise(function(w){return function(q){w.g.addEventListener("load",q);w.g.addEventListener("error",q)}}(b)),a.push(p))}return Promise.race([Promise.all(a),new Promise(function(w){var q=
performance.now();setTimeout(w,2300>q&&2E3<q?2300-q:500)})])},types:[]});z.ready.finally(function(){for(var a=l.length-3;0<=a;a-=3){var b=l[a],e=b.style;e.viewTransitionName=l[a+1];e.viewTransitionClass=l[a+1];""===b.getAttribute("style")&&b.removeAttribute("style")}});z.finished.finally(function(){document.__reactViewTransition===z&&(document.__reactViewTransition=null)});$RB=[];return}}catch(a){}A(g)}.bind(null,$RV);`
        );
        var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("'), completeBoundaryWithStylesScript1FullPartial = stringToPrecomputedChunk(
          '$RM=new Map;$RR=function(n,w,p){function u(q){this._p=null;q()}for(var r=new Map,t=document,h,b,e=t.querySelectorAll("link[data-precedence],style[data-precedence]"),v=[],k=0;b=e[k++];)"not all"===b.getAttribute("media")?v.push(b):("LINK"===b.tagName&&$RM.set(b.getAttribute("href"),b),r.set(b.dataset.precedence,h=b));e=0;b=[];var l,a;for(k=!0;;){if(k){var f=p[e++];if(!f){k=!1;e=0;continue}var c=!1,m=0;var d=f[m++];if(a=$RM.get(d)){var g=a._p;c=!0}else{a=t.createElement("link");a.href=d;a.rel=\n"stylesheet";for(a.dataset.precedence=l=f[m++];g=f[m++];)a.setAttribute(g,f[m++]);g=a._p=new Promise(function(q,x){a.onload=u.bind(a,q);a.onerror=u.bind(a,x)});$RM.set(d,a)}d=a.getAttribute("media");!g||d&&!matchMedia(d).matches||b.push(g);if(c)continue}else{a=v[e++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=r.get(l)||h;c===h&&(h=a);r.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=t.head,c.insertBefore(a,c.firstChild))}if(p=document.getElementById(n))p.previousSibling.data=\n"$~";Promise.all(b).then($RC.bind(null,n,w),$RX.bind(null,n,"CSS failed to load"))};$RR("'
        ), completeBoundaryWithStylesScript1Partial = stringToPrecomputedChunk('$RR("'), completeBoundaryScript2 = stringToPrecomputedChunk('","'), completeBoundaryScript3a = stringToPrecomputedChunk('",'), completeBoundaryScript3b = stringToPrecomputedChunk('"'), completeBoundaryScriptEnd = stringToPrecomputedChunk(")<\/script>");
        stringToPrecomputedChunk('<template data-rci="" data-bid="');
        stringToPrecomputedChunk('<template data-rri="" data-bid="');
        stringToPrecomputedChunk('" data-sid="');
        stringToPrecomputedChunk('" data-sty="');
        var clientRenderScriptFunctionOnly = stringToPrecomputedChunk(
          '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};'
        ), clientRenderScript1Full = stringToPrecomputedChunk(
          '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("'
        ), clientRenderScript1Partial = stringToPrecomputedChunk('$RX("'), clientRenderScript1A = stringToPrecomputedChunk('"'), clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(","), clientRenderScriptEnd = stringToPrecomputedChunk(")<\/script>");
        stringToPrecomputedChunk('<template data-rxi="" data-bid="');
        stringToPrecomputedChunk('" data-dgst="');
        stringToPrecomputedChunk('" data-msg="');
        stringToPrecomputedChunk('" data-stck="');
        stringToPrecomputedChunk('" data-cstck="');
        var regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g, regexForJSStringsInScripts = /[&><\u2028\u2029]/g, lateStyleTagResourceOpen1 = stringToPrecomputedChunk(
          ' media="not all" data-precedence="'
        ), lateStyleTagResourceOpen2 = stringToPrecomputedChunk('" data-href="'), lateStyleTagResourceOpen3 = stringToPrecomputedChunk('">'), lateStyleTagTemplateClose = stringToPrecomputedChunk("</style>"), currentlyRenderingBoundaryHasStylesToHoist = false, destinationHasCapacity = true, stylesheetFlushingQueue = [], styleTagResourceOpen1 = stringToPrecomputedChunk(' data-precedence="'), styleTagResourceOpen2 = stringToPrecomputedChunk('" data-href="'), spaceSeparator = stringToPrecomputedChunk(" "), styleTagResourceOpen3 = stringToPrecomputedChunk('">'), styleTagResourceClose = stringToPrecomputedChunk("</style>");
        stringToPrecomputedChunk('<link rel="expect" href="#');
        stringToPrecomputedChunk('" blocking="render"/>');
        var completedShellIdAttributeStart = stringToPrecomputedChunk(' id="'), arrayFirstOpenBracket = stringToPrecomputedChunk("["), arraySubsequentOpenBracket = stringToPrecomputedChunk(",["), arrayInterstitial = stringToPrecomputedChunk(","), arrayCloseBracket = stringToPrecomputedChunk("]"), PENDING$1 = 0, PRELOADED = 1, PREAMBLE = 2, LATE = 3, regexForHrefInLinkHeaderURLContext = /[<>\r\n]/g, regexForLinkHeaderQuotedParamValueContext = /["';,\r\n]/g, bind = Function.prototype.bind, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), emptyContextObject = {};
        Object.freeze(emptyContextObject);
        var rendererSigil = {};
        var currentActiveSnapshot = null, didWarnAboutNoopUpdateForComponent = {}, didWarnAboutDeprecatedWillMount = {};
        var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
        var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
        var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
        var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
        var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        var classComponentUpdater = {
          enqueueSetState: function(inst, payload, callback) {
            var internals = inst._reactInternals;
            null === internals.queue ? warnNoop(inst, "setState") : (internals.queue.push(payload), void 0 !== callback && null !== callback && warnOnInvalidCallback(callback));
          },
          enqueueReplaceState: function(inst, payload, callback) {
            inst = inst._reactInternals;
            inst.replace = true;
            inst.queue = [payload];
            void 0 !== callback && null !== callback && warnOnInvalidCallback(callback);
          },
          enqueueForceUpdate: function(inst, callback) {
            null === inst._reactInternals.queue ? warnNoop(inst, "forceUpdate") : void 0 !== callback && null !== callback && warnOnInvalidCallback(callback);
          }
        }, emptyTreeContext = { id: 1, overflow: "" }, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2, SuspenseException = Error(
          "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
        ), suspendedThenable = null, objectIs = "function" === typeof Object.is ? Object.is : is, currentlyRenderingComponent = null, currentlyRenderingTask = null, currentlyRenderingRequest = null, currentlyRenderingKeyPath = null, firstWorkInProgressHook = null, workInProgressHook = null, isReRender = false, didScheduleRenderPhaseUpdate = false, localIdCounter = 0, actionStateCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, thenableState = null, renderPhaseUpdates = null, numberOfReRenders = 0, isInHookUserCodeInDev = false, currentHookNameInDev, HooksDispatcher = {
          readContext,
          use: function(usable) {
            if (null !== usable && "object" === typeof usable) {
              if ("function" === typeof usable.then)
                return unwrapThenable(usable);
              if (usable.$$typeof === REACT_CONTEXT_TYPE)
                return readContext(usable);
            }
            throw Error(
              "An unsupported type was passed to use(): " + String(usable)
            );
          },
          useContext: function(context2) {
            currentHookNameInDev = "useContext";
            resolveCurrentlyRenderingComponent();
            return context2._currentValue;
          },
          useMemo: useMemo3,
          useReducer: useReducer3,
          useRef: function(initialValue) {
            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
            workInProgressHook = createWorkInProgressHook();
            var previousRef = workInProgressHook.memoizedState;
            return null === previousRef ? (initialValue = { current: initialValue }, Object.seal(initialValue), workInProgressHook.memoizedState = initialValue) : previousRef;
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            return useReducer3(basicStateReducer, initialState);
          },
          useInsertionEffect: noop,
          useLayoutEffect: noop,
          useCallback: function(callback, deps) {
            return useMemo3(function() {
              return callback;
            }, deps);
          },
          useImperativeHandle: noop,
          useEffect: noop,
          useDebugValue: noop,
          useDeferredValue: function(value, initialValue) {
            resolveCurrentlyRenderingComponent();
            return void 0 !== initialValue ? initialValue : value;
          },
          useTransition: function() {
            resolveCurrentlyRenderingComponent();
            return [false, unsupportedStartTransition];
          },
          useId: function() {
            var treeId = currentlyRenderingTask.treeContext;
            var overflow = treeId.overflow;
            treeId = treeId.id;
            treeId = (treeId & ~(1 << 32 - clz32(treeId) - 1)).toString(32) + overflow;
            var resumableState = currentResumableState;
            if (null === resumableState)
              throw Error(
                "Invalid hook call. Hooks can only be called inside of the body of a function component."
              );
            overflow = localIdCounter++;
            treeId = "_" + resumableState.idPrefix + "R_" + treeId;
            0 < overflow && (treeId += "H" + overflow.toString(32));
            return treeId + "_";
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            if (void 0 === getServerSnapshot)
              throw Error(
                "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
              );
            return getServerSnapshot();
          },
          useOptimistic: function(passthrough) {
            resolveCurrentlyRenderingComponent();
            return [passthrough, unsupportedSetOptimisticState];
          },
          useActionState,
          useFormState: useActionState,
          useHostTransitionStatus: function() {
            resolveCurrentlyRenderingComponent();
            return NotPending;
          },
          useMemoCache: function(size) {
            for (var data = Array(size), i = 0; i < size; i++)
              data[i] = REACT_MEMO_CACHE_SENTINEL;
            return data;
          },
          useCacheRefresh: function() {
            return unsupportedRefresh;
          },
          useEffectEvent: function() {
            return throwOnUseEffectEventCall;
          }
        }, currentResumableState = null, currentTaskInDEV = null, DefaultAsyncDispatcher = {
          getCacheForType: function() {
            throw Error("Not implemented.");
          },
          cacheSignal: function() {
            throw Error("Not implemented.");
          },
          getOwner: function() {
            return null === currentTaskInDEV ? null : currentTaskInDEV.componentStack;
          }
        }, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
        disabledLog.__reactDisabledLog = true;
        var prefix, suffix, reentry = false;
        var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
        var callComponent = {
          react_stack_bottom_frame: function(Component, props, secondArg) {
            return Component(props, secondArg);
          }
        }, callComponentInDEV = callComponent.react_stack_bottom_frame.bind(callComponent), callRender = {
          react_stack_bottom_frame: function(instance) {
            return instance.render();
          }
        }, callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender), callLazyInit = {
          react_stack_bottom_frame: function(lazy) {
            var init = lazy._init;
            return init(lazy._payload);
          }
        }, callLazyInitInDEV = callLazyInit.react_stack_bottom_frame.bind(callLazyInit), lastResetTime = 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          var getCurrentTime = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          getCurrentTime = function() {
            return localDate.now();
          };
        }
        var CLIENT_RENDERED = 4, PENDING = 0, COMPLETED = 1, FLUSHED = 2, ABORTED = 3, ERRORED = 4, POSTPONED = 5, CLOSED = 14, currentRequest = null, didWarnAboutBadClass = {}, didWarnAboutContextTypes = {}, didWarnAboutContextTypeOnFunctionComponent = {}, didWarnAboutGetDerivedStateOnFunctionComponent = {}, didWarnAboutReassigningProps = false, didWarnAboutGenerators = false, didWarnAboutMaps = false, flushedByteSize = 0, flushingPartialBoundaries = false;
        ensureCorrectIsomorphicReactVersion();
        ensureCorrectIsomorphicReactVersion();
        exports2.prerender = function(children, options) {
          return new Promise(function(resolve, reject2) {
            var onHeaders = options ? options.onHeaders : void 0, onHeadersImpl;
            onHeaders && (onHeadersImpl = function(headersDescriptor) {
              onHeaders(new Headers(headersDescriptor));
            });
            var resources = createResumableState(
              options ? options.identifierPrefix : void 0,
              options ? options.unstable_externalRuntimeSrc : void 0,
              options ? options.bootstrapScriptContent : void 0,
              options ? options.bootstrapScripts : void 0,
              options ? options.bootstrapModules : void 0
            ), request = createPrerenderRequest(
              children,
              resources,
              createRenderState(
                resources,
                void 0,
                options ? options.unstable_externalRuntimeSrc : void 0,
                options ? options.importMap : void 0,
                onHeadersImpl,
                options ? options.maxHeadersLength : void 0
              ),
              createRootFormatContext(options ? options.namespaceURI : void 0),
              options ? options.progressiveChunkSize : void 0,
              options ? options.onError : void 0,
              function() {
                var stream = new ReadableStream(
                  {
                    type: "bytes",
                    pull: function(controller) {
                      startFlowing(request, controller);
                    },
                    cancel: function(reason) {
                      request.destination = null;
                      abort(request, reason);
                    }
                  },
                  { highWaterMark: 0 }
                );
                stream = {
                  postponed: getPostponedState(request),
                  prelude: stream
                };
                resolve(stream);
              },
              void 0,
              void 0,
              reject2,
              options ? options.onPostpone : void 0
            );
            if (options && options.signal) {
              var signal = options.signal;
              if (signal.aborted) abort(request, signal.reason);
              else {
                var listener = function() {
                  abort(request, signal.reason);
                  signal.removeEventListener("abort", listener);
                };
                signal.addEventListener("abort", listener);
              }
            }
            startWork(request);
          });
        };
        exports2.renderToReadableStream = function(children, options) {
          return new Promise(function(resolve, reject2) {
            var onFatalError, onAllReady, allReady = new Promise(function(res, rej) {
              onAllReady = res;
              onFatalError = rej;
            }), onHeaders = options ? options.onHeaders : void 0, onHeadersImpl;
            onHeaders && (onHeadersImpl = function(headersDescriptor) {
              onHeaders(new Headers(headersDescriptor));
            });
            var resumableState = createResumableState(
              options ? options.identifierPrefix : void 0,
              options ? options.unstable_externalRuntimeSrc : void 0,
              options ? options.bootstrapScriptContent : void 0,
              options ? options.bootstrapScripts : void 0,
              options ? options.bootstrapModules : void 0
            ), request = createRequest(
              children,
              resumableState,
              createRenderState(
                resumableState,
                options ? options.nonce : void 0,
                options ? options.unstable_externalRuntimeSrc : void 0,
                options ? options.importMap : void 0,
                onHeadersImpl,
                options ? options.maxHeadersLength : void 0
              ),
              createRootFormatContext(options ? options.namespaceURI : void 0),
              options ? options.progressiveChunkSize : void 0,
              options ? options.onError : void 0,
              onAllReady,
              function() {
                var stream = new ReadableStream(
                  {
                    type: "bytes",
                    pull: function(controller) {
                      startFlowing(request, controller);
                    },
                    cancel: function(reason) {
                      request.destination = null;
                      abort(request, reason);
                    }
                  },
                  { highWaterMark: 0 }
                );
                stream.allReady = allReady;
                resolve(stream);
              },
              function(error) {
                allReady.catch(function() {
                });
                reject2(error);
              },
              onFatalError,
              options ? options.onPostpone : void 0,
              options ? options.formState : void 0
            );
            if (options && options.signal) {
              var signal = options.signal;
              if (signal.aborted) abort(request, signal.reason);
              else {
                var listener = function() {
                  abort(request, signal.reason);
                  signal.removeEventListener("abort", listener);
                };
                signal.addEventListener("abort", listener);
              }
            }
            startWork(request);
          });
        };
        exports2.resume = function(children, postponedState, options) {
          return new Promise(function(resolve, reject2) {
            var onFatalError, onAllReady, allReady = new Promise(function(res, rej) {
              onAllReady = res;
              onFatalError = rej;
            }), request = resumeRequest(
              children,
              postponedState,
              createRenderState(
                postponedState.resumableState,
                options ? options.nonce : void 0,
                void 0,
                void 0,
                void 0,
                void 0
              ),
              options ? options.onError : void 0,
              onAllReady,
              function() {
                var stream = new ReadableStream(
                  {
                    type: "bytes",
                    pull: function(controller) {
                      startFlowing(request, controller);
                    },
                    cancel: function(reason) {
                      request.destination = null;
                      abort(request, reason);
                    }
                  },
                  { highWaterMark: 0 }
                );
                stream.allReady = allReady;
                resolve(stream);
              },
              function(error) {
                allReady.catch(function() {
                });
                reject2(error);
              },
              onFatalError,
              options ? options.onPostpone : void 0
            );
            if (options && options.signal) {
              var signal = options.signal;
              if (signal.aborted) abort(request, signal.reason);
              else {
                var listener = function() {
                  abort(request, signal.reason);
                  signal.removeEventListener("abort", listener);
                };
                signal.addEventListener("abort", listener);
              }
            }
            startWork(request);
          });
        };
        exports2.resumeAndPrerender = function(children, postponedState, options) {
          return new Promise(function(resolve, reject2) {
            var request = resumeAndPrerenderRequest(
              children,
              postponedState,
              createRenderState(
                postponedState.resumableState,
                void 0,
                void 0,
                void 0,
                void 0,
                void 0
              ),
              options ? options.onError : void 0,
              function() {
                var stream = new ReadableStream(
                  {
                    type: "bytes",
                    pull: function(controller) {
                      startFlowing(request, controller);
                    },
                    cancel: function(reason) {
                      request.destination = null;
                      abort(request, reason);
                    }
                  },
                  { highWaterMark: 0 }
                );
                stream = { postponed: getPostponedState(request), prelude: stream };
                resolve(stream);
              },
              void 0,
              void 0,
              reject2,
              options ? options.onPostpone : void 0
            );
            if (options && options.signal) {
              var signal = options.signal;
              if (signal.aborted) abort(request, signal.reason);
              else {
                var listener = function() {
                  abort(request, signal.reason);
                  signal.removeEventListener("abort", listener);
                };
                signal.addEventListener("abort", listener);
              }
            }
            startWork(request);
          });
        };
        exports2.version = "19.2.0";
      })();
    }
  });

  // node_modules/react-dom/server.browser.js
  var require_server_browser = __commonJS({
    "node_modules/react-dom/server.browser.js"(exports2) {
      "use strict";
      var l;
      var s;
      if (false) {
        l = null;
        s = null;
      } else {
        l = require_react_dom_server_legacy_browser_development();
        s = require_react_dom_server_browser_development();
      }
      exports2.version = l.version;
      exports2.renderToString = l.renderToString;
      exports2.renderToStaticMarkup = l.renderToStaticMarkup;
      exports2.renderToReadableStream = s.renderToReadableStream;
      exports2.resume = s.resume;
    }
  });

  // node_modules/classnames/index.js
  var require_classnames = __commonJS({
    "node_modules/classnames/index.js"(exports2, module2) {
      (function() {
        "use strict";
        var hasOwn = {}.hasOwnProperty;
        function classNames2() {
          var classes = "";
          for (var i = 0; i < arguments.length; i++) {
            var arg = arguments[i];
            if (arg) {
              classes = appendClass(classes, parseValue(arg));
            }
          }
          return classes;
        }
        function parseValue(arg) {
          if (typeof arg === "string" || typeof arg === "number") {
            return arg;
          }
          if (typeof arg !== "object") {
            return "";
          }
          if (Array.isArray(arg)) {
            return classNames2.apply(null, arg);
          }
          if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
            return arg.toString();
          }
          var classes = "";
          for (var key in arg) {
            if (hasOwn.call(arg, key) && arg[key]) {
              classes = appendClass(classes, key);
            }
          }
          return classes;
        }
        function appendClass(value, newClass) {
          if (!newClass) {
            return value;
          }
          if (value) {
            return value + " " + newClass;
          }
          return value + newClass;
        }
        if (typeof module2 !== "undefined" && module2.exports) {
          classNames2.default = classNames2;
          module2.exports = classNames2;
        } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
          define("classnames", [], function() {
            return classNames2;
          });
        } else {
          window.classNames = classNames2;
        }
      })();
    }
  });

  // node_modules/fast-formula-parser/grammar/type/collection.js
  var require_collection = __commonJS({
    "node_modules/fast-formula-parser/grammar/type/collection.js"(exports2, module2) {
      var Collection = class {
        constructor(data, refs) {
          if (data == null && refs == null) {
            this._data = [];
            this._refs = [];
          } else {
            if (data.length !== refs.length)
              throw Error("Collection: data length should match references length.");
            this._data = data;
            this._refs = refs;
          }
        }
        get data() {
          return this._data;
        }
        get refs() {
          return this._refs;
        }
        get length() {
          return this._data.length;
        }
        /**
         * Add data and references to this collection.
         * @param {{}} obj - data
         * @param {{}} ref - reference
         */
        add(obj, ref) {
          this._data.push(obj);
          this._refs.push(ref);
        }
      };
      module2.exports = Collection;
    }
  });

  // node_modules/fast-formula-parser/formulas/helpers.js
  var require_helpers = __commonJS({
    "node_modules/fast-formula-parser/formulas/helpers.js"(exports2, module2) {
      var FormulaError2 = require_error();
      var Collection = require_collection();
      var Types = {
        NUMBER: 0,
        ARRAY: 1,
        BOOLEAN: 2,
        STRING: 3,
        RANGE_REF: 4,
        // can be 'A:C' or '1:4', not only 'A1:C3'
        CELL_REF: 5,
        COLLECTIONS: 6,
        // Unions of references
        NUMBER_NO_BOOLEAN: 10
      };
      var Factorials = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800, 87178291200, 1307674368e3, 20922789888e3, 355687428096e3, 6402373705728e3, 121645100408832e3, 243290200817664e4, 5109094217170944e4, 11240007277776077e5, 2585201673888498e7, 6204484017332394e8, 15511210043330986e9, 40329146112660565e10, 10888869450418352e12, 30488834461171387e13, 8841761993739702e15, 26525285981219107e16, 8222838654177922e18, 2631308369336935e20, 8683317618811886e21, 29523279903960416e22, 10333147966386145e24, 37199332678990125e25, 13763753091226346e27, 5230226174666011e29, 20397882081197444e30, 8159152832478977e32, 3345252661316381e34, 140500611775288e37, 6041526306337383e37, 2658271574788449e39, 11962222086548019e40, 5502622159812089e42, 25862324151116818e43, 12413915592536073e45, 6082818640342675e47, 30414093201713376e48, 15511187532873822e50, 8065817517094388e52, 42748832840600255e53, 2308436973392414e56, 12696403353658276e57, 7109985878048635e59, 40526919504877214e60, 23505613312828785e62, 13868311854568984e64, 832098711274139e67, 5075802138772248e68, 3146997326038794e70, 198260831540444e73, 12688693218588417e73, 8247650592082472e75, 5443449390774431e77, 3647111091818868e79, 24800355424368305e80, 1711224524281413e83, 11978571669969892e84, 8504785885678623e86, 61234458376886085e87, 44701154615126844e89, 3307885441519386e92, 248091408113954e95, 18854947016660504e95, 14518309202828587e97, 11324281178206297e99, 8946182130782976e101, 7156945704626381e103, 5797126020747368e105, 4753643337012842e107, 3945523969720659e109, 3314240134565353e111, 281710411438055e114, 24227095383672734e114, 2107757298379528e117, 18548264225739844e118, 1650795516090846e121, 14857159644817615e122, 1352001527678403e125, 12438414054641308e126, 11567725070816416e128, 1087366156656743e131, 1032997848823906e133, 9916779348709496e134, 9619275968248212e136, 9426890448883248e138, 9332621544394415e140, 9332621544394415e142];
      var ReversedTypes = {};
      Object.keys(Types).forEach((key) => {
        ReversedTypes[Types[key]] = key;
      });
      var FormulaHelpers = class {
        constructor() {
          this.Types = Types;
          this.type2Number = {
            number: Types.NUMBER,
            boolean: Types.BOOLEAN,
            string: Types.STRING,
            object: -1
          };
        }
        checkFunctionResult(result) {
          const type = typeof result;
          if (type === "number") {
            if (isNaN(result)) {
              return FormulaError2.VALUE;
            } else if (!isFinite(result)) {
              return FormulaError2.NUM;
            }
          }
          if (result === void 0 || result === null)
            return FormulaError2.NULL;
          return result;
        }
        /**
         * Flatten an array
         * @param {Array} arr1
         * @returns {*}
         */
        flattenDeep(arr1) {
          return arr1.reduce((acc, val) => Array.isArray(val) ? acc.concat(this.flattenDeep(val)) : acc.concat(val), []);
        }
        /**
         *
         * @param obj
         * @param isArray - if it is an array: [1,2,3], will extract the first element
         * @param allowBoolean - Allow parse boolean into number
         * @returns {number|FormulaError}
         */
        acceptNumber(obj, isArray2 = true, allowBoolean = true) {
          if (obj instanceof FormulaError2)
            return obj;
          let number;
          if (typeof obj === "number")
            number = obj;
          else if (typeof obj === "boolean") {
            if (allowBoolean) {
              number = Number(obj);
            } else {
              throw FormulaError2.VALUE;
            }
          } else if (typeof obj === "string") {
            if (obj.length === 0) {
              throw FormulaError2.VALUE;
            }
            number = Number(obj);
            if (number !== number) {
              throw FormulaError2.VALUE;
            }
          } else if (Array.isArray(obj)) {
            if (!isArray2) {
              if (obj[0].length === 1) {
                number = this.acceptNumber(obj[0][0]);
              } else {
                throw FormulaError2.VALUE;
              }
            } else {
              number = this.acceptNumber(obj[0][0]);
            }
          } else {
            throw Error("Unknown type in FormulaHelpers.acceptNumber");
          }
          return number;
        }
        /**
         * Flatten parameters to 1D array.
         * @see {@link FormulaHelpers.accept}
         * @param {Array} params - Parameter that needs to flatten.
         * @param {Types|null} valueType - The type each item should be,
         *                          null if allows any type. This only applies to literals.
         * @param {boolean} allowUnion - Allow union, e.g. (A1:C1, E4:F3)
         * @param {function} hook - Invoked after parsing each item.
         *                         of the array.
         * @param {*} [defValue=null] - The value if an param is omitted. i.e. SUM(1,2,,,,,)
         * @param {number} [minSize=1] - The minimum size of the parameters
         */
        flattenParams(params, valueType, allowUnion, hook, defValue = null, minSize = 1) {
          if (params.length < minSize)
            throw FormulaError2.ARG_MISSING([valueType]);
          if (defValue == null) {
            defValue = valueType === Types.NUMBER ? 0 : valueType == null ? null : "";
          }
          params.forEach((param) => {
            const { isCellRef, isRangeRef, isArray: isArray2 } = param;
            const isUnion = param.value instanceof Collection;
            const isLiteral = !isCellRef && !isRangeRef && !isArray2 && !isUnion;
            const info = { isLiteral, isCellRef, isRangeRef, isArray: isArray2, isUnion };
            if (isLiteral) {
              if (param.omitted)
                param = defValue;
              else
                param = this.accept(param, valueType, defValue);
              hook(param, info);
            } else if (isCellRef) {
              hook(param.value, info);
            } else if (isUnion) {
              if (!allowUnion) throw FormulaError2.VALUE;
              param = param.value.data;
              param = this.flattenDeep(param);
              param.forEach((item) => {
                hook(item, info);
              });
            } else if (isRangeRef || isArray2) {
              param = this.flattenDeep(param.value);
              param.forEach((item) => {
                hook(item, info);
              });
            }
          });
        }
        /**
         * Check if the param valid, return the parsed param.
         * If type is not given, return the un-parsed param.
         * @param {*} param
         * @param {number|null} [type] - The expected type
         *           NUMBER: Expect a single number,
         *           ARRAY: Expect an flatten array,
         *           BOOLEAN: Expect a single boolean,
         *           STRING: Expect a single string,
         *           COLLECTIONS: Expect an Array of the above types
         *           null: Do not parse the value, return it directly.
         *           The collection is not a flatted array.
         * @param {*} [defValue] - Default value if the param is not given.
         *               if undefined, this param is required, a Error will throw if not given.
         *               if null, and param is undefined, null will be returned.
         * @param {boolean} [flat=true] - If the array should be flattened,
         *                      only applicable when type is ARRAY.
         *                      If false, collection is disallowed.
         * @param {boolean} allowSingleValue - If pack single value into 2d array,
         *                     only applicable when type is ARRAY.
         * @return {string|number|boolean|{}|Array}
         */
        accept(param, type = null, defValue, flat = true, allowSingleValue = false) {
          if (Array.isArray(type))
            type = type[0];
          if (param == null && defValue === void 0) {
            throw FormulaError2.ARG_MISSING([type]);
          } else if (param == null)
            return defValue;
          if (typeof param !== "object" || Array.isArray(param))
            return param;
          const isArray2 = param.isArray;
          if (param.value != null) param = param.value;
          if (type == null)
            return param;
          if (param instanceof FormulaError2)
            throw param;
          if (type === Types.ARRAY) {
            if (Array.isArray(param)) {
              return flat ? this.flattenDeep(param) : param;
            } else if (param instanceof Collection) {
              throw FormulaError2.VALUE;
            } else if (allowSingleValue) {
              return flat ? [param] : [[param]];
            }
            throw FormulaError2.VALUE;
          } else if (type === Types.COLLECTIONS) {
            return param;
          }
          if (isArray2) {
            param = param[0][0];
          }
          const paramType = this.type(param);
          if (type === Types.STRING) {
            if (paramType === Types.BOOLEAN)
              param = param ? "TRUE" : "FALSE";
            else
              param = `${param}`;
          } else if (type === Types.BOOLEAN) {
            if (paramType === Types.STRING)
              throw FormulaError2.VALUE;
            if (paramType === Types.NUMBER)
              param = Boolean(param);
          } else if (type === Types.NUMBER) {
            param = this.acceptNumber(param, false);
          } else if (type === Types.NUMBER_NO_BOOLEAN) {
            param = this.acceptNumber(param, false, false);
          } else {
            throw FormulaError2.VALUE;
          }
          return param;
        }
        type(variable) {
          let type = this.type2Number[typeof variable];
          if (type === -1) {
            if (Array.isArray(variable))
              type = Types.ARRAY;
            else if (variable.ref) {
              if (variable.ref.from) {
                type = Types.RANGE_REF;
              } else {
                type = Types.CELL_REF;
              }
            } else if (variable instanceof Collection)
              type = Types.COLLECTIONS;
          }
          return type;
        }
        isRangeRef(param) {
          return param.ref && param.ref.from;
        }
        isCellRef(param) {
          return param.ref && !param.ref.from;
        }
        /**
         * Helper function for SUMIF, AVERAGEIF,...
         * @param context
         * @param range1
         * @param range2
         */
        retrieveRanges(context2, range1, range2) {
          range2 = Address.extend(range1, range2);
          range1 = this.retrieveArg(context2, range1);
          range1 = H.accept(range1, Types.ARRAY, void 0, false, true);
          if (range2 !== range1) {
            range2 = this.retrieveArg(context2, range2);
            range2 = H.accept(range2, Types.ARRAY, void 0, false, true);
          } else
            range2 = range1;
          return [range1, range2];
        }
        retrieveArg(context2, arg) {
          if (arg === null)
            return { value: 0, isArray: false, omitted: true };
          const res = context2.utils.extractRefValue(arg);
          return { value: res.val, isArray: res.isArray, ref: arg.ref };
        }
      };
      var H = new FormulaHelpers();
      var WildCard = {
        /**
         * @param {string|*} obj
         * @returns {*}
         */
        isWildCard: (obj) => {
          if (typeof obj === "string")
            return /[*?]/.test(obj);
          return false;
        },
        toRegex: (lookupText, flags) => {
          return RegExp(lookupText.replace(/[.+^${}()|[\]\\]/g, "\\$&").replace(/([^~]??)[?]/g, "$1.").replace(/([^~]??)[*]/g, "$1.*").replace(/~([?*])/g, "$1"), flags);
        }
      };
      var Criteria = {
        /**
         * Parse criteria, support comparison and wild card match.
         * @param {string|number} criteria
         * @return {{op: string, value: string|number|boolean|RegExp, match: boolean|undefined}} - The parsed criteria.
         */
        parse: (criteria) => {
          const type = typeof criteria;
          if (type === "string") {
            const upper = criteria.toUpperCase();
            if (upper === "TRUE" || upper === "FALSE") {
              return { op: "=", value: upper === "TRUE" };
            }
            const res = criteria.match(/(<>|>=|<=|>|<|=)(.*)/);
            if (res) {
              let op = res[1], value;
              if (isNaN(res[2])) {
                const upper2 = res[2].toUpperCase();
                if (upper2 === "TRUE" || upper2 === "FALSE") {
                  value = upper2 === "TRUE";
                } else if (/#NULL!|#DIV\/0!|#VALUE!|#NAME\?|#NUM!|#N\/A|#REF!/.test(res[2])) {
                  value = new FormulaError2(res[2]);
                } else {
                  value = res[2];
                  if (WildCard.isWildCard(value)) {
                    return { op: "wc", value: WildCard.toRegex(value), match: op === "=" };
                  }
                }
              } else {
                value = Number(res[2]);
              }
              return { op, value };
            } else if (WildCard.isWildCard(criteria)) {
              return { op: "wc", value: WildCard.toRegex(criteria), match: true };
            } else {
              return { op: "=", value: criteria };
            }
          } else if (type === "boolean" || type === "number" || (Array.isArray(criteria) || criteria instanceof FormulaError2)) {
            return { op: "=", value: criteria };
          } else {
            throw Error(`Criteria.parse: type ${typeof criteria} not support`);
          }
        }
      };
      var Address = {
        columnNumberToName: (number) => {
          let dividend = number;
          let name = "";
          let modulo = 0;
          while (dividend > 0) {
            modulo = (dividend - 1) % 26;
            name = String.fromCharCode("A".charCodeAt(0) + modulo) + name;
            dividend = Math.floor((dividend - modulo) / 26);
          }
          return name;
        },
        columnNameToNumber: (columnName) => {
          columnName = columnName.toUpperCase();
          const len = columnName.length;
          let number = 0;
          for (let i = 0; i < len; i++) {
            const code = columnName.charCodeAt(i);
            if (!isNaN(code)) {
              number += (code - 64) * 26 ** (len - i - 1);
            }
          }
          return number;
        },
        /**
         * Extend range2 to match with the dimension in range1.
         * @param {{ref: {}}} range1
         * @param {{ref: {}}} [range2]
         */
        extend: (range1, range2) => {
          if (range2 == null) {
            return range1;
          }
          let rowOffset, colOffset;
          if (H.isCellRef(range1)) {
            rowOffset = 0;
            colOffset = 0;
          } else if (H.isRangeRef(range1)) {
            rowOffset = range1.ref.to.row - range1.ref.from.row;
            colOffset = range1.ref.to.col - range1.ref.from.col;
          } else throw Error("Address.extend should not reach here.");
          if (H.isCellRef(range2)) {
            if (rowOffset > 0 || colOffset > 0)
              range2 = {
                ref: {
                  from: { col: range2.ref.col, row: range2.ref.row },
                  to: { row: range2.ref.row + rowOffset, col: range2.ref.col + colOffset }
                }
              };
          } else {
            range2.ref.to.row = range2.ref.from.row + rowOffset;
            range2.ref.to.col = range2.ref.from.col + colOffset;
          }
          return range2;
        }
      };
      module2.exports = {
        FormulaHelpers: H,
        Types,
        ReversedTypes,
        Factorials,
        WildCard,
        Criteria,
        Address
      };
    }
  });

  // node_modules/fast-formula-parser/formulas/error.js
  var require_error = __commonJS({
    "node_modules/fast-formula-parser/formulas/error.js"(exports2, module2) {
      var FormulaError2 = class _FormulaError extends Error {
        /**
         * @param {string} error - error code, i.e. #NUM!
         * @param {string} [msg] - detailed error message
         * @param {object|Error} [details]
         * @returns {FormulaError}
         */
        constructor(error, msg, details) {
          super(msg);
          if (msg == null && details == null && _FormulaError.errorMap.has(error))
            return _FormulaError.errorMap.get(error);
          else if (msg == null && details == null) {
            this._error = error;
            _FormulaError.errorMap.set(error, this);
          } else {
            this._error = error;
          }
          this.details = details;
        }
        /**
         * Get the error name.
         * @returns {string} formula error
         */
        get error() {
          return this._error;
        }
        get name() {
          return this._error;
        }
        /**
         * Return true if two errors are same.
         * @param {FormulaError} err
         * @returns {boolean} if two errors are same.
         */
        equals(err) {
          return err instanceof _FormulaError && err._error === this._error;
        }
        /**
         * Return the formula error in string representation.
         * @returns {string} the formula error in string representation.
         */
        toString() {
          return this._error;
        }
      };
      FormulaError2.errorMap = /* @__PURE__ */ new Map();
      FormulaError2.DIV0 = new FormulaError2("#DIV/0!");
      FormulaError2.NA = new FormulaError2("#N/A");
      FormulaError2.NAME = new FormulaError2("#NAME?");
      FormulaError2.NULL = new FormulaError2("#NULL!");
      FormulaError2.NUM = new FormulaError2("#NUM!");
      FormulaError2.REF = new FormulaError2("#REF!");
      FormulaError2.VALUE = new FormulaError2("#VALUE!");
      FormulaError2.NOT_IMPLEMENTED = (functionName) => {
        return new FormulaError2("#NAME?", `Function ${functionName} is not implemented.`);
      };
      FormulaError2.TOO_MANY_ARGS = (functionName) => {
        return new FormulaError2("#N/A", `Function ${functionName} has too many arguments.`);
      };
      FormulaError2.ARG_MISSING = (args) => {
        const { Types } = require_helpers();
        return new FormulaError2("#N/A", `Argument type ${args.map((arg) => Types[arg]).join(", ")} is missing.`);
      };
      FormulaError2.ERROR = (msg, details) => {
        return new FormulaError2("#ERROR!", msg, details);
      };
      module2.exports = FormulaError2;
    }
  });

  // node_modules/fast-formula-parser/ssf/ssf.js
  var require_ssf = __commonJS({
    "node_modules/fast-formula-parser/ssf/ssf.js"(exports2, module2) {
      var SSF = class {
      };
      SSF.version = "0.10.3";
      function _strrev(x) {
        let o = "", i = x.length - 1;
        while (i >= 0) o += x.charAt(i--);
        return o;
      }
      function fill(c, l) {
        let o = "";
        while (o.length < l) o += c;
        return o;
      }
      function pad0(v, d) {
        let t = "" + v;
        return t.length >= d ? t : fill("0", d - t.length) + t;
      }
      function pad_(v, d) {
        let t = "" + v;
        return t.length >= d ? t : fill(" ", d - t.length) + t;
      }
      function rpad_(v, d) {
        let t = "" + v;
        return t.length >= d ? t : t + fill(" ", d - t.length);
      }
      function pad0r1(v, d) {
        let t = "" + Math.round(v);
        return t.length >= d ? t : fill("0", d - t.length) + t;
      }
      function pad0r2(v, d) {
        let t = "" + v;
        return t.length >= d ? t : fill("0", d - t.length) + t;
      }
      var p2_32 = Math.pow(2, 32);
      function pad0r(v, d) {
        if (v > p2_32 || v < -p2_32) return pad0r1(v, d);
        const i = Math.round(v);
        return pad0r2(i, d);
      }
      function isgeneral(s, i) {
        i = i || 0;
        return s.length >= 7 + i && (s.charCodeAt(i) | 32) === 103 && (s.charCodeAt(i + 1) | 32) === 101 && (s.charCodeAt(i + 2) | 32) === 110 && (s.charCodeAt(i + 3) | 32) === 101 && (s.charCodeAt(i + 4) | 32) === 114 && (s.charCodeAt(i + 5) | 32) === 97 && (s.charCodeAt(i + 6) | 32) === 108;
      }
      var days = [
        ["Sun", "Sunday"],
        ["Mon", "Monday"],
        ["Tue", "Tuesday"],
        ["Wed", "Wednesday"],
        ["Thu", "Thursday"],
        ["Fri", "Friday"],
        ["Sat", "Saturday"]
      ];
      var months = [
        ["J", "Jan", "January"],
        ["F", "Feb", "February"],
        ["M", "Mar", "March"],
        ["A", "Apr", "April"],
        ["M", "May", "May"],
        ["J", "Jun", "June"],
        ["J", "Jul", "July"],
        ["A", "Aug", "August"],
        ["S", "Sep", "September"],
        ["O", "Oct", "October"],
        ["N", "Nov", "November"],
        ["D", "Dec", "December"]
      ];
      function init_table2(t) {
        t[0] = "General";
        t[1] = "0";
        t[2] = "0.00";
        t[3] = "#,##0";
        t[4] = "#,##0.00";
        t[9] = "0%";
        t[10] = "0.00%";
        t[11] = "0.00E+00";
        t[12] = "# ?/?";
        t[13] = "# ??/??";
        t[14] = "m/d/yy";
        t[15] = "d-mmm-yy";
        t[16] = "d-mmm";
        t[17] = "mmm-yy";
        t[18] = "h:mm AM/PM";
        t[19] = "h:mm:ss AM/PM";
        t[20] = "h:mm";
        t[21] = "h:mm:ss";
        t[22] = "m/d/yy h:mm";
        t[37] = "#,##0 ;(#,##0)";
        t[38] = "#,##0 ;[Red](#,##0)";
        t[39] = "#,##0.00;(#,##0.00)";
        t[40] = "#,##0.00;[Red](#,##0.00)";
        t[45] = "mm:ss";
        t[46] = "[h]:mm:ss";
        t[47] = "mmss.0";
        t[48] = "##0.0E+0";
        t[49] = "@";
        t[56] = '"\u4E0A\u5348/\u4E0B\u5348 "hh"\u6642"mm"\u5206"ss"\u79D2 "';
        t[65535] = "General";
      }
      var table_fmt = {};
      init_table2(table_fmt);
      function frac(x, D, mixed) {
        const sgn = x < 0 ? -1 : 1;
        let B = x * sgn;
        let P_2 = 0, P_1 = 1, P = 0;
        let Q_2 = 1, Q_1 = 0, Q = 0;
        let A = Math.floor(B);
        while (Q_1 < D) {
          A = Math.floor(B);
          P = A * P_1 + P_2;
          Q = A * Q_1 + Q_2;
          if (B - A < 5e-8) break;
          B = 1 / (B - A);
          P_2 = P_1;
          P_1 = P;
          Q_2 = Q_1;
          Q_1 = Q;
        }
        if (Q > D) {
          if (Q_1 > D) {
            Q = Q_2;
            P = P_2;
          } else {
            Q = Q_1;
            P = P_1;
          }
        }
        if (!mixed) return [0, sgn * P, Q];
        const q = Math.floor(sgn * P / Q);
        return [q, sgn * P - q * Q, Q];
      }
      function parse_date_code(v, opts, b2) {
        if (v > 2958465 || v < 0) return null;
        let date = v | 0, time = Math.floor(86400 * (v - date)), dow = 0;
        let dout = [];
        const out = { D: date, T: time, u: 86400 * (v - date) - time, y: 0, m: 0, d: 0, H: 0, M: 0, S: 0, q: 0 };
        if (Math.abs(out.u) < 1e-6) out.u = 0;
        if (opts && opts.date1904) date += 1462;
        if (out.u > 0.9999) {
          out.u = 0;
          if (++time === 86400) {
            out.T = time = 0;
            ++date;
            ++out.D;
          }
        }
        if (date === 60) {
          dout = b2 ? [1317, 10, 29] : [1900, 2, 29];
          dow = 3;
        } else if (date === 0) {
          dout = b2 ? [1317, 8, 29] : [1900, 1, 0];
          dow = 6;
        } else {
          if (date > 60) --date;
          const d = new Date(1900, 0, 1);
          d.setDate(d.getDate() + date - 1);
          dout = [d.getFullYear(), d.getMonth() + 1, d.getDate()];
          dow = d.getDay();
          if (date < 60) dow = (dow + 6) % 7;
          if (b2) dow = fix_hijri(d, dout);
        }
        out.y = dout[0];
        out.m = dout[1];
        out.d = dout[2];
        out.S = time % 60;
        time = Math.floor(time / 60);
        out.M = time % 60;
        time = Math.floor(time / 60);
        out.H = time;
        out.q = dow;
        return out;
      }
      SSF.parse_date_code = parse_date_code;
      var basedate = new Date(1899, 11, 31, 0, 0, 0);
      var dnthresh = basedate.getTime();
      var base1904 = new Date(1900, 2, 1, 0, 0, 0);
      function datenum_local(v, date1904) {
        let epoch = v.getTime();
        if (date1904) epoch -= 1461 * 24 * 60 * 60 * 1e3;
        else if (v >= base1904) epoch += 24 * 60 * 60 * 1e3;
        return (epoch - (dnthresh + (v.getTimezoneOffset() - basedate.getTimezoneOffset()) * 6e4)) / (24 * 60 * 60 * 1e3);
      }
      function general_fmt_int(v) {
        return v.toString(10);
      }
      SSF._general_int = general_fmt_int;
      var general_fmt_num = /* @__PURE__ */ (function make_general_fmt_num() {
        const gnr1 = /\.(\d*[1-9])0+$/, gnr2 = /\.0*$/, gnr4 = /\.(\d*[1-9])0+/, gnr5 = /\.0*[Ee]/, gnr6 = /(E[+-])(\d)$/;
        function gfn2(v) {
          const w = v < 0 ? 12 : 11;
          let o = gfn5(v.toFixed(12));
          if (o.length <= w) return o;
          o = v.toPrecision(10);
          if (o.length <= w) return o;
          return v.toExponential(5);
        }
        function gfn3(v) {
          let o = v.toFixed(11).replace(gnr1, ".$1");
          if (o.length > (v < 0 ? 12 : 11)) o = v.toPrecision(6);
          return o;
        }
        function gfn4(o) {
          for (let i = 0; i !== o.length; ++i) if ((o.charCodeAt(i) | 32) === 101) return o.replace(gnr4, ".$1").replace(gnr5, "E").replace("e", "E").replace(gnr6, "$10$2");
          return o;
        }
        function gfn5(o) {
          return o.indexOf(".") > -1 ? o.replace(gnr2, "").replace(gnr1, ".$1") : o;
        }
        return function general_fmt_num2(v) {
          let V = Math.floor(Math.log(Math.abs(v)) * Math.LOG10E), o;
          if (V >= -4 && V <= -1) o = v.toPrecision(10 + V);
          else if (Math.abs(V) <= 9) o = gfn2(v);
          else if (V === 10) o = v.toFixed(10).substr(0, 12);
          else o = gfn3(v);
          return gfn5(gfn4(o));
        };
      })();
      SSF._general_num = general_fmt_num;
      function general_fmt(v, opts) {
        switch (typeof v) {
          case "string":
            return v;
          case "boolean":
            return v ? "TRUE" : "FALSE";
          case "number":
            return (v | 0) === v ? general_fmt_int(v) : general_fmt_num(v);
          case "undefined":
            return "";
          case "object":
            if (v == null) return "";
            if (v instanceof Date) return format(14, datenum_local(v, opts && opts.date1904), opts);
        }
        throw new Error("unsupported value in General format: " + v);
      }
      SSF._general = general_fmt;
      function fix_hijri() {
        return 0;
      }
      function write_date(type, fmt, val, ss0) {
        let o = "", ss = 0, tt = 0, y = val.y, out, outl = 0;
        switch (type) {
          case 98:
            y = val.y + 543;
          /* falls through */
          case 121:
            switch (fmt.length) {
              case 1:
              case 2:
                out = y % 100;
                outl = 2;
                break;
              default:
                out = y % 1e4;
                outl = 4;
                break;
            }
            break;
          case 109:
            switch (fmt.length) {
              case 1:
              case 2:
                out = val.m;
                outl = fmt.length;
                break;
              case 3:
                return months[val.m - 1][1];
              case 5:
                return months[val.m - 1][0];
              default:
                return months[val.m - 1][2];
            }
            break;
          case 100:
            switch (fmt.length) {
              case 1:
              case 2:
                out = val.d;
                outl = fmt.length;
                break;
              case 3:
                return days[val.q][0];
              default:
                return days[val.q][1];
            }
            break;
          case 104:
            switch (fmt.length) {
              case 1:
              case 2:
                out = 1 + (val.H + 11) % 12;
                outl = fmt.length;
                break;
              default:
                throw "bad hour format: " + fmt;
            }
            break;
          case 72:
            switch (fmt.length) {
              case 1:
              case 2:
                out = val.H;
                outl = fmt.length;
                break;
              default:
                throw "bad hour format: " + fmt;
            }
            break;
          case 77:
            switch (fmt.length) {
              case 1:
              case 2:
                out = val.M;
                outl = fmt.length;
                break;
              default:
                throw "bad minute format: " + fmt;
            }
            break;
          case 115:
            if (fmt !== "s" && fmt !== "ss" && fmt !== ".0" && fmt !== ".00" && fmt !== ".000") throw "bad second format: " + fmt;
            if (val.u === 0 && (fmt === "s" || fmt === "ss")) return pad0(val.S, fmt.length);
            if (ss0 >= 2) tt = ss0 === 3 ? 1e3 : 100;
            else tt = ss0 === 1 ? 10 : 1;
            ss = Math.round(tt * (val.S + val.u));
            if (ss >= 60 * tt) ss = 0;
            if (fmt === "s") return ss === 0 ? "0" : "" + ss / tt;
            o = pad0(ss, 2 + ss0);
            if (fmt === "ss") return o.substr(0, 2);
            return "." + o.substr(2, fmt.length - 1);
          case 90:
            switch (fmt) {
              case "[h]":
              case "[hh]":
                out = val.D * 24 + val.H;
                break;
              case "[m]":
              case "[mm]":
                out = (val.D * 24 + val.H) * 60 + val.M;
                break;
              case "[s]":
              case "[ss]":
                out = ((val.D * 24 + val.H) * 60 + val.M) * 60 + Math.round(val.S + val.u);
                break;
              default:
                throw "bad abstime format: " + fmt;
            }
            outl = fmt.length === 3 ? 1 : 2;
            break;
          case 101:
            out = y;
            outl = 1;
        }
        if (outl > 0) return pad0(out, outl);
        else return "";
      }
      function commaify(s) {
        const w = 3;
        if (s.length <= w) return s;
        let j = s.length % w, o = s.substr(0, j);
        for (; j !== s.length; j += w) o += (o.length > 0 ? "," : "") + s.substr(j, w);
        return o;
      }
      var write_num = /* @__PURE__ */ (function make_write_num() {
        const pct1 = /%/g;
        function write_num_pct(type, fmt, val) {
          const sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
          return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
        }
        function write_num_cm(type, fmt, val) {
          let idx = fmt.length - 1;
          while (fmt.charCodeAt(idx - 1) === 44) --idx;
          return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
        }
        function write_num_exp(fmt, val) {
          let o;
          let idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
          if (fmt.match(/^#+0.0E\+0$/)) {
            if (val === 0) return "0.0E+0";
            else if (val < 0) return "-" + write_num_exp(fmt, -val);
            let period = fmt.indexOf(".");
            if (period === -1) period = fmt.indexOf("E");
            let ee = Math.floor(Math.log(val) * Math.LOG10E) % period;
            if (ee < 0) ee += period;
            o = (val / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);
            if (o.indexOf("e") === -1) {
              const fakee = Math.floor(Math.log(val) * Math.LOG10E);
              if (o.indexOf(".") === -1) o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length + ee);
              else o += "E+" + (fakee - ee);
              while (o.substr(0, 2) === "0.") {
                o = o.charAt(0) + o.substr(2, period) + "." + o.substr(2 + period);
                o = o.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
              }
              o = o.replace(/\+-/, "-");
            }
            o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
              return $1 + $2 + $3.substr(0, (period + ee) % period) + "." + $3.substr(ee) + "E";
            });
          } else o = val.toExponential(idx);
          if (fmt.match(/E\+00$/) && o.match(/e[+-]\d$/)) o = o.substr(0, o.length - 1) + "0" + o.charAt(o.length - 1);
          if (fmt.match(/E\-/) && o.match(/e\+/)) o = o.replace(/e\+/, "e");
          return o.replace("e", "E");
        }
        const frac1 = /# (\?+)( ?)\/( ?)(\d+)/;
        function write_num_f1(r, aval, sign) {
          const den = parseInt(r[4], 10), rr = Math.round(aval * den), base = Math.floor(rr / den);
          let myn = rr - base * den, myd = den;
          return sign + (base === 0 ? "" : "" + base) + " " + (myn === 0 ? fill(" ", r[1].length + 1 + r[4].length) : pad_(myn, r[1].length) + r[2] + "/" + r[3] + pad0(myd, r[4].length));
        }
        function write_num_f2(r, aval, sign) {
          return sign + (aval === 0 ? "" : "" + aval) + fill(" ", r[1].length + 2 + r[4].length);
        }
        const dec1 = /^#*0*\.([0#]+)/;
        const closeparen = /\).*[0#]/;
        const phone = /\(###\) ###\\?-####/;
        function hashq(str) {
          let o = "", cc;
          for (let i = 0; i !== str.length; ++i) switch (cc = str.charCodeAt(i)) {
            case 35:
              break;
            case 63:
              o += " ";
              break;
            case 48:
              o += "0";
              break;
            default:
              o += String.fromCharCode(cc);
          }
          return o;
        }
        function rnd(val, d) {
          const dd = Math.pow(10, d);
          return "" + Math.round(val * dd) / dd;
        }
        function dec(val, d) {
          if (d < ("" + Math.round((val - Math.floor(val)) * Math.pow(10, d))).length) {
            return 0;
          }
          return Math.round((val - Math.floor(val)) * Math.pow(10, d));
        }
        function carry(val, d) {
          if (d < ("" + Math.round((val - Math.floor(val)) * Math.pow(10, d))).length) {
            return 1;
          }
          return 0;
        }
        function flr(val) {
          if (val < 2147483647 && val > -2147483648) return "" + (val >= 0 ? val | 0 : val - 1 | 0);
          return "" + Math.floor(val);
        }
        function write_num_flt(type, fmt, val) {
          if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
            const ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
            if (val >= 0) return write_num_flt("n", ffmt, val);
            return "(" + write_num_flt("n", ffmt, -val) + ")";
          }
          if (fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm(type, fmt, val);
          if (fmt.indexOf("%") !== -1) return write_num_pct(type, fmt, val);
          if (fmt.indexOf("E") !== -1) return write_num_exp(fmt, val);
          if (fmt.charCodeAt(0) === 36) return "$" + write_num_flt(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
          let o;
          let r, ri, ff, aval = Math.abs(val), sign = val < 0 ? "-" : "";
          if (fmt.match(/^00+$/)) return sign + pad0r(aval, fmt.length);
          if (fmt.match(/^[#?]+$/)) {
            o = pad0r(val, 0);
            if (o === "0") o = "";
            return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o;
          }
          if (r = fmt.match(frac1)) return write_num_f1(r, aval, sign);
          if (fmt.match(/^#+0+$/)) return sign + pad0r(aval, fmt.length - fmt.indexOf("0"));
          if (r = fmt.match(dec1)) {
            o = rnd(val, r[1].length).replace(/^([^\.]+)$/, "$1." + hashq(r[1])).replace(/\.$/, "." + hashq(r[1])).replace(/\.(\d*)$/, function($$, $1) {
              return "." + $1 + fill("0", hashq(r[1]).length - $1.length);
            });
            return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".");
          }
          fmt = fmt.replace(/^#+([0.])/, "$1");
          if (r = fmt.match(/^(0*)\.(#*)$/)) {
            return sign + rnd(aval, r[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".");
          }
          if (r = fmt.match(/^#{1,3},##0(\.?)$/)) return sign + commaify(pad0r(aval, 0));
          if (r = fmt.match(/^#,##0\.([#0]*0)$/)) {
            return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify("" + (Math.floor(val) + carry(val, r[1].length))) + "." + pad0(dec(val, r[1].length), r[1].length);
          }
          if (r = fmt.match(/^#,#*,#0/)) return write_num_flt(type, fmt.replace(/^#,#*,/, ""), val);
          if (r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
            o = _strrev(write_num_flt(type, fmt.replace(/[\\-]/g, ""), val));
            ri = 0;
            return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x) {
              return ri < o.length ? o.charAt(ri++) : x === "0" ? "0" : "";
            }));
          }
          if (fmt.match(phone)) {
            o = write_num_flt(type, "##########", val);
            return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
          }
          let oa = "";
          if (r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
            ri = Math.min(r[4].length, 7);
            ff = frac(aval, Math.pow(10, ri) - 1, false);
            o = "" + sign;
            oa = write_num("n", r[1], ff[1]);
            if (oa.charAt(oa.length - 1) === " ") oa = oa.substr(0, oa.length - 1) + "0";
            o += oa + r[2] + "/" + r[3];
            oa = rpad_(ff[2], ri);
            if (oa.length < r[4].length) oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
            o += oa;
            return o;
          }
          if (r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
            ri = Math.min(Math.max(r[1].length, r[4].length), 7);
            ff = frac(aval, Math.pow(10, ri) - 1, true);
            return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r[2].length + r[3].length));
          }
          if (r = fmt.match(/^[#0?]+$/)) {
            o = pad0r(val, 0);
            if (fmt.length <= o.length) return o;
            return hashq(fmt.substr(0, fmt.length - o.length)) + o;
          }
          if (r = fmt.match(/^([#0?]+)\.([#0]+)$/)) {
            o = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
            ri = o.indexOf(".");
            const lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;
            return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres));
          }
          if (r = fmt.match(/^00,000\.([#0]*0)$/)) {
            ri = dec(val, r[1].length);
            return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify(flr(val)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
              return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
            }) + "." + pad0(ri, r[1].length);
          }
          switch (fmt) {
            case "###,##0.00":
              return write_num_flt(type, "#,##0.00", val);
            case "###,###":
            case "##,###":
            case "#,###":
              const x = commaify(pad0r(aval, 0));
              return x !== "0" ? sign + x : "";
            case "###,###.00":
              return write_num_flt(type, "###,##0.00", val).replace(/^0\./, ".");
            case "#,###.00":
              return write_num_flt(type, "#,##0.00", val).replace(/^0\./, ".");
            default:
          }
          throw new Error("unsupported format |" + fmt + "|");
        }
        function write_num_cm2(type, fmt, val) {
          let idx = fmt.length - 1;
          while (fmt.charCodeAt(idx - 1) === 44) --idx;
          return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
        }
        function write_num_pct2(type, fmt, val) {
          const sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
          return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
        }
        function write_num_exp2(fmt, val) {
          let o;
          let idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
          if (fmt.match(/^#+0.0E\+0$/)) {
            if (val === 0) return "0.0E+0";
            else if (val < 0) return "-" + write_num_exp2(fmt, -val);
            let period = fmt.indexOf(".");
            if (period === -1) period = fmt.indexOf("E");
            let ee = Math.floor(Math.log(val) * Math.LOG10E) % period;
            if (ee < 0) ee += period;
            o = (val / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);
            if (!o.match(/[Ee]/)) {
              const fakee = Math.floor(Math.log(val) * Math.LOG10E);
              if (o.indexOf(".") === -1) o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length + ee);
              else o += "E+" + (fakee - ee);
              o = o.replace(/\+-/, "-");
            }
            o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
              return $1 + $2 + $3.substr(0, (period + ee) % period) + "." + $3.substr(ee) + "E";
            });
          } else o = val.toExponential(idx);
          if (fmt.match(/E\+00$/) && o.match(/e[+-]\d$/)) o = o.substr(0, o.length - 1) + "0" + o.charAt(o.length - 1);
          if (fmt.match(/E\-/) && o.match(/e\+/)) o = o.replace(/e\+/, "e");
          return o.replace("e", "E");
        }
        function write_num_int(type, fmt, val) {
          if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
            const ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
            if (val >= 0) return write_num_int("n", ffmt, val);
            return "(" + write_num_int("n", ffmt, -val) + ")";
          }
          if (fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm2(type, fmt, val);
          if (fmt.indexOf("%") !== -1) return write_num_pct2(type, fmt, val);
          if (fmt.indexOf("E") !== -1) return write_num_exp2(fmt, val);
          if (fmt.charCodeAt(0) === 36) return "$" + write_num_int(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
          let o;
          let r, ri, ff, aval = Math.abs(val), sign = val < 0 ? "-" : "";
          if (fmt.match(/^00+$/)) return sign + pad0(aval, fmt.length);
          if (fmt.match(/^[#?]+$/)) {
            o = "" + val;
            if (val === 0) o = "";
            return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o;
          }
          if (r = fmt.match(frac1)) return write_num_f2(r, aval, sign);
          if (fmt.match(/^#+0+$/)) return sign + pad0(aval, fmt.length - fmt.indexOf("0"));
          if (r = fmt.match(dec1)) {
            o = ("" + val).replace(/^([^\.]+)$/, "$1." + hashq(r[1])).replace(/\.$/, "." + hashq(r[1]));
            o = o.replace(/\.(\d*)$/, function($$, $1) {
              return "." + $1 + fill("0", hashq(r[1]).length - $1.length);
            });
            return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".");
          }
          fmt = fmt.replace(/^#+([0.])/, "$1");
          if (r = fmt.match(/^(0*)\.(#*)$/)) {
            return sign + ("" + aval).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".");
          }
          if (r = fmt.match(/^#{1,3},##0(\.?)$/)) return sign + commaify("" + aval);
          if (r = fmt.match(/^#,##0\.([#0]*0)$/)) {
            return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val) + "." + fill("0", r[1].length);
          }
          if (r = fmt.match(/^#,#*,#0/)) return write_num_int(type, fmt.replace(/^#,#*,/, ""), val);
          if (r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
            o = _strrev(write_num_int(type, fmt.replace(/[\\-]/g, ""), val));
            ri = 0;
            return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x) {
              return ri < o.length ? o.charAt(ri++) : x === "0" ? "0" : "";
            }));
          }
          if (fmt.match(phone)) {
            o = write_num_int(type, "##########", val);
            return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
          }
          let oa = "";
          if (r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
            ri = Math.min(r[4].length, 7);
            ff = frac(aval, Math.pow(10, ri) - 1, false);
            o = "" + sign;
            oa = write_num("n", r[1], ff[1]);
            if (oa.charAt(oa.length - 1) == " ") oa = oa.substr(0, oa.length - 1) + "0";
            o += oa + r[2] + "/" + r[3];
            oa = rpad_(ff[2], ri);
            if (oa.length < r[4].length) oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
            o += oa;
            return o;
          }
          if (r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
            ri = Math.min(Math.max(r[1].length, r[4].length), 7);
            ff = frac(aval, Math.pow(10, ri) - 1, true);
            return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r[2].length + r[3].length));
          }
          if (r = fmt.match(/^[#0?]+$/)) {
            o = "" + val;
            if (fmt.length <= o.length) return o;
            return hashq(fmt.substr(0, fmt.length - o.length)) + o;
          }
          if (r = fmt.match(/^([#0]+)\.([#0]+)$/)) {
            o = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
            ri = o.indexOf(".");
            let lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;
            return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres));
          }
          if (r = fmt.match(/^00,000\.([#0]*0)$/)) {
            return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
              return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
            }) + "." + pad0(0, r[1].length);
          }
          switch (fmt) {
            case "###,###":
            case "##,###":
            case "#,###":
              const x = commaify("" + aval);
              return x !== "0" ? sign + x : "";
            default:
              if (fmt.match(/\.[0#?]*$/)) return write_num_int(type, fmt.slice(0, fmt.lastIndexOf(".")), val) + hashq(fmt.slice(fmt.lastIndexOf(".")));
          }
          throw new Error("unsupported format |" + fmt + "|");
        }
        return function write_num2(type, fmt, val) {
          return (val | 0) === val ? write_num_int(type, fmt, val) : write_num_flt(type, fmt, val);
        };
      })();
      function split_fmt(fmt) {
        const out = [];
        let in_str = false, j = 0;
        for (let i = 0; i < fmt.length; ++i) switch (
          /*cc=*/
          fmt.charCodeAt(i)
        ) {
          case 34:
            in_str = !in_str;
            break;
          case 95:
          case 42:
          case 92:
            ++i;
            break;
          case 59:
            out[out.length] = fmt.substr(j, i - j);
            j = i + 1;
        }
        out[out.length] = fmt.substr(j);
        if (in_str === true) throw new Error("Format |" + fmt + "| unterminated string ");
        return out;
      }
      SSF._split = split_fmt;
      var abstime = /\[[HhMmSs]*\]/;
      function fmt_is_date(fmt) {
        let i = 0, c = "", o = "";
        while (i < fmt.length) {
          switch (c = fmt.charAt(i)) {
            case "G":
              if (isgeneral(fmt, i)) i += 6;
              i++;
              break;
            case '"':
              for (
                ;
                /*cc=*/
                fmt.charCodeAt(++i) !== 34 && i < fmt.length;
              ) ++i;
              ++i;
              break;
            case "\\":
              i += 2;
              break;
            case "_":
              i += 2;
              break;
            case "@":
              ++i;
              break;
            case "B":
            case "b":
              if (fmt.charAt(i + 1) === "1" || fmt.charAt(i + 1) === "2") return true;
            /* falls through */
            case "M":
            case "D":
            case "Y":
            case "H":
            case "S":
            case "E":
            /* falls through */
            case "m":
            case "d":
            case "y":
            case "h":
            case "s":
            case "e":
            case "g":
              return true;
            case "A":
            case "a":
              if (fmt.substr(i, 3).toUpperCase() === "A/P") return true;
              if (fmt.substr(i, 5).toUpperCase() === "AM/PM") return true;
              ++i;
              break;
            case "[":
              o = c;
              while (fmt.charAt(i++) !== "]" && i < fmt.length) o += fmt.charAt(i);
              if (o.match(abstime)) return true;
              break;
            case ".":
            /* falls through */
            case "0":
            case "#":
              while (i < fmt.length && ("0#?.,E+-%".indexOf(c = fmt.charAt(++i)) > -1 || c == "\\" && fmt.charAt(i + 1) == "-" && "0#".indexOf(fmt.charAt(i + 2)) > -1)) {
              }
              break;
            case "?":
              while (fmt.charAt(++i) === c) {
              }
              break;
            case "*":
              ++i;
              if (fmt.charAt(i) === " " || fmt.charAt(i) === "*") ++i;
              break;
            case "(":
            case ")":
              ++i;
              break;
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              while (i < fmt.length && "0123456789".indexOf(fmt.charAt(++i)) > -1) {
              }
              break;
            case " ":
              ++i;
              break;
            default:
              ++i;
              break;
          }
        }
        return false;
      }
      SSF.is_date = fmt_is_date;
      function eval_fmt(fmt, v, opts, flen) {
        let out = [], o = "", i = 0, c = "", lst = "t", dt, j, cc;
        let hr = "H";
        while (i < fmt.length) {
          switch (c = fmt.charAt(i)) {
            case "G":
              if (!isgeneral(fmt, i)) throw new Error("unrecognized character " + c + " in " + fmt);
              out[out.length] = { t: "G", v: "General" };
              i += 7;
              break;
            case '"':
              for (o = ""; (cc = fmt.charCodeAt(++i)) !== 34 && i < fmt.length; ) o += String.fromCharCode(cc);
              out[out.length] = { t: "t", v: o };
              ++i;
              break;
            case "\\":
              const w = fmt.charAt(++i), t = w === "(" || w === ")" ? w : "t";
              out[out.length] = { t, v: w };
              ++i;
              break;
            case "_":
              out[out.length] = { t: "t", v: " " };
              i += 2;
              break;
            case "@":
              out[out.length] = { t: "T", v };
              ++i;
              break;
            case "B":
            case "b":
              if (fmt.charAt(i + 1) === "1" || fmt.charAt(i + 1) === "2") {
                if (dt == null) {
                  dt = parse_date_code(v, opts, fmt.charAt(i + 1) === "2");
                  if (dt == null) return "";
                }
                out[out.length] = { t: "X", v: fmt.substr(i, 2) };
                lst = c;
                i += 2;
                break;
              }
            /* falls through */
            case "M":
            case "D":
            case "Y":
            case "H":
            case "S":
            case "E":
              c = c.toLowerCase();
            /* falls through */
            case "m":
            case "d":
            case "y":
            case "h":
            case "s":
            case "e":
            case "g":
              if (v < 0) return "";
              if (dt == null) {
                dt = parse_date_code(v, opts);
                if (dt == null) return "";
              }
              o = c;
              while (++i < fmt.length && fmt.charAt(i).toLowerCase() === c) o += c;
              if (c === "m" && lst.toLowerCase() === "h") c = "M";
              if (c === "h") c = hr;
              out[out.length] = { t: c, v: o };
              lst = c;
              break;
            case "A":
            case "a":
              const q = { t: c, v: c };
              if (dt == null) dt = parse_date_code(v, opts);
              if (fmt.substr(i, 3).toUpperCase() === "A/P") {
                if (dt != null) q.v = dt.H >= 12 ? "P" : "A";
                q.t = "T";
                hr = "h";
                i += 3;
              } else if (fmt.substr(i, 5).toUpperCase() === "AM/PM") {
                if (dt != null) q.v = dt.H >= 12 ? "PM" : "AM";
                q.t = "T";
                i += 5;
                hr = "h";
              } else {
                q.t = "t";
                ++i;
              }
              if (dt == null && q.t === "T") return "";
              out[out.length] = q;
              lst = c;
              break;
            case "[":
              o = c;
              while (fmt.charAt(i++) !== "]" && i < fmt.length) o += fmt.charAt(i);
              if (o.slice(-1) !== "]") throw 'unterminated "[" block: |' + o + "|";
              if (o.match(abstime)) {
                if (dt == null) {
                  dt = parse_date_code(v, opts);
                  if (dt == null) return "";
                }
                out[out.length] = { t: "Z", v: o.toLowerCase() };
                lst = o.charAt(1);
              } else if (o.indexOf("$") > -1) {
                o = (o.match(/\$([^-\[\]]*)/) || [])[1] || "$";
                if (!fmt_is_date(fmt)) out[out.length] = { t: "t", v: o };
              }
              break;
            /* Numbers */
            case ".":
              if (dt != null) {
                o = c;
                while (++i < fmt.length && (c = fmt.charAt(i)) === "0") o += c;
                out[out.length] = { t: "s", v: o };
                break;
              }
            /* falls through */
            case "0":
            case "#":
              o = c;
              while (++i < fmt.length && "0#?.,E+-%".indexOf(c = fmt.charAt(i)) > -1 || c == "\\" && fmt.charAt(i + 1) == "-" && i < fmt.length - 2 && "0#".indexOf(fmt.charAt(i + 2)) > -1) o += c;
              out[out.length] = { t: "n", v: o };
              break;
            case "?":
              o = c;
              while (fmt.charAt(++i) === c) o += c;
              out[out.length] = { t: c, v: o };
              lst = c;
              break;
            case "*":
              ++i;
              if (fmt.charAt(i) === " " || fmt.charAt(i) === "*") ++i;
              break;
            // **
            case "(":
            case ")":
              out[out.length] = { t: flen === 1 || typeof v === "number" && v < 0 ? "t" : c, v: c };
              ++i;
              break;
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              o = c;
              while (i < fmt.length && "0123456789".indexOf(fmt.charAt(++i)) > -1) o += fmt.charAt(i);
              out[out.length] = { t: "D", v: o };
              break;
            case " ":
              out[out.length] = { t: c, v: c };
              ++i;
              break;
            default:
              if (",$-+/():!^&'~{}<>=\u20ACacfijklopqrtuvwxzP".indexOf(c) === -1) throw new Error("unrecognized character " + c + " in " + fmt);
              out[out.length] = { t: "t", v: c };
              ++i;
              break;
          }
        }
        let bt = 0, ss0 = 0, ssm;
        for (i = out.length - 1, lst = "t"; i >= 0; --i) {
          switch (out[i].t) {
            case "h":
            case "H":
              out[i].t = hr;
              lst = "h";
              if (bt < 1) bt = 1;
              break;
            case "s":
              if (ssm = out[i].v.match(/\.0+$/)) ss0 = Math.max(ss0, ssm[0].length - 1);
              if (bt < 3) bt = 3;
            /* falls through */
            case "d":
            case "y":
            case "M":
            case "e":
              lst = out[i].t;
              break;
            case "m":
              if (lst === "s") {
                out[i].t = "M";
                if (bt < 2) bt = 2;
              }
              break;
            case "X":
              break;
            case "Z":
              if (bt < 1 && out[i].v.match(/[Hh]/)) bt = 1;
              if (bt < 2 && out[i].v.match(/[Mm]/)) bt = 2;
              if (bt < 3 && out[i].v.match(/[Ss]/)) bt = 3;
          }
        }
        switch (bt) {
          case 0:
            break;
          case 1:
            if (dt.u >= 0.5) {
              dt.u = 0;
              ++dt.S;
            }
            if (dt.S >= 60) {
              dt.S = 0;
              ++dt.M;
            }
            if (dt.M >= 60) {
              dt.M = 0;
              ++dt.H;
            }
            break;
          case 2:
            if (dt.u >= 0.5) {
              dt.u = 0;
              ++dt.S;
            }
            if (dt.S >= 60) {
              dt.S = 0;
              ++dt.M;
            }
            break;
        }
        let nstr = "", jj;
        for (i = 0; i < out.length; ++i) {
          switch (out[i].t) {
            case "t":
            case "T":
            case " ":
            case "D":
              break;
            case "X":
              out[i].v = "";
              out[i].t = ";";
              break;
            case "d":
            case "m":
            case "y":
            case "h":
            case "H":
            case "M":
            case "s":
            case "e":
            case "b":
            case "Z":
              out[i].v = write_date(out[i].t.charCodeAt(0), out[i].v, dt, ss0);
              out[i].t = "t";
              break;
            case "n":
            case "(":
            case "?":
              jj = i + 1;
              while (out[jj] != null && ((c = out[jj].t) === "?" || c === "D" || (c === " " || c === "t") && out[jj + 1] != null && (out[jj + 1].t === "?" || out[jj + 1].t === "t" && out[jj + 1].v === "/") || out[i].t === "(" && (c === " " || c === "n" || c === ")") || c === "t" && (out[jj].v === "/" || out[jj].v === " " && out[jj + 1] != null && out[jj + 1].t === "?"))) {
                out[i].v += out[jj].v;
                out[jj] = { v: "", t: ";" };
                ++jj;
              }
              nstr += out[i].v;
              i = jj - 1;
              break;
            case "G":
              out[i].t = "t";
              out[i].v = general_fmt(v, opts);
              break;
          }
        }
        let vv = "", myv, ostr;
        if (nstr.length > 0) {
          if (nstr.charCodeAt(0) === 40) {
            myv = v < 0 && nstr.charCodeAt(0) === 45 ? -v : v;
            ostr = write_num("(", nstr, myv);
          } else {
            myv = v < 0 && flen > 1 ? -v : v;
            ostr = write_num("n", nstr, myv);
            if (myv < 0 && out[0] && out[0].t === "t") {
              ostr = ostr.substr(1);
              out[0].v = "-" + out[0].v;
            }
          }
          jj = ostr.length - 1;
          let decpt = out.length;
          for (i = 0; i < out.length; ++i) if (out[i] != null && out[i].t !== "t" && out[i].v.indexOf(".") > -1) {
            decpt = i;
            break;
          }
          let lasti = out.length;
          if (decpt === out.length && ostr.indexOf("E") === -1) {
            for (i = out.length - 1; i >= 0; --i) {
              if (out[i] == null || "n?(".indexOf(out[i].t) === -1) continue;
              if (jj >= out[i].v.length - 1) {
                jj -= out[i].v.length;
                out[i].v = ostr.substr(jj + 1, out[i].v.length);
              } else if (jj < 0) out[i].v = "";
              else {
                out[i].v = ostr.substr(0, jj + 1);
                jj = -1;
              }
              out[i].t = "t";
              lasti = i;
            }
            if (jj >= 0 && lasti < out.length) out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
          } else if (decpt !== out.length && ostr.indexOf("E") === -1) {
            jj = ostr.indexOf(".") - 1;
            for (i = decpt; i >= 0; --i) {
              if (out[i] == null || "n?(".indexOf(out[i].t) === -1) continue;
              j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") - 1 : out[i].v.length - 1;
              vv = out[i].v.substr(j + 1);
              for (; j >= 0; --j) {
                if (jj >= 0 && (out[i].v.charAt(j) === "0" || out[i].v.charAt(j) === "#")) vv = ostr.charAt(jj--) + vv;
              }
              out[i].v = vv;
              out[i].t = "t";
              lasti = i;
            }
            if (jj >= 0 && lasti < out.length) out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
            jj = ostr.indexOf(".") + 1;
            for (i = decpt; i < out.length; ++i) {
              if (out[i] == null || "n?(".indexOf(out[i].t) === -1 && i !== decpt) continue;
              j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") + 1 : 0;
              vv = out[i].v.substr(0, j);
              for (; j < out[i].v.length; ++j) {
                if (jj < ostr.length) vv += ostr.charAt(jj++);
              }
              out[i].v = vv;
              out[i].t = "t";
              lasti = i;
            }
          }
        }
        for (i = 0; i < out.length; ++i) if (out[i] != null && "n(?".indexOf(out[i].t) > -1) {
          myv = flen > 1 && v < 0 && i > 0 && out[i - 1].v === "-" ? -v : v;
          out[i].v = write_num(out[i].t, out[i].v, myv);
          out[i].t = "t";
        }
        let retval = "";
        for (i = 0; i !== out.length; ++i) if (out[i] != null) retval += out[i].v;
        return retval;
      }
      SSF._eval = eval_fmt;
      var cfregex = /\[[=<>]/;
      var cfregex2 = /\[([=<>]*)(-?\d+\.?\d*)\]/;
      function chkcond(v, rr) {
        if (rr == null) return false;
        const thresh = parseFloat(rr[2]);
        switch (rr[1]) {
          case "=":
            if (v === thresh) return true;
            break;
          case ">":
            if (v > thresh) return true;
            break;
          case "<":
            if (v < thresh) return true;
            break;
          case "<>":
            if (v !== thresh) return true;
            break;
          case ">=":
            if (v >= thresh) return true;
            break;
          case "<=":
            if (v <= thresh) return true;
            break;
        }
        return false;
      }
      function choose_fmt(f, v) {
        let fmt = split_fmt(f);
        let l = fmt.length, lat = fmt[l - 1].indexOf("@");
        if (l < 4 && lat > -1) --l;
        if (fmt.length > 4) throw new Error("cannot find right format for |" + fmt.join("|") + "|");
        if (typeof v !== "number") return [4, fmt.length === 4 || lat > -1 ? fmt[fmt.length - 1] : "@"];
        switch (fmt.length) {
          case 1:
            fmt = lat > -1 ? ["General", "General", "General", fmt[0]] : [fmt[0], fmt[0], fmt[0], "@"];
            break;
          case 2:
            fmt = lat > -1 ? [fmt[0], fmt[0], fmt[0], fmt[1]] : [fmt[0], fmt[1], fmt[0], "@"];
            break;
          case 3:
            fmt = lat > -1 ? [fmt[0], fmt[1], fmt[0], fmt[2]] : [fmt[0], fmt[1], fmt[2], "@"];
            break;
          case 4:
            break;
        }
        const ff = v > 0 ? fmt[0] : v < 0 ? fmt[1] : fmt[2];
        if (fmt[0].indexOf("[") === -1 && fmt[1].indexOf("[") === -1) return [l, ff];
        if (fmt[0].match(cfregex) != null || fmt[1].match(cfregex) != null) {
          const m1 = fmt[0].match(cfregex2);
          const m2 = fmt[1].match(cfregex2);
          return chkcond(v, m1) ? [l, fmt[0]] : chkcond(v, m2) ? [l, fmt[1]] : [l, fmt[m1 != null && m2 != null ? 2 : 1]];
        }
        return [l, ff];
      }
      function format(fmt, v, o) {
        if (o == null) o = {};
        let sfmt = "";
        switch (typeof fmt) {
          case "string":
            if (fmt === "m/d/yy" && o.dateNF) sfmt = o.dateNF;
            else sfmt = fmt;
            break;
          case "number":
            if (fmt === 14 && o.dateNF) sfmt = o.dateNF;
            else sfmt = (o.table != null ? o.table : table_fmt)[fmt];
            break;
        }
        if (isgeneral(sfmt, 0)) return general_fmt(v, o);
        if (v instanceof Date) v = datenum_local(v, o.date1904);
        const f = choose_fmt(sfmt, v);
        if (isgeneral(f[1])) return general_fmt(v, o);
        if (v === true) v = "TRUE";
        else if (v === false) v = "FALSE";
        else if (v === "" || v == null) return "";
        return eval_fmt(f[1], v, o, f[0]);
      }
      function load_entry(fmt, idx) {
        if (typeof idx !== "number") {
          idx = +idx || -1;
          for (let i = 0; i < 392; ++i) {
            if (table_fmt[i] === void 0) {
              if (idx < 0) idx = i;
              continue;
            }
            if (table_fmt[i] === fmt) {
              idx = i;
              break;
            }
          }
          if (idx < 0) idx = 391;
        }
        table_fmt[idx] = fmt;
        return idx;
      }
      SSF.load = load_entry;
      SSF._table = table_fmt;
      SSF.get_table = function get_table() {
        return table_fmt;
      };
      SSF.load_table = function load_table(tbl) {
        for (let i = 0; i !== 392; ++i)
          if (tbl[i] !== void 0) load_entry(tbl[i], i);
      };
      SSF.init_table = init_table2;
      SSF.format = format;
      module2.exports = SSF;
    }
  });

  // node_modules/bahttext/src/index.js
  var require_src = __commonJS({
    "node_modules/bahttext/src/index.js"(exports2, module2) {
      var defaultResult = "\u0E28\u0E39\u0E19\u0E22\u0E4C\u0E1A\u0E32\u0E17\u0E16\u0E49\u0E27\u0E19";
      var singleUnitStrs = [
        "",
        "\u0E2B\u0E19\u0E36\u0E48\u0E07",
        "\u0E2A\u0E2D\u0E07",
        "\u0E2A\u0E32\u0E21",
        "\u0E2A\u0E35\u0E48",
        "\u0E2B\u0E49\u0E32",
        "\u0E2B\u0E01",
        "\u0E40\u0E08\u0E47\u0E14",
        "\u0E41\u0E1B\u0E14",
        "\u0E40\u0E01\u0E49\u0E32"
      ];
      var placeNameStrs = [
        "",
        "\u0E2A\u0E34\u0E1A",
        "\u0E23\u0E49\u0E2D\u0E22",
        "\u0E1E\u0E31\u0E19",
        "\u0E2B\u0E21\u0E37\u0E48\u0E19",
        "\u0E41\u0E2A\u0E19",
        "\u0E25\u0E49\u0E32\u0E19"
      ];
      function num2Word(nums) {
        let result = "";
        const len = nums.length;
        const maxLen = 7;
        if (len > maxLen) {
          const overflowIndex = len - maxLen + 1;
          const overflowNums = nums.slice(0, overflowIndex);
          const remainingNumbs = nums.slice(overflowIndex);
          return num2Word(overflowNums) + "\u0E25\u0E49\u0E32\u0E19" + num2Word(remainingNumbs);
        } else {
          for (let i = 0; i < len; i++) {
            const digit = nums[i];
            if (digit > 0) {
              result += singleUnitStrs[digit] + placeNameStrs[len - i - 1];
            }
          }
        }
        return result;
      }
      function grammarFix(str) {
        let result = str;
        result = result.replace("\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E2A\u0E34\u0E1A", "\u0E2A\u0E34\u0E1A");
        result = result.replace("\u0E2A\u0E2D\u0E07\u0E2A\u0E34\u0E1A", "\u0E22\u0E35\u0E48\u0E2A\u0E34\u0E1A");
        const neungLen = 5;
        if (result.length > neungLen && result.length - result.lastIndexOf("\u0E2B\u0E19\u0E36\u0E48\u0E07") === neungLen) {
          result = result.substr(0, result.length - neungLen) + "\u0E40\u0E2D\u0E47\u0E14";
        }
        return result;
      }
      function combine(baht, satang) {
        let result = "";
        if (baht === "" && satang === "") {
          result = defaultResult;
        } else if (baht !== "" && satang === "") {
          result = baht + "\u0E1A\u0E32\u0E17\u0E16\u0E49\u0E27\u0E19";
        } else if (baht === "" && satang !== "") {
          result = satang + "\u0E2A\u0E15\u0E32\u0E07\u0E04\u0E4C";
        } else {
          result = baht + "\u0E1A\u0E32\u0E17" + satang + "\u0E2A\u0E15\u0E32\u0E07\u0E04\u0E4C";
        }
        return result;
      }
      function bahttext(num) {
        let result = defaultResult;
        if (isNaN(num)) return result;
        if (num >= Number.MAX_SAFE_INTEGER) return result;
        const bahtStr = Math.floor(num).toString();
        const satangStr = Math.round(num % 1 * 100).toString();
        const bahtArr = Array.from(bahtStr).map(Number);
        const satangArr = Array.from(satangStr).map(Number);
        let baht = num2Word(bahtArr);
        let satang = num2Word(satangArr);
        baht = grammarFix(baht);
        satang = grammarFix(satang);
        result = combine(baht, satang);
        return result;
      }
      if (typeof module2 !== "undefined" && module2.exports != null) {
        module2.exports = bahttext;
      }
    }
  });

  // node_modules/fast-formula-parser/formulas/functions/text.js
  var require_text = __commonJS({
    "node_modules/fast-formula-parser/formulas/functions/text.js"(exports2, module2) {
      var FormulaError2 = require_error();
      var { FormulaHelpers, Types, WildCard } = require_helpers();
      var H = FormulaHelpers;
      var ssf = require_ssf();
      var bahttext = require_src();
      var charsets = {
        latin: { halfRE: /[!-~]/g, fullRE: /[-]/g, delta: 65248 },
        hangul1: { halfRE: /[-]/g, fullRE: /[-]/g, delta: -60921 },
        hangul2: { halfRE: /[-]/g, fullRE: /[-]/g, delta: -61025 },
        kana: {
          delta: 0,
          half: "\uFF61\uFF62\uFF63\uFF64\uFF65\uFF66\uFF67\uFF68\uFF69\uFF6A\uFF6B\uFF6C\uFF6D\uFF6E\uFF6F\uFF70\uFF71\uFF72\uFF73\uFF74\uFF75\uFF76\uFF77\uFF78\uFF79\uFF7A\uFF7B\uFF7C\uFF7D\uFF7E\uFF7F\uFF80\uFF81\uFF82\uFF83\uFF84\uFF85\uFF86\uFF87\uFF88\uFF89\uFF8A\uFF8B\uFF8C\uFF8D\uFF8E\uFF8F\uFF90\uFF91\uFF92\uFF93\uFF94\uFF95\uFF96\uFF97\uFF98\uFF99\uFF9A\uFF9B\uFF9C\uFF9D\uFF9E\uFF9F",
          full: "\u3002\u300C\u300D\u3001\u30FB\u30F2\u30A1\u30A3\u30A5\u30A7\u30A9\u30E3\u30E5\u30E7\u30C3\u30FC\u30A2\u30A4\u30A6\u30A8\u30AA\u30AB\u30AD\u30AF\u30B1\u30B3\u30B5\u30B7\u30B9\u30BB\u30BD\u30BF\u30C1\u30C4\u30C6\u30C8\u30CA\u30CB\u30CC\u30CD\u30CE\u30CF\u30D2\u30D5\u30D8\u30DB\u30DE\u30DF\u30E0\u30E1\u30E2\u30E4\u30E6\u30E8\u30E9\u30EA\u30EB\u30EC\u30ED\u30EF\u30F3\u309B\u309C"
        },
        extras: {
          delta: 0,
          half: "\xA2\xA3\xAC\xAF\xA6\xA5\u20A9 |\u2190\u2191\u2192\u2193\u25A0\xB0",
          full: "\uFFE0\uFFE1\uFFE2\uFFE3\uFFE4\uFFE5\uFFE6\u3000\uFFE8\uFFE9\uFFEA\uFFEB\uFFEC\uFFED\uFFEE"
        }
      };
      var toFull = (set2) => (c) => set2.delta ? String.fromCharCode(c.charCodeAt(0) + set2.delta) : [...set2.full][[...set2.half].indexOf(c)];
      var toHalf = (set2) => (c) => set2.delta ? String.fromCharCode(c.charCodeAt(0) - set2.delta) : [...set2.half][[...set2.full].indexOf(c)];
      var re = (set2, way) => set2[way + "RE"] || new RegExp("[" + set2[way] + "]", "g");
      var sets = Object.keys(charsets).map((i) => charsets[i]);
      var toFullWidth = (str0) => sets.reduce((str, set2) => str.replace(re(set2, "half"), toFull(set2)), str0);
      var toHalfWidth = (str0) => sets.reduce((str, set2) => str.replace(re(set2, "full"), toHalf(set2)), str0);
      var TextFunctions = {
        ASC: (text) => {
          text = H.accept(text, Types.STRING);
          return toHalfWidth(text);
        },
        BAHTTEXT: (number) => {
          number = H.accept(number, Types.NUMBER);
          try {
            return bahttext(number);
          } catch (e) {
            throw Error(`Error in https://github.com/jojoee/bahttext 
${e.toString()}`);
          }
        },
        CHAR: (number) => {
          number = H.accept(number, Types.NUMBER);
          if (number > 255 || number < 1)
            throw FormulaError2.VALUE;
          return String.fromCharCode(number);
        },
        CLEAN: (text) => {
          text = H.accept(text, Types.STRING);
          return text.replace(/[\x00-\x1F]/g, "");
        },
        CODE: (text) => {
          text = H.accept(text, Types.STRING);
          if (text.length === 0)
            throw FormulaError2.VALUE;
          return text.charCodeAt(0);
        },
        CONCAT: (...params) => {
          let text = "";
          H.flattenParams(params, Types.STRING, false, (item) => {
            item = H.accept(item, Types.STRING);
            text += item;
          });
          return text;
        },
        CONCATENATE: (...params) => {
          let text = "";
          if (params.length === 0)
            throw Error("CONCATENATE need at least one argument.");
          params.forEach((param) => {
            param = H.accept(param, Types.STRING);
            text += param;
          });
          return text;
        },
        DBCS: (text) => {
          text = H.accept(text, Types.STRING);
          return toFullWidth(text);
        },
        DOLLAR: (number, decimals) => {
          number = H.accept(number, Types.NUMBER);
          decimals = H.accept(decimals, Types.NUMBER, 2);
          const decimalString = Array(decimals).fill("0").join("");
          return ssf.format(`$#,##0.${decimalString}_);($#,##0.${decimalString})`, number).trim();
        },
        EXACT: (text1, text2) => {
          text1 = H.accept(text1, [Types.STRING]);
          text2 = H.accept(text2, [Types.STRING]);
          return text1 === text2;
        },
        FIND: (findText, withinText, startNum) => {
          findText = H.accept(findText, Types.STRING);
          withinText = H.accept(withinText, Types.STRING);
          startNum = H.accept(startNum, Types.NUMBER, 1);
          if (startNum < 1 || startNum > withinText.length)
            throw FormulaError2.VALUE;
          const res = withinText.indexOf(findText, startNum - 1);
          if (res === -1)
            throw FormulaError2.VALUE;
          return res + 1;
        },
        FINDB: (...params) => {
          return TextFunctions.FIND(...params);
        },
        FIXED: (number, decimals, noCommas) => {
          number = H.accept(number, Types.NUMBER);
          decimals = H.accept(decimals, Types.NUMBER, 2);
          noCommas = H.accept(noCommas, Types.BOOLEAN, false);
          const decimalString = Array(decimals).fill("0").join("");
          const comma = noCommas ? "" : "#,";
          return ssf.format(`${comma}##0.${decimalString}_);(${comma}##0.${decimalString})`, number).trim();
        },
        LEFT: (text, numChars) => {
          text = H.accept(text, Types.STRING);
          numChars = H.accept(numChars, Types.NUMBER, 1);
          if (numChars < 0)
            throw FormulaError2.VALUE;
          if (numChars > text.length)
            return text;
          return text.slice(0, numChars);
        },
        LEFTB: (...params) => {
          return TextFunctions.LEFT(...params);
        },
        LEN: (text) => {
          text = H.accept(text, Types.STRING);
          return text.length;
        },
        LENB: (...params) => {
          return TextFunctions.LEN(...params);
        },
        LOWER: (text) => {
          text = H.accept(text, Types.STRING);
          return text.toLowerCase();
        },
        MID: (text, startNum, numChars) => {
          text = H.accept(text, Types.STRING);
          startNum = H.accept(startNum, Types.NUMBER);
          numChars = H.accept(numChars, Types.NUMBER);
          if (startNum > text.length)
            return "";
          if (startNum < 1 || numChars < 1)
            throw FormulaError2.VALUE;
          return text.slice(startNum - 1, startNum + numChars - 1);
        },
        MIDB: (...params) => {
          return TextFunctions.MID(...params);
        },
        NUMBERVALUE: (text, decimalSeparator, groupSeparator) => {
          text = H.accept(text, Types.STRING);
          decimalSeparator = H.accept(decimalSeparator, Types.STRING, ".");
          groupSeparator = H.accept(groupSeparator, Types.STRING, ",");
          if (text.length === 0)
            return 0;
          if (decimalSeparator.length === 0 || groupSeparator.length === 0)
            throw FormulaError2.VALUE;
          decimalSeparator = decimalSeparator[0];
          groupSeparator = groupSeparator[0];
          if (decimalSeparator === groupSeparator || text.indexOf(decimalSeparator) < text.lastIndexOf(groupSeparator))
            throw FormulaError2.VALUE;
          const res = text.replace(groupSeparator, "").replace(decimalSeparator, ".").replace(/[^\-0-9.%()]/g, "").match(/([(-]*)([0-9]*[.]*[0-9]+)([)]?)([%]*)/);
          if (!res)
            throw FormulaError2.VALUE;
          const leftParenOrMinus = res[1].length, rightParen = res[3].length, percent = res[4].length;
          let number = Number(res[2]);
          if (leftParenOrMinus > 1 || leftParenOrMinus && !rightParen || !leftParenOrMinus && rightParen || isNaN(number))
            throw FormulaError2.VALUE;
          number = number / 100 ** percent;
          return leftParenOrMinus ? -number : number;
        },
        PHONETIC: () => {
        },
        PROPER: (text) => {
          text = H.accept(text, [Types.STRING]);
          text = text.toLowerCase();
          text = text.charAt(0).toUpperCase() + text.slice(1);
          return text.replace(
            /(?:[^a-zA-Z])([a-zA-Z])/g,
            (letter) => letter.toUpperCase()
          );
        },
        REPLACE: (old_text, start_num, num_chars, new_text) => {
          old_text = H.accept(old_text, [Types.STRING]);
          start_num = H.accept(start_num, [Types.NUMBER]);
          num_chars = H.accept(num_chars, [Types.NUMBER]);
          new_text = H.accept(new_text, [Types.STRING]);
          let arr = old_text.split("");
          arr.splice(start_num - 1, num_chars, new_text);
          return arr.join("");
        },
        REPLACEB: (...params) => {
          return TextFunctions.REPLACE(...params);
        },
        REPT: (text, number_times) => {
          text = H.accept(text, Types.STRING);
          number_times = H.accept(number_times, Types.NUMBER);
          let str = "";
          for (let i = 0; i < number_times; i++) {
            str += text;
          }
          return str;
        },
        RIGHT: (text, numChars) => {
          text = H.accept(text, Types.STRING);
          numChars = H.accept(numChars, Types.NUMBER, 1);
          if (numChars < 0)
            throw FormulaError2.VALUE;
          const len = text.length;
          if (numChars > len)
            return text;
          return text.slice(len - numChars);
        },
        RIGHTB: (...params) => {
          return TextFunctions.RIGHT(...params);
        },
        SEARCH: (findText, withinText, startNum) => {
          findText = H.accept(findText, Types.STRING);
          withinText = H.accept(withinText, Types.STRING);
          startNum = H.accept(startNum, Types.NUMBER, 1);
          if (startNum < 1 || startNum > withinText.length)
            throw FormulaError2.VALUE;
          let findTextRegex = WildCard.isWildCard(findText) ? WildCard.toRegex(findText, "i") : findText;
          const res = withinText.slice(startNum - 1).search(findTextRegex);
          if (res === -1)
            throw FormulaError2.VALUE;
          return res + startNum;
        },
        SEARCHB: (...params) => {
          return TextFunctions.SEARCH(...params);
        },
        SUBSTITUTE: (...params) => {
        },
        T: (value) => {
          value = H.accept(value);
          if (typeof value === "string")
            return value;
          return "";
        },
        TEXT: (value, formatText) => {
          value = H.accept(value, Types.NUMBER);
          formatText = H.accept(formatText, Types.STRING);
          try {
            return ssf.format(formatText, value);
          } catch (e) {
            console.error(e);
            throw FormulaError2.VALUE;
          }
        },
        TEXTJOIN: (...params) => {
        },
        TRIM: (text) => {
          text = H.accept(text, [Types.STRING]);
          return text.replace(/^\s+|\s+$/g, "");
        },
        UNICHAR: (number) => {
          number = H.accept(number, [Types.NUMBER]);
          if (number <= 0)
            throw FormulaError2.VALUE;
          return String.fromCharCode(number);
        },
        UNICODE: (text) => {
          return TextFunctions.CODE(text);
        }
      };
      module2.exports = TextFunctions;
    }
  });

  // node_modules/fast-formula-parser/formulas/operators.js
  var require_operators = __commonJS({
    "node_modules/fast-formula-parser/formulas/operators.js"(exports2, module2) {
      var FormulaError2 = require_error();
      var { FormulaHelpers } = require_helpers();
      var Prefix = {
        unaryOp: (prefixes, value, isArray2) => {
          let sign = 1;
          prefixes.forEach((prefix) => {
            if (prefix === "+") {
            } else if (prefix === "-") {
              sign = -sign;
            } else {
              throw new Error(`Unrecognized prefix: ${prefix}`);
            }
          });
          if (value == null) {
            value = 0;
          }
          if (sign === 1) {
            return value;
          }
          try {
            value = FormulaHelpers.acceptNumber(value, isArray2);
          } catch (e) {
            if (e instanceof FormulaError2) {
              if (Array.isArray(value))
                value = value[0][0];
            } else
              throw e;
          }
          if (typeof value === "number" && isNaN(value)) return FormulaError2.VALUE;
          return -value;
        }
      };
      var Postfix = {
        percentOp: (value, postfix, isArray2) => {
          try {
            value = FormulaHelpers.acceptNumber(value, isArray2);
          } catch (e) {
            if (e instanceof FormulaError2)
              return e;
            throw e;
          }
          if (postfix === "%") {
            return value / 100;
          }
          throw new Error(`Unrecognized postfix: ${postfix}`);
        }
      };
      var type2Number = { "boolean": 3, "string": 2, "number": 1 };
      var Infix = {
        compareOp: (value1, infix, value2, isArray1, isArray2) => {
          if (value1 == null) value1 = 0;
          if (value2 == null) value2 = 0;
          if (isArray1) {
            value1 = value1[0][0];
          }
          if (isArray2) {
            value2 = value2[0][0];
          }
          const type1 = typeof value1, type2 = typeof value2;
          if (type1 === type2) {
            switch (infix) {
              case "=":
                return value1 === value2;
              case ">":
                return value1 > value2;
              case "<":
                return value1 < value2;
              case "<>":
                return value1 !== value2;
              case "<=":
                return value1 <= value2;
              case ">=":
                return value1 >= value2;
            }
          } else {
            switch (infix) {
              case "=":
                return false;
              case ">":
                return type2Number[type1] > type2Number[type2];
              case "<":
                return type2Number[type1] < type2Number[type2];
              case "<>":
                return true;
              case "<=":
                return type2Number[type1] <= type2Number[type2];
              case ">=":
                return type2Number[type1] >= type2Number[type2];
            }
          }
          throw Error("Infix.compareOp: Should not reach here.");
        },
        concatOp: (value1, infix, value2, isArray1, isArray2) => {
          if (value1 == null) value1 = "";
          if (value2 == null) value2 = "";
          if (isArray1) {
            value1 = value1[0][0];
          }
          if (isArray2) {
            value2 = value2[0][0];
          }
          const type1 = typeof value1, type2 = typeof value2;
          if (type1 === "boolean")
            value1 = value1 ? "TRUE" : "FALSE";
          if (type2 === "boolean")
            value2 = value2 ? "TRUE" : "FALSE";
          return "" + value1 + value2;
        },
        mathOp: (value1, infix, value2, isArray1, isArray2) => {
          if (value1 == null) value1 = 0;
          if (value2 == null) value2 = 0;
          try {
            value1 = FormulaHelpers.acceptNumber(value1, isArray1);
            value2 = FormulaHelpers.acceptNumber(value2, isArray2);
          } catch (e) {
            if (e instanceof FormulaError2)
              return e;
            throw e;
          }
          switch (infix) {
            case "+":
              return value1 + value2;
            case "-":
              return value1 - value2;
            case "*":
              return value1 * value2;
            case "/":
              if (value2 === 0)
                return FormulaError2.DIV0;
              return value1 / value2;
            case "^":
              return value1 ** value2;
          }
          throw Error("Infix.mathOp: Should not reach here.");
        }
      };
      module2.exports = {
        Prefix,
        Postfix,
        Infix,
        Operators: {
          compareOp: ["<", ">", "=", "<>", "<=", ">="],
          concatOp: ["&"],
          mathOp: ["+", "-", "*", "/", "^"]
        }
      };
    }
  });

  // node_modules/fast-formula-parser/formulas/functions/math.js
  var require_math = __commonJS({
    "node_modules/fast-formula-parser/formulas/functions/math.js"(exports2, module2) {
      var FormulaError2 = require_error();
      var { FormulaHelpers, Types, Factorials, Criteria } = require_helpers();
      var { Infix } = require_operators();
      var H = FormulaHelpers;
      var f = [];
      var fd = [];
      function factorial(n) {
        if (n <= 100)
          return Factorials[n];
        if (f[n] > 0)
          return f[n];
        return f[n] = factorial(n - 1) * n;
      }
      function factorialDouble(n) {
        if (n === 1 || n === 0)
          return 1;
        if (n === 2)
          return 2;
        if (fd[n] > 0)
          return fd[n];
        return fd[n] = factorialDouble(n - 2) * n;
      }
      var MathFunctions = {
        ABS: (number) => {
          number = H.accept(number, Types.NUMBER);
          return Math.abs(number);
        },
        AGGREGATE: (functionNum, options, ref1, ...refs) => {
        },
        ARABIC: (text) => {
          text = H.accept(text, Types.STRING).toUpperCase();
          if (!/^M*(?:D?C{0,3}|C[MD])(?:L?X{0,3}|X[CL])(?:V?I{0,3}|I[XV])$/.test(text)) {
            throw new FormulaError2("#VALUE!", "Invalid roman numeral in ARABIC evaluation.");
          }
          let r = 0;
          text.replace(/[MDLV]|C[MD]?|X[CL]?|I[XV]?/g, function(i) {
            r += {
              M: 1e3,
              CM: 900,
              D: 500,
              CD: 400,
              C: 100,
              XC: 90,
              L: 50,
              XL: 40,
              X: 10,
              IX: 9,
              V: 5,
              IV: 4,
              I: 1
            }[i];
          });
          return r;
        },
        BASE: (number, radix, minLength) => {
          number = H.accept(number, Types.NUMBER);
          if (number < 0 || number >= 2 ** 53)
            throw FormulaError2.NUM;
          radix = H.accept(radix, Types.NUMBER);
          if (radix < 2 || radix > 36)
            throw FormulaError2.NUM;
          minLength = H.accept(minLength, Types.NUMBER, 0);
          if (minLength < 0) {
            throw FormulaError2.NUM;
          }
          const result = number.toString(radix).toUpperCase();
          return new Array(Math.max(minLength + 1 - result.length, 0)).join("0") + result;
        },
        CEILING: (number, significance) => {
          number = H.accept(number, Types.NUMBER);
          significance = H.accept(significance, Types.NUMBER);
          if (significance === 0)
            return 0;
          if (number / significance % 1 === 0)
            return number;
          const absSignificance = Math.abs(significance);
          const times = Math.floor(Math.abs(number) / absSignificance);
          if (number < 0) {
            const roundDown = significance < 0;
            return roundDown ? -absSignificance * (times + 1) : -absSignificance * times;
          } else {
            return (times + 1) * absSignificance;
          }
        },
        "CEILING.MATH": (number, significance, mode) => {
          number = H.accept(number, Types.NUMBER);
          significance = H.accept(significance, Types.NUMBER, number > 0 ? 1 : -1);
          mode = H.accept(mode, Types.NUMBER, 0);
          if (number >= 0) {
            return MathFunctions.CEILING(number, significance);
          }
          const offset = mode ? significance : 0;
          return MathFunctions.CEILING(number, significance) - offset;
        },
        "CEILING.PRECISE": (number, significance) => {
          number = H.accept(number, Types.NUMBER);
          significance = H.accept(significance, Types.NUMBER, 1);
          return MathFunctions.CEILING(number, Math.abs(significance));
        },
        COMBIN: (number, numberChosen) => {
          number = H.accept(number, Types.NUMBER);
          numberChosen = H.accept(numberChosen, Types.NUMBER);
          if (number < 0 || numberChosen < 0 || number < numberChosen)
            throw FormulaError2.NUM;
          const nFactorial = MathFunctions.FACT(number), kFactorial = MathFunctions.FACT(numberChosen);
          return nFactorial / kFactorial / MathFunctions.FACT(number - numberChosen);
        },
        COMBINA: (number, numberChosen) => {
          number = H.accept(number, Types.NUMBER);
          numberChosen = H.accept(numberChosen, Types.NUMBER);
          if ((number === 0 || number === 1) && numberChosen === 0)
            return 1;
          if (number < 0 || numberChosen < 0)
            throw FormulaError2.NUM;
          return MathFunctions.COMBIN(number + numberChosen - 1, number - 1);
        },
        DECIMAL: (text, radix) => {
          text = H.accept(text, Types.STRING);
          radix = H.accept(radix, Types.NUMBER);
          radix = Math.trunc(radix);
          if (radix < 2 || radix > 36)
            throw FormulaError2.NUM;
          const res = parseInt(text, radix);
          if (isNaN(res))
            throw FormulaError2.NUM;
          return res;
        },
        DEGREES: (radians) => {
          radians = H.accept(radians, Types.NUMBER);
          return radians * (180 / Math.PI);
        },
        EVEN: (number) => {
          return MathFunctions.CEILING(number, -2);
        },
        EXP: (number) => {
          number = H.accept(number, Types.NUMBER);
          return Math.exp(number);
        },
        FACT: (number) => {
          number = H.accept(number, Types.NUMBER);
          number = Math.trunc(number);
          if (number > 170 || number < 0)
            throw FormulaError2.NUM;
          if (number <= 100)
            return Factorials[number];
          return factorial(number);
        },
        FACTDOUBLE: (number) => {
          number = H.accept(number, Types.NUMBER);
          number = Math.trunc(number);
          if (number < -1)
            throw FormulaError2.NUM;
          if (number === -1)
            return 1;
          return factorialDouble(number);
        },
        FLOOR: (number, significance) => {
          number = H.accept(number, Types.NUMBER);
          significance = H.accept(significance, Types.NUMBER);
          if (significance === 0)
            return 0;
          if (number > 0 && significance < 0)
            throw FormulaError2.NUM;
          if (number / significance % 1 === 0)
            return number;
          const absSignificance = Math.abs(significance);
          const times = Math.floor(Math.abs(number) / absSignificance);
          if (number < 0) {
            const roundDown = significance < 0;
            return roundDown ? -absSignificance * times : -absSignificance * (times + 1);
          } else {
            return times * absSignificance;
          }
        },
        "FLOOR.MATH": (number, significance, mode) => {
          number = H.accept(number, Types.NUMBER);
          significance = H.accept(significance, Types.NUMBER, number > 0 ? 1 : -1);
          mode = H.accept(mode, Types.NUMBER, 0);
          if (mode === 0 || number >= 0) {
            return MathFunctions.FLOOR(number, Math.abs(significance));
          }
          return MathFunctions.FLOOR(number, significance) + significance;
        },
        "FLOOR.PRECISE": (number, significance) => {
          number = H.accept(number, Types.NUMBER);
          significance = H.accept(significance, Types.NUMBER, 1);
          return MathFunctions.FLOOR(number, Math.abs(significance));
        },
        GCD: (...params) => {
          const arr = [];
          H.flattenParams(
            params,
            null,
            false,
            (param) => {
              param = typeof param === "boolean" ? NaN : Number(param);
              if (!isNaN(param)) {
                if (param < 0 || param > 9007199254740990)
                  throw FormulaError2.NUM;
                arr.push(Math.trunc(param));
              } else
                throw FormulaError2.VALUE;
            },
            0
          );
          let i, y, n = params.length, x = Math.abs(arr[0]);
          for (i = 1; i < n; i++) {
            y = Math.abs(arr[i]);
            while (x && y) {
              x > y ? x %= y : y %= x;
            }
            x += y;
          }
          return x;
        },
        INT: (number) => {
          number = H.accept(number, Types.NUMBER);
          return Math.floor(number);
        },
        "ISO.CEILING": (...params) => {
          return MathFunctions["CEILING.PRECISE"](...params);
        },
        LCM: (...params) => {
          const arr = [];
          H.flattenParams(
            params,
            null,
            false,
            (param) => {
              param = typeof param === "boolean" ? NaN : Number(param);
              if (!isNaN(param)) {
                if (param < 0 || param > 9007199254740990)
                  throw FormulaError2.NUM;
                arr.push(Math.trunc(param));
              } else
                throw FormulaError2.VALUE;
            },
            1
          );
          let n = arr.length, a = Math.abs(arr[0]);
          for (let i = 1; i < n; i++) {
            let b = Math.abs(arr[i]), c = a;
            while (a && b) {
              a > b ? a %= b : b %= a;
            }
            a = Math.abs(c * arr[i]) / (a + b);
          }
          return a;
        },
        LN: (number) => {
          number = H.accept(number, Types.NUMBER);
          return Math.log(number);
        },
        LOG: (number, base) => {
          number = H.accept(number, Types.NUMBER);
          base = H.accept(base, Types.NUMBER, 10);
          return Math.log(number) / Math.log(base);
        },
        LOG10: (number) => {
          number = H.accept(number, Types.NUMBER);
          return Math.log10(number);
        },
        MDETERM: (array) => {
          array = H.accept(array, Types.ARRAY, void 0, false, true);
          if (array[0].length !== array.length)
            throw FormulaError2.VALUE;
          const numRow = array.length, numCol = array[0].length;
          let det = 0, diagLeft, diagRight;
          if (numRow === 1) {
            return array[0][0];
          } else if (numRow === 2) {
            return array[0][0] * array[1][1] - array[0][1] * array[1][0];
          }
          for (let col = 0; col < numCol; col++) {
            diagLeft = array[0][col];
            diagRight = array[0][col];
            for (let row = 1; row < numRow; row++) {
              diagRight *= array[row][((col + row) % numCol + numCol) % numCol];
              diagLeft *= array[row][((col - row) % numCol + numCol) % numCol];
            }
            det += diagRight - diagLeft;
          }
          return det;
        },
        MINVERSE: (array) => {
        },
        MMULT: (array1, array2) => {
          array1 = H.accept(array1, Types.ARRAY, void 0, false, true);
          array2 = H.accept(array2, Types.ARRAY, void 0, false, true);
          const aNumRows = array1.length, aNumCols = array1[0].length, bNumRows = array2.length, bNumCols = array2[0].length, m = new Array(aNumRows);
          if (aNumCols !== bNumRows)
            throw FormulaError2.VALUE;
          for (let r = 0; r < aNumRows; r++) {
            m[r] = new Array(bNumCols);
            for (let c = 0; c < bNumCols; c++) {
              m[r][c] = 0;
              for (let i = 0; i < aNumCols; i++) {
                const v1 = array1[r][i], v2 = array2[i][c];
                if (typeof v1 !== "number" || typeof v2 !== "number") throw FormulaError2.VALUE;
                m[r][c] += array1[r][i] * array2[i][c];
              }
            }
          }
          return m;
        },
        MOD: (number, divisor) => {
          number = H.accept(number, Types.NUMBER);
          divisor = H.accept(divisor, Types.NUMBER);
          if (divisor === 0)
            throw FormulaError2.DIV0;
          return number - divisor * MathFunctions.INT(number / divisor);
        },
        MROUND: (number, multiple) => {
          number = H.accept(number, Types.NUMBER);
          multiple = H.accept(multiple, Types.NUMBER);
          if (multiple === 0)
            return 0;
          if (number > 0 && multiple < 0 || number < 0 && multiple > 0)
            throw FormulaError2.NUM;
          if (number / multiple % 1 === 0)
            return number;
          return Math.round(number / multiple) * multiple;
        },
        MULTINOMIAL: (...numbers) => {
          let numerator = 0, denominator = 1;
          H.flattenParams(numbers, Types.NUMBER, false, (number) => {
            if (number < 0)
              throw FormulaError2.NUM;
            numerator += number;
            denominator *= factorial(number);
          });
          return factorial(numerator) / denominator;
        },
        MUNIT: (dimension) => {
          dimension = H.accept(dimension, Types.NUMBER);
          const matrix = [];
          for (let row = 0; row < dimension; row++) {
            const rowArr = [];
            for (let col = 0; col < dimension; col++) {
              if (row === col)
                rowArr.push(1);
              else
                rowArr.push(0);
            }
            matrix.push(rowArr);
          }
          return matrix;
        },
        ODD: (number) => {
          number = H.accept(number, Types.NUMBER);
          if (number === 0)
            return 1;
          let temp = Math.ceil(Math.abs(number));
          temp = temp & 1 ? temp : temp + 1;
          return number > 0 ? temp : -temp;
        },
        PI: () => {
          return Math.PI;
        },
        POWER: (number, power) => {
          number = H.accept(number, Types.NUMBER);
          power = H.accept(power, Types.NUMBER);
          return number ** power;
        },
        PRODUCT: (...numbers) => {
          let product = 1;
          H.flattenParams(numbers, null, true, (number, info) => {
            const parsedNumber = Number(number);
            if (info.isLiteral && !isNaN(parsedNumber)) {
              product *= parsedNumber;
            } else {
              if (typeof number === "number")
                product *= number;
            }
          }, 1);
          return product;
        },
        QUOTIENT: (numerator, denominator) => {
          numerator = H.accept(numerator, Types.NUMBER);
          denominator = H.accept(denominator, Types.NUMBER);
          return Math.trunc(numerator / denominator);
        },
        RADIANS: (degrees) => {
          degrees = H.accept(degrees, Types.NUMBER);
          return degrees / 180 * Math.PI;
        },
        RAND: () => {
          return Math.random();
        },
        RANDBETWEEN: (bottom, top) => {
          bottom = H.accept(bottom, Types.NUMBER);
          top = H.accept(top, Types.NUMBER);
          return Math.floor(Math.random() * (top - bottom + 1) + bottom);
        },
        ROMAN: (number, form) => {
          number = H.accept(number, Types.NUMBER);
          form = H.accept(form, Types.NUMBER, 0);
          if (form !== 0)
            throw Error("ROMAN: only allows form=0 (classic form).");
          const digits = String(number).split("");
          const key = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
          let roman = "", i = 3;
          while (i--) {
            roman = (key[+digits.pop() + i * 10] || "") + roman;
          }
          return new Array(+digits.join("") + 1).join("M") + roman;
        },
        ROUND: (number, digits) => {
          number = H.accept(number, Types.NUMBER);
          digits = H.accept(digits, Types.NUMBER);
          const multiplier = Math.pow(10, Math.abs(digits));
          const sign = number > 0 ? 1 : -1;
          if (digits > 0) {
            return sign * Math.round(Math.abs(number) * multiplier) / multiplier;
          } else if (digits === 0) {
            return sign * Math.round(Math.abs(number));
          } else {
            return sign * Math.round(Math.abs(number) / multiplier) * multiplier;
          }
        },
        ROUNDDOWN: (number, digits) => {
          number = H.accept(number, Types.NUMBER);
          digits = H.accept(digits, Types.NUMBER);
          const multiplier = Math.pow(10, Math.abs(digits));
          const sign = number > 0 ? 1 : -1;
          if (digits > 0) {
            const offset = 1 / multiplier * 0.5;
            return sign * Math.round((Math.abs(number) - offset) * multiplier) / multiplier;
          } else if (digits === 0) {
            const offset = 0.5;
            return sign * Math.round(Math.abs(number) - offset);
          } else {
            const offset = multiplier * 0.5;
            return sign * Math.round((Math.abs(number) - offset) / multiplier) * multiplier;
          }
        },
        ROUNDUP: (number, digits) => {
          number = H.accept(number, Types.NUMBER);
          digits = H.accept(digits, Types.NUMBER);
          const multiplier = Math.pow(10, Math.abs(digits));
          const sign = number > 0 ? 1 : -1;
          if (digits > 0) {
            const offset = 1 / multiplier * 0.5;
            return sign * Math.round((Math.abs(number) + offset) * multiplier) / multiplier;
          } else if (digits === 0) {
            const offset = 0.5;
            return sign * Math.round(Math.abs(number) + offset);
          } else {
            const offset = multiplier * 0.5;
            return sign * Math.round((Math.abs(number) + offset) / multiplier) * multiplier;
          }
        },
        SERIESSUM: (x, n, m, coefficients) => {
          x = H.accept(x, Types.NUMBER);
          n = H.accept(n, Types.NUMBER);
          m = H.accept(m, Types.NUMBER);
          let i = 0, result;
          H.flattenParams([coefficients], Types.NUMBER, false, (coefficient) => {
            if (typeof coefficient !== "number") {
              throw FormulaError2.VALUE;
            }
            if (i === 0) {
              result = coefficient * Math.pow(x, n);
            } else {
              result += coefficient * Math.pow(x, n + i * m);
            }
            i++;
          });
          return result;
        },
        SIGN: (number) => {
          number = H.accept(number, Types.NUMBER);
          return number > 0 ? 1 : number === 0 ? 0 : -1;
        },
        SQRT: (number) => {
          number = H.accept(number, Types.NUMBER);
          if (number < 0)
            throw FormulaError2.NUM;
          return Math.sqrt(number);
        },
        SQRTPI: (number) => {
          number = H.accept(number, Types.NUMBER);
          if (number < 0)
            throw FormulaError2.NUM;
          return Math.sqrt(number * Math.PI);
        },
        SUBTOTAL: () => {
        },
        SUM: (...params) => {
          let result = 0;
          H.flattenParams(
            params,
            Types.NUMBER,
            true,
            (item, info) => {
              if (info.isLiteral) {
                result += item;
              } else {
                if (typeof item === "number")
                  result += item;
              }
            }
          );
          return result;
        },
        /**
         * This functions requires instance of {@link FormulaParser}.
         */
        SUMIF: (context2, range2, criteria, sumRange) => {
          const ranges = H.retrieveRanges(context2, range2, sumRange);
          range2 = ranges[0];
          sumRange = ranges[1];
          criteria = H.retrieveArg(context2, criteria);
          const isCriteriaArray = criteria.isArray;
          criteria = Criteria.parse(H.accept(criteria));
          let sum = 0;
          range2.forEach((row, rowNum) => {
            row.forEach((value, colNum) => {
              const valueToAdd = sumRange[rowNum][colNum];
              if (typeof valueToAdd !== "number")
                return;
              if (criteria.op === "wc") {
                if (criteria.match === criteria.value.test(value)) {
                  sum += valueToAdd;
                }
              } else if (Infix.compareOp(value, criteria.op, criteria.value, Array.isArray(value), isCriteriaArray)) {
                sum += valueToAdd;
              }
            });
          });
          return sum;
        },
        SUMIFS: () => {
        },
        SUMPRODUCT: (array1, ...arrays) => {
          array1 = H.accept(array1, Types.ARRAY, void 0, false, true);
          arrays.forEach((array) => {
            array = H.accept(array, Types.ARRAY, void 0, false, true);
            if (array1[0].length !== array[0].length || array1.length !== array.length)
              throw FormulaError2.VALUE;
            for (let i = 0; i < array1.length; i++) {
              for (let j = 0; j < array1[0].length; j++) {
                if (typeof array1[i][j] !== "number")
                  array1[i][j] = 0;
                if (typeof array[i][j] !== "number")
                  array[i][j] = 0;
                array1[i][j] *= array[i][j];
              }
            }
          });
          let result = 0;
          array1.forEach((row) => {
            row.forEach((value) => {
              result += value;
            });
          });
          return result;
        },
        SUMSQ: (...params) => {
          let result = 0;
          H.flattenParams(
            params,
            Types.NUMBER,
            true,
            (item, info) => {
              if (info.isLiteral) {
                result += item ** 2;
              } else {
                if (typeof item === "number")
                  result += item ** 2;
              }
            }
          );
          return result;
        },
        SUMX2MY2: (arrayX, arrayY) => {
          const x = [], y = [];
          let sum = 0;
          H.flattenParams([arrayX], null, false, (item, info) => {
            x.push(item);
          });
          H.flattenParams([arrayY], null, false, (item, info) => {
            y.push(item);
          });
          if (x.length !== y.length)
            throw FormulaError2.NA;
          for (let i = 0; i < x.length; i++) {
            if (typeof x[i] === "number" && typeof y[i] === "number")
              sum += x[i] ** 2 - y[i] ** 2;
          }
          return sum;
        },
        SUMX2PY2: (arrayX, arrayY) => {
          const x = [], y = [];
          let sum = 0;
          H.flattenParams([arrayX], null, false, (item, info) => {
            x.push(item);
          });
          H.flattenParams([arrayY], null, false, (item, info) => {
            y.push(item);
          });
          if (x.length !== y.length)
            throw FormulaError2.NA;
          for (let i = 0; i < x.length; i++) {
            if (typeof x[i] === "number" && typeof y[i] === "number")
              sum += x[i] ** 2 + y[i] ** 2;
          }
          return sum;
        },
        SUMXMY2: (arrayX, arrayY) => {
          const x = [], y = [];
          let sum = 0;
          H.flattenParams([arrayX], null, false, (item, info) => {
            x.push(item);
          });
          H.flattenParams([arrayY], null, false, (item, info) => {
            y.push(item);
          });
          if (x.length !== y.length)
            throw FormulaError2.NA;
          for (let i = 0; i < x.length; i++) {
            if (typeof x[i] === "number" && typeof y[i] === "number")
              sum += (x[i] - y[i]) ** 2;
          }
          return sum;
        },
        TRUNC: (number) => {
          number = H.accept(number, Types.NUMBER);
          return Math.trunc(number);
        }
      };
      module2.exports = MathFunctions;
    }
  });

  // node_modules/fast-formula-parser/formulas/functions/trigonometry.js
  var require_trigonometry = __commonJS({
    "node_modules/fast-formula-parser/formulas/functions/trigonometry.js"(exports2, module2) {
      var FormulaError2 = require_error();
      var { FormulaHelpers, Types } = require_helpers();
      var H = FormulaHelpers;
      var MAX_NUMBER = 2 ** 27 - 1;
      var TrigFunctions = {
        ACOS: (number) => {
          number = H.accept(number, Types.NUMBER);
          if (number > 1 || number < -1)
            throw FormulaError2.NUM;
          return Math.acos(number);
        },
        ACOSH: (number) => {
          number = H.accept(number, Types.NUMBER);
          if (number < 1)
            throw FormulaError2.NUM;
          return Math.acosh(number);
        },
        ACOT: (number) => {
          number = H.accept(number, Types.NUMBER);
          return Math.PI / 2 - Math.atan(number);
        },
        ACOTH: (number) => {
          number = H.accept(number, Types.NUMBER);
          if (Math.abs(number) <= 1)
            throw FormulaError2.NUM;
          return Math.atanh(1 / number);
        },
        ASIN: (number) => {
          number = H.accept(number, Types.NUMBER);
          if (number > 1 || number < -1)
            throw FormulaError2.NUM;
          return Math.asin(number);
        },
        ASINH: (number) => {
          number = H.accept(number, Types.NUMBER);
          return Math.asinh(number);
        },
        ATAN: (number) => {
          number = H.accept(number, Types.NUMBER);
          return Math.atan(number);
        },
        ATAN2: (x, y) => {
          x = H.accept(x, Types.NUMBER);
          y = H.accept(y, Types.NUMBER);
          if (y === 0 && x === 0)
            throw FormulaError2.DIV0;
          return Math.atan2(y, x);
        },
        ATANH: (number) => {
          number = H.accept(number, Types.NUMBER);
          if (Math.abs(number) > 1)
            throw FormulaError2.NUM;
          return Math.atanh(number);
        },
        COS: (number) => {
          number = H.accept(number, Types.NUMBER);
          if (Math.abs(number) > MAX_NUMBER)
            throw FormulaError2.NUM;
          return Math.cos(number);
        },
        COSH: (number) => {
          number = H.accept(number, Types.NUMBER);
          return Math.cosh(number);
        },
        COT: (number) => {
          number = H.accept(number, Types.NUMBER);
          if (Math.abs(number) > MAX_NUMBER)
            throw FormulaError2.NUM;
          if (number === 0)
            throw FormulaError2.DIV0;
          return 1 / Math.tan(number);
        },
        COTH: (number) => {
          number = H.accept(number, Types.NUMBER);
          if (number === 0)
            throw FormulaError2.DIV0;
          return 1 / Math.tanh(number);
        },
        CSC: (number) => {
          number = H.accept(number, Types.NUMBER);
          if (Math.abs(number) > MAX_NUMBER)
            throw FormulaError2.NUM;
          return 1 / Math.sin(number);
        },
        CSCH: (number) => {
          number = H.accept(number, Types.NUMBER);
          if (number === 0)
            throw FormulaError2.DIV0;
          return 1 / Math.sinh(number);
        },
        SEC: (number) => {
          number = H.accept(number, Types.NUMBER);
          if (Math.abs(number) > MAX_NUMBER)
            throw FormulaError2.NUM;
          return 1 / Math.cos(number);
        },
        SECH: (number) => {
          number = H.accept(number, Types.NUMBER);
          return 1 / Math.cosh(number);
        },
        SIN: (number) => {
          number = H.accept(number, Types.NUMBER);
          if (Math.abs(number) > MAX_NUMBER)
            throw FormulaError2.NUM;
          return Math.sin(number);
        },
        SINH: (number) => {
          number = H.accept(number, Types.NUMBER);
          return Math.sinh(number);
        },
        TAN: (number) => {
          number = H.accept(number, Types.NUMBER);
          if (Math.abs(number) > MAX_NUMBER)
            throw FormulaError2.NUM;
          return Math.tan(number);
        },
        TANH: (number) => {
          number = H.accept(number, Types.NUMBER);
          return Math.tanh(number);
        }
      };
      module2.exports = TrigFunctions;
    }
  });

  // node_modules/fast-formula-parser/formulas/functions/logical.js
  var require_logical = __commonJS({
    "node_modules/fast-formula-parser/formulas/functions/logical.js"(exports2, module2) {
      var FormulaError2 = require_error();
      var { FormulaHelpers, Types } = require_helpers();
      var H = FormulaHelpers;
      function getNumLogicalValue(params) {
        let numTrue = 0, numFalse = 0;
        H.flattenParams(params, null, true, (val) => {
          const type = typeof val;
          if (type === "string") {
            if (val === "TRUE")
              val = true;
            else if (val === "FALSE")
              val = false;
          } else if (type === "number")
            val = Boolean(val);
          if (typeof val === "boolean") {
            if (val === true)
              numTrue++;
            else
              numFalse++;
          }
        });
        return [numTrue, numFalse];
      }
      var LogicalFunctions = {
        AND: (...params) => {
          const [numTrue, numFalse] = getNumLogicalValue(params);
          if (numTrue === 0 && numFalse === 0)
            return FormulaError2.VALUE;
          return numTrue > 0 && numFalse === 0;
        },
        FALSE: () => {
          return false;
        },
        // Special
        IF: (context2, logicalTest, valueIfTrue, valueIfFalse) => {
          logicalTest = H.accept(logicalTest, Types.BOOLEAN);
          valueIfTrue = H.accept(valueIfTrue);
          valueIfFalse = H.accept(valueIfFalse, null, false);
          return logicalTest ? valueIfTrue : valueIfFalse;
        },
        IFERROR: (value, valueIfError) => {
          return value.value instanceof FormulaError2 ? H.accept(valueIfError) : H.accept(value);
        },
        IFNA: function(value, valueIfNa) {
          if (arguments.length > 2)
            throw FormulaError2.TOO_MANY_ARGS("IFNA");
          return FormulaError2.NA.equals(value.value) ? H.accept(valueIfNa) : H.accept(value);
        },
        IFS: (...params) => {
          if (params.length % 2 !== 0)
            return new FormulaError2("#N/A", "IFS expects all arguments after position 0 to be in pairs.");
          for (let i = 0; i < params.length / 2; i++) {
            const logicalTest = H.accept(params[i * 2], Types.BOOLEAN);
            const valueIfTrue = H.accept(params[i * 2 + 1]);
            if (logicalTest)
              return valueIfTrue;
          }
          return FormulaError2.NA;
        },
        NOT: (logical) => {
          logical = H.accept(logical, Types.BOOLEAN);
          return !logical;
        },
        OR: (...params) => {
          const [numTrue, numFalse] = getNumLogicalValue(params);
          if (numTrue === 0 && numFalse === 0)
            return FormulaError2.VALUE;
          return numTrue > 0;
        },
        SWITCH: (...params) => {
        },
        TRUE: () => {
          return true;
        },
        XOR: (...params) => {
          const [numTrue, numFalse] = getNumLogicalValue(params);
          if (numTrue === 0 && numFalse === 0)
            return FormulaError2.VALUE;
          return numTrue % 2 === 1;
        }
      };
      module2.exports = LogicalFunctions;
    }
  });

  // node_modules/bessel/bessel.js
  var require_bessel = __commonJS({
    "node_modules/bessel/bessel.js"(exports2) {
      var BESSEL;
      (function(factory) {
        if (typeof DO_NOT_EXPORT_BESSEL === "undefined") {
          if ("object" === typeof exports2) {
            factory(exports2);
          } else if ("function" === typeof define && define.amd) {
            define(function() {
              var module3 = {};
              factory(module3);
              return module3;
            });
          } else {
            factory(BESSEL = {});
          }
        } else {
          factory(BESSEL = {});
        }
      })(function(BESSEL2) {
        BESSEL2.version = "1.0.2";
        var M = Math;
        function _horner(arr, v) {
          for (var i = 0, z = 0; i < arr.length; ++i) z = v * z + arr[i];
          return z;
        }
        function _bessel_iter(x, n, f0, f1, sign) {
          if (n === 0) return f0;
          if (n === 1) return f1;
          var tdx = 2 / x, f2 = f1;
          for (var o = 1; o < n; ++o) {
            f2 = f1 * o * tdx + sign * f0;
            f0 = f1;
            f1 = f2;
          }
          return f2;
        }
        function _bessel_wrap(bessel0, bessel1, name, nonzero, sign) {
          return function bessel(x, n) {
            if (nonzero) {
              if (x === 0) return nonzero == 1 ? -Infinity : Infinity;
              else if (x < 0) return NaN;
            }
            if (n === 0) return bessel0(x);
            if (n === 1) return bessel1(x);
            if (n < 0) return NaN;
            n |= 0;
            var b0 = bessel0(x), b1 = bessel1(x);
            return _bessel_iter(x, n, b0, b1, sign);
          };
        }
        var besselj = (function() {
          var W = 0.636619772;
          var b0_a1a = [57568490574, -13362590354, 6516196407e-1, -1121442418e-2, 77392.33017, -184.9052456].reverse();
          var b0_a2a = [57568490411, 1029532985, 9494680718e-3, 59272.64853, 267.8532712, 1].reverse();
          var b0_a1b = [1, -0.001098628627, 2734510407e-14, -2073370639e-15, 2093887211e-16].reverse();
          var b0_a2b = [-0.01562499995, 1430488765e-13, -6911147651e-15, 7621095161e-16, -934935152e-16].reverse();
          function bessel0(x) {
            var a = 0, a1 = 0, a2 = 0, y = x * x;
            if (x < 8) {
              a1 = _horner(b0_a1a, y);
              a2 = _horner(b0_a2a, y);
              a = a1 / a2;
            } else {
              var xx = x - 0.785398164;
              y = 64 / y;
              a1 = _horner(b0_a1b, y);
              a2 = _horner(b0_a2b, y);
              a = M.sqrt(W / x) * (M.cos(xx) * a1 - M.sin(xx) * a2 * 8 / x);
            }
            return a;
          }
          var b1_a1a = [72362614232, -7895059235, 2423968531e-1, -2972611439e-3, 15704.4826, -30.16036606].reverse();
          var b1_a2a = [144725228442, 2300535178, 1858330474e-2, 99447.43394, 376.9991397, 1].reverse();
          var b1_a1b = [1, 183105e-8, -3516396496e-14, 2457520174e-15, -240337019e-15].reverse();
          var b1_a2b = [0.04687499995, -2002690873e-13, 8449199096e-15, -88228987e-14, 105787412e-15].reverse();
          function bessel1(x) {
            var a = 0, a1 = 0, a2 = 0, y = x * x, xx = M.abs(x) - 2.356194491;
            if (Math.abs(x) < 8) {
              a1 = x * _horner(b1_a1a, y);
              a2 = _horner(b1_a2a, y);
              a = a1 / a2;
            } else {
              y = 64 / y;
              a1 = _horner(b1_a1b, y);
              a2 = _horner(b1_a2b, y);
              a = M.sqrt(W / M.abs(x)) * (M.cos(xx) * a1 - M.sin(xx) * a2 * 8 / M.abs(x));
              if (x < 0) a = -a;
            }
            return a;
          }
          return function besselj2(x, n) {
            n = Math.round(n);
            if (!isFinite(x)) return isNaN(x) ? x : 0;
            if (n < 0) return (n % 2 ? -1 : 1) * besselj2(x, -n);
            if (x < 0) return (n % 2 ? -1 : 1) * besselj2(-x, n);
            if (n === 0) return bessel0(x);
            if (n === 1) return bessel1(x);
            if (x === 0) return 0;
            var ret = 0;
            if (x > n) {
              ret = _bessel_iter(x, n, bessel0(x), bessel1(x), -1);
            } else {
              var m = 2 * M.floor((n + M.floor(M.sqrt(40 * n))) / 2);
              var jsum = false;
              var bjp = 0, sum = 0;
              var bj = 1, bjm = 0;
              var tox = 2 / x;
              for (var j = m; j > 0; j--) {
                bjm = j * tox * bj - bjp;
                bjp = bj;
                bj = bjm;
                if (M.abs(bj) > 1e10) {
                  bj *= 1e-10;
                  bjp *= 1e-10;
                  ret *= 1e-10;
                  sum *= 1e-10;
                }
                if (jsum) sum += bj;
                jsum = !jsum;
                if (j == n) ret = bjp;
              }
              sum = 2 * sum - bj;
              ret /= sum;
            }
            return ret;
          };
        })();
        var bessely = (function() {
          var W = 0.636619772;
          var b0_a1a = [-2957821389, 7062834065, -5123598036e-1, 1087988129e-2, -86327.92757, 228.4622733].reverse();
          var b0_a2a = [40076544269, 7452499648e-1, 7189466438e-3, 47447.2647, 226.1030244, 1].reverse();
          var b0_a1b = [1, -0.001098628627, 2734510407e-14, -2073370639e-15, 2093887211e-16].reverse();
          var b0_a2b = [-0.01562499995, 1430488765e-13, -6911147651e-15, 7621095161e-16, -934945152e-16].reverse();
          function bessel0(x) {
            var a = 0, a1 = 0, a2 = 0, y = x * x, xx = x - 0.785398164;
            if (x < 8) {
              a1 = _horner(b0_a1a, y);
              a2 = _horner(b0_a2a, y);
              a = a1 / a2 + W * besselj(x, 0) * M.log(x);
            } else {
              y = 64 / y;
              a1 = _horner(b0_a1b, y);
              a2 = _horner(b0_a2b, y);
              a = M.sqrt(W / x) * (M.sin(xx) * a1 + M.cos(xx) * a2 * 8 / x);
            }
            return a;
          }
          var b1_a1a = [-4900604943e3, 127527439e4, -51534381390, 7349264551e-1, -4237922726e-3, 8511.937935].reverse();
          var b1_a2a = [249958057e5, 424441966400, 3733650367, 2245904002e-2, 102042.605, 354.9632885, 1].reverse();
          var b1_a1b = [1, 183105e-8, -3516396496e-14, 2457520174e-15, -240337019e-15].reverse();
          var b1_a2b = [0.04687499995, -2002690873e-13, 8449199096e-15, -88228987e-14, 105787412e-15].reverse();
          function bessel1(x) {
            var a = 0, a1 = 0, a2 = 0, y = x * x, xx = x - 2.356194491;
            if (x < 8) {
              a1 = x * _horner(b1_a1a, y);
              a2 = _horner(b1_a2a, y);
              a = a1 / a2 + W * (besselj(x, 1) * M.log(x) - 1 / x);
            } else {
              y = 64 / y;
              a1 = _horner(b1_a1b, y);
              a2 = _horner(b1_a2b, y);
              a = M.sqrt(W / x) * (M.sin(xx) * a1 + M.cos(xx) * a2 * 8 / x);
            }
            return a;
          }
          return _bessel_wrap(bessel0, bessel1, "BESSELY", 1, -1);
        })();
        var besseli = (function() {
          var b0_a = [1, 3.5156229, 3.0899424, 1.2067492, 0.2659732, 0.0360768, 45813e-7].reverse();
          var b0_b = [0.39894228, 0.01328592, 225319e-8, -157565e-8, 916281e-8, -0.02057706, 0.02635537, -0.01647633, 392377e-8].reverse();
          function bessel0(x) {
            if (x <= 3.75) return _horner(b0_a, x * x / (3.75 * 3.75));
            return M.exp(M.abs(x)) / M.sqrt(M.abs(x)) * _horner(b0_b, 3.75 / M.abs(x));
          }
          var b1_a = [0.5, 0.87890594, 0.51498869, 0.15084934, 0.02658733, 301532e-8, 32411e-8].reverse();
          var b1_b = [0.39894228, -0.03988024, -362018e-8, 163801e-8, -0.01031555, 0.02282967, -0.02895312, 0.01787654, -420059e-8].reverse();
          function bessel1(x) {
            if (x < 3.75) return x * _horner(b1_a, x * x / (3.75 * 3.75));
            return (x < 0 ? -1 : 1) * M.exp(M.abs(x)) / M.sqrt(M.abs(x)) * _horner(b1_b, 3.75 / M.abs(x));
          }
          return function besseli2(x, n) {
            n = Math.round(n);
            if (n === 0) return bessel0(x);
            if (n === 1) return bessel1(x);
            if (n < 0) return NaN;
            if (M.abs(x) === 0) return 0;
            if (x == Infinity) return Infinity;
            var ret = 0, j, tox = 2 / M.abs(x), bip = 0, bi = 1, bim = 0;
            var m = 2 * M.round((n + M.round(M.sqrt(40 * n))) / 2);
            for (j = m; j > 0; j--) {
              bim = j * tox * bi + bip;
              bip = bi;
              bi = bim;
              if (M.abs(bi) > 1e10) {
                bi *= 1e-10;
                bip *= 1e-10;
                ret *= 1e-10;
              }
              if (j == n) ret = bip;
            }
            ret *= besseli2(x, 0) / bi;
            return x < 0 && n % 2 ? -ret : ret;
          };
        })();
        var besselk = (function() {
          var b0_a = [-0.57721566, 0.4227842, 0.23069756, 0.0348859, 262698e-8, 1075e-7, 74e-7].reverse();
          var b0_b = [1.25331414, -0.07832358, 0.02189568, -0.01062446, 587872e-8, -25154e-7, 53208e-8].reverse();
          function bessel0(x) {
            if (x <= 2) return -M.log(x / 2) * besseli(x, 0) + _horner(b0_a, x * x / 4);
            return M.exp(-x) / M.sqrt(x) * _horner(b0_b, 2 / x);
          }
          var b1_a = [1, 0.15443144, -0.67278579, -0.18156897, -0.01919402, -110404e-8, -4686e-8].reverse();
          var b1_b = [1.25331414, 0.23498619, -0.0365562, 0.01504268, -780353e-8, 325614e-8, -68245e-8].reverse();
          function bessel1(x) {
            if (x <= 2) return M.log(x / 2) * besseli(x, 1) + 1 / x * _horner(b1_a, x * x / 4);
            return M.exp(-x) / M.sqrt(x) * _horner(b1_b, 2 / x);
          }
          return _bessel_wrap(bessel0, bessel1, "BESSELK", 2, 1);
        })();
        BESSEL2.besselj = besselj;
        BESSEL2.bessely = bessely;
        BESSEL2.besseli = besseli;
        BESSEL2.besselk = besselk;
      });
    }
  });

  // node_modules/jstat/dist/jstat.js
  var require_jstat = __commonJS({
    "node_modules/jstat/dist/jstat.js"(exports2, module2) {
      (function(window2, factory) {
        if (typeof exports2 === "object") {
          module2.exports = factory();
        } else if (typeof define === "function" && define.amd) {
          define(factory);
        } else {
          window2.jStat = factory();
        }
      })(exports2, function() {
        var jStat = (function(Math2, undefined2) {
          var concat = Array.prototype.concat;
          var slice2 = Array.prototype.slice;
          var toString2 = Object.prototype.toString;
          function calcRdx(n, m) {
            var val = n > m ? n : m;
            return Math2.pow(
              10,
              17 - ~~(Math2.log(val > 0 ? val : -val) * Math2.LOG10E)
            );
          }
          var isArray2 = Array.isArray || function isArray3(arg) {
            return toString2.call(arg) === "[object Array]";
          };
          function isFunction2(arg) {
            return toString2.call(arg) === "[object Function]";
          }
          function isNumber(num) {
            return typeof num === "number" ? num - num === 0 : false;
          }
          function toVector(arr) {
            return concat.apply([], arr);
          }
          function jStat2() {
            return new jStat2._init(arguments);
          }
          jStat2.fn = jStat2.prototype;
          jStat2._init = function _init(args) {
            if (isArray2(args[0])) {
              if (isArray2(args[0][0])) {
                if (isFunction2(args[1]))
                  args[0] = jStat2.map(args[0], args[1]);
                for (var i = 0; i < args[0].length; i++)
                  this[i] = args[0][i];
                this.length = args[0].length;
              } else {
                this[0] = isFunction2(args[1]) ? jStat2.map(args[0], args[1]) : args[0];
                this.length = 1;
              }
            } else if (isNumber(args[0])) {
              this[0] = jStat2.seq.apply(null, args);
              this.length = 1;
            } else if (args[0] instanceof jStat2) {
              return jStat2(args[0].toArray());
            } else {
              this[0] = [];
              this.length = 1;
            }
            return this;
          };
          jStat2._init.prototype = jStat2.prototype;
          jStat2._init.constructor = jStat2;
          jStat2.utils = {
            calcRdx,
            isArray: isArray2,
            isFunction: isFunction2,
            isNumber,
            toVector
          };
          jStat2._random_fn = Math2.random;
          jStat2.setRandom = function setRandom(fn) {
            if (typeof fn !== "function")
              throw new TypeError("fn is not a function");
            jStat2._random_fn = fn;
          };
          jStat2.extend = function extend(obj) {
            var i, j;
            if (arguments.length === 1) {
              for (j in obj)
                jStat2[j] = obj[j];
              return this;
            }
            for (i = 1; i < arguments.length; i++) {
              for (j in arguments[i])
                obj[j] = arguments[i][j];
            }
            return obj;
          };
          jStat2.rows = function rows(arr) {
            return arr.length || 1;
          };
          jStat2.cols = function cols(arr) {
            return arr[0].length || 1;
          };
          jStat2.dimensions = function dimensions(arr) {
            return {
              rows: jStat2.rows(arr),
              cols: jStat2.cols(arr)
            };
          };
          jStat2.row = function row(arr, index) {
            if (isArray2(index)) {
              return index.map(function(i) {
                return jStat2.row(arr, i);
              });
            }
            return arr[index];
          };
          jStat2.rowa = function rowa(arr, i) {
            return jStat2.row(arr, i);
          };
          jStat2.col = function col(arr, index) {
            if (isArray2(index)) {
              var submat = jStat2.arange(arr.length).map(function() {
                return new Array(index.length);
              });
              index.forEach(function(ind, i2) {
                jStat2.arange(arr.length).forEach(function(j) {
                  submat[j][i2] = arr[j][ind];
                });
              });
              return submat;
            }
            var column = new Array(arr.length);
            for (var i = 0; i < arr.length; i++)
              column[i] = [arr[i][index]];
            return column;
          };
          jStat2.cola = function cola(arr, i) {
            return jStat2.col(arr, i).map(function(a) {
              return a[0];
            });
          };
          jStat2.diag = function diag(arr) {
            var nrow = jStat2.rows(arr);
            var res = new Array(nrow);
            for (var row = 0; row < nrow; row++)
              res[row] = [arr[row][row]];
            return res;
          };
          jStat2.antidiag = function antidiag(arr) {
            var nrow = jStat2.rows(arr) - 1;
            var res = new Array(nrow);
            for (var i = 0; nrow >= 0; nrow--, i++)
              res[i] = [arr[i][nrow]];
            return res;
          };
          jStat2.transpose = function transpose(arr) {
            var obj = [];
            var objArr, rows, cols, j, i;
            if (!isArray2(arr[0]))
              arr = [arr];
            rows = arr.length;
            cols = arr[0].length;
            for (i = 0; i < cols; i++) {
              objArr = new Array(rows);
              for (j = 0; j < rows; j++)
                objArr[j] = arr[j][i];
              obj.push(objArr);
            }
            return obj.length === 1 ? obj[0] : obj;
          };
          jStat2.map = function map3(arr, func, toAlter) {
            var row, nrow, ncol, res, col;
            if (!isArray2(arr[0]))
              arr = [arr];
            nrow = arr.length;
            ncol = arr[0].length;
            res = toAlter ? arr : new Array(nrow);
            for (row = 0; row < nrow; row++) {
              if (!res[row])
                res[row] = new Array(ncol);
              for (col = 0; col < ncol; col++)
                res[row][col] = func(arr[row][col], row, col);
            }
            return res.length === 1 ? res[0] : res;
          };
          jStat2.cumreduce = function cumreduce(arr, func, toAlter) {
            var row, nrow, ncol, res, col;
            if (!isArray2(arr[0]))
              arr = [arr];
            nrow = arr.length;
            ncol = arr[0].length;
            res = toAlter ? arr : new Array(nrow);
            for (row = 0; row < nrow; row++) {
              if (!res[row])
                res[row] = new Array(ncol);
              if (ncol > 0)
                res[row][0] = arr[row][0];
              for (col = 1; col < ncol; col++)
                res[row][col] = func(res[row][col - 1], arr[row][col]);
            }
            return res.length === 1 ? res[0] : res;
          };
          jStat2.alter = function alter(arr, func) {
            return jStat2.map(arr, func, true);
          };
          jStat2.create = function create(rows, cols, func) {
            var res = new Array(rows);
            var i, j;
            if (isFunction2(cols)) {
              func = cols;
              cols = rows;
            }
            for (i = 0; i < rows; i++) {
              res[i] = new Array(cols);
              for (j = 0; j < cols; j++)
                res[i][j] = func(i, j);
            }
            return res;
          };
          function retZero() {
            return 0;
          }
          jStat2.zeros = function zeros(rows, cols) {
            if (!isNumber(cols))
              cols = rows;
            return jStat2.create(rows, cols, retZero);
          };
          function retOne() {
            return 1;
          }
          jStat2.ones = function ones(rows, cols) {
            if (!isNumber(cols))
              cols = rows;
            return jStat2.create(rows, cols, retOne);
          };
          jStat2.rand = function rand(rows, cols) {
            if (!isNumber(cols))
              cols = rows;
            return jStat2.create(rows, cols, jStat2._random_fn);
          };
          function retIdent(i, j) {
            return i === j ? 1 : 0;
          }
          jStat2.identity = function identity(rows, cols) {
            if (!isNumber(cols))
              cols = rows;
            return jStat2.create(rows, cols, retIdent);
          };
          jStat2.symmetric = function symmetric(arr) {
            var size = arr.length;
            var row, col;
            if (arr.length !== arr[0].length)
              return false;
            for (row = 0; row < size; row++) {
              for (col = 0; col < size; col++)
                if (arr[col][row] !== arr[row][col])
                  return false;
            }
            return true;
          };
          jStat2.clear = function clear2(arr) {
            return jStat2.alter(arr, retZero);
          };
          jStat2.seq = function seq(min, max, length, func) {
            if (!isFunction2(func))
              func = false;
            var arr = [];
            var hival = calcRdx(min, max);
            var step = (max * hival - min * hival) / ((length - 1) * hival);
            var current = min;
            var cnt;
            for (cnt = 0; current <= max && cnt < length; cnt++, current = (min * hival + step * hival * cnt) / hival) {
              arr.push(func ? func(current, cnt) : current);
            }
            return arr;
          };
          jStat2.arange = function arange(start, end, step) {
            var rl = [];
            var i;
            step = step || 1;
            if (end === undefined2) {
              end = start;
              start = 0;
            }
            if (start === end || step === 0) {
              return [];
            }
            if (start < end && step < 0) {
              return [];
            }
            if (start > end && step > 0) {
              return [];
            }
            if (step > 0) {
              for (i = start; i < end; i += step) {
                rl.push(i);
              }
            } else {
              for (i = start; i > end; i += step) {
                rl.push(i);
              }
            }
            return rl;
          };
          jStat2.slice = /* @__PURE__ */ (function() {
            function _slice(list, start, end, step) {
              var i;
              var rl = [];
              var length = list.length;
              if (start === undefined2 && end === undefined2 && step === undefined2) {
                return jStat2.copy(list);
              }
              start = start || 0;
              end = end || list.length;
              start = start >= 0 ? start : length + start;
              end = end >= 0 ? end : length + end;
              step = step || 1;
              if (start === end || step === 0) {
                return [];
              }
              if (start < end && step < 0) {
                return [];
              }
              if (start > end && step > 0) {
                return [];
              }
              if (step > 0) {
                for (i = start; i < end; i += step) {
                  rl.push(list[i]);
                }
              } else {
                for (i = start; i > end; i += step) {
                  rl.push(list[i]);
                }
              }
              return rl;
            }
            function slice3(list, rcSlice) {
              var colSlice, rowSlice;
              rcSlice = rcSlice || {};
              if (isNumber(rcSlice.row)) {
                if (isNumber(rcSlice.col))
                  return list[rcSlice.row][rcSlice.col];
                var row = jStat2.rowa(list, rcSlice.row);
                colSlice = rcSlice.col || {};
                return _slice(row, colSlice.start, colSlice.end, colSlice.step);
              }
              if (isNumber(rcSlice.col)) {
                var col = jStat2.cola(list, rcSlice.col);
                rowSlice = rcSlice.row || {};
                return _slice(col, rowSlice.start, rowSlice.end, rowSlice.step);
              }
              rowSlice = rcSlice.row || {};
              colSlice = rcSlice.col || {};
              var rows = _slice(list, rowSlice.start, rowSlice.end, rowSlice.step);
              return rows.map(function(row2) {
                return _slice(row2, colSlice.start, colSlice.end, colSlice.step);
              });
            }
            return slice3;
          })();
          jStat2.sliceAssign = function sliceAssign(A, rcSlice, B) {
            var nl, ml;
            if (isNumber(rcSlice.row)) {
              if (isNumber(rcSlice.col))
                return A[rcSlice.row][rcSlice.col] = B;
              rcSlice.col = rcSlice.col || {};
              rcSlice.col.start = rcSlice.col.start || 0;
              rcSlice.col.end = rcSlice.col.end || A[0].length;
              rcSlice.col.step = rcSlice.col.step || 1;
              nl = jStat2.arange(
                rcSlice.col.start,
                Math2.min(A.length, rcSlice.col.end),
                rcSlice.col.step
              );
              var m = rcSlice.row;
              nl.forEach(function(n2, i) {
                A[m][n2] = B[i];
              });
              return A;
            }
            if (isNumber(rcSlice.col)) {
              rcSlice.row = rcSlice.row || {};
              rcSlice.row.start = rcSlice.row.start || 0;
              rcSlice.row.end = rcSlice.row.end || A.length;
              rcSlice.row.step = rcSlice.row.step || 1;
              ml = jStat2.arange(
                rcSlice.row.start,
                Math2.min(A[0].length, rcSlice.row.end),
                rcSlice.row.step
              );
              var n = rcSlice.col;
              ml.forEach(function(m2, j) {
                A[m2][n] = B[j];
              });
              return A;
            }
            if (B[0].length === undefined2) {
              B = [B];
            }
            rcSlice.row.start = rcSlice.row.start || 0;
            rcSlice.row.end = rcSlice.row.end || A.length;
            rcSlice.row.step = rcSlice.row.step || 1;
            rcSlice.col.start = rcSlice.col.start || 0;
            rcSlice.col.end = rcSlice.col.end || A[0].length;
            rcSlice.col.step = rcSlice.col.step || 1;
            ml = jStat2.arange(
              rcSlice.row.start,
              Math2.min(A.length, rcSlice.row.end),
              rcSlice.row.step
            );
            nl = jStat2.arange(
              rcSlice.col.start,
              Math2.min(A[0].length, rcSlice.col.end),
              rcSlice.col.step
            );
            ml.forEach(function(m2, i) {
              nl.forEach(function(n2, j) {
                A[m2][n2] = B[i][j];
              });
            });
            return A;
          };
          jStat2.diagonal = function diagonal(diagArray) {
            var mat = jStat2.zeros(diagArray.length, diagArray.length);
            diagArray.forEach(function(t, i) {
              mat[i][i] = t;
            });
            return mat;
          };
          jStat2.copy = function copy2(A) {
            return A.map(function(row) {
              if (isNumber(row))
                return row;
              return row.map(function(t) {
                return t;
              });
            });
          };
          var jProto = jStat2.prototype;
          jProto.length = 0;
          jProto.push = Array.prototype.push;
          jProto.sort = Array.prototype.sort;
          jProto.splice = Array.prototype.splice;
          jProto.slice = Array.prototype.slice;
          jProto.toArray = function toArray2() {
            return this.length > 1 ? slice2.call(this) : slice2.call(this)[0];
          };
          jProto.map = function map3(func, toAlter) {
            return jStat2(jStat2.map(this, func, toAlter));
          };
          jProto.cumreduce = function cumreduce(func, toAlter) {
            return jStat2(jStat2.cumreduce(this, func, toAlter));
          };
          jProto.alter = function alter(func) {
            jStat2.alter(this, func);
            return this;
          };
          (function(funcs) {
            for (var i = 0; i < funcs.length; i++) (function(passfunc) {
              jProto[passfunc] = function(func) {
                var self2 = this, results;
                if (func) {
                  setTimeout(function() {
                    func.call(self2, jProto[passfunc].call(self2));
                  });
                  return this;
                }
                results = jStat2[passfunc](this);
                return isArray2(results) ? jStat2(results) : results;
              };
            })(funcs[i]);
          })("transpose clear symmetric rows cols dimensions diag antidiag".split(" "));
          (function(funcs) {
            for (var i = 0; i < funcs.length; i++) (function(passfunc) {
              jProto[passfunc] = function(index, func) {
                var self2 = this;
                if (func) {
                  setTimeout(function() {
                    func.call(self2, jProto[passfunc].call(self2, index));
                  });
                  return this;
                }
                return jStat2(jStat2[passfunc](this, index));
              };
            })(funcs[i]);
          })("row col".split(" "));
          (function(funcs) {
            for (var i = 0; i < funcs.length; i++) (function(passfunc) {
              jProto[passfunc] = function() {
                return jStat2(jStat2[passfunc].apply(null, arguments));
              };
            })(funcs[i]);
          })("create zeros ones rand identity".split(" "));
          return jStat2;
        })(Math);
        (function(jStat2, Math2) {
          var isFunction2 = jStat2.utils.isFunction;
          function ascNum(a, b) {
            return a - b;
          }
          function clip(arg, min, max) {
            return Math2.max(min, Math2.min(arg, max));
          }
          jStat2.sum = function sum(arr) {
            var sum2 = 0;
            var i = arr.length;
            while (--i >= 0)
              sum2 += arr[i];
            return sum2;
          };
          jStat2.sumsqrd = function sumsqrd(arr) {
            var sum = 0;
            var i = arr.length;
            while (--i >= 0)
              sum += arr[i] * arr[i];
            return sum;
          };
          jStat2.sumsqerr = function sumsqerr(arr) {
            var mean = jStat2.mean(arr);
            var sum = 0;
            var i = arr.length;
            var tmp;
            while (--i >= 0) {
              tmp = arr[i] - mean;
              sum += tmp * tmp;
            }
            return sum;
          };
          jStat2.sumrow = function sumrow(arr) {
            var sum = 0;
            var i = arr.length;
            while (--i >= 0)
              sum += arr[i];
            return sum;
          };
          jStat2.product = function product(arr) {
            var prod = 1;
            var i = arr.length;
            while (--i >= 0)
              prod *= arr[i];
            return prod;
          };
          jStat2.min = function min(arr) {
            var low = arr[0];
            var i = 0;
            while (++i < arr.length)
              if (arr[i] < low)
                low = arr[i];
            return low;
          };
          jStat2.max = function max(arr) {
            var high = arr[0];
            var i = 0;
            while (++i < arr.length)
              if (arr[i] > high)
                high = arr[i];
            return high;
          };
          jStat2.unique = function unique(arr) {
            var hash = {}, _arr = [];
            for (var i = 0; i < arr.length; i++) {
              if (!hash[arr[i]]) {
                hash[arr[i]] = true;
                _arr.push(arr[i]);
              }
            }
            return _arr;
          };
          jStat2.mean = function mean(arr) {
            return jStat2.sum(arr) / arr.length;
          };
          jStat2.meansqerr = function meansqerr(arr) {
            return jStat2.sumsqerr(arr) / arr.length;
          };
          jStat2.geomean = function geomean(arr) {
            var logs = arr.map(Math2.log);
            var meanOfLogs = jStat2.mean(logs);
            return Math2.exp(meanOfLogs);
          };
          jStat2.median = function median(arr) {
            var arrlen = arr.length;
            var _arr = arr.slice().sort(ascNum);
            return !(arrlen & 1) ? (_arr[arrlen / 2 - 1] + _arr[arrlen / 2]) / 2 : _arr[arrlen / 2 | 0];
          };
          jStat2.cumsum = function cumsum(arr) {
            return jStat2.cumreduce(arr, function(a, b) {
              return a + b;
            });
          };
          jStat2.cumprod = function cumprod(arr) {
            return jStat2.cumreduce(arr, function(a, b) {
              return a * b;
            });
          };
          jStat2.diff = function diff(arr) {
            var diffs = [];
            var arrLen = arr.length;
            var i;
            for (i = 1; i < arrLen; i++)
              diffs.push(arr[i] - arr[i - 1]);
            return diffs;
          };
          jStat2.rank = function(arr) {
            var i;
            var distinctNumbers = [];
            var numberCounts = {};
            for (i = 0; i < arr.length; i++) {
              var number = arr[i];
              if (numberCounts[number]) {
                numberCounts[number]++;
              } else {
                numberCounts[number] = 1;
                distinctNumbers.push(number);
              }
            }
            var sortedDistinctNumbers = distinctNumbers.sort(ascNum);
            var numberRanks = {};
            var currentRank = 1;
            for (i = 0; i < sortedDistinctNumbers.length; i++) {
              var number = sortedDistinctNumbers[i];
              var count = numberCounts[number];
              var first2 = currentRank;
              var last2 = currentRank + count - 1;
              var rank = (first2 + last2) / 2;
              numberRanks[number] = rank;
              currentRank += count;
            }
            return arr.map(function(number2) {
              return numberRanks[number2];
            });
          };
          jStat2.mode = function mode(arr) {
            var arrLen = arr.length;
            var _arr = arr.slice().sort(ascNum);
            var count = 1;
            var maxCount = 0;
            var numMaxCount = 0;
            var mode_arr = [];
            var i;
            for (i = 0; i < arrLen; i++) {
              if (_arr[i] === _arr[i + 1]) {
                count++;
              } else {
                if (count > maxCount) {
                  mode_arr = [_arr[i]];
                  maxCount = count;
                  numMaxCount = 0;
                } else if (count === maxCount) {
                  mode_arr.push(_arr[i]);
                  numMaxCount++;
                }
                count = 1;
              }
            }
            return numMaxCount === 0 ? mode_arr[0] : mode_arr;
          };
          jStat2.range = function range2(arr) {
            return jStat2.max(arr) - jStat2.min(arr);
          };
          jStat2.variance = function variance(arr, flag) {
            return jStat2.sumsqerr(arr) / (arr.length - (flag ? 1 : 0));
          };
          jStat2.pooledvariance = function pooledvariance(arr) {
            var sumsqerr = arr.reduce(function(a, samples) {
              return a + jStat2.sumsqerr(samples);
            }, 0);
            var count = arr.reduce(function(a, samples) {
              return a + samples.length;
            }, 0);
            return sumsqerr / (count - arr.length);
          };
          jStat2.deviation = function(arr) {
            var mean = jStat2.mean(arr);
            var arrlen = arr.length;
            var dev = new Array(arrlen);
            for (var i = 0; i < arrlen; i++) {
              dev[i] = arr[i] - mean;
            }
            return dev;
          };
          jStat2.stdev = function stdev(arr, flag) {
            return Math2.sqrt(jStat2.variance(arr, flag));
          };
          jStat2.pooledstdev = function pooledstdev(arr) {
            return Math2.sqrt(jStat2.pooledvariance(arr));
          };
          jStat2.meandev = function meandev(arr) {
            var mean = jStat2.mean(arr);
            var a = [];
            for (var i = arr.length - 1; i >= 0; i--) {
              a.push(Math2.abs(arr[i] - mean));
            }
            return jStat2.mean(a);
          };
          jStat2.meddev = function meddev(arr) {
            var median = jStat2.median(arr);
            var a = [];
            for (var i = arr.length - 1; i >= 0; i--) {
              a.push(Math2.abs(arr[i] - median));
            }
            return jStat2.median(a);
          };
          jStat2.coeffvar = function coeffvar(arr) {
            return jStat2.stdev(arr) / jStat2.mean(arr);
          };
          jStat2.quartiles = function quartiles(arr) {
            var arrlen = arr.length;
            var _arr = arr.slice().sort(ascNum);
            return [
              _arr[Math2.round(arrlen / 4) - 1],
              _arr[Math2.round(arrlen / 2) - 1],
              _arr[Math2.round(arrlen * 3 / 4) - 1]
            ];
          };
          jStat2.quantiles = function quantiles(arr, quantilesArray, alphap, betap) {
            var sortedArray = arr.slice().sort(ascNum);
            var quantileVals = [quantilesArray.length];
            var n = arr.length;
            var i, p, m, aleph, k, gamma;
            if (typeof alphap === "undefined")
              alphap = 3 / 8;
            if (typeof betap === "undefined")
              betap = 3 / 8;
            for (i = 0; i < quantilesArray.length; i++) {
              p = quantilesArray[i];
              m = alphap + p * (1 - alphap - betap);
              aleph = n * p + m;
              k = Math2.floor(clip(aleph, 1, n - 1));
              gamma = clip(aleph - k, 0, 1);
              quantileVals[i] = (1 - gamma) * sortedArray[k - 1] + gamma * sortedArray[k];
            }
            return quantileVals;
          };
          jStat2.percentile = function percentile(arr, k, exclusive) {
            var _arr = arr.slice().sort(ascNum);
            var realIndex = k * (_arr.length + (exclusive ? 1 : -1)) + (exclusive ? 0 : 1);
            var index = parseInt(realIndex);
            var frac = realIndex - index;
            if (index + 1 < _arr.length) {
              return _arr[index - 1] + frac * (_arr[index] - _arr[index - 1]);
            } else {
              return _arr[index - 1];
            }
          };
          jStat2.percentileOfScore = function percentileOfScore(arr, score, kind) {
            var counter = 0;
            var len = arr.length;
            var strict = false;
            var value, i;
            if (kind === "strict")
              strict = true;
            for (i = 0; i < len; i++) {
              value = arr[i];
              if (strict && value < score || !strict && value <= score) {
                counter++;
              }
            }
            return counter / len;
          };
          jStat2.histogram = function histogram(arr, binCnt) {
            binCnt = binCnt || 4;
            var first2 = jStat2.min(arr);
            var binWidth = (jStat2.max(arr) - first2) / binCnt;
            var len = arr.length;
            var bins = [];
            var i;
            for (i = 0; i < binCnt; i++)
              bins[i] = 0;
            for (i = 0; i < len; i++)
              bins[Math2.min(Math2.floor((arr[i] - first2) / binWidth), binCnt - 1)] += 1;
            return bins;
          };
          jStat2.covariance = function covariance(arr1, arr2) {
            var u = jStat2.mean(arr1);
            var v = jStat2.mean(arr2);
            var arr1Len = arr1.length;
            var sq_dev = new Array(arr1Len);
            var i;
            for (i = 0; i < arr1Len; i++)
              sq_dev[i] = (arr1[i] - u) * (arr2[i] - v);
            return jStat2.sum(sq_dev) / (arr1Len - 1);
          };
          jStat2.corrcoeff = function corrcoeff(arr1, arr2) {
            return jStat2.covariance(arr1, arr2) / jStat2.stdev(arr1, 1) / jStat2.stdev(arr2, 1);
          };
          jStat2.spearmancoeff = function(arr1, arr2) {
            arr1 = jStat2.rank(arr1);
            arr2 = jStat2.rank(arr2);
            return jStat2.corrcoeff(arr1, arr2);
          };
          jStat2.stanMoment = function stanMoment(arr, n) {
            var mu = jStat2.mean(arr);
            var sigma = jStat2.stdev(arr);
            var len = arr.length;
            var skewSum = 0;
            for (var i = 0; i < len; i++)
              skewSum += Math2.pow((arr[i] - mu) / sigma, n);
            return skewSum / arr.length;
          };
          jStat2.skewness = function skewness(arr) {
            return jStat2.stanMoment(arr, 3);
          };
          jStat2.kurtosis = function kurtosis(arr) {
            return jStat2.stanMoment(arr, 4) - 3;
          };
          var jProto = jStat2.prototype;
          (function(funcs) {
            for (var i = 0; i < funcs.length; i++) (function(passfunc) {
              jProto[passfunc] = function(fullbool, func) {
                var arr = [];
                var i2 = 0;
                var tmpthis = this;
                if (isFunction2(fullbool)) {
                  func = fullbool;
                  fullbool = false;
                }
                if (func) {
                  setTimeout(function() {
                    func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
                  });
                  return this;
                }
                if (this.length > 1) {
                  tmpthis = fullbool === true ? this : this.transpose();
                  for (; i2 < tmpthis.length; i2++)
                    arr[i2] = jStat2[passfunc](tmpthis[i2]);
                  return arr;
                }
                return jStat2[passfunc](this[0], fullbool);
              };
            })(funcs[i]);
          })("cumsum cumprod".split(" "));
          (function(funcs) {
            for (var i = 0; i < funcs.length; i++) (function(passfunc) {
              jProto[passfunc] = function(fullbool, func) {
                var arr = [];
                var i2 = 0;
                var tmpthis = this;
                if (isFunction2(fullbool)) {
                  func = fullbool;
                  fullbool = false;
                }
                if (func) {
                  setTimeout(function() {
                    func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
                  });
                  return this;
                }
                if (this.length > 1) {
                  if (passfunc !== "sumrow")
                    tmpthis = fullbool === true ? this : this.transpose();
                  for (; i2 < tmpthis.length; i2++)
                    arr[i2] = jStat2[passfunc](tmpthis[i2]);
                  return fullbool === true ? jStat2[passfunc](jStat2.utils.toVector(arr)) : arr;
                }
                return jStat2[passfunc](this[0], fullbool);
              };
            })(funcs[i]);
          })("sum sumsqrd sumsqerr sumrow product min max unique mean meansqerr geomean median diff rank mode range variance deviation stdev meandev meddev coeffvar quartiles histogram skewness kurtosis".split(" "));
          (function(funcs) {
            for (var i = 0; i < funcs.length; i++) (function(passfunc) {
              jProto[passfunc] = function() {
                var arr = [];
                var i2 = 0;
                var tmpthis = this;
                var args = Array.prototype.slice.call(arguments);
                var callbackFunction;
                if (isFunction2(args[args.length - 1])) {
                  callbackFunction = args[args.length - 1];
                  var argsToPass = args.slice(0, args.length - 1);
                  setTimeout(function() {
                    callbackFunction.call(
                      tmpthis,
                      jProto[passfunc].apply(tmpthis, argsToPass)
                    );
                  });
                  return this;
                } else {
                  callbackFunction = void 0;
                  var curriedFunction = function curriedFunction2(vector) {
                    return jStat2[passfunc].apply(tmpthis, [vector].concat(args));
                  };
                }
                if (this.length > 1) {
                  tmpthis = tmpthis.transpose();
                  for (; i2 < tmpthis.length; i2++)
                    arr[i2] = curriedFunction(tmpthis[i2]);
                  return arr;
                }
                return curriedFunction(this[0]);
              };
            })(funcs[i]);
          })("quantiles percentileOfScore".split(" "));
        })(jStat, Math);
        (function(jStat2, Math2) {
          jStat2.gammaln = function gammaln(x) {
            var j = 0;
            var cof = [
              76.18009172947146,
              -86.50532032941678,
              24.01409824083091,
              -1.231739572450155,
              0.001208650973866179,
              -5395239384953e-18
            ];
            var ser = 1.000000000190015;
            var xx, y, tmp;
            tmp = (y = xx = x) + 5.5;
            tmp -= (xx + 0.5) * Math2.log(tmp);
            for (; j < 6; j++)
              ser += cof[j] / ++y;
            return Math2.log(2.5066282746310007 * ser / xx) - tmp;
          };
          jStat2.loggam = function loggam(x) {
            var x0, x2, xp, gl, gl0;
            var k, n;
            var a = [
              0.08333333333333333,
              -0.002777777777777778,
              7936507936507937e-19,
              -5952380952380952e-19,
              8417508417508418e-19,
              -0.001917526917526918,
              0.00641025641025641,
              -0.02955065359477124,
              0.1796443723688307,
              -1.3924322169059
            ];
            x0 = x;
            n = 0;
            if (x == 1 || x == 2) {
              return 0;
            }
            if (x <= 7) {
              n = Math2.floor(7 - x);
              x0 = x + n;
            }
            x2 = 1 / (x0 * x0);
            xp = 2 * Math2.PI;
            gl0 = a[9];
            for (k = 8; k >= 0; k--) {
              gl0 *= x2;
              gl0 += a[k];
            }
            gl = gl0 / x0 + 0.5 * Math2.log(xp) + (x0 - 0.5) * Math2.log(x0) - x0;
            if (x <= 7) {
              for (k = 1; k <= n; k++) {
                gl -= Math2.log(x0 - 1);
                x0 -= 1;
              }
            }
            return gl;
          };
          jStat2.gammafn = function gammafn(x) {
            var p = [
              -1.716185138865495,
              24.76565080557592,
              -379.80425647094563,
              629.3311553128184,
              866.9662027904133,
              -31451.272968848367,
              -36144.413418691176,
              66456.14382024054
            ];
            var q = [
              -30.8402300119739,
              315.35062697960416,
              -1015.1563674902192,
              -3107.771671572311,
              22538.11842098015,
              4755.846277527881,
              -134659.9598649693,
              -115132.2596755535
            ];
            var fact = false;
            var n = 0;
            var xden = 0;
            var xnum = 0;
            var y = x;
            var i, z, yi, res;
            if (x > 171.6243769536076) {
              return Infinity;
            }
            if (y <= 0) {
              res = y % 1 + 36e-17;
              if (res) {
                fact = (!(y & 1) ? 1 : -1) * Math2.PI / Math2.sin(Math2.PI * res);
                y = 1 - y;
              } else {
                return Infinity;
              }
            }
            yi = y;
            if (y < 1) {
              z = y++;
            } else {
              z = (y -= n = (y | 0) - 1) - 1;
            }
            for (i = 0; i < 8; ++i) {
              xnum = (xnum + p[i]) * z;
              xden = xden * z + q[i];
            }
            res = xnum / xden + 1;
            if (yi < y) {
              res /= yi;
            } else if (yi > y) {
              for (i = 0; i < n; ++i) {
                res *= y;
                y++;
              }
            }
            if (fact) {
              res = fact / res;
            }
            return res;
          };
          jStat2.gammap = function gammap(a, x) {
            return jStat2.lowRegGamma(a, x) * jStat2.gammafn(a);
          };
          jStat2.lowRegGamma = function lowRegGamma(a, x) {
            var aln = jStat2.gammaln(a);
            var ap = a;
            var sum = 1 / a;
            var del = sum;
            var b = x + 1 - a;
            var c = 1 / 1e-30;
            var d = 1 / b;
            var h = d;
            var i = 1;
            var ITMAX = -~(Math2.log(a >= 1 ? a : 1 / a) * 8.5 + a * 0.4 + 17);
            var an;
            if (x < 0 || a <= 0) {
              return NaN;
            } else if (x < a + 1) {
              for (; i <= ITMAX; i++) {
                sum += del *= x / ++ap;
              }
              return sum * Math2.exp(-x + a * Math2.log(x) - aln);
            }
            for (; i <= ITMAX; i++) {
              an = -i * (i - a);
              b += 2;
              d = an * d + b;
              c = b + an / c;
              d = 1 / d;
              h *= d * c;
            }
            return 1 - h * Math2.exp(-x + a * Math2.log(x) - aln);
          };
          jStat2.factorialln = function factorialln(n) {
            return n < 0 ? NaN : jStat2.gammaln(n + 1);
          };
          jStat2.factorial = function factorial(n) {
            return n < 0 ? NaN : jStat2.gammafn(n + 1);
          };
          jStat2.combination = function combination(n, m) {
            return n > 170 || m > 170 ? Math2.exp(jStat2.combinationln(n, m)) : jStat2.factorial(n) / jStat2.factorial(m) / jStat2.factorial(n - m);
          };
          jStat2.combinationln = function combinationln(n, m) {
            return jStat2.factorialln(n) - jStat2.factorialln(m) - jStat2.factorialln(n - m);
          };
          jStat2.permutation = function permutation(n, m) {
            return jStat2.factorial(n) / jStat2.factorial(n - m);
          };
          jStat2.betafn = function betafn(x, y) {
            if (x <= 0 || y <= 0)
              return void 0;
            return x + y > 170 ? Math2.exp(jStat2.betaln(x, y)) : jStat2.gammafn(x) * jStat2.gammafn(y) / jStat2.gammafn(x + y);
          };
          jStat2.betaln = function betaln(x, y) {
            return jStat2.gammaln(x) + jStat2.gammaln(y) - jStat2.gammaln(x + y);
          };
          jStat2.betacf = function betacf(x, a, b) {
            var fpmin = 1e-30;
            var m = 1;
            var qab = a + b;
            var qap = a + 1;
            var qam = a - 1;
            var c = 1;
            var d = 1 - qab * x / qap;
            var m2, aa, del, h;
            if (Math2.abs(d) < fpmin)
              d = fpmin;
            d = 1 / d;
            h = d;
            for (; m <= 100; m++) {
              m2 = 2 * m;
              aa = m * (b - m) * x / ((qam + m2) * (a + m2));
              d = 1 + aa * d;
              if (Math2.abs(d) < fpmin)
                d = fpmin;
              c = 1 + aa / c;
              if (Math2.abs(c) < fpmin)
                c = fpmin;
              d = 1 / d;
              h *= d * c;
              aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
              d = 1 + aa * d;
              if (Math2.abs(d) < fpmin)
                d = fpmin;
              c = 1 + aa / c;
              if (Math2.abs(c) < fpmin)
                c = fpmin;
              d = 1 / d;
              del = d * c;
              h *= del;
              if (Math2.abs(del - 1) < 3e-7)
                break;
            }
            return h;
          };
          jStat2.gammapinv = function gammapinv(p, a) {
            var j = 0;
            var a1 = a - 1;
            var EPS = 1e-8;
            var gln = jStat2.gammaln(a);
            var x, err, t, u, pp, lna1, afac;
            if (p >= 1)
              return Math2.max(100, a + 100 * Math2.sqrt(a));
            if (p <= 0)
              return 0;
            if (a > 1) {
              lna1 = Math2.log(a1);
              afac = Math2.exp(a1 * (lna1 - 1) - gln);
              pp = p < 0.5 ? p : 1 - p;
              t = Math2.sqrt(-2 * Math2.log(pp));
              x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
              if (p < 0.5)
                x = -x;
              x = Math2.max(
                1e-3,
                a * Math2.pow(1 - 1 / (9 * a) - x / (3 * Math2.sqrt(a)), 3)
              );
            } else {
              t = 1 - a * (0.253 + a * 0.12);
              if (p < t)
                x = Math2.pow(p / t, 1 / a);
              else
                x = 1 - Math2.log(1 - (p - t) / (1 - t));
            }
            for (; j < 12; j++) {
              if (x <= 0)
                return 0;
              err = jStat2.lowRegGamma(a, x) - p;
              if (a > 1)
                t = afac * Math2.exp(-(x - a1) + a1 * (Math2.log(x) - lna1));
              else
                t = Math2.exp(-x + a1 * Math2.log(x) - gln);
              u = err / t;
              x -= t = u / (1 - 0.5 * Math2.min(1, u * ((a - 1) / x - 1)));
              if (x <= 0)
                x = 0.5 * (x + t);
              if (Math2.abs(t) < EPS * x)
                break;
            }
            return x;
          };
          jStat2.erf = function erf(x) {
            var cof = [
              -1.3026537197817094,
              0.6419697923564902,
              0.019476473204185836,
              -0.00956151478680863,
              -946595344482036e-18,
              366839497852761e-18,
              42523324806907e-18,
              -20278578112534e-18,
              -1624290004647e-18,
              130365583558e-17,
              15626441722e-18,
              -85238095915e-18,
              6529054439e-18,
              5059343495e-18,
              -991364156e-18,
              -227365122e-18,
              96467911e-18,
              2394038e-18,
              -6886027e-18,
              894487e-18,
              313092e-18,
              -112708e-18,
              381e-18,
              7106e-18,
              -1523e-18,
              -94e-18,
              121e-18,
              -28e-18
            ];
            var j = cof.length - 1;
            var isneg = false;
            var d = 0;
            var dd = 0;
            var t, ty, tmp, res;
            if (x < 0) {
              x = -x;
              isneg = true;
            }
            t = 2 / (2 + x);
            ty = 4 * t - 2;
            for (; j > 0; j--) {
              tmp = d;
              d = ty * d - dd + cof[j];
              dd = tmp;
            }
            res = t * Math2.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);
            return isneg ? res - 1 : 1 - res;
          };
          jStat2.erfc = function erfc(x) {
            return 1 - jStat2.erf(x);
          };
          jStat2.erfcinv = function erfcinv(p) {
            var j = 0;
            var x, err, t, pp;
            if (p >= 2)
              return -100;
            if (p <= 0)
              return 100;
            pp = p < 1 ? p : 2 - p;
            t = Math2.sqrt(-2 * Math2.log(pp / 2));
            x = -0.70711 * ((2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t);
            for (; j < 2; j++) {
              err = jStat2.erfc(x) - pp;
              x += err / (1.1283791670955126 * Math2.exp(-x * x) - x * err);
            }
            return p < 1 ? x : -x;
          };
          jStat2.ibetainv = function ibetainv(p, a, b) {
            var EPS = 1e-8;
            var a1 = a - 1;
            var b1 = b - 1;
            var j = 0;
            var lna, lnb, pp, t, u, err, x, al, h, w, afac;
            if (p <= 0)
              return 0;
            if (p >= 1)
              return 1;
            if (a >= 1 && b >= 1) {
              pp = p < 0.5 ? p : 1 - p;
              t = Math2.sqrt(-2 * Math2.log(pp));
              x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
              if (p < 0.5)
                x = -x;
              al = (x * x - 3) / 6;
              h = 2 / (1 / (2 * a - 1) + 1 / (2 * b - 1));
              w = x * Math2.sqrt(al + h) / h - (1 / (2 * b - 1) - 1 / (2 * a - 1)) * (al + 5 / 6 - 2 / (3 * h));
              x = a / (a + b * Math2.exp(2 * w));
            } else {
              lna = Math2.log(a / (a + b));
              lnb = Math2.log(b / (a + b));
              t = Math2.exp(a * lna) / a;
              u = Math2.exp(b * lnb) / b;
              w = t + u;
              if (p < t / w)
                x = Math2.pow(a * w * p, 1 / a);
              else
                x = 1 - Math2.pow(b * w * (1 - p), 1 / b);
            }
            afac = -jStat2.gammaln(a) - jStat2.gammaln(b) + jStat2.gammaln(a + b);
            for (; j < 10; j++) {
              if (x === 0 || x === 1)
                return x;
              err = jStat2.ibeta(x, a, b) - p;
              t = Math2.exp(a1 * Math2.log(x) + b1 * Math2.log(1 - x) + afac);
              u = err / t;
              x -= t = u / (1 - 0.5 * Math2.min(1, u * (a1 / x - b1 / (1 - x))));
              if (x <= 0)
                x = 0.5 * (x + t);
              if (x >= 1)
                x = 0.5 * (x + t + 1);
              if (Math2.abs(t) < EPS * x && j > 0)
                break;
            }
            return x;
          };
          jStat2.ibeta = function ibeta(x, a, b) {
            var bt = x === 0 || x === 1 ? 0 : Math2.exp(jStat2.gammaln(a + b) - jStat2.gammaln(a) - jStat2.gammaln(b) + a * Math2.log(x) + b * Math2.log(1 - x));
            if (x < 0 || x > 1)
              return false;
            if (x < (a + 1) / (a + b + 2))
              return bt * jStat2.betacf(x, a, b) / a;
            return 1 - bt * jStat2.betacf(1 - x, b, a) / b;
          };
          jStat2.randn = function randn(n, m) {
            var u, v, x, y, q;
            if (!m)
              m = n;
            if (n)
              return jStat2.create(n, m, function() {
                return jStat2.randn();
              });
            do {
              u = jStat2._random_fn();
              v = 1.7156 * (jStat2._random_fn() - 0.5);
              x = u - 0.449871;
              y = Math2.abs(v) + 0.386595;
              q = x * x + y * (0.196 * y - 0.25472 * x);
            } while (q > 0.27597 && (q > 0.27846 || v * v > -4 * Math2.log(u) * u * u));
            return v / u;
          };
          jStat2.randg = function randg(shape, n, m) {
            var oalph = shape;
            var a1, a2, u, v, x, mat;
            if (!m)
              m = n;
            if (!shape)
              shape = 1;
            if (n) {
              mat = jStat2.zeros(n, m);
              mat.alter(function() {
                return jStat2.randg(shape);
              });
              return mat;
            }
            if (shape < 1)
              shape += 1;
            a1 = shape - 1 / 3;
            a2 = 1 / Math2.sqrt(9 * a1);
            do {
              do {
                x = jStat2.randn();
                v = 1 + a2 * x;
              } while (v <= 0);
              v = v * v * v;
              u = jStat2._random_fn();
            } while (u > 1 - 0.331 * Math2.pow(x, 4) && Math2.log(u) > 0.5 * x * x + a1 * (1 - v + Math2.log(v)));
            if (shape == oalph)
              return a1 * v;
            do {
              u = jStat2._random_fn();
            } while (u === 0);
            return Math2.pow(u, 1 / oalph) * a1 * v;
          };
          (function(funcs) {
            for (var i = 0; i < funcs.length; i++) (function(passfunc) {
              jStat2.fn[passfunc] = function() {
                return jStat2(
                  jStat2.map(this, function(value) {
                    return jStat2[passfunc](value);
                  })
                );
              };
            })(funcs[i]);
          })("gammaln gammafn factorial factorialln".split(" "));
          (function(funcs) {
            for (var i = 0; i < funcs.length; i++) (function(passfunc) {
              jStat2.fn[passfunc] = function() {
                return jStat2(jStat2[passfunc].apply(null, arguments));
              };
            })(funcs[i]);
          })("randn".split(" "));
        })(jStat, Math);
        (function(jStat2, Math2) {
          (function(list) {
            for (var i = 0; i < list.length; i++) (function(func) {
              jStat2[func] = function f(a, b, c) {
                if (!(this instanceof f))
                  return new f(a, b, c);
                this._a = a;
                this._b = b;
                this._c = c;
                return this;
              };
              jStat2.fn[func] = function(a, b, c) {
                var newthis = jStat2[func](a, b, c);
                newthis.data = this;
                return newthis;
              };
              jStat2[func].prototype.sample = function(arr) {
                var a = this._a;
                var b = this._b;
                var c = this._c;
                if (arr)
                  return jStat2.alter(arr, function() {
                    return jStat2[func].sample(a, b, c);
                  });
                else
                  return jStat2[func].sample(a, b, c);
              };
              (function(vals) {
                for (var i2 = 0; i2 < vals.length; i2++) (function(fnfunc) {
                  jStat2[func].prototype[fnfunc] = function(x) {
                    var a = this._a;
                    var b = this._b;
                    var c = this._c;
                    if (!x && x !== 0)
                      x = this.data;
                    if (typeof x !== "number") {
                      return jStat2.fn.map.call(x, function(x2) {
                        return jStat2[func][fnfunc](x2, a, b, c);
                      });
                    }
                    return jStat2[func][fnfunc](x, a, b, c);
                  };
                })(vals[i2]);
              })("pdf cdf inv".split(" "));
              (function(vals) {
                for (var i2 = 0; i2 < vals.length; i2++) (function(fnfunc) {
                  jStat2[func].prototype[fnfunc] = function() {
                    return jStat2[func][fnfunc](this._a, this._b, this._c);
                  };
                })(vals[i2]);
              })("mean median mode variance".split(" "));
            })(list[i]);
          })("beta centralF cauchy chisquare exponential gamma invgamma kumaraswamy laplace lognormal noncentralt normal pareto studentt weibull uniform binomial negbin hypgeom poisson triangular tukey arcsine".split(" "));
          jStat2.extend(jStat2.beta, {
            pdf: function pdf(x, alpha, beta) {
              if (x > 1 || x < 0)
                return 0;
              if (alpha == 1 && beta == 1)
                return 1;
              if (alpha < 512 && beta < 512) {
                return Math2.pow(x, alpha - 1) * Math2.pow(1 - x, beta - 1) / jStat2.betafn(alpha, beta);
              } else {
                return Math2.exp((alpha - 1) * Math2.log(x) + (beta - 1) * Math2.log(1 - x) - jStat2.betaln(alpha, beta));
              }
            },
            cdf: function cdf(x, alpha, beta) {
              return x > 1 || x < 0 ? (x > 1) * 1 : jStat2.ibeta(x, alpha, beta);
            },
            inv: function inv(x, alpha, beta) {
              return jStat2.ibetainv(x, alpha, beta);
            },
            mean: function mean(alpha, beta) {
              return alpha / (alpha + beta);
            },
            median: function median(alpha, beta) {
              return jStat2.ibetainv(0.5, alpha, beta);
            },
            mode: function mode(alpha, beta) {
              return (alpha - 1) / (alpha + beta - 2);
            },
            // return a random sample
            sample: function sample(alpha, beta) {
              var u = jStat2.randg(alpha);
              return u / (u + jStat2.randg(beta));
            },
            variance: function variance(alpha, beta) {
              return alpha * beta / (Math2.pow(alpha + beta, 2) * (alpha + beta + 1));
            }
          });
          jStat2.extend(jStat2.centralF, {
            // This implementation of the pdf function avoids float overflow
            // See the way that R calculates this value:
            // https://svn.r-project.org/R/trunk/src/nmath/df.c
            pdf: function pdf(x, df1, df2) {
              var p, q, f;
              if (x < 0)
                return 0;
              if (df1 <= 2) {
                if (x === 0 && df1 < 2) {
                  return Infinity;
                }
                if (x === 0 && df1 === 2) {
                  return 1;
                }
                return 1 / jStat2.betafn(df1 / 2, df2 / 2) * Math2.pow(df1 / df2, df1 / 2) * Math2.pow(x, df1 / 2 - 1) * Math2.pow(1 + df1 / df2 * x, -(df1 + df2) / 2);
              }
              p = df1 * x / (df2 + x * df1);
              q = df2 / (df2 + x * df1);
              f = df1 * q / 2;
              return f * jStat2.binomial.pdf((df1 - 2) / 2, (df1 + df2 - 2) / 2, p);
            },
            cdf: function cdf(x, df1, df2) {
              if (x < 0)
                return 0;
              return jStat2.ibeta(df1 * x / (df1 * x + df2), df1 / 2, df2 / 2);
            },
            inv: function inv(x, df1, df2) {
              return df2 / (df1 * (1 / jStat2.ibetainv(x, df1 / 2, df2 / 2) - 1));
            },
            mean: function mean(df1, df2) {
              return df2 > 2 ? df2 / (df2 - 2) : void 0;
            },
            mode: function mode(df1, df2) {
              return df1 > 2 ? df2 * (df1 - 2) / (df1 * (df2 + 2)) : void 0;
            },
            // return a random sample
            sample: function sample(df1, df2) {
              var x1 = jStat2.randg(df1 / 2) * 2;
              var x2 = jStat2.randg(df2 / 2) * 2;
              return x1 / df1 / (x2 / df2);
            },
            variance: function variance(df1, df2) {
              if (df2 <= 4)
                return void 0;
              return 2 * df2 * df2 * (df1 + df2 - 2) / (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4));
            }
          });
          jStat2.extend(jStat2.cauchy, {
            pdf: function pdf(x, local, scale) {
              if (scale < 0) {
                return 0;
              }
              return scale / (Math2.pow(x - local, 2) + Math2.pow(scale, 2)) / Math2.PI;
            },
            cdf: function cdf(x, local, scale) {
              return Math2.atan((x - local) / scale) / Math2.PI + 0.5;
            },
            inv: function(p, local, scale) {
              return local + scale * Math2.tan(Math2.PI * (p - 0.5));
            },
            median: function median(local) {
              return local;
            },
            mode: function mode(local) {
              return local;
            },
            sample: function sample(local, scale) {
              return jStat2.randn() * Math2.sqrt(1 / (2 * jStat2.randg(0.5))) * scale + local;
            }
          });
          jStat2.extend(jStat2.chisquare, {
            pdf: function pdf(x, dof) {
              if (x < 0)
                return 0;
              return x === 0 && dof === 2 ? 0.5 : Math2.exp((dof / 2 - 1) * Math2.log(x) - x / 2 - dof / 2 * Math2.log(2) - jStat2.gammaln(dof / 2));
            },
            cdf: function cdf(x, dof) {
              if (x < 0)
                return 0;
              return jStat2.lowRegGamma(dof / 2, x / 2);
            },
            inv: function(p, dof) {
              return 2 * jStat2.gammapinv(p, 0.5 * dof);
            },
            mean: function(dof) {
              return dof;
            },
            // TODO: this is an approximation (is there a better way?)
            median: function median(dof) {
              return dof * Math2.pow(1 - 2 / (9 * dof), 3);
            },
            mode: function mode(dof) {
              return dof - 2 > 0 ? dof - 2 : 0;
            },
            sample: function sample(dof) {
              return jStat2.randg(dof / 2) * 2;
            },
            variance: function variance(dof) {
              return 2 * dof;
            }
          });
          jStat2.extend(jStat2.exponential, {
            pdf: function pdf(x, rate) {
              return x < 0 ? 0 : rate * Math2.exp(-rate * x);
            },
            cdf: function cdf(x, rate) {
              return x < 0 ? 0 : 1 - Math2.exp(-rate * x);
            },
            inv: function(p, rate) {
              return -Math2.log(1 - p) / rate;
            },
            mean: function(rate) {
              return 1 / rate;
            },
            median: function(rate) {
              return 1 / rate * Math2.log(2);
            },
            mode: function mode() {
              return 0;
            },
            sample: function sample(rate) {
              return -1 / rate * Math2.log(jStat2._random_fn());
            },
            variance: function(rate) {
              return Math2.pow(rate, -2);
            }
          });
          jStat2.extend(jStat2.gamma, {
            pdf: function pdf(x, shape, scale) {
              if (x < 0)
                return 0;
              return x === 0 && shape === 1 ? 1 / scale : Math2.exp((shape - 1) * Math2.log(x) - x / scale - jStat2.gammaln(shape) - shape * Math2.log(scale));
            },
            cdf: function cdf(x, shape, scale) {
              if (x < 0)
                return 0;
              return jStat2.lowRegGamma(shape, x / scale);
            },
            inv: function(p, shape, scale) {
              return jStat2.gammapinv(p, shape) * scale;
            },
            mean: function(shape, scale) {
              return shape * scale;
            },
            mode: function mode(shape, scale) {
              if (shape > 1) return (shape - 1) * scale;
              return void 0;
            },
            sample: function sample(shape, scale) {
              return jStat2.randg(shape) * scale;
            },
            variance: function variance(shape, scale) {
              return shape * scale * scale;
            }
          });
          jStat2.extend(jStat2.invgamma, {
            pdf: function pdf(x, shape, scale) {
              if (x <= 0)
                return 0;
              return Math2.exp(-(shape + 1) * Math2.log(x) - scale / x - jStat2.gammaln(shape) + shape * Math2.log(scale));
            },
            cdf: function cdf(x, shape, scale) {
              if (x <= 0)
                return 0;
              return 1 - jStat2.lowRegGamma(shape, scale / x);
            },
            inv: function(p, shape, scale) {
              return scale / jStat2.gammapinv(1 - p, shape);
            },
            mean: function(shape, scale) {
              return shape > 1 ? scale / (shape - 1) : void 0;
            },
            mode: function mode(shape, scale) {
              return scale / (shape + 1);
            },
            sample: function sample(shape, scale) {
              return scale / jStat2.randg(shape);
            },
            variance: function variance(shape, scale) {
              if (shape <= 2)
                return void 0;
              return scale * scale / ((shape - 1) * (shape - 1) * (shape - 2));
            }
          });
          jStat2.extend(jStat2.kumaraswamy, {
            pdf: function pdf(x, alpha, beta) {
              if (x === 0 && alpha === 1)
                return beta;
              else if (x === 1 && beta === 1)
                return alpha;
              return Math2.exp(Math2.log(alpha) + Math2.log(beta) + (alpha - 1) * Math2.log(x) + (beta - 1) * Math2.log(1 - Math2.pow(x, alpha)));
            },
            cdf: function cdf(x, alpha, beta) {
              if (x < 0)
                return 0;
              else if (x > 1)
                return 1;
              return 1 - Math2.pow(1 - Math2.pow(x, alpha), beta);
            },
            inv: function inv(p, alpha, beta) {
              return Math2.pow(1 - Math2.pow(1 - p, 1 / beta), 1 / alpha);
            },
            mean: function(alpha, beta) {
              return beta * jStat2.gammafn(1 + 1 / alpha) * jStat2.gammafn(beta) / jStat2.gammafn(1 + 1 / alpha + beta);
            },
            median: function median(alpha, beta) {
              return Math2.pow(1 - Math2.pow(2, -1 / beta), 1 / alpha);
            },
            mode: function mode(alpha, beta) {
              if (!(alpha >= 1 && beta >= 1 && (alpha !== 1 && beta !== 1)))
                return void 0;
              return Math2.pow((alpha - 1) / (alpha * beta - 1), 1 / alpha);
            },
            variance: function variance() {
              throw new Error("variance not yet implemented");
            }
          });
          jStat2.extend(jStat2.lognormal, {
            pdf: function pdf(x, mu, sigma) {
              if (x <= 0)
                return 0;
              return Math2.exp(-Math2.log(x) - 0.5 * Math2.log(2 * Math2.PI) - Math2.log(sigma) - Math2.pow(Math2.log(x) - mu, 2) / (2 * sigma * sigma));
            },
            cdf: function cdf(x, mu, sigma) {
              if (x < 0)
                return 0;
              return 0.5 + 0.5 * jStat2.erf((Math2.log(x) - mu) / Math2.sqrt(2 * sigma * sigma));
            },
            inv: function(p, mu, sigma) {
              return Math2.exp(-1.4142135623730951 * sigma * jStat2.erfcinv(2 * p) + mu);
            },
            mean: function mean(mu, sigma) {
              return Math2.exp(mu + sigma * sigma / 2);
            },
            median: function median(mu) {
              return Math2.exp(mu);
            },
            mode: function mode(mu, sigma) {
              return Math2.exp(mu - sigma * sigma);
            },
            sample: function sample(mu, sigma) {
              return Math2.exp(jStat2.randn() * sigma + mu);
            },
            variance: function variance(mu, sigma) {
              return (Math2.exp(sigma * sigma) - 1) * Math2.exp(2 * mu + sigma * sigma);
            }
          });
          jStat2.extend(jStat2.noncentralt, {
            pdf: function pdf(x, dof, ncp) {
              var tol = 1e-14;
              if (Math2.abs(ncp) < tol)
                return jStat2.studentt.pdf(x, dof);
              if (Math2.abs(x) < tol) {
                return Math2.exp(jStat2.gammaln((dof + 1) / 2) - ncp * ncp / 2 - 0.5 * Math2.log(Math2.PI * dof) - jStat2.gammaln(dof / 2));
              }
              return dof / x * (jStat2.noncentralt.cdf(x * Math2.sqrt(1 + 2 / dof), dof + 2, ncp) - jStat2.noncentralt.cdf(x, dof, ncp));
            },
            cdf: function cdf(x, dof, ncp) {
              var tol = 1e-14;
              var min_iterations = 200;
              if (Math2.abs(ncp) < tol)
                return jStat2.studentt.cdf(x, dof);
              var flip = false;
              if (x < 0) {
                flip = true;
                ncp = -ncp;
              }
              var prob = jStat2.normal.cdf(-ncp, 0, 1);
              var value = tol + 1;
              var lastvalue = value;
              var y = x * x / (x * x + dof);
              var j = 0;
              var p = Math2.exp(-ncp * ncp / 2);
              var q = Math2.exp(-ncp * ncp / 2 - 0.5 * Math2.log(2) - jStat2.gammaln(3 / 2)) * ncp;
              while (j < min_iterations || lastvalue > tol || value > tol) {
                lastvalue = value;
                if (j > 0) {
                  p *= ncp * ncp / (2 * j);
                  q *= ncp * ncp / (2 * (j + 1 / 2));
                }
                value = p * jStat2.beta.cdf(y, j + 0.5, dof / 2) + q * jStat2.beta.cdf(y, j + 1, dof / 2);
                prob += 0.5 * value;
                j++;
              }
              return flip ? 1 - prob : prob;
            }
          });
          jStat2.extend(jStat2.normal, {
            pdf: function pdf(x, mean, std) {
              return Math2.exp(-0.5 * Math2.log(2 * Math2.PI) - Math2.log(std) - Math2.pow(x - mean, 2) / (2 * std * std));
            },
            cdf: function cdf(x, mean, std) {
              return 0.5 * (1 + jStat2.erf((x - mean) / Math2.sqrt(2 * std * std)));
            },
            inv: function(p, mean, std) {
              return -1.4142135623730951 * std * jStat2.erfcinv(2 * p) + mean;
            },
            mean: function(mean) {
              return mean;
            },
            median: function median(mean) {
              return mean;
            },
            mode: function(mean) {
              return mean;
            },
            sample: function sample(mean, std) {
              return jStat2.randn() * std + mean;
            },
            variance: function(mean, std) {
              return std * std;
            }
          });
          jStat2.extend(jStat2.pareto, {
            pdf: function pdf(x, scale, shape) {
              if (x < scale)
                return 0;
              return shape * Math2.pow(scale, shape) / Math2.pow(x, shape + 1);
            },
            cdf: function cdf(x, scale, shape) {
              if (x < scale)
                return 0;
              return 1 - Math2.pow(scale / x, shape);
            },
            inv: function inv(p, scale, shape) {
              return scale / Math2.pow(1 - p, 1 / shape);
            },
            mean: function mean(scale, shape) {
              if (shape <= 1)
                return void 0;
              return shape * Math2.pow(scale, shape) / (shape - 1);
            },
            median: function median(scale, shape) {
              return scale * (shape * Math2.SQRT2);
            },
            mode: function mode(scale) {
              return scale;
            },
            variance: function(scale, shape) {
              if (shape <= 2)
                return void 0;
              return scale * scale * shape / (Math2.pow(shape - 1, 2) * (shape - 2));
            }
          });
          jStat2.extend(jStat2.studentt, {
            pdf: function pdf(x, dof) {
              dof = dof > 1e100 ? 1e100 : dof;
              return 1 / (Math2.sqrt(dof) * jStat2.betafn(0.5, dof / 2)) * Math2.pow(1 + x * x / dof, -((dof + 1) / 2));
            },
            cdf: function cdf(x, dof) {
              var dof2 = dof / 2;
              return jStat2.ibeta((x + Math2.sqrt(x * x + dof)) / (2 * Math2.sqrt(x * x + dof)), dof2, dof2);
            },
            inv: function(p, dof) {
              var x = jStat2.ibetainv(2 * Math2.min(p, 1 - p), 0.5 * dof, 0.5);
              x = Math2.sqrt(dof * (1 - x) / x);
              return p > 0.5 ? x : -x;
            },
            mean: function mean(dof) {
              return dof > 1 ? 0 : void 0;
            },
            median: function median() {
              return 0;
            },
            mode: function mode() {
              return 0;
            },
            sample: function sample(dof) {
              return jStat2.randn() * Math2.sqrt(dof / (2 * jStat2.randg(dof / 2)));
            },
            variance: function variance(dof) {
              return dof > 2 ? dof / (dof - 2) : dof > 1 ? Infinity : void 0;
            }
          });
          jStat2.extend(jStat2.weibull, {
            pdf: function pdf(x, scale, shape) {
              if (x < 0 || scale < 0 || shape < 0)
                return 0;
              return shape / scale * Math2.pow(x / scale, shape - 1) * Math2.exp(-Math2.pow(x / scale, shape));
            },
            cdf: function cdf(x, scale, shape) {
              return x < 0 ? 0 : 1 - Math2.exp(-Math2.pow(x / scale, shape));
            },
            inv: function(p, scale, shape) {
              return scale * Math2.pow(-Math2.log(1 - p), 1 / shape);
            },
            mean: function(scale, shape) {
              return scale * jStat2.gammafn(1 + 1 / shape);
            },
            median: function median(scale, shape) {
              return scale * Math2.pow(Math2.log(2), 1 / shape);
            },
            mode: function mode(scale, shape) {
              if (shape <= 1)
                return 0;
              return scale * Math2.pow((shape - 1) / shape, 1 / shape);
            },
            sample: function sample(scale, shape) {
              return scale * Math2.pow(-Math2.log(jStat2._random_fn()), 1 / shape);
            },
            variance: function variance(scale, shape) {
              return scale * scale * jStat2.gammafn(1 + 2 / shape) - Math2.pow(jStat2.weibull.mean(scale, shape), 2);
            }
          });
          jStat2.extend(jStat2.uniform, {
            pdf: function pdf(x, a, b) {
              return x < a || x > b ? 0 : 1 / (b - a);
            },
            cdf: function cdf(x, a, b) {
              if (x < a)
                return 0;
              else if (x < b)
                return (x - a) / (b - a);
              return 1;
            },
            inv: function(p, a, b) {
              return a + p * (b - a);
            },
            mean: function mean(a, b) {
              return 0.5 * (a + b);
            },
            median: function median(a, b) {
              return jStat2.mean(a, b);
            },
            mode: function mode() {
              throw new Error("mode is not yet implemented");
            },
            sample: function sample(a, b) {
              return a / 2 + b / 2 + (b / 2 - a / 2) * (2 * jStat2._random_fn() - 1);
            },
            variance: function variance(a, b) {
              return Math2.pow(b - a, 2) / 12;
            }
          });
          function betinc(x, a, b, eps) {
            var a0 = 0;
            var b0 = 1;
            var a1 = 1;
            var b1 = 1;
            var m9 = 0;
            var a2 = 0;
            var c9;
            while (Math2.abs((a1 - a2) / a1) > eps) {
              a2 = a1;
              c9 = -(a + m9) * (a + b + m9) * x / (a + 2 * m9) / (a + 2 * m9 + 1);
              a0 = a1 + c9 * a0;
              b0 = b1 + c9 * b0;
              m9 = m9 + 1;
              c9 = m9 * (b - m9) * x / (a + 2 * m9 - 1) / (a + 2 * m9);
              a1 = a0 + c9 * a1;
              b1 = b0 + c9 * b1;
              a0 = a0 / b1;
              b0 = b0 / b1;
              a1 = a1 / b1;
              b1 = 1;
            }
            return a1 / a;
          }
          jStat2.extend(jStat2.binomial, {
            pdf: function pdf(k, n, p) {
              return p === 0 || p === 1 ? n * p === k ? 1 : 0 : jStat2.combination(n, k) * Math2.pow(p, k) * Math2.pow(1 - p, n - k);
            },
            cdf: function cdf(x, n, p) {
              var betacdf;
              var eps = 1e-10;
              if (x < 0)
                return 0;
              if (x >= n)
                return 1;
              if (p < 0 || p > 1 || n <= 0)
                return NaN;
              x = Math2.floor(x);
              var z = p;
              var a = x + 1;
              var b = n - x;
              var s = a + b;
              var bt = Math2.exp(jStat2.gammaln(s) - jStat2.gammaln(b) - jStat2.gammaln(a) + a * Math2.log(z) + b * Math2.log(1 - z));
              if (z < (a + 1) / (s + 2))
                betacdf = bt * betinc(z, a, b, eps);
              else
                betacdf = 1 - bt * betinc(1 - z, b, a, eps);
              return Math2.round((1 - betacdf) * (1 / eps)) / (1 / eps);
            }
          });
          jStat2.extend(jStat2.negbin, {
            pdf: function pdf(k, r, p) {
              if (k !== k >>> 0)
                return false;
              if (k < 0)
                return 0;
              return jStat2.combination(k + r - 1, r - 1) * Math2.pow(1 - p, k) * Math2.pow(p, r);
            },
            cdf: function cdf(x, r, p) {
              var sum = 0, k = 0;
              if (x < 0) return 0;
              for (; k <= x; k++) {
                sum += jStat2.negbin.pdf(k, r, p);
              }
              return sum;
            }
          });
          jStat2.extend(jStat2.hypgeom, {
            pdf: function pdf(k, N, m, n) {
              if (k !== k | 0) {
                return false;
              } else if (k < 0 || k < m - (N - n)) {
                return 0;
              } else if (k > n || k > m) {
                return 0;
              } else if (m * 2 > N) {
                if (n * 2 > N) {
                  return jStat2.hypgeom.pdf(N - m - n + k, N, N - m, N - n);
                } else {
                  return jStat2.hypgeom.pdf(n - k, N, N - m, n);
                }
              } else if (n * 2 > N) {
                return jStat2.hypgeom.pdf(m - k, N, m, N - n);
              } else if (m < n) {
                return jStat2.hypgeom.pdf(k, N, n, m);
              } else {
                var scaledPDF = 1;
                var samplesDone = 0;
                for (var i = 0; i < k; i++) {
                  while (scaledPDF > 1 && samplesDone < n) {
                    scaledPDF *= 1 - m / (N - samplesDone);
                    samplesDone++;
                  }
                  scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));
                }
                for (; samplesDone < n; samplesDone++) {
                  scaledPDF *= 1 - m / (N - samplesDone);
                }
                return Math2.min(1, Math2.max(0, scaledPDF));
              }
            },
            cdf: function cdf(x, N, m, n) {
              if (x < 0 || x < m - (N - n)) {
                return 0;
              } else if (x >= n || x >= m) {
                return 1;
              } else if (m * 2 > N) {
                if (n * 2 > N) {
                  return jStat2.hypgeom.cdf(N - m - n + x, N, N - m, N - n);
                } else {
                  return 1 - jStat2.hypgeom.cdf(n - x - 1, N, N - m, n);
                }
              } else if (n * 2 > N) {
                return 1 - jStat2.hypgeom.cdf(m - x - 1, N, m, N - n);
              } else if (m < n) {
                return jStat2.hypgeom.cdf(x, N, n, m);
              } else {
                var scaledCDF = 1;
                var scaledPDF = 1;
                var samplesDone = 0;
                for (var i = 0; i < x; i++) {
                  while (scaledCDF > 1 && samplesDone < n) {
                    var factor = 1 - m / (N - samplesDone);
                    scaledPDF *= factor;
                    scaledCDF *= factor;
                    samplesDone++;
                  }
                  scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));
                  scaledCDF += scaledPDF;
                }
                for (; samplesDone < n; samplesDone++) {
                  scaledCDF *= 1 - m / (N - samplesDone);
                }
                return Math2.min(1, Math2.max(0, scaledCDF));
              }
            }
          });
          jStat2.extend(jStat2.poisson, {
            pdf: function pdf(k, l) {
              if (l < 0 || k % 1 !== 0 || k < 0) {
                return 0;
              }
              return Math2.pow(l, k) * Math2.exp(-l) / jStat2.factorial(k);
            },
            cdf: function cdf(x, l) {
              var sumarr = [], k = 0;
              if (x < 0) return 0;
              for (; k <= x; k++) {
                sumarr.push(jStat2.poisson.pdf(k, l));
              }
              return jStat2.sum(sumarr);
            },
            mean: function(l) {
              return l;
            },
            variance: function(l) {
              return l;
            },
            sampleSmall: function sampleSmall(l) {
              var p = 1, k = 0, L = Math2.exp(-l);
              do {
                k++;
                p *= jStat2._random_fn();
              } while (p > L);
              return k - 1;
            },
            sampleLarge: function sampleLarge(l) {
              var lam = l;
              var k;
              var U, V, slam, loglam, a, b, invalpha, vr, us;
              slam = Math2.sqrt(lam);
              loglam = Math2.log(lam);
              b = 0.931 + 2.53 * slam;
              a = -0.059 + 0.02483 * b;
              invalpha = 1.1239 + 1.1328 / (b - 3.4);
              vr = 0.9277 - 3.6224 / (b - 2);
              while (1) {
                U = Math2.random() - 0.5;
                V = Math2.random();
                us = 0.5 - Math2.abs(U);
                k = Math2.floor((2 * a / us + b) * U + lam + 0.43);
                if (us >= 0.07 && V <= vr) {
                  return k;
                }
                if (k < 0 || us < 0.013 && V > us) {
                  continue;
                }
                if (Math2.log(V) + Math2.log(invalpha) - Math2.log(a / (us * us) + b) <= -lam + k * loglam - jStat2.loggam(k + 1)) {
                  return k;
                }
              }
            },
            sample: function sample(l) {
              if (l < 10)
                return this.sampleSmall(l);
              else
                return this.sampleLarge(l);
            }
          });
          jStat2.extend(jStat2.triangular, {
            pdf: function pdf(x, a, b, c) {
              if (b <= a || c < a || c > b) {
                return NaN;
              } else {
                if (x < a || x > b) {
                  return 0;
                } else if (x < c) {
                  return 2 * (x - a) / ((b - a) * (c - a));
                } else if (x === c) {
                  return 2 / (b - a);
                } else {
                  return 2 * (b - x) / ((b - a) * (b - c));
                }
              }
            },
            cdf: function cdf(x, a, b, c) {
              if (b <= a || c < a || c > b)
                return NaN;
              if (x <= a)
                return 0;
              else if (x >= b)
                return 1;
              if (x <= c)
                return Math2.pow(x - a, 2) / ((b - a) * (c - a));
              else
                return 1 - Math2.pow(b - x, 2) / ((b - a) * (b - c));
            },
            inv: function inv(p, a, b, c) {
              if (b <= a || c < a || c > b) {
                return NaN;
              } else {
                if (p <= (c - a) / (b - a)) {
                  return a + (b - a) * Math2.sqrt(p * ((c - a) / (b - a)));
                } else {
                  return a + (b - a) * (1 - Math2.sqrt((1 - p) * (1 - (c - a) / (b - a))));
                }
              }
            },
            mean: function mean(a, b, c) {
              return (a + b + c) / 3;
            },
            median: function median(a, b, c) {
              if (c <= (a + b) / 2) {
                return b - Math2.sqrt((b - a) * (b - c)) / Math2.sqrt(2);
              } else if (c > (a + b) / 2) {
                return a + Math2.sqrt((b - a) * (c - a)) / Math2.sqrt(2);
              }
            },
            mode: function mode(a, b, c) {
              return c;
            },
            sample: function sample(a, b, c) {
              var u = jStat2._random_fn();
              if (u < (c - a) / (b - a))
                return a + Math2.sqrt(u * (b - a) * (c - a));
              return b - Math2.sqrt((1 - u) * (b - a) * (b - c));
            },
            variance: function variance(a, b, c) {
              return (a * a + b * b + c * c - a * b - a * c - b * c) / 18;
            }
          });
          jStat2.extend(jStat2.arcsine, {
            pdf: function pdf(x, a, b) {
              if (b <= a) return NaN;
              return x <= a || x >= b ? 0 : 2 / Math2.PI * Math2.pow(Math2.pow(b - a, 2) - Math2.pow(2 * x - a - b, 2), -0.5);
            },
            cdf: function cdf(x, a, b) {
              if (x < a)
                return 0;
              else if (x < b)
                return 2 / Math2.PI * Math2.asin(Math2.sqrt((x - a) / (b - a)));
              return 1;
            },
            inv: function(p, a, b) {
              return a + (0.5 - 0.5 * Math2.cos(Math2.PI * p)) * (b - a);
            },
            mean: function mean(a, b) {
              if (b <= a) return NaN;
              return (a + b) / 2;
            },
            median: function median(a, b) {
              if (b <= a) return NaN;
              return (a + b) / 2;
            },
            mode: function mode() {
              throw new Error("mode is not yet implemented");
            },
            sample: function sample(a, b) {
              return (a + b) / 2 + (b - a) / 2 * Math2.sin(2 * Math2.PI * jStat2.uniform.sample(0, 1));
            },
            variance: function variance(a, b) {
              if (b <= a) return NaN;
              return Math2.pow(b - a, 2) / 8;
            }
          });
          function laplaceSign(x) {
            return x / Math2.abs(x);
          }
          jStat2.extend(jStat2.laplace, {
            pdf: function pdf(x, mu, b) {
              return b <= 0 ? 0 : Math2.exp(-Math2.abs(x - mu) / b) / (2 * b);
            },
            cdf: function cdf(x, mu, b) {
              if (b <= 0) {
                return 0;
              }
              if (x < mu) {
                return 0.5 * Math2.exp((x - mu) / b);
              } else {
                return 1 - 0.5 * Math2.exp(-(x - mu) / b);
              }
            },
            mean: function(mu) {
              return mu;
            },
            median: function(mu) {
              return mu;
            },
            mode: function(mu) {
              return mu;
            },
            variance: function(mu, b) {
              return 2 * b * b;
            },
            sample: function sample(mu, b) {
              var u = jStat2._random_fn() - 0.5;
              return mu - b * laplaceSign(u) * Math2.log(1 - 2 * Math2.abs(u));
            }
          });
          function tukeyWprob(w, rr, cc) {
            var nleg = 12;
            var ihalf = 6;
            var C1 = -30;
            var C2 = -50;
            var C3 = 60;
            var bb = 8;
            var wlar = 3;
            var wincr1 = 2;
            var wincr2 = 3;
            var xleg = [
              0.9815606342467192,
              0.9041172563704749,
              0.7699026741943047,
              0.5873179542866175,
              0.3678314989981802,
              0.1252334085114689
            ];
            var aleg = [
              0.04717533638651183,
              0.10693932599531843,
              0.16007832854334622,
              0.20316742672306592,
              0.2334925365383548,
              0.24914704581340277
            ];
            var qsqz = w * 0.5;
            if (qsqz >= bb)
              return 1;
            var pr_w = 2 * jStat2.normal.cdf(qsqz, 0, 1, 1, 0) - 1;
            if (pr_w >= Math2.exp(C2 / cc))
              pr_w = Math2.pow(pr_w, cc);
            else
              pr_w = 0;
            var wincr;
            if (w > wlar)
              wincr = wincr1;
            else
              wincr = wincr2;
            var blb = qsqz;
            var binc = (bb - qsqz) / wincr;
            var bub = blb + binc;
            var einsum = 0;
            var cc1 = cc - 1;
            for (var wi = 1; wi <= wincr; wi++) {
              var elsum = 0;
              var a = 0.5 * (bub + blb);
              var b = 0.5 * (bub - blb);
              for (var jj = 1; jj <= nleg; jj++) {
                var j, xx;
                if (ihalf < jj) {
                  j = nleg - jj + 1;
                  xx = xleg[j - 1];
                } else {
                  j = jj;
                  xx = -xleg[j - 1];
                }
                var c = b * xx;
                var ac = a + c;
                var qexpo = ac * ac;
                if (qexpo > C3)
                  break;
                var pplus = 2 * jStat2.normal.cdf(ac, 0, 1, 1, 0);
                var pminus = 2 * jStat2.normal.cdf(ac, w, 1, 1, 0);
                var rinsum = pplus * 0.5 - pminus * 0.5;
                if (rinsum >= Math2.exp(C1 / cc1)) {
                  rinsum = aleg[j - 1] * Math2.exp(-(0.5 * qexpo)) * Math2.pow(rinsum, cc1);
                  elsum += rinsum;
                }
              }
              elsum *= 2 * b * cc / Math2.sqrt(2 * Math2.PI);
              einsum += elsum;
              blb = bub;
              bub += binc;
            }
            pr_w += einsum;
            if (pr_w <= Math2.exp(C1 / rr))
              return 0;
            pr_w = Math2.pow(pr_w, rr);
            if (pr_w >= 1)
              return 1;
            return pr_w;
          }
          function tukeyQinv(p, c, v) {
            var p0 = 0.322232421088;
            var q0 = 0.099348462606;
            var p1 = -1;
            var q1 = 0.588581570495;
            var p2 = -0.342242088547;
            var q2 = 0.531103462366;
            var p3 = -0.204231210125;
            var q3 = 0.10353775285;
            var p4 = -453642210148e-16;
            var q4 = 0.0038560700634;
            var c1 = 0.8832;
            var c2 = 0.2368;
            var c3 = 1.214;
            var c4 = 1.208;
            var c5 = 1.4142;
            var vmax = 120;
            var ps = 0.5 - 0.5 * p;
            var yi = Math2.sqrt(Math2.log(1 / (ps * ps)));
            var t = yi + ((((yi * p4 + p3) * yi + p2) * yi + p1) * yi + p0) / ((((yi * q4 + q3) * yi + q2) * yi + q1) * yi + q0);
            if (v < vmax) t += (t * t * t + t) / v / 4;
            var q = c1 - c2 * t;
            if (v < vmax) q += -c3 / v + c4 * t / v;
            return t * (q * Math2.log(c - 1) + c5);
          }
          jStat2.extend(jStat2.tukey, {
            cdf: function cdf(q, nmeans, df) {
              var rr = 1;
              var cc = nmeans;
              var nlegq = 16;
              var ihalfq = 8;
              var eps1 = -30;
              var eps2 = 1e-14;
              var dhaf = 100;
              var dquar = 800;
              var deigh = 5e3;
              var dlarg = 25e3;
              var ulen1 = 1;
              var ulen2 = 0.5;
              var ulen3 = 0.25;
              var ulen4 = 0.125;
              var xlegq = [
                0.9894009349916499,
                0.9445750230732326,
                0.8656312023878318,
                0.755404408355003,
                0.6178762444026438,
                0.45801677765722737,
                0.2816035507792589,
                0.09501250983763744
              ];
              var alegq = [
                0.027152459411754096,
                0.062253523938647894,
                0.09515851168249279,
                0.12462897125553388,
                0.14959598881657674,
                0.16915651939500254,
                0.18260341504492358,
                0.1894506104550685
              ];
              if (q <= 0)
                return 0;
              if (df < 2 || rr < 1 || cc < 2) return NaN;
              if (!Number.isFinite(q))
                return 1;
              if (df > dlarg)
                return tukeyWprob(q, rr, cc);
              var f2 = df * 0.5;
              var f2lf = f2 * Math2.log(df) - df * Math2.log(2) - jStat2.gammaln(f2);
              var f21 = f2 - 1;
              var ff4 = df * 0.25;
              var ulen;
              if (df <= dhaf) ulen = ulen1;
              else if (df <= dquar) ulen = ulen2;
              else if (df <= deigh) ulen = ulen3;
              else ulen = ulen4;
              f2lf += Math2.log(ulen);
              var ans = 0;
              for (var i = 1; i <= 50; i++) {
                var otsum = 0;
                var twa1 = (2 * i - 1) * ulen;
                for (var jj = 1; jj <= nlegq; jj++) {
                  var j, t1;
                  if (ihalfq < jj) {
                    j = jj - ihalfq - 1;
                    t1 = f2lf + f21 * Math2.log(twa1 + xlegq[j] * ulen) - (xlegq[j] * ulen + twa1) * ff4;
                  } else {
                    j = jj - 1;
                    t1 = f2lf + f21 * Math2.log(twa1 - xlegq[j] * ulen) + (xlegq[j] * ulen - twa1) * ff4;
                  }
                  var qsqz;
                  if (t1 >= eps1) {
                    if (ihalfq < jj) {
                      qsqz = q * Math2.sqrt((xlegq[j] * ulen + twa1) * 0.5);
                    } else {
                      qsqz = q * Math2.sqrt((-(xlegq[j] * ulen) + twa1) * 0.5);
                    }
                    var wprb = tukeyWprob(qsqz, rr, cc);
                    var rotsum = wprb * alegq[j] * Math2.exp(t1);
                    otsum += rotsum;
                  }
                }
                if (i * ulen >= 1 && otsum <= eps2)
                  break;
                ans += otsum;
              }
              if (otsum > eps2) {
                throw new Error("tukey.cdf failed to converge");
              }
              if (ans > 1)
                ans = 1;
              return ans;
            },
            inv: function(p, nmeans, df) {
              var rr = 1;
              var cc = nmeans;
              var eps = 1e-4;
              var maxiter = 50;
              if (df < 2 || rr < 1 || cc < 2) return NaN;
              if (p < 0 || p > 1) return NaN;
              if (p === 0) return 0;
              if (p === 1) return Infinity;
              var x0 = tukeyQinv(p, cc, df);
              var valx0 = jStat2.tukey.cdf(x0, nmeans, df) - p;
              var x1;
              if (valx0 > 0)
                x1 = Math2.max(0, x0 - 1);
              else
                x1 = x0 + 1;
              var valx1 = jStat2.tukey.cdf(x1, nmeans, df) - p;
              var ans;
              for (var iter = 1; iter < maxiter; iter++) {
                ans = x1 - valx1 * (x1 - x0) / (valx1 - valx0);
                valx0 = valx1;
                x0 = x1;
                if (ans < 0) {
                  ans = 0;
                  valx1 = -p;
                }
                valx1 = jStat2.tukey.cdf(ans, nmeans, df) - p;
                x1 = ans;
                var xabs = Math2.abs(x1 - x0);
                if (xabs < eps)
                  return ans;
              }
              throw new Error("tukey.inv failed to converge");
            }
          });
        })(jStat, Math);
        (function(jStat2, Math2) {
          var push = Array.prototype.push;
          var isArray2 = jStat2.utils.isArray;
          function isUsable(arg) {
            return isArray2(arg) || arg instanceof jStat2;
          }
          jStat2.extend({
            // add a vector/matrix to a vector/matrix or scalar
            add: function add(arr, arg) {
              if (isUsable(arg)) {
                if (!isUsable(arg[0])) arg = [arg];
                return jStat2.map(arr, function(value, row, col) {
                  return value + arg[row][col];
                });
              }
              return jStat2.map(arr, function(value) {
                return value + arg;
              });
            },
            // subtract a vector or scalar from the vector
            subtract: function subtract(arr, arg) {
              if (isUsable(arg)) {
                if (!isUsable(arg[0])) arg = [arg];
                return jStat2.map(arr, function(value, row, col) {
                  return value - arg[row][col] || 0;
                });
              }
              return jStat2.map(arr, function(value) {
                return value - arg;
              });
            },
            // matrix division
            divide: function divide(arr, arg) {
              if (isUsable(arg)) {
                if (!isUsable(arg[0])) arg = [arg];
                return jStat2.multiply(arr, jStat2.inv(arg));
              }
              return jStat2.map(arr, function(value) {
                return value / arg;
              });
            },
            // matrix multiplication
            multiply: function multiply(arr, arg) {
              var row, col, nrescols, sum, nrow, ncol, res, rescols;
              if (arr.length === void 0 && arg.length === void 0) {
                return arr * arg;
              }
              nrow = arr.length, ncol = arr[0].length, res = jStat2.zeros(nrow, nrescols = isUsable(arg) ? arg[0].length : ncol), rescols = 0;
              if (isUsable(arg)) {
                for (; rescols < nrescols; rescols++) {
                  for (row = 0; row < nrow; row++) {
                    sum = 0;
                    for (col = 0; col < ncol; col++)
                      sum += arr[row][col] * arg[col][rescols];
                    res[row][rescols] = sum;
                  }
                }
                return nrow === 1 && rescols === 1 ? res[0][0] : res;
              }
              return jStat2.map(arr, function(value) {
                return value * arg;
              });
            },
            // outer([1,2,3],[4,5,6])
            // ===
            // [[1],[2],[3]] times [[4,5,6]]
            // ->
            // [[4,5,6],[8,10,12],[12,15,18]]
            outer: function outer(A, B) {
              return jStat2.multiply(A.map(function(t) {
                return [t];
              }), [B]);
            },
            // Returns the dot product of two matricies
            dot: function dot(arr, arg) {
              if (!isUsable(arr[0])) arr = [arr];
              if (!isUsable(arg[0])) arg = [arg];
              var left = arr[0].length === 1 && arr.length !== 1 ? jStat2.transpose(arr) : arr, right = arg[0].length === 1 && arg.length !== 1 ? jStat2.transpose(arg) : arg, res = [], row = 0, nrow = left.length, ncol = left[0].length, sum, col;
              for (; row < nrow; row++) {
                res[row] = [];
                sum = 0;
                for (col = 0; col < ncol; col++)
                  sum += left[row][col] * right[row][col];
                res[row] = sum;
              }
              return res.length === 1 ? res[0] : res;
            },
            // raise every element by a scalar
            pow: function pow(arr, arg) {
              return jStat2.map(arr, function(value) {
                return Math2.pow(value, arg);
              });
            },
            // exponentiate every element
            exp: function exp(arr) {
              return jStat2.map(arr, function(value) {
                return Math2.exp(value);
              });
            },
            // generate the natural log of every element
            log: function exp(arr) {
              return jStat2.map(arr, function(value) {
                return Math2.log(value);
              });
            },
            // generate the absolute values of the vector
            abs: function abs(arr) {
              return jStat2.map(arr, function(value) {
                return Math2.abs(value);
              });
            },
            // computes the p-norm of the vector
            // In the case that a matrix is passed, uses the first row as the vector
            norm: function norm(arr, p) {
              var nnorm = 0, i = 0;
              if (isNaN(p)) p = 2;
              if (isUsable(arr[0])) arr = arr[0];
              for (; i < arr.length; i++) {
                nnorm += Math2.pow(Math2.abs(arr[i]), p);
              }
              return Math2.pow(nnorm, 1 / p);
            },
            // computes the angle between two vectors in rads
            // In case a matrix is passed, this uses the first row as the vector
            angle: function angle(arr, arg) {
              return Math2.acos(jStat2.dot(arr, arg) / (jStat2.norm(arr) * jStat2.norm(arg)));
            },
            // augment one matrix by another
            // Note: this function returns a matrix, not a jStat object
            aug: function aug(a, b) {
              var newarr = [];
              var i;
              for (i = 0; i < a.length; i++) {
                newarr.push(a[i].slice());
              }
              for (i = 0; i < newarr.length; i++) {
                push.apply(newarr[i], b[i]);
              }
              return newarr;
            },
            // The inv() function calculates the inverse of a matrix
            // Create the inverse by augmenting the matrix by the identity matrix of the
            // appropriate size, and then use G-J elimination on the augmented matrix.
            inv: function inv(a) {
              var rows = a.length;
              var cols = a[0].length;
              var b = jStat2.identity(rows, cols);
              var c = jStat2.gauss_jordan(a, b);
              var result = [];
              var i = 0;
              var j;
              for (; i < rows; i++) {
                result[i] = [];
                for (j = cols; j < c[0].length; j++)
                  result[i][j - cols] = c[i][j];
              }
              return result;
            },
            // calculate the determinant of a matrix
            det: function det(a) {
              if (a.length === 2) {
                return a[0][0] * a[1][1] - a[0][1] * a[1][0];
              }
              var determinant = 0;
              for (var i = 0; i < a.length; i++) {
                var submatrix = [];
                for (var row = 1; row < a.length; row++) {
                  submatrix[row - 1] = [];
                  for (var col = 0; col < a.length; col++) {
                    if (col < i) {
                      submatrix[row - 1][col] = a[row][col];
                    } else if (col > i) {
                      submatrix[row - 1][col - 1] = a[row][col];
                    }
                  }
                }
                var sign = i % 2 ? -1 : 1;
                determinant += det(submatrix) * a[0][i] * sign;
              }
              return determinant;
            },
            gauss_elimination: function gauss_elimination(a, b) {
              var i = 0, j = 0, n = a.length, m = a[0].length, factor = 1, sum = 0, x = [], maug, pivot, temp, k;
              a = jStat2.aug(a, b);
              maug = a[0].length;
              for (i = 0; i < n; i++) {
                pivot = a[i][i];
                j = i;
                for (k = i + 1; k < m; k++) {
                  if (pivot < Math2.abs(a[k][i])) {
                    pivot = a[k][i];
                    j = k;
                  }
                }
                if (j != i) {
                  for (k = 0; k < maug; k++) {
                    temp = a[i][k];
                    a[i][k] = a[j][k];
                    a[j][k] = temp;
                  }
                }
                for (j = i + 1; j < n; j++) {
                  factor = a[j][i] / a[i][i];
                  for (k = i; k < maug; k++) {
                    a[j][k] = a[j][k] - factor * a[i][k];
                  }
                }
              }
              for (i = n - 1; i >= 0; i--) {
                sum = 0;
                for (j = i + 1; j <= n - 1; j++) {
                  sum = sum + x[j] * a[i][j];
                }
                x[i] = (a[i][maug - 1] - sum) / a[i][i];
              }
              return x;
            },
            gauss_jordan: function gauss_jordan(a, b) {
              var m = jStat2.aug(a, b);
              var h = m.length;
              var w = m[0].length;
              var c = 0;
              var x, y, y2;
              for (y = 0; y < h; y++) {
                var maxrow = y;
                for (y2 = y + 1; y2 < h; y2++) {
                  if (Math2.abs(m[y2][y]) > Math2.abs(m[maxrow][y]))
                    maxrow = y2;
                }
                var tmp = m[y];
                m[y] = m[maxrow];
                m[maxrow] = tmp;
                for (y2 = y + 1; y2 < h; y2++) {
                  c = m[y2][y] / m[y][y];
                  for (x = y; x < w; x++) {
                    m[y2][x] -= m[y][x] * c;
                  }
                }
              }
              for (y = h - 1; y >= 0; y--) {
                c = m[y][y];
                for (y2 = 0; y2 < y; y2++) {
                  for (x = w - 1; x > y - 1; x--) {
                    m[y2][x] -= m[y][x] * m[y2][y] / c;
                  }
                }
                m[y][y] /= c;
                for (x = h; x < w; x++) {
                  m[y][x] /= c;
                }
              }
              return m;
            },
            // solve equation
            // Ax=b
            // A is upper triangular matrix
            // A=[[1,2,3],[0,4,5],[0,6,7]]
            // b=[1,2,3]
            // triaUpSolve(A,b) // -> [2.666,0.1666,1.666]
            // if you use matrix style
            // A=[[1,2,3],[0,4,5],[0,6,7]]
            // b=[[1],[2],[3]]
            // will return [[2.666],[0.1666],[1.666]]
            triaUpSolve: function triaUpSolve(A, b) {
              var size = A[0].length;
              var x = jStat2.zeros(1, size)[0];
              var parts;
              var matrix_mode = false;
              if (b[0].length != void 0) {
                b = b.map(function(i) {
                  return i[0];
                });
                matrix_mode = true;
              }
              jStat2.arange(size - 1, -1, -1).forEach(function(i) {
                parts = jStat2.arange(i + 1, size).map(function(j) {
                  return x[j] * A[i][j];
                });
                x[i] = (b[i] - jStat2.sum(parts)) / A[i][i];
              });
              if (matrix_mode)
                return x.map(function(i) {
                  return [i];
                });
              return x;
            },
            triaLowSolve: function triaLowSolve(A, b) {
              var size = A[0].length;
              var x = jStat2.zeros(1, size)[0];
              var parts;
              var matrix_mode = false;
              if (b[0].length != void 0) {
                b = b.map(function(i) {
                  return i[0];
                });
                matrix_mode = true;
              }
              jStat2.arange(size).forEach(function(i) {
                parts = jStat2.arange(i).map(function(j) {
                  return A[i][j] * x[j];
                });
                x[i] = (b[i] - jStat2.sum(parts)) / A[i][i];
              });
              if (matrix_mode)
                return x.map(function(i) {
                  return [i];
                });
              return x;
            },
            // A -> [L,U]
            // A=LU
            // L is lower triangular matrix
            // U is upper triangular matrix
            lu: function lu(A) {
              var size = A.length;
              var L = jStat2.identity(size);
              var R = jStat2.zeros(A.length, A[0].length);
              var parts;
              jStat2.arange(size).forEach(function(t) {
                R[0][t] = A[0][t];
              });
              jStat2.arange(1, size).forEach(function(l) {
                jStat2.arange(l).forEach(function(i) {
                  parts = jStat2.arange(i).map(function(jj) {
                    return L[l][jj] * R[jj][i];
                  });
                  L[l][i] = (A[l][i] - jStat2.sum(parts)) / R[i][i];
                });
                jStat2.arange(l, size).forEach(function(j) {
                  parts = jStat2.arange(l).map(function(jj) {
                    return L[l][jj] * R[jj][j];
                  });
                  R[l][j] = A[parts.length][j] - jStat2.sum(parts);
                });
              });
              return [L, R];
            },
            // A -> T
            // A=TT'
            // T is lower triangular matrix
            cholesky: function cholesky(A) {
              var size = A.length;
              var T = jStat2.zeros(A.length, A[0].length);
              var parts;
              jStat2.arange(size).forEach(function(i) {
                parts = jStat2.arange(i).map(function(t) {
                  return Math2.pow(T[i][t], 2);
                });
                T[i][i] = Math2.sqrt(A[i][i] - jStat2.sum(parts));
                jStat2.arange(i + 1, size).forEach(function(j) {
                  parts = jStat2.arange(i).map(function(t) {
                    return T[i][t] * T[j][t];
                  });
                  T[j][i] = (A[i][j] - jStat2.sum(parts)) / T[i][i];
                });
              });
              return T;
            },
            gauss_jacobi: function gauss_jacobi(a, b, x, r) {
              var i = 0;
              var j = 0;
              var n = a.length;
              var l = [];
              var u = [];
              var d = [];
              var xv, c, h, xk;
              for (; i < n; i++) {
                l[i] = [];
                u[i] = [];
                d[i] = [];
                for (j = 0; j < n; j++) {
                  if (i > j) {
                    l[i][j] = a[i][j];
                    u[i][j] = d[i][j] = 0;
                  } else if (i < j) {
                    u[i][j] = a[i][j];
                    l[i][j] = d[i][j] = 0;
                  } else {
                    d[i][j] = a[i][j];
                    l[i][j] = u[i][j] = 0;
                  }
                }
              }
              h = jStat2.multiply(jStat2.multiply(jStat2.inv(d), jStat2.add(l, u)), -1);
              c = jStat2.multiply(jStat2.inv(d), b);
              xv = x;
              xk = jStat2.add(jStat2.multiply(h, x), c);
              i = 2;
              while (Math2.abs(jStat2.norm(jStat2.subtract(xk, xv))) > r) {
                xv = xk;
                xk = jStat2.add(jStat2.multiply(h, xv), c);
                i++;
              }
              return xk;
            },
            gauss_seidel: function gauss_seidel(a, b, x, r) {
              var i = 0;
              var n = a.length;
              var l = [];
              var u = [];
              var d = [];
              var j, xv, c, h, xk;
              for (; i < n; i++) {
                l[i] = [];
                u[i] = [];
                d[i] = [];
                for (j = 0; j < n; j++) {
                  if (i > j) {
                    l[i][j] = a[i][j];
                    u[i][j] = d[i][j] = 0;
                  } else if (i < j) {
                    u[i][j] = a[i][j];
                    l[i][j] = d[i][j] = 0;
                  } else {
                    d[i][j] = a[i][j];
                    l[i][j] = u[i][j] = 0;
                  }
                }
              }
              h = jStat2.multiply(jStat2.multiply(jStat2.inv(jStat2.add(d, l)), u), -1);
              c = jStat2.multiply(jStat2.inv(jStat2.add(d, l)), b);
              xv = x;
              xk = jStat2.add(jStat2.multiply(h, x), c);
              i = 2;
              while (Math2.abs(jStat2.norm(jStat2.subtract(xk, xv))) > r) {
                xv = xk;
                xk = jStat2.add(jStat2.multiply(h, xv), c);
                i = i + 1;
              }
              return xk;
            },
            SOR: function SOR(a, b, x, r, w) {
              var i = 0;
              var n = a.length;
              var l = [];
              var u = [];
              var d = [];
              var j, xv, c, h, xk;
              for (; i < n; i++) {
                l[i] = [];
                u[i] = [];
                d[i] = [];
                for (j = 0; j < n; j++) {
                  if (i > j) {
                    l[i][j] = a[i][j];
                    u[i][j] = d[i][j] = 0;
                  } else if (i < j) {
                    u[i][j] = a[i][j];
                    l[i][j] = d[i][j] = 0;
                  } else {
                    d[i][j] = a[i][j];
                    l[i][j] = u[i][j] = 0;
                  }
                }
              }
              h = jStat2.multiply(
                jStat2.inv(jStat2.add(d, jStat2.multiply(l, w))),
                jStat2.subtract(
                  jStat2.multiply(d, 1 - w),
                  jStat2.multiply(u, w)
                )
              );
              c = jStat2.multiply(jStat2.multiply(jStat2.inv(jStat2.add(
                d,
                jStat2.multiply(l, w)
              )), b), w);
              xv = x;
              xk = jStat2.add(jStat2.multiply(h, x), c);
              i = 2;
              while (Math2.abs(jStat2.norm(jStat2.subtract(xk, xv))) > r) {
                xv = xk;
                xk = jStat2.add(jStat2.multiply(h, xv), c);
                i++;
              }
              return xk;
            },
            householder: function householder(a) {
              var m = a.length;
              var n = a[0].length;
              var i = 0;
              var w = [];
              var p = [];
              var alpha, r, k, j, factor;
              for (; i < m - 1; i++) {
                alpha = 0;
                for (j = i + 1; j < n; j++)
                  alpha += a[j][i] * a[j][i];
                factor = a[i + 1][i] > 0 ? -1 : 1;
                alpha = factor * Math2.sqrt(alpha);
                r = Math2.sqrt((alpha * alpha - a[i + 1][i] * alpha) / 2);
                w = jStat2.zeros(m, 1);
                w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);
                for (k = i + 2; k < m; k++) w[k][0] = a[k][i] / (2 * r);
                p = jStat2.subtract(
                  jStat2.identity(m, n),
                  jStat2.multiply(jStat2.multiply(w, jStat2.transpose(w)), 2)
                );
                a = jStat2.multiply(p, jStat2.multiply(a, p));
              }
              return a;
            },
            // A -> [Q,R]
            // Q is orthogonal matrix
            // R is upper triangular
            QR: (function() {
              var sum = jStat2.sum;
              var range2 = jStat2.arange;
              function qr2(x) {
                var n = x.length;
                var p = x[0].length;
                var r = jStat2.zeros(p, p);
                x = jStat2.copy(x);
                var i, j, k;
                for (j = 0; j < p; j++) {
                  r[j][j] = Math2.sqrt(sum(range2(n).map(function(i2) {
                    return x[i2][j] * x[i2][j];
                  })));
                  for (i = 0; i < n; i++) {
                    x[i][j] = x[i][j] / r[j][j];
                  }
                  for (k = j + 1; k < p; k++) {
                    r[j][k] = sum(range2(n).map(function(i2) {
                      return x[i2][j] * x[i2][k];
                    }));
                    for (i = 0; i < n; i++) {
                      x[i][k] = x[i][k] - x[i][j] * r[j][k];
                    }
                  }
                }
                return [x, r];
              }
              return qr2;
            })(),
            lstsq: /* @__PURE__ */ (function() {
              function R_I(A) {
                A = jStat2.copy(A);
                var size = A.length;
                var I = jStat2.identity(size);
                jStat2.arange(size - 1, -1, -1).forEach(function(i) {
                  jStat2.sliceAssign(
                    I,
                    { row: i },
                    jStat2.divide(jStat2.slice(I, { row: i }), A[i][i])
                  );
                  jStat2.sliceAssign(
                    A,
                    { row: i },
                    jStat2.divide(jStat2.slice(A, { row: i }), A[i][i])
                  );
                  jStat2.arange(i).forEach(function(j) {
                    var c = jStat2.multiply(A[j][i], -1);
                    var Aj = jStat2.slice(A, { row: j });
                    var cAi = jStat2.multiply(jStat2.slice(A, { row: i }), c);
                    jStat2.sliceAssign(A, { row: j }, jStat2.add(Aj, cAi));
                    var Ij = jStat2.slice(I, { row: j });
                    var cIi = jStat2.multiply(jStat2.slice(I, { row: i }), c);
                    jStat2.sliceAssign(I, { row: j }, jStat2.add(Ij, cIi));
                  });
                });
                return I;
              }
              function qr_solve(A, b) {
                var array_mode = false;
                if (b[0].length === void 0) {
                  b = b.map(function(x2) {
                    return [x2];
                  });
                  array_mode = true;
                }
                var QR = jStat2.QR(A);
                var Q = QR[0];
                var R = QR[1];
                var attrs = A[0].length;
                var Q1 = jStat2.slice(Q, { col: { end: attrs } });
                var R1 = jStat2.slice(R, { row: { end: attrs } });
                var RI = R_I(R1);
                var Q2 = jStat2.transpose(Q1);
                if (Q2[0].length === void 0) {
                  Q2 = [Q2];
                }
                var x = jStat2.multiply(jStat2.multiply(RI, Q2), b);
                if (x.length === void 0) {
                  x = [[x]];
                }
                if (array_mode)
                  return x.map(function(i) {
                    return i[0];
                  });
                return x;
              }
              return qr_solve;
            })(),
            jacobi: function jacobi(a) {
              var condition = 1;
              var n = a.length;
              var e = jStat2.identity(n, n);
              var ev = [];
              var b, i, j, p, q, maxim, theta, s;
              while (condition === 1) {
                maxim = a[0][1];
                p = 0;
                q = 1;
                for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                    if (i != j) {
                      if (maxim < Math2.abs(a[i][j])) {
                        maxim = Math2.abs(a[i][j]);
                        p = i;
                        q = j;
                      }
                    }
                  }
                }
                if (a[p][p] === a[q][q])
                  theta = a[p][q] > 0 ? Math2.PI / 4 : -Math2.PI / 4;
                else
                  theta = Math2.atan(2 * a[p][q] / (a[p][p] - a[q][q])) / 2;
                s = jStat2.identity(n, n);
                s[p][p] = Math2.cos(theta);
                s[p][q] = -Math2.sin(theta);
                s[q][p] = Math2.sin(theta);
                s[q][q] = Math2.cos(theta);
                e = jStat2.multiply(e, s);
                b = jStat2.multiply(jStat2.multiply(jStat2.inv(s), a), s);
                a = b;
                condition = 0;
                for (i = 1; i < n; i++) {
                  for (j = 1; j < n; j++) {
                    if (i != j && Math2.abs(a[i][j]) > 1e-3) {
                      condition = 1;
                    }
                  }
                }
              }
              for (i = 0; i < n; i++) ev.push(a[i][i]);
              return [e, ev];
            },
            rungekutta: function rungekutta(f, h, p, t_j, u_j, order) {
              var k1, k2, u_j1, k3, k4;
              if (order === 2) {
                while (t_j <= p) {
                  k1 = h * f(t_j, u_j);
                  k2 = h * f(t_j + h, u_j + k1);
                  u_j1 = u_j + (k1 + k2) / 2;
                  u_j = u_j1;
                  t_j = t_j + h;
                }
              }
              if (order === 4) {
                while (t_j <= p) {
                  k1 = h * f(t_j, u_j);
                  k2 = h * f(t_j + h / 2, u_j + k1 / 2);
                  k3 = h * f(t_j + h / 2, u_j + k2 / 2);
                  k4 = h * f(t_j + h, u_j + k3);
                  u_j1 = u_j + (k1 + 2 * k2 + 2 * k3 + k4) / 6;
                  u_j = u_j1;
                  t_j = t_j + h;
                }
              }
              return u_j;
            },
            romberg: function romberg(f, a, b, order) {
              var i = 0;
              var h = (b - a) / 2;
              var x = [];
              var h1 = [];
              var g = [];
              var m, a1, j, k, I;
              while (i < order / 2) {
                I = f(a);
                for (j = a, k = 0; j <= b; j = j + h, k++) x[k] = j;
                m = x.length;
                for (j = 1; j < m - 1; j++) {
                  I += (j % 2 !== 0 ? 4 : 2) * f(x[j]);
                }
                I = h / 3 * (I + f(b));
                g[i] = I;
                h /= 2;
                i++;
              }
              a1 = g.length;
              m = 1;
              while (a1 !== 1) {
                for (j = 0; j < a1 - 1; j++)
                  h1[j] = (Math2.pow(4, m) * g[j + 1] - g[j]) / (Math2.pow(4, m) - 1);
                a1 = h1.length;
                g = h1;
                h1 = [];
                m++;
              }
              return g;
            },
            richardson: function richardson(X, f, x, h) {
              function pos(X2, x2) {
                var i2 = 0;
                var n = X2.length;
                var p;
                for (; i2 < n; i2++)
                  if (X2[i2] === x2) p = i2;
                return p;
              }
              var h_min = Math2.abs(x - X[pos(X, x) + 1]);
              var i = 0;
              var g = [];
              var h1 = [];
              var y1, y2, m, a, j;
              while (h >= h_min) {
                y1 = pos(X, x + h);
                y2 = pos(X, x);
                g[i] = (f[y1] - 2 * f[y2] + f[2 * y2 - y1]) / (h * h);
                h /= 2;
                i++;
              }
              a = g.length;
              m = 1;
              while (a != 1) {
                for (j = 0; j < a - 1; j++)
                  h1[j] = (Math2.pow(4, m) * g[j + 1] - g[j]) / (Math2.pow(4, m) - 1);
                a = h1.length;
                g = h1;
                h1 = [];
                m++;
              }
              return g;
            },
            simpson: function simpson(f, a, b, n) {
              var h = (b - a) / n;
              var I = f(a);
              var x = [];
              var j = a;
              var k = 0;
              var i = 1;
              var m;
              for (; j <= b; j = j + h, k++)
                x[k] = j;
              m = x.length;
              for (; i < m - 1; i++) {
                I += (i % 2 !== 0 ? 4 : 2) * f(x[i]);
              }
              return h / 3 * (I + f(b));
            },
            hermite: function hermite(X, F, dF, value) {
              var n = X.length;
              var p = 0;
              var i = 0;
              var l = [];
              var dl = [];
              var A = [];
              var B = [];
              var j;
              for (; i < n; i++) {
                l[i] = 1;
                for (j = 0; j < n; j++) {
                  if (i != j) l[i] *= (value - X[j]) / (X[i] - X[j]);
                }
                dl[i] = 0;
                for (j = 0; j < n; j++) {
                  if (i != j) dl[i] += 1 / (X[i] - X[j]);
                }
                A[i] = (1 - 2 * (value - X[i]) * dl[i]) * (l[i] * l[i]);
                B[i] = (value - X[i]) * (l[i] * l[i]);
                p += A[i] * F[i] + B[i] * dF[i];
              }
              return p;
            },
            lagrange: function lagrange(X, F, value) {
              var p = 0;
              var i = 0;
              var j, l;
              var n = X.length;
              for (; i < n; i++) {
                l = F[i];
                for (j = 0; j < n; j++) {
                  if (i != j) l *= (value - X[j]) / (X[i] - X[j]);
                }
                p += l;
              }
              return p;
            },
            cubic_spline: function cubic_spline(X, F, value) {
              var n = X.length;
              var i = 0, j;
              var A = [];
              var B = [];
              var alpha = [];
              var c = [];
              var h = [];
              var b = [];
              var d = [];
              for (; i < n - 1; i++)
                h[i] = X[i + 1] - X[i];
              alpha[0] = 0;
              for (i = 1; i < n - 1; i++) {
                alpha[i] = 3 / h[i] * (F[i + 1] - F[i]) - 3 / h[i - 1] * (F[i] - F[i - 1]);
              }
              for (i = 1; i < n - 1; i++) {
                A[i] = [];
                B[i] = [];
                A[i][i - 1] = h[i - 1];
                A[i][i] = 2 * (h[i - 1] + h[i]);
                A[i][i + 1] = h[i];
                B[i][0] = alpha[i];
              }
              c = jStat2.multiply(jStat2.inv(A), B);
              for (j = 0; j < n - 1; j++) {
                b[j] = (F[j + 1] - F[j]) / h[j] - h[j] * (c[j + 1][0] + 2 * c[j][0]) / 3;
                d[j] = (c[j + 1][0] - c[j][0]) / (3 * h[j]);
              }
              for (j = 0; j < n; j++) {
                if (X[j] > value) break;
              }
              j -= 1;
              return F[j] + (value - X[j]) * b[j] + jStat2.sq(value - X[j]) * c[j] + (value - X[j]) * jStat2.sq(value - X[j]) * d[j];
            },
            gauss_quadrature: function gauss_quadrature() {
              throw new Error("gauss_quadrature not yet implemented");
            },
            PCA: function PCA(X) {
              var m = X.length;
              var n = X[0].length;
              var i = 0;
              var j, temp1;
              var u = [];
              var D = [];
              var result = [];
              var temp2 = [];
              var Y = [];
              var Bt = [];
              var B = [];
              var C = [];
              var V = [];
              var Vt = [];
              for (i = 0; i < m; i++) {
                u[i] = jStat2.sum(X[i]) / n;
              }
              for (i = 0; i < n; i++) {
                B[i] = [];
                for (j = 0; j < m; j++) {
                  B[i][j] = X[j][i] - u[j];
                }
              }
              B = jStat2.transpose(B);
              for (i = 0; i < m; i++) {
                C[i] = [];
                for (j = 0; j < m; j++) {
                  C[i][j] = jStat2.dot([B[i]], [B[j]]) / (n - 1);
                }
              }
              result = jStat2.jacobi(C);
              V = result[0];
              D = result[1];
              Vt = jStat2.transpose(V);
              for (i = 0; i < D.length; i++) {
                for (j = i; j < D.length; j++) {
                  if (D[i] < D[j]) {
                    temp1 = D[i];
                    D[i] = D[j];
                    D[j] = temp1;
                    temp2 = Vt[i];
                    Vt[i] = Vt[j];
                    Vt[j] = temp2;
                  }
                }
              }
              Bt = jStat2.transpose(B);
              for (i = 0; i < m; i++) {
                Y[i] = [];
                for (j = 0; j < Bt.length; j++) {
                  Y[i][j] = jStat2.dot([Vt[i]], [Bt[j]]);
                }
              }
              return [X, D, Vt, Y];
            }
          });
          (function(funcs) {
            for (var i = 0; i < funcs.length; i++) (function(passfunc) {
              jStat2.fn[passfunc] = function(arg, func) {
                var tmpthis = this;
                if (func) {
                  setTimeout(function() {
                    func.call(tmpthis, jStat2.fn[passfunc].call(tmpthis, arg));
                  }, 15);
                  return this;
                }
                if (typeof jStat2[passfunc](this, arg) === "number")
                  return jStat2[passfunc](this, arg);
                else
                  return jStat2(jStat2[passfunc](this, arg));
              };
            })(funcs[i]);
          })("add divide multiply subtract dot pow exp log abs norm angle".split(" "));
        })(jStat, Math);
        (function(jStat2, Math2) {
          var slice2 = [].slice;
          var isNumber = jStat2.utils.isNumber;
          var isArray2 = jStat2.utils.isArray;
          jStat2.extend({
            // 2 different parameter lists:
            // (value, mean, sd)
            // (value, array, flag)
            zscore: function zscore() {
              var args = slice2.call(arguments);
              if (isNumber(args[1])) {
                return (args[0] - args[1]) / args[2];
              }
              return (args[0] - jStat2.mean(args[1])) / jStat2.stdev(args[1], args[2]);
            },
            // 3 different paramter lists:
            // (value, mean, sd, sides)
            // (zscore, sides)
            // (value, array, sides, flag)
            ztest: function ztest() {
              var args = slice2.call(arguments);
              var z;
              if (isArray2(args[1])) {
                z = jStat2.zscore(args[0], args[1], args[3]);
                return args[2] === 1 ? jStat2.normal.cdf(-Math2.abs(z), 0, 1) : jStat2.normal.cdf(-Math2.abs(z), 0, 1) * 2;
              } else {
                if (args.length > 2) {
                  z = jStat2.zscore(args[0], args[1], args[2]);
                  return args[3] === 1 ? jStat2.normal.cdf(-Math2.abs(z), 0, 1) : jStat2.normal.cdf(-Math2.abs(z), 0, 1) * 2;
                } else {
                  z = args[0];
                  return args[1] === 1 ? jStat2.normal.cdf(-Math2.abs(z), 0, 1) : jStat2.normal.cdf(-Math2.abs(z), 0, 1) * 2;
                }
              }
            }
          });
          jStat2.extend(jStat2.fn, {
            zscore: function zscore(value, flag) {
              return (value - this.mean()) / this.stdev(flag);
            },
            ztest: function ztest(value, sides, flag) {
              var zscore = Math2.abs(this.zscore(value, flag));
              return sides === 1 ? jStat2.normal.cdf(-zscore, 0, 1) : jStat2.normal.cdf(-zscore, 0, 1) * 2;
            }
          });
          jStat2.extend({
            // 2 parameter lists
            // (value, mean, sd, n)
            // (value, array)
            tscore: function tscore() {
              var args = slice2.call(arguments);
              return args.length === 4 ? (args[0] - args[1]) / (args[2] / Math2.sqrt(args[3])) : (args[0] - jStat2.mean(args[1])) / (jStat2.stdev(args[1], true) / Math2.sqrt(args[1].length));
            },
            // 3 different paramter lists:
            // (value, mean, sd, n, sides)
            // (tscore, n, sides)
            // (value, array, sides)
            ttest: function ttest() {
              var args = slice2.call(arguments);
              var tscore;
              if (args.length === 5) {
                tscore = Math2.abs(jStat2.tscore(args[0], args[1], args[2], args[3]));
                return args[4] === 1 ? jStat2.studentt.cdf(-tscore, args[3] - 1) : jStat2.studentt.cdf(-tscore, args[3] - 1) * 2;
              }
              if (isNumber(args[1])) {
                tscore = Math2.abs(args[0]);
                return args[2] == 1 ? jStat2.studentt.cdf(-tscore, args[1] - 1) : jStat2.studentt.cdf(-tscore, args[1] - 1) * 2;
              }
              tscore = Math2.abs(jStat2.tscore(args[0], args[1]));
              return args[2] == 1 ? jStat2.studentt.cdf(-tscore, args[1].length - 1) : jStat2.studentt.cdf(-tscore, args[1].length - 1) * 2;
            }
          });
          jStat2.extend(jStat2.fn, {
            tscore: function tscore(value) {
              return (value - this.mean()) / (this.stdev(true) / Math2.sqrt(this.cols()));
            },
            ttest: function ttest(value, sides) {
              return sides === 1 ? 1 - jStat2.studentt.cdf(Math2.abs(this.tscore(value)), this.cols() - 1) : jStat2.studentt.cdf(-Math2.abs(this.tscore(value)), this.cols() - 1) * 2;
            }
          });
          jStat2.extend({
            // Paramter list is as follows:
            // (array1, array2, array3, ...)
            // or it is an array of arrays
            // array of arrays conversion
            anovafscore: function anovafscore() {
              var args = slice2.call(arguments), expVar, sample, sampMean, sampSampMean, tmpargs, unexpVar, i, j;
              if (args.length === 1) {
                tmpargs = new Array(args[0].length);
                for (i = 0; i < args[0].length; i++) {
                  tmpargs[i] = args[0][i];
                }
                args = tmpargs;
              }
              sample = new Array();
              for (i = 0; i < args.length; i++) {
                sample = sample.concat(args[i]);
              }
              sampMean = jStat2.mean(sample);
              expVar = 0;
              for (i = 0; i < args.length; i++) {
                expVar = expVar + args[i].length * Math2.pow(jStat2.mean(args[i]) - sampMean, 2);
              }
              expVar /= args.length - 1;
              unexpVar = 0;
              for (i = 0; i < args.length; i++) {
                sampSampMean = jStat2.mean(args[i]);
                for (j = 0; j < args[i].length; j++) {
                  unexpVar += Math2.pow(args[i][j] - sampSampMean, 2);
                }
              }
              unexpVar /= sample.length - args.length;
              return expVar / unexpVar;
            },
            // 2 different paramter setups
            // (array1, array2, array3, ...)
            // (anovafscore, df1, df2)
            anovaftest: function anovaftest() {
              var args = slice2.call(arguments), df1, df2, n, i;
              if (isNumber(args[0])) {
                return 1 - jStat2.centralF.cdf(args[0], args[1], args[2]);
              }
              var anovafscore = jStat2.anovafscore(args);
              df1 = args.length - 1;
              n = 0;
              for (i = 0; i < args.length; i++) {
                n = n + args[i].length;
              }
              df2 = n - df1 - 1;
              return 1 - jStat2.centralF.cdf(anovafscore, df1, df2);
            },
            ftest: function ftest(fscore, df1, df2) {
              return 1 - jStat2.centralF.cdf(fscore, df1, df2);
            }
          });
          jStat2.extend(jStat2.fn, {
            anovafscore: function anovafscore() {
              return jStat2.anovafscore(this.toArray());
            },
            anovaftes: function anovaftes() {
              var n = 0;
              var i;
              for (i = 0; i < this.length; i++) {
                n = n + this[i].length;
              }
              return jStat2.ftest(this.anovafscore(), this.length - 1, n - this.length);
            }
          });
          jStat2.extend({
            // 2 parameter lists
            // (mean1, mean2, n1, n2, sd)
            // (array1, array2, sd)
            qscore: function qscore() {
              var args = slice2.call(arguments);
              var mean1, mean2, n1, n2, sd;
              if (isNumber(args[0])) {
                mean1 = args[0];
                mean2 = args[1];
                n1 = args[2];
                n2 = args[3];
                sd = args[4];
              } else {
                mean1 = jStat2.mean(args[0]);
                mean2 = jStat2.mean(args[1]);
                n1 = args[0].length;
                n2 = args[1].length;
                sd = args[2];
              }
              return Math2.abs(mean1 - mean2) / (sd * Math2.sqrt((1 / n1 + 1 / n2) / 2));
            },
            // 3 different parameter lists:
            // (qscore, n, k)
            // (mean1, mean2, n1, n2, sd, n, k)
            // (array1, array2, sd, n, k)
            qtest: function qtest() {
              var args = slice2.call(arguments);
              var qscore;
              if (args.length === 3) {
                qscore = args[0];
                args = args.slice(1);
              } else if (args.length === 7) {
                qscore = jStat2.qscore(args[0], args[1], args[2], args[3], args[4]);
                args = args.slice(5);
              } else {
                qscore = jStat2.qscore(args[0], args[1], args[2]);
                args = args.slice(3);
              }
              var n = args[0];
              var k = args[1];
              return 1 - jStat2.tukey.cdf(qscore, k, n - k);
            },
            tukeyhsd: function tukeyhsd(arrays) {
              var sd = jStat2.pooledstdev(arrays);
              var means = arrays.map(function(arr) {
                return jStat2.mean(arr);
              });
              var n = arrays.reduce(function(n2, arr) {
                return n2 + arr.length;
              }, 0);
              var results = [];
              for (var i = 0; i < arrays.length; ++i) {
                for (var j = i + 1; j < arrays.length; ++j) {
                  var p = jStat2.qtest(means[i], means[j], arrays[i].length, arrays[j].length, sd, n, arrays.length);
                  results.push([[i, j], p]);
                }
              }
              return results;
            }
          });
          jStat2.extend({
            // 2 different parameter setups
            // (value, alpha, sd, n)
            // (value, alpha, array)
            normalci: function normalci() {
              var args = slice2.call(arguments), ans = new Array(2), change;
              if (args.length === 4) {
                change = Math2.abs(jStat2.normal.inv(args[1] / 2, 0, 1) * args[2] / Math2.sqrt(args[3]));
              } else {
                change = Math2.abs(jStat2.normal.inv(args[1] / 2, 0, 1) * jStat2.stdev(args[2]) / Math2.sqrt(args[2].length));
              }
              ans[0] = args[0] - change;
              ans[1] = args[0] + change;
              return ans;
            },
            // 2 different parameter setups
            // (value, alpha, sd, n)
            // (value, alpha, array)
            tci: function tci() {
              var args = slice2.call(arguments), ans = new Array(2), change;
              if (args.length === 4) {
                change = Math2.abs(jStat2.studentt.inv(args[1] / 2, args[3] - 1) * args[2] / Math2.sqrt(args[3]));
              } else {
                change = Math2.abs(jStat2.studentt.inv(args[1] / 2, args[2].length - 1) * jStat2.stdev(args[2], true) / Math2.sqrt(args[2].length));
              }
              ans[0] = args[0] - change;
              ans[1] = args[0] + change;
              return ans;
            },
            significant: function significant(pvalue, alpha) {
              return pvalue < alpha;
            }
          });
          jStat2.extend(jStat2.fn, {
            normalci: function normalci(value, alpha) {
              return jStat2.normalci(value, alpha, this.toArray());
            },
            tci: function tci(value, alpha) {
              return jStat2.tci(value, alpha, this.toArray());
            }
          });
          function differenceOfProportions(p1, n1, p2, n2) {
            if (p1 > 1 || p2 > 1 || p1 <= 0 || p2 <= 0) {
              throw new Error("Proportions should be greater than 0 and less than 1");
            }
            var pooled = (p1 * n1 + p2 * n2) / (n1 + n2);
            var se = Math2.sqrt(pooled * (1 - pooled) * (1 / n1 + 1 / n2));
            return (p1 - p2) / se;
          }
          jStat2.extend(jStat2.fn, {
            oneSidedDifferenceOfProportions: function oneSidedDifferenceOfProportions(p1, n1, p2, n2) {
              var z = differenceOfProportions(p1, n1, p2, n2);
              return jStat2.ztest(z, 1);
            },
            twoSidedDifferenceOfProportions: function twoSidedDifferenceOfProportions(p1, n1, p2, n2) {
              var z = differenceOfProportions(p1, n1, p2, n2);
              return jStat2.ztest(z, 2);
            }
          });
        })(jStat, Math);
        jStat.models = /* @__PURE__ */ (function() {
          function sub_regress(exog) {
            var var_count = exog[0].length;
            var modelList = jStat.arange(var_count).map(function(endog_index) {
              var exog_index = jStat.arange(var_count).filter(function(i) {
                return i !== endog_index;
              });
              return ols(
                jStat.col(exog, endog_index).map(function(x) {
                  return x[0];
                }),
                jStat.col(exog, exog_index)
              );
            });
            return modelList;
          }
          function ols(endog, exog) {
            var nobs = endog.length;
            var df_model = exog[0].length - 1;
            var df_resid = nobs - df_model - 1;
            var coef = jStat.lstsq(exog, endog);
            var predict = jStat.multiply(exog, coef.map(function(x) {
              return [x];
            })).map(function(p) {
              return p[0];
            });
            var resid = jStat.subtract(endog, predict);
            var ybar = jStat.mean(endog);
            var SSE = jStat.sum(predict.map(function(f) {
              return Math.pow(f - ybar, 2);
            }));
            var SSR = jStat.sum(endog.map(function(y, i) {
              return Math.pow(y - predict[i], 2);
            }));
            var SST = SSE + SSR;
            var R2 = SSE / SST;
            return {
              exog,
              endog,
              nobs,
              df_model,
              df_resid,
              coef,
              predict,
              resid,
              ybar,
              SST,
              SSE,
              SSR,
              R2
            };
          }
          function t_test(model) {
            var subModelList = sub_regress(model.exog);
            var sigmaHat = Math.sqrt(model.SSR / model.df_resid);
            var seBetaHat = subModelList.map(function(mod) {
              var SST = mod.SST;
              var R2 = mod.R2;
              return sigmaHat / Math.sqrt(SST * (1 - R2));
            });
            var tStatistic = model.coef.map(function(coef, i) {
              return (coef - 0) / seBetaHat[i];
            });
            var pValue = tStatistic.map(function(t) {
              var leftppf = jStat.studentt.cdf(t, model.df_resid);
              return (leftppf > 0.5 ? 1 - leftppf : leftppf) * 2;
            });
            var c = jStat.studentt.inv(0.975, model.df_resid);
            var interval95 = model.coef.map(function(coef, i) {
              var d = c * seBetaHat[i];
              return [coef - d, coef + d];
            });
            return {
              se: seBetaHat,
              t: tStatistic,
              p: pValue,
              sigmaHat,
              interval95
            };
          }
          function F_test(model) {
            var F_statistic = model.R2 / model.df_model / ((1 - model.R2) / model.df_resid);
            var fcdf = function(x, n1, n2) {
              return jStat.beta.cdf(x / (n2 / n1 + x), n1 / 2, n2 / 2);
            };
            var pvalue = 1 - fcdf(F_statistic, model.df_model, model.df_resid);
            return { F_statistic, pvalue };
          }
          function ols_wrap(endog, exog) {
            var model = ols(endog, exog);
            var ttest = t_test(model);
            var ftest = F_test(model);
            var adjust_R2 = 1 - (1 - model.R2) * ((model.nobs - 1) / model.df_resid);
            model.t = ttest;
            model.f = ftest;
            model.adjust_R2 = adjust_R2;
            return model;
          }
          return { ols: ols_wrap };
        })();
        jStat.extend({
          buildxmatrix: function buildxmatrix() {
            var matrixRows = new Array(arguments.length);
            for (var i = 0; i < arguments.length; i++) {
              var array = [1];
              matrixRows[i] = array.concat(arguments[i]);
            }
            return jStat(matrixRows);
          },
          builddxmatrix: function builddxmatrix() {
            var matrixRows = new Array(arguments[0].length);
            for (var i = 0; i < arguments[0].length; i++) {
              var array = [1];
              matrixRows[i] = array.concat(arguments[0][i]);
            }
            return jStat(matrixRows);
          },
          buildjxmatrix: function buildjxmatrix(jMat) {
            var pass = new Array(jMat.length);
            for (var i = 0; i < jMat.length; i++) {
              pass[i] = jMat[i];
            }
            return jStat.builddxmatrix(pass);
          },
          buildymatrix: function buildymatrix(array) {
            return jStat(array).transpose();
          },
          buildjymatrix: function buildjymatrix(jMat) {
            return jMat.transpose();
          },
          matrixmult: function matrixmult(A, B) {
            var i, j, k, result, sum;
            if (A.cols() == B.rows()) {
              if (B.rows() > 1) {
                result = [];
                for (i = 0; i < A.rows(); i++) {
                  result[i] = [];
                  for (j = 0; j < B.cols(); j++) {
                    sum = 0;
                    for (k = 0; k < A.cols(); k++) {
                      sum += A.toArray()[i][k] * B.toArray()[k][j];
                    }
                    result[i][j] = sum;
                  }
                }
                return jStat(result);
              }
              result = [];
              for (i = 0; i < A.rows(); i++) {
                result[i] = [];
                for (j = 0; j < B.cols(); j++) {
                  sum = 0;
                  for (k = 0; k < A.cols(); k++) {
                    sum += A.toArray()[i][k] * B.toArray()[j];
                  }
                  result[i][j] = sum;
                }
              }
              return jStat(result);
            }
          },
          //regress and regresst to be fixed
          regress: function regress(jMatX, jMatY) {
            var innerinv = jStat.xtranspxinv(jMatX);
            var xtransp = jMatX.transpose();
            var next = jStat.matrixmult(jStat(innerinv), xtransp);
            return jStat.matrixmult(next, jMatY);
          },
          regresst: function regresst(jMatX, jMatY, sides) {
            var beta = jStat.regress(jMatX, jMatY);
            var compile = {};
            compile.anova = {};
            var jMatYBar = jStat.jMatYBar(jMatX, beta);
            compile.yBar = jMatYBar;
            var yAverage = jMatY.mean();
            compile.anova.residuals = jStat.residuals(jMatY, jMatYBar);
            compile.anova.ssr = jStat.ssr(jMatYBar, yAverage);
            compile.anova.msr = compile.anova.ssr / (jMatX[0].length - 1);
            compile.anova.sse = jStat.sse(jMatY, jMatYBar);
            compile.anova.mse = compile.anova.sse / (jMatY.length - (jMatX[0].length - 1) - 1);
            compile.anova.sst = jStat.sst(jMatY, yAverage);
            compile.anova.mst = compile.anova.sst / (jMatY.length - 1);
            compile.anova.r2 = 1 - compile.anova.sse / compile.anova.sst;
            if (compile.anova.r2 < 0) compile.anova.r2 = 0;
            compile.anova.fratio = compile.anova.msr / compile.anova.mse;
            compile.anova.pvalue = jStat.anovaftest(
              compile.anova.fratio,
              jMatX[0].length - 1,
              jMatY.length - (jMatX[0].length - 1) - 1
            );
            compile.anova.rmse = Math.sqrt(compile.anova.mse);
            compile.anova.r2adj = 1 - compile.anova.mse / compile.anova.mst;
            if (compile.anova.r2adj < 0) compile.anova.r2adj = 0;
            compile.stats = new Array(jMatX[0].length);
            var covar = jStat.xtranspxinv(jMatX);
            var sds, ts, ps;
            for (var i = 0; i < beta.length; i++) {
              sds = Math.sqrt(compile.anova.mse * Math.abs(covar[i][i]));
              ts = Math.abs(beta[i] / sds);
              ps = jStat.ttest(ts, jMatY.length - jMatX[0].length - 1, sides);
              compile.stats[i] = [beta[i], sds, ts, ps];
            }
            compile.regress = beta;
            return compile;
          },
          xtranspx: function xtranspx(jMatX) {
            return jStat.matrixmult(jMatX.transpose(), jMatX);
          },
          xtranspxinv: function xtranspxinv(jMatX) {
            var inner = jStat.matrixmult(jMatX.transpose(), jMatX);
            var innerinv = jStat.inv(inner);
            return innerinv;
          },
          jMatYBar: function jMatYBar(jMatX, beta) {
            var yBar = jStat.matrixmult(jMatX, beta);
            return new jStat(yBar);
          },
          residuals: function residuals(jMatY, jMatYBar) {
            return jStat.matrixsubtract(jMatY, jMatYBar);
          },
          ssr: function ssr(jMatYBar, yAverage) {
            var ssr2 = 0;
            for (var i = 0; i < jMatYBar.length; i++) {
              ssr2 += Math.pow(jMatYBar[i] - yAverage, 2);
            }
            return ssr2;
          },
          sse: function sse(jMatY, jMatYBar) {
            var sse2 = 0;
            for (var i = 0; i < jMatY.length; i++) {
              sse2 += Math.pow(jMatY[i] - jMatYBar[i], 2);
            }
            return sse2;
          },
          sst: function sst(jMatY, yAverage) {
            var sst2 = 0;
            for (var i = 0; i < jMatY.length; i++) {
              sst2 += Math.pow(jMatY[i] - yAverage, 2);
            }
            return sst2;
          },
          matrixsubtract: function matrixsubtract(A, B) {
            var ans = new Array(A.length);
            for (var i = 0; i < A.length; i++) {
              ans[i] = new Array(A[i].length);
              for (var j = 0; j < A[i].length; j++) {
                ans[i][j] = A[i][j] - B[i][j];
              }
            }
            return jStat(ans);
          }
        });
        jStat.jStat = jStat;
        return jStat;
      });
    }
  });

  // node_modules/fast-formula-parser/formulas/functions/engineering.js
  var require_engineering = __commonJS({
    "node_modules/fast-formula-parser/formulas/functions/engineering.js"(exports2, module2) {
      var FormulaError2 = require_error();
      var TextFunctions = require_text();
      var { FormulaHelpers, Types } = require_helpers();
      var H = FormulaHelpers;
      var bessel = require_bessel();
      var jStat = require_jstat();
      var MAX_OCT = 536870911;
      var MIN_OCT = -536870912;
      var MAX_BIN = 511;
      var MIN_BIN = -512;
      var numberRegex = /^\s?[+-]?\s?[0-9]+[.]?[0-9]*([eE][+\-][0-9]+)?\s?$/;
      var IMWithoutRealRegex = /^\s?([+-]?\s?([0-9]+[.]?[0-9]*([eE][+\-][0-9]+)?)?)\s?[ij]\s?$/;
      var IMRegex = /^\s?([+-]?\s?[0-9]+[.]?[0-9]*([eE][+\-][0-9]+)?)\s?([+-]?\s?([0-9]+[.]?[0-9]*([eE][+\-][0-9]+)?)?)\s?[ij]\s?$/;
      function parseIM(textOrNumber) {
        textOrNumber = H.accept(textOrNumber);
        let real = 0, im = 0, unit = "i";
        if (typeof textOrNumber === "number")
          return { real: textOrNumber, im, unit };
        if (typeof textOrNumber === "boolean")
          throw FormulaError2.VALUE;
        let match = textOrNumber.match(numberRegex);
        if (match) {
          real = Number(match[0]);
          return { real, im, unit };
        }
        match = textOrNumber.match(IMWithoutRealRegex);
        if (match) {
          im = Number(/^\s?[+-]?\s?$/.test(match[1]) ? match[1] + "1" : match[1]);
          unit = match[0].slice(-1);
          return { real, im, unit };
        }
        match = textOrNumber.match(IMRegex);
        if (match) {
          real = Number(match[1]);
          im = Number(/^\s?[+-]?\s?$/.test(match[3]) ? match[3] + "1" : match[3]);
          unit = match[0].slice(-1);
          return { real, im, unit };
        }
        throw FormulaError2.NUM;
      }
      var EngineeringFunctions = {
        BESSELI: (x, n) => {
          x = H.accept(x, Types.NUMBER_NO_BOOLEAN);
          n = H.accept(n, Types.NUMBER_NO_BOOLEAN);
          n = Math.trunc(n);
          if (n < 0) {
            throw FormulaError2.NUM;
          }
          return bessel.besseli(x, n);
        },
        BESSELJ: (x, n) => {
          x = H.accept(x, Types.NUMBER_NO_BOOLEAN);
          n = H.accept(n, Types.NUMBER_NO_BOOLEAN);
          n = Math.trunc(n);
          if (n < 0) {
            throw FormulaError2.NUM;
          }
          return bessel.besselj(x, n);
        },
        BESSELK: (x, n) => {
          x = H.accept(x, Types.NUMBER_NO_BOOLEAN);
          n = H.accept(n, Types.NUMBER_NO_BOOLEAN);
          n = Math.trunc(n);
          if (n < 0) {
            throw FormulaError2.NUM;
          }
          return bessel.besselk(x, n);
        },
        BESSELY: (x, n) => {
          x = H.accept(x, Types.NUMBER_NO_BOOLEAN);
          n = H.accept(n, Types.NUMBER_NO_BOOLEAN);
          n = Math.trunc(n);
          if (n < 0) {
            throw FormulaError2.NUM;
          }
          return bessel.bessely(x, n);
        },
        BIN2DEC: (number) => {
          number = H.accept(number, Types.NUMBER_NO_BOOLEAN);
          let numberStr = number.toString();
          if (numberStr.length > 10) {
            throw FormulaError2.NUM;
          }
          if (numberStr.length === 10 && numberStr.substring(0, 1) === "1") {
            return parseInt(numberStr.substring(1), 2) + MIN_BIN;
          } else {
            return parseInt(numberStr, 2);
          }
        },
        BIN2HEX: (number, places) => {
          number = H.accept(number, Types.NUMBER_NO_BOOLEAN);
          places = H.accept(places, Types.NUMBER_NO_BOOLEAN, null);
          const numberStr = number.toString();
          if (numberStr.length > 10) {
            throw FormulaError2.NUM;
          }
          if (numberStr.length === 10 && numberStr.substring(0, 1) === "1") {
            return (parseInt(numberStr.substring(1), 2) + 1099511627264).toString(16).toUpperCase();
          }
          const result = parseInt(number, 2).toString(16);
          if (places == null) {
            return result.toUpperCase();
          } else {
            if (places < 0) {
              throw FormulaError2.NUM;
            }
            places = Math.trunc(places);
            if (places >= result.length) {
              return (TextFunctions.REPT("0", places - result.length) + result).toUpperCase();
            } else {
              throw FormulaError2.NUM;
            }
          }
        },
        BIN2OCT: (number, places) => {
          number = H.accept(number, Types.NUMBER_NO_BOOLEAN);
          places = H.accept(places, Types.NUMBER, null);
          let numberStr = number.toString();
          if (numberStr.length > 10) {
            throw FormulaError2.NUM;
          }
          if (numberStr.length === 10 && numberStr.substr(0, 1) === "1") {
            return (parseInt(numberStr.substr(1), 2) + 1073741312).toString(8);
          }
          let result = parseInt(number, 2).toString(8);
          if (places == null) {
            return result.toUpperCase();
          } else {
            if (places < 0) {
              throw FormulaError2.NUM;
            }
            places = Math.trunc(places);
            if (places >= result.length) {
              return TextFunctions.REPT("0", places - result.length) + result;
            } else {
              throw FormulaError2.NUM;
            }
          }
        },
        BITAND: (number1, number2) => {
          number1 = H.accept(number1, Types.NUMBER);
          number2 = H.accept(number2, Types.NUMBER);
          if (number1 < 0 || number2 < 0) {
            throw FormulaError2.NUM;
          }
          if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
            throw FormulaError2.NUM;
          }
          if (number1 > 281474976710655 || number2 > 281474976710655) {
            throw FormulaError2.NUM;
          }
          return number1 & number2;
        },
        BITLSHIFT: (number, shiftAmount) => {
          number = H.accept(number, Types.NUMBER);
          shiftAmount = H.accept(shiftAmount, Types.NUMBER);
          shiftAmount = Math.trunc(shiftAmount);
          if (Math.abs(shiftAmount) > 53) {
            throw FormulaError2.NUM;
          }
          if (number < 0 || Math.floor(number) !== number || number > 281474976710655) {
            throw FormulaError2.NUM;
          }
          const result = shiftAmount >= 0 ? number * 2 ** shiftAmount : Math.trunc(number / 2 ** -shiftAmount);
          if (result > 281474976710655)
            throw FormulaError2.NUM;
          else
            return result;
        },
        BITOR: (number1, number2) => {
          number1 = H.accept(number1, Types.NUMBER);
          number2 = H.accept(number2, Types.NUMBER);
          if (number1 < 0 || number2 < 0) {
            throw FormulaError2.NUM;
          }
          if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
            throw FormulaError2.NUM;
          }
          if (number1 > 281474976710655 || number2 > 281474976710655) {
            throw FormulaError2.NUM;
          }
          return number1 | number2;
        },
        BITRSHIFT: (number, shiftAmount) => {
          number = H.accept(number, Types.NUMBER);
          shiftAmount = H.accept(shiftAmount, Types.NUMBER);
          return EngineeringFunctions.BITLSHIFT(number, -shiftAmount);
        },
        BITXOR: (number1, number2) => {
          number1 = H.accept(number1, Types.NUMBER);
          number2 = H.accept(number2, Types.NUMBER);
          if (number1 < 0 || number1 > 281474976710655 || Math.floor(number1) !== number1) {
            throw FormulaError2.NUM;
          }
          if (number2 < 0 || number2 > 281474976710655 || Math.floor(number2) !== number2) {
            throw FormulaError2.NUM;
          }
          return number1 ^ number2;
        },
        COMPLEX: (realNum, iNum, suffix) => {
          realNum = H.accept(realNum, Types.NUMBER_NO_BOOLEAN);
          iNum = H.accept(iNum, Types.NUMBER_NO_BOOLEAN);
          suffix = H.accept(suffix, Types.STRING, "i");
          if (suffix !== "i" && suffix !== "j") {
            throw FormulaError2.VALUE;
          }
          if (realNum === 0 && iNum === 0) {
            return 0;
          } else if (realNum === 0) {
            if (iNum === 1) {
              return suffix;
            } else if (iNum === -1) {
              return "-" + suffix;
            } else {
              return iNum.toString() + suffix;
            }
          } else if (iNum === 0) {
            return realNum.toString();
          } else {
            let sign = iNum > 0 ? "+" : "";
            if (iNum === 1) {
              return realNum.toString() + sign + suffix;
            } else if (iNum === -1) {
              return realNum.toString() + sign + "-" + suffix;
            } else {
              return realNum.toString() + sign + iNum.toString() + suffix;
            }
          }
        },
        DEC2BIN: (number, places) => {
          number = H.accept(number, Types.NUMBER);
          places = H.accept(places, Types.NUMBER, null);
          if (number < MIN_BIN || number > MAX_BIN) {
            throw FormulaError2.NUM;
          }
          if (number < 0) {
            return "1" + TextFunctions.REPT("0", 9 - (512 + number).toString(2).length) + (512 + number).toString(2);
          }
          let result = parseInt(number, 10).toString(2);
          if (places == null) {
            return result;
          } else {
            places = Math.trunc(places);
            if (places <= 0) {
              throw FormulaError2.NUM;
            }
            if (places < result.length)
              throw FormulaError2.NUM;
            return TextFunctions.REPT("0", places - result.length) + result;
          }
        },
        DEC2HEX: (number, places) => {
          number = H.accept(number, Types.NUMBER);
          places = H.accept(places, Types.NUMBER, null);
          if (number < -549755813888 || number > 549755813888) {
            throw FormulaError2.NUM;
          }
          if (number < 0) {
            return (1099511627776 + number).toString(16).toUpperCase();
          }
          let result = parseInt(number, 10).toString(16);
          if (places == null) {
            return result.toUpperCase();
          } else {
            places = Math.trunc(places);
            if (places <= 0) {
              throw FormulaError2.NUM;
            }
            if (places < result.length)
              throw FormulaError2.NUM;
            return TextFunctions.REPT("0", places - result.length) + result.toUpperCase();
          }
        },
        DEC2OCT: (number, places) => {
          number = H.accept(number, Types.NUMBER);
          places = H.accept(places, Types.NUMBER, null);
          if (number < -536870912 || number > 536870912) {
            throw FormulaError2.NUM;
          }
          if (number < 0) {
            return (number + 1073741824).toString(8);
          }
          let result = parseInt(number, 10).toString(8);
          if (places == null) {
            return result.toUpperCase();
          } else {
            places = Math.trunc(places);
            if (places <= 0) {
              throw FormulaError2.NUM;
            }
            if (places < result.length)
              throw FormulaError2.NUM;
            return TextFunctions.REPT("0", places - result.length) + result;
          }
        },
        DELTA: (number1, number2) => {
          number1 = H.accept(number1, Types.NUMBER_NO_BOOLEAN);
          number2 = H.accept(number2, Types.NUMBER_NO_BOOLEAN, 0);
          return number1 === number2 ? 1 : 0;
        },
        ERF: (lowerLimit, upperLimit) => {
          lowerLimit = H.accept(lowerLimit, Types.NUMBER_NO_BOOLEAN);
          upperLimit = H.accept(upperLimit, Types.NUMBER_NO_BOOLEAN, 0);
          return jStat.erf(lowerLimit);
        },
        ERFC: (x) => {
          x = H.accept(x, Types.NUMBER_NO_BOOLEAN);
          return jStat.erfc(x);
        },
        GESTEP: (number, step) => {
          number = H.accept(number, Types.NUMBER_NO_BOOLEAN);
          step = H.accept(step, Types.NUMBER_NO_BOOLEAN, 0);
          return number >= step ? 1 : 0;
        },
        HEX2BIN: (number, places) => {
          number = H.accept(number, Types.STRING);
          places = H.accept(places, Types.NUMBER, null);
          if (number.length > 10 || !/^[0-9a-fA-F]*$/.test(number)) {
            throw FormulaError2.NUM;
          }
          let ifNegative = number.length === 10 && number.substr(0, 1).toLowerCase() === "f";
          let toDecimal = ifNegative ? parseInt(number, 16) - 1099511627776 : parseInt(number, 16);
          if (toDecimal < MIN_BIN || toDecimal > MAX_BIN) {
            throw FormulaError2.NUM;
          }
          if (ifNegative) {
            return "1" + TextFunctions.REPT("0", 9 - (toDecimal + 512).toString(2).length) + (toDecimal + 512).toString(2);
          }
          let toBinary = toDecimal.toString(2);
          if (places == null) {
            return toBinary;
          } else {
            places = Math.trunc(places);
            if (places <= 0 || places < toBinary.length) {
              throw FormulaError2.NUM;
            }
            return TextFunctions.REPT("0", places - toBinary.length) + toBinary;
          }
        },
        HEX2DEC: (number) => {
          number = H.accept(number, Types.STRING);
          if (number.length > 10 || !/^[0-9a-fA-F]*$/.test(number)) {
            throw FormulaError2.NUM;
          }
          let result = parseInt(number, 16);
          return result >= 549755813888 ? result - 1099511627776 : result;
        },
        HEX2OCT: (number, places) => {
          number = H.accept(number, Types.STRING);
          if (number.length > 10 || !/^[0-9a-fA-F]*$/.test(number)) {
            throw FormulaError2.NUM;
          }
          let toDecimal = EngineeringFunctions.HEX2DEC(number);
          if (toDecimal > MAX_OCT || toDecimal < MIN_OCT) {
            throw FormulaError2.NUM;
          }
          return EngineeringFunctions.DEC2OCT(toDecimal, places);
        },
        IMABS: (iNumber) => {
          const { real, im } = parseIM(iNumber);
          return Math.sqrt(Math.pow(real, 2) + Math.pow(im, 2));
        },
        IMAGINARY: (iNumber) => {
          return parseIM(iNumber).im;
        },
        IMARGUMENT: (iNumber) => {
          const { real, im } = parseIM(iNumber);
          if (real === 0 && im === 0) {
            throw FormulaError2.DIV0;
          }
          if (real === 0 && im > 0) {
            return Math.PI / 2;
          }
          if (real === 0 && im < 0) {
            return -Math.PI / 2;
          }
          if (real < 0 && im === 0) {
            return Math.PI;
          }
          if (real > 0 && im === 0) {
            return 0;
          }
          if (real > 0) {
            return Math.atan(im / real);
          } else if (real < 0 && im > 0) {
            return Math.atan(im / real) + Math.PI;
          } else {
            return Math.atan(im / real) - Math.PI;
          }
        },
        IMCONJUGATE: (iNumber) => {
          const { real, im, unit } = parseIM(iNumber);
          return im !== 0 ? EngineeringFunctions.COMPLEX(real, -im, unit) : "" + real;
        },
        IMCOS: (iNumber) => {
          const { real, im, unit } = parseIM(iNumber);
          let realInput = Math.cos(real) * (Math.exp(im) + Math.exp(-im)) / 2;
          let imaginaryInput = -Math.sin(real) * (Math.exp(im) - Math.exp(-im)) / 2;
          return EngineeringFunctions.COMPLEX(realInput, imaginaryInput, unit);
        },
        IMCOSH: (iNumber) => {
          const { real, im, unit } = parseIM(iNumber);
          let realInput = Math.cos(im) * (Math.exp(real) + Math.exp(-real)) / 2;
          let imaginaryInput = -Math.sin(im) * (Math.exp(real) - Math.exp(-real)) / 2;
          return EngineeringFunctions.COMPLEX(realInput, -imaginaryInput, unit);
        },
        IMCOT: (iNumber) => {
          iNumber = H.accept(iNumber);
          let real = EngineeringFunctions.IMCOS(iNumber);
          let imaginary = EngineeringFunctions.IMSIN(iNumber);
          return EngineeringFunctions.IMDIV(real, imaginary);
        },
        IMCSC: (iNumber) => {
          iNumber = H.accept(iNumber);
          return EngineeringFunctions.IMDIV("1", EngineeringFunctions.IMSIN(iNumber));
        },
        IMCSCH: (iNumber) => {
          iNumber = H.accept(iNumber);
          return EngineeringFunctions.IMDIV("1", EngineeringFunctions.IMSINH(iNumber));
        },
        IMDIV: (iNumber1, iNumber2) => {
          const res1 = parseIM(iNumber1);
          const a = res1.real, b = res1.im, unit1 = res1.unit;
          const res2 = parseIM(iNumber2);
          const c = res2.real, d = res2.im, unit2 = res2.unit;
          if (c === 0 && d === 0 || unit1 !== unit2) {
            throw FormulaError2.NUM;
          }
          let unit = unit1;
          let denominator = Math.pow(c, 2) + Math.pow(d, 2);
          return EngineeringFunctions.COMPLEX((a * c + b * d) / denominator, (b * c - a * d) / denominator, unit);
        },
        IMEXP: (iNumber) => {
          const { real, im, unit } = parseIM(iNumber);
          let e = Math.exp(real);
          return EngineeringFunctions.COMPLEX(e * Math.cos(im), e * Math.sin(im), unit);
        },
        IMLN: (iNumber) => {
          const { real, im, unit } = parseIM(iNumber);
          return EngineeringFunctions.COMPLEX(
            Math.log(Math.sqrt(Math.pow(real, 2) + Math.pow(im, 2))),
            Math.atan(im / real),
            unit
          );
        },
        IMLOG10: (iNumber) => {
          const { real, im, unit } = parseIM(iNumber);
          let realInput = Math.log(Math.sqrt(Math.pow(real, 2) + Math.pow(im, 2))) / Math.log(10);
          let imaginaryInput = Math.atan(im / real) / Math.log(10);
          return EngineeringFunctions.COMPLEX(realInput, imaginaryInput, unit);
        },
        IMLOG2: (iNumber) => {
          const { real, im, unit } = parseIM(iNumber);
          let realInput = Math.log(Math.sqrt(Math.pow(real, 2) + Math.pow(im, 2))) / Math.log(2);
          let imaginaryInput = Math.atan(im / real) / Math.log(2);
          return EngineeringFunctions.COMPLEX(realInput, imaginaryInput, unit);
        },
        IMPOWER: (iNumber, number) => {
          let { unit } = parseIM(iNumber);
          number = H.accept(number, Types.NUMBER_NO_BOOLEAN);
          let p = Math.pow(EngineeringFunctions.IMABS(iNumber), number);
          let t = EngineeringFunctions.IMARGUMENT(iNumber);
          let real = p * Math.cos(number * t);
          let imaginary = p * Math.sin(number * t);
          return EngineeringFunctions.COMPLEX(real, imaginary, unit);
        },
        IMPRODUCT: (...params) => {
          let result;
          let i = 0;
          H.flattenParams(params, null, false, (item) => {
            if (i === 0) {
              result = H.accept(item);
              parseIM(result);
            } else {
              const res1 = parseIM(result);
              const a = res1.real, b = res1.im, unit1 = res1.unit;
              const res2 = parseIM(item);
              const c = res2.real, d = res2.im, unit2 = res2.unit;
              if (unit1 !== unit2)
                throw FormulaError2.VALUE;
              result = EngineeringFunctions.COMPLEX(a * c - b * d, a * d + b * c);
            }
            i++;
          }, 1);
          return result;
        },
        IMREAL: (iNumber) => {
          return parseIM(iNumber).real;
        },
        IMSEC: (iNumber) => {
          return EngineeringFunctions.IMDIV("1", EngineeringFunctions.IMCOS(iNumber));
        },
        IMSECH: (iNumber) => {
          return EngineeringFunctions.IMDIV("1", EngineeringFunctions.IMCOSH(iNumber));
        },
        IMSIN: (iNumber) => {
          const { real, im, unit } = parseIM(iNumber);
          let realInput = Math.sin(real) * (Math.exp(im) + Math.exp(-im)) / 2;
          let imaginaryInput = Math.cos(real) * (Math.exp(im) - Math.exp(-im)) / 2;
          return EngineeringFunctions.COMPLEX(realInput, imaginaryInput, unit);
        },
        IMSINH: (iNumber) => {
          const { real, im, unit } = parseIM(iNumber);
          let realInput = Math.cos(im) * (Math.exp(real) - Math.exp(-real)) / 2;
          let imaginaryInput = Math.sin(im) * (Math.exp(real) + Math.exp(-real)) / 2;
          return EngineeringFunctions.COMPLEX(realInput, imaginaryInput, unit);
        },
        IMSQRT: (iNumber) => {
          const { unit } = parseIM(iNumber);
          let power = Math.sqrt(EngineeringFunctions.IMABS(iNumber));
          let argument = EngineeringFunctions.IMARGUMENT(iNumber);
          return EngineeringFunctions.COMPLEX(power * Math.cos(argument / 2), power * Math.sin(argument / 2), unit);
        },
        IMSUB: (iNumber1, iNumber2) => {
          const res1 = parseIM(iNumber1);
          const a = res1.real, b = res1.im, unit1 = res1.unit;
          const res2 = parseIM(iNumber2);
          const c = res2.real, d = res2.im, unit2 = res2.unit;
          if (unit1 !== unit2) {
            throw FormulaError2.VALUE;
          }
          return EngineeringFunctions.COMPLEX(a - c, b - d, unit1);
        },
        IMSUM: (...params) => {
          let realSum = 0, imSum = 0, prevUnit;
          H.flattenParams(params, null, false, (item) => {
            const { real, im, unit } = parseIM(item);
            if (!prevUnit) prevUnit = unit;
            if (prevUnit !== unit)
              throw FormulaError2.VALUE;
            realSum += real;
            imSum += im;
          });
          return EngineeringFunctions.COMPLEX(realSum, imSum, prevUnit);
        },
        IMTAN: (iNumber) => {
          const { unit } = parseIM(iNumber);
          return EngineeringFunctions.IMDIV(EngineeringFunctions.IMSIN(iNumber), EngineeringFunctions.IMCOS(iNumber), unit);
        },
        // FIXME: need to check the test cases
        OCT2BIN: (number, places) => {
          number = H.accept(number, Types.STRING);
          places = H.accept(places, Types.NUMBER, null);
          if (number.length > 10) {
            throw FormulaError2.NUM;
          }
          if (places > 10) {
            throw FormulaError2.NUM;
          }
          if (places !== null && places < 0) {
            throw FormulaError2.NUM;
          }
          places = Math.trunc(places);
          let isNegative = number.length === 10 && number.substring(0, 1) === "7";
          let toDecimal = EngineeringFunctions.OCT2DEC(number);
          if (toDecimal < MIN_BIN || toDecimal > MAX_BIN) {
            return FormulaError2.NUM;
          }
          if (isNegative) {
            return "1" + TextFunctions.REPT("0", 9 - (512 + toDecimal).toString(2).length) + (512 + toDecimal).toString(2);
          }
          let result = toDecimal.toString(2);
          if (places === 0) {
            return result;
          }
          if (places < result.length) {
            throw FormulaError2.NUM;
          }
          return TextFunctions.REPT("0", places - result.length) + result;
        },
        OCT2DEC: (number) => {
          number = H.accept(number, Types.STRING);
          if (number.length > 10) {
            throw FormulaError2.NUM;
          }
          for (const n of number) {
            if (n < "0" || n > "7") {
              throw FormulaError2.NUM;
            }
          }
          let result = parseInt(number, 8);
          return result >= 536870912 ? result - 1073741824 : result;
        },
        OCT2HEX: (number, places) => {
          number = H.accept(number, Types.STRING);
          places = H.accept(places, Types.NUMBER_NO_BOOLEAN, null);
          if (number.length > 10) {
            throw FormulaError2.NUM;
          }
          for (const n of number) {
            if (n < "0" || n > "7") {
              throw FormulaError2.NUM;
            }
          }
          places = Math.trunc(places);
          if (places < 0 || places > 10) {
            throw FormulaError2.NUM;
          }
          let toDecimal = EngineeringFunctions.OCT2DEC(number);
          let toHex = EngineeringFunctions.DEC2HEX(toDecimal);
          if (places === 0) {
            return toHex;
          }
          if (places < toHex.length) {
            throw FormulaError2.NUM;
          } else {
            return TextFunctions.REPT("0", places - toHex.length) + toHex;
          }
        }
      };
      module2.exports = EngineeringFunctions;
    }
  });

  // node_modules/fast-formula-parser/formulas/functions/reference.js
  var require_reference = __commonJS({
    "node_modules/fast-formula-parser/formulas/functions/reference.js"(exports2, module2) {
      var FormulaError2 = require_error();
      var { FormulaHelpers, Types, WildCard, Address } = require_helpers();
      var Collection = require_collection();
      var H = FormulaHelpers;
      var ReferenceFunctions = {
        ADDRESS: (rowNumber, columnNumber, absNum, a1, sheetText) => {
          rowNumber = H.accept(rowNumber, Types.NUMBER);
          columnNumber = H.accept(columnNumber, Types.NUMBER);
          absNum = H.accept(absNum, Types.NUMBER, 1);
          a1 = H.accept(a1, Types.BOOLEAN, true);
          sheetText = H.accept(sheetText, Types.STRING, "");
          if (rowNumber < 1 || columnNumber < 1 || absNum < 1 || absNum > 4)
            throw FormulaError2.VALUE;
          let result = "";
          if (sheetText.length > 0) {
            if (/[^A-Za-z_.\d\u007F-\uFFFF]/.test(sheetText)) {
              result += `'${sheetText}'!`;
            } else {
              result += sheetText + "!";
            }
          }
          if (a1) {
            result += absNum === 1 || absNum === 3 ? "$" : "";
            result += Address.columnNumberToName(columnNumber);
            result += absNum === 1 || absNum === 2 ? "$" : "";
            result += rowNumber;
          } else {
            result += "R";
            result += absNum === 4 || absNum === 3 ? `[${rowNumber}]` : rowNumber;
            result += "C";
            result += absNum === 4 || absNum === 2 ? `[${columnNumber}]` : columnNumber;
          }
          return result;
        },
        AREAS: (refs) => {
          refs = H.accept(refs);
          if (refs instanceof Collection) {
            return refs.length;
          }
          return 1;
        },
        CHOOSE: (indexNum, ...values2) => {
        },
        // Special
        COLUMN: (context2, obj) => {
          if (obj == null) {
            if (context2.position.col != null)
              return context2.position.col;
            else
              throw Error("FormulaParser.parse is called without position parameter.");
          } else {
            if (typeof obj !== "object" || Array.isArray(obj))
              throw FormulaError2.VALUE;
            if (H.isCellRef(obj)) {
              return obj.ref.col;
            } else if (H.isRangeRef(obj)) {
              return obj.ref.from.col;
            } else {
              throw Error("ReferenceFunctions.COLUMN should not reach here.");
            }
          }
        },
        // Special
        COLUMNS: (context2, obj) => {
          if (obj == null) {
            throw Error("COLUMNS requires one argument");
          }
          if (typeof obj != "object" || Array.isArray(obj))
            throw FormulaError2.VALUE;
          if (H.isCellRef(obj)) {
            return 1;
          } else if (H.isRangeRef(obj)) {
            return Math.abs(obj.ref.from.col - obj.ref.to.col) + 1;
          } else {
            throw Error("ReferenceFunctions.COLUMNS should not reach here.");
          }
        },
        HLOOKUP: (lookupValue, tableArray, rowIndexNum, rangeLookup) => {
          lookupValue = H.accept(lookupValue);
          try {
            tableArray = H.accept(tableArray, Types.ARRAY, void 0, false);
          } catch (e) {
            if (e instanceof FormulaError2)
              throw FormulaError2.NA;
            throw e;
          }
          rowIndexNum = H.accept(rowIndexNum, Types.NUMBER);
          rangeLookup = H.accept(rangeLookup, Types.BOOLEAN, true);
          if (rowIndexNum < 1)
            throw FormulaError2.VALUE;
          if (tableArray[rowIndexNum - 1] === void 0)
            throw FormulaError2.REF;
          const lookupType = typeof lookupValue;
          if (rangeLookup) {
            let prevValue = lookupType === typeof tableArray[0][0] ? tableArray[0][0] : null;
            for (let i = 1; i < tableArray[0].length; i++) {
              const currValue = tableArray[0][i];
              const type = typeof currValue;
              if (type !== lookupType)
                continue;
              if (prevValue > lookupValue && currValue > lookupValue) {
                throw FormulaError2.NA;
              }
              if (currValue === lookupValue)
                return tableArray[rowIndexNum - 1][i];
              if (prevValue != null && currValue > lookupValue && prevValue <= lookupValue) {
                return tableArray[rowIndexNum - 1][i - 1];
              }
              prevValue = currValue;
            }
            if (prevValue == null)
              throw FormulaError2.NA;
            return prevValue;
          } else {
            let index = -1;
            if (WildCard.isWildCard(lookupValue)) {
              index = tableArray[0].findIndex((item) => {
                return WildCard.toRegex(lookupValue, "i").test(item);
              });
            } else {
              index = tableArray[0].findIndex((item) => {
                return item === lookupValue;
              });
            }
            if (index === -1) throw FormulaError2.NA;
            return tableArray[rowIndexNum - 1][index];
          }
        },
        // Special
        INDEX: (context2, ranges, rowNum, colNum, areaNum) => {
          rowNum = context2.utils.extractRefValue(rowNum);
          rowNum = { value: rowNum.val, isArray: rowNum.isArray };
          rowNum = H.accept(rowNum, Types.NUMBER);
          rowNum = Math.trunc(rowNum);
          if (colNum == null) {
            colNum = 1;
          } else {
            colNum = context2.utils.extractRefValue(colNum);
            colNum = { value: colNum.val, isArray: colNum.isArray };
            colNum = H.accept(colNum, Types.NUMBER, 1);
            colNum = Math.trunc(colNum);
          }
          if (areaNum == null) {
            areaNum = 1;
          } else {
            areaNum = context2.utils.extractRefValue(areaNum);
            areaNum = { value: areaNum.val, isArray: areaNum.isArray };
            areaNum = H.accept(areaNum, Types.NUMBER, 1);
            areaNum = Math.trunc(areaNum);
          }
          let range2 = ranges;
          if (ranges instanceof Collection) {
            range2 = ranges.refs[areaNum - 1];
          } else if (areaNum > 1) {
            throw FormulaError2.REF;
          }
          if (rowNum === 0 && colNum === 0) {
            return range2;
          }
          if (rowNum === 0) {
            if (H.isRangeRef(range2)) {
              if (range2.ref.to.col - range2.ref.from.col < colNum - 1)
                throw FormulaError2.REF;
              range2.ref.from.col += colNum - 1;
              range2.ref.to.col = range2.ref.from.col;
              return range2;
            } else if (Array.isArray(range2)) {
              const res = [];
              range2.forEach((row) => res.push([row[colNum - 1]]));
              return res;
            }
          }
          if (colNum === 0) {
            if (H.isRangeRef(range2)) {
              if (range2.ref.to.row - range2.ref.from.row < rowNum - 1)
                throw FormulaError2.REF;
              range2.ref.from.row += rowNum - 1;
              range2.ref.to.row = range2.ref.from.row;
              return range2;
            } else if (Array.isArray(range2)) {
              return range2[colNum - 1];
            }
          }
          if (rowNum !== 0 && colNum !== 0) {
            if (H.isRangeRef(range2)) {
              range2 = range2.ref;
              if (range2.to.row - range2.from.row < rowNum - 1 || range2.to.col - range2.from.col < colNum - 1)
                throw FormulaError2.REF;
              return { ref: { row: range2.from.row + rowNum - 1, col: range2.from.col + colNum - 1 } };
            } else if (H.isCellRef(range2)) {
              range2 = range2.ref;
              if (rowNum > 1 || colNum > 1)
                throw FormulaError2.REF;
              return { ref: { row: range2.row + rowNum - 1, col: range2.col + colNum - 1 } };
            } else if (Array.isArray(range2)) {
              if (range2.length < rowNum || range2[0].length < colNum)
                throw FormulaError2.REF;
              return range2[rowNum - 1][colNum - 1];
            }
          }
        },
        MATCH: () => {
        },
        // Special
        ROW: (context2, obj) => {
          if (obj == null) {
            if (context2.position.row != null)
              return context2.position.row;
            else
              throw Error("FormulaParser.parse is called without position parameter.");
          } else {
            if (typeof obj !== "object" || Array.isArray(obj))
              throw FormulaError2.VALUE;
            if (H.isCellRef(obj)) {
              return obj.ref.row;
            } else if (H.isRangeRef(obj)) {
              return obj.ref.from.row;
            } else {
              throw Error("ReferenceFunctions.ROW should not reach here.");
            }
          }
        },
        // Special
        ROWS: (context2, obj) => {
          if (obj == null) {
            throw Error("ROWS requires one argument");
          }
          if (typeof obj != "object" || Array.isArray(obj))
            throw FormulaError2.VALUE;
          if (H.isCellRef(obj)) {
            return 1;
          } else if (H.isRangeRef(obj)) {
            return Math.abs(obj.ref.from.row - obj.ref.to.row) + 1;
          } else {
            throw Error("ReferenceFunctions.ROWS should not reach here.");
          }
        },
        TRANSPOSE: (array) => {
          array = H.accept(array, Types.ARRAY, void 0, false);
          const result = [];
          for (let i = 0; i < array[0].length; i++) {
            result[i] = [];
            for (let j = 0; j < array.length; j++) {
              result[i][j] = array[j][i];
            }
          }
          return result;
        },
        VLOOKUP: (lookupValue, tableArray, colIndexNum, rangeLookup) => {
          lookupValue = H.accept(lookupValue);
          try {
            tableArray = H.accept(tableArray, Types.ARRAY, void 0, false);
          } catch (e) {
            if (e instanceof FormulaError2)
              throw FormulaError2.NA;
            throw e;
          }
          colIndexNum = H.accept(colIndexNum, Types.NUMBER);
          rangeLookup = H.accept(rangeLookup, Types.BOOLEAN, true);
          if (colIndexNum < 1)
            throw FormulaError2.VALUE;
          if (tableArray[0][colIndexNum - 1] === void 0)
            throw FormulaError2.REF;
          const lookupType = typeof lookupValue;
          if (rangeLookup) {
            let prevValue = lookupType === typeof tableArray[0][0] ? tableArray[0][0] : null;
            for (let i = 1; i < tableArray.length; i++) {
              const currRow = tableArray[i];
              const currValue = tableArray[i][0];
              const type = typeof currValue;
              if (type !== lookupType)
                continue;
              if (prevValue > lookupValue && currValue > lookupValue) {
                throw FormulaError2.NA;
              }
              if (currValue === lookupValue)
                return currRow[colIndexNum - 1];
              if (prevValue != null && currValue > lookupValue && prevValue <= lookupValue) {
                return tableArray[i - 1][colIndexNum - 1];
              }
              prevValue = currValue;
            }
            if (prevValue == null)
              throw FormulaError2.NA;
            return prevValue;
          } else {
            let index = -1;
            if (WildCard.isWildCard(lookupValue)) {
              index = tableArray.findIndex((currRow) => {
                return WildCard.toRegex(lookupValue, "i").test(currRow[0]);
              });
            } else {
              index = tableArray.findIndex((currRow) => {
                return currRow[0] === lookupValue;
              });
            }
            if (index === -1) throw FormulaError2.NA;
            return tableArray[index][colIndexNum - 1];
          }
        }
      };
      module2.exports = ReferenceFunctions;
    }
  });

  // node_modules/fast-formula-parser/formulas/functions/information.js
  var require_information = __commonJS({
    "node_modules/fast-formula-parser/formulas/functions/information.js"(exports2, module2) {
      var FormulaError2 = require_error();
      var { FormulaHelpers, Types } = require_helpers();
      var H = FormulaHelpers;
      var error2Number = {
        "#NULL!": 1,
        "#DIV/0!": 2,
        "#VALUE!": 3,
        "#REF!": 4,
        "#NAME?": 5,
        "#NUM!": 6,
        "#N/A": 7
      };
      var InfoFunctions = {
        CELL: (infoType, reference) => {
        },
        "ERROR.TYPE": (value) => {
          value = H.accept(value);
          if (value instanceof FormulaError2)
            return error2Number[value.toString()];
          throw FormulaError2.NA;
        },
        INFO: () => {
        },
        ISBLANK: (value) => {
          if (!value.ref)
            return false;
          return value.value == null || value.value === "";
        },
        ISERR: (value) => {
          value = H.accept(value);
          return value instanceof FormulaError2 && value.toString() !== "#N/A";
        },
        ISERROR: (value) => {
          value = H.accept(value);
          return value instanceof FormulaError2;
        },
        ISEVEN: (number) => {
          number = H.accept(number, Types.NUMBER);
          number = Math.trunc(number);
          return number % 2 === 0;
        },
        ISLOGICAL: (value) => {
          value = H.accept(value);
          return typeof value === "boolean";
        },
        ISNA: (value) => {
          value = H.accept(value);
          return value instanceof FormulaError2 && value.toString() === "#N/A";
        },
        ISNONTEXT: (value) => {
          value = H.accept(value);
          return typeof value !== "string";
        },
        ISNUMBER: (value) => {
          value = H.accept(value);
          return typeof value === "number";
        },
        ISREF: (value) => {
          if (!value.ref)
            return false;
          if (H.isCellRef(value) && (value.ref.row > 1048576 || value.ref.col > 16384)) {
            return false;
          }
          if (H.isRangeRef(value) && (value.ref.from.row > 1048576 || value.ref.from.col > 16384 || value.ref.to.row > 1048576 || value.ref.to.col > 16384)) {
            return false;
          }
          value = H.accept(value);
          return !(value instanceof FormulaError2 && value.toString() === "#REF!");
        },
        ISTEXT: (value) => {
          value = H.accept(value);
          return typeof value === "string";
        },
        N: (value) => {
          value = H.accept(value);
          const type = typeof value;
          if (type === "number")
            return value;
          else if (type === "boolean")
            return Number(value);
          else if (value instanceof FormulaError2)
            throw value;
          return 0;
        },
        NA: () => {
          throw FormulaError2.NA;
        },
        TYPE: (value) => {
          if (value.ref) {
            if (H.isRangeRef(value)) {
              return 16;
            } else if (H.isCellRef(value)) {
              value = H.accept(value);
              if (typeof value === "string" && value.length === 0)
                return 1;
            }
          }
          value = H.accept(value);
          const type = typeof value;
          if (type === "number")
            return 1;
          else if (type === "string")
            return 2;
          else if (type === "boolean")
            return 4;
          else if (value instanceof FormulaError2)
            return 16;
          else if (Array.isArray(value))
            return 64;
        }
      };
      module2.exports = InfoFunctions;
    }
  });

  // node_modules/fast-formula-parser/formulas/functions/distribution.js
  var require_distribution = __commonJS({
    "node_modules/fast-formula-parser/formulas/functions/distribution.js"(exports2, module2) {
      var FormulaError2 = require_error();
      var { FormulaHelpers, Types } = require_helpers();
      var H = FormulaHelpers;
      var jStat = require_jstat();
      var MathFunctions = require_math();
      var SQRT2PI = 2.5066282746310002;
      var DistributionFunctions = {
        "BETA.DIST": (x, alpha, beta, cumulative, a, b) => {
          x = H.accept(x, Types.NUMBER);
          alpha = H.accept(alpha, Types.NUMBER);
          beta = H.accept(beta, Types.NUMBER);
          cumulative = H.accept(cumulative, Types.BOOLEAN);
          a = H.accept(a, Types.NUMBER, 0);
          b = H.accept(b, Types.NUMBER, 1);
          if (alpha <= 0 || beta <= 0 || x < a || x > b || a === b)
            throw FormulaError2.NUM;
          x = (x - a) / (b - a);
          return cumulative ? jStat.beta.cdf(x, alpha, beta) : jStat.beta.pdf(x, alpha, beta) / (b - a);
        },
        "BETA.INV": (probability, alpha, beta, a, b) => {
          probability = H.accept(probability, Types.NUMBER);
          alpha = H.accept(alpha, Types.NUMBER);
          beta = H.accept(beta, Types.NUMBER);
          a = H.accept(a, Types.NUMBER, 0);
          b = H.accept(b, Types.NUMBER, 1);
          if (alpha <= 0 || beta <= 0 || probability <= 0 || probability > 1)
            throw FormulaError2.NUM;
          return jStat.beta.inv(probability, alpha, beta) * (b - a) + a;
        },
        "BINOM.DIST": (numberS, trials, probabilityS, cumulative) => {
          numberS = H.accept(numberS, Types.NUMBER);
          trials = H.accept(trials, Types.NUMBER);
          probabilityS = H.accept(probabilityS, Types.NUMBER);
          cumulative = H.accept(cumulative, Types.BOOLEAN);
          if (trials < 0 || probabilityS < 0 || probabilityS > 1 || numberS < 0 || numberS > trials)
            throw FormulaError2.NUM;
          return cumulative ? jStat.binomial.cdf(numberS, trials, probabilityS) : jStat.binomial.pdf(numberS, trials, probabilityS);
        },
        "BINOM.DIST.RANGE": (trials, probabilityS, numberS, numberS2) => {
          trials = H.accept(trials, Types.NUMBER);
          probabilityS = H.accept(probabilityS, Types.NUMBER);
          numberS = H.accept(numberS, Types.NUMBER);
          numberS2 = H.accept(numberS2, Types.NUMBER, numberS);
          if (trials < 0 || probabilityS < 0 || probabilityS > 1 || numberS < 0 || numberS > trials || numberS2 < numberS || numberS2 > trials)
            throw FormulaError2.NUM;
          let result = 0;
          for (let i = numberS; i <= numberS2; i++) {
            result += MathFunctions.COMBIN(trials, i) * Math.pow(probabilityS, i) * Math.pow(1 - probabilityS, trials - i);
          }
          return result;
        },
        "BINOM.INV": (trials, probabilityS, alpha) => {
          trials = H.accept(trials, Types.NUMBER);
          probabilityS = H.accept(probabilityS, Types.NUMBER);
          alpha = H.accept(alpha, Types.NUMBER);
          if (trials < 0 || probabilityS < 0 || probabilityS > 1 || alpha < 0 || alpha > 1)
            throw FormulaError2.NUM;
          let x = 0;
          while (x <= trials) {
            if (jStat.binomial.cdf(x, trials, probabilityS) >= alpha) {
              return x;
            }
            x++;
          }
        },
        "CHISQ.DIST": (x, degFreedom, cumulative) => {
          x = H.accept(x, Types.NUMBER);
          degFreedom = H.accept(degFreedom, Types.NUMBER);
          cumulative = H.accept(cumulative, Types.NUMBER);
          degFreedom = Math.trunc(degFreedom);
          if (x < 0 || degFreedom < 1 || degFreedom > 10 ** 10)
            throw FormulaError2.NUM;
          return cumulative ? jStat.chisquare.cdf(x, degFreedom) : jStat.chisquare.pdf(x, degFreedom);
        },
        "CHISQ.DIST.RT": (x, degFreedom) => {
          x = H.accept(x, Types.NUMBER);
          degFreedom = H.accept(degFreedom, Types.NUMBER);
          degFreedom = Math.trunc(degFreedom);
          if (x < 0 || degFreedom < 1 || degFreedom > 10 ** 10)
            throw FormulaError2.NUM;
          return 1 - jStat.chisquare.cdf(x, degFreedom);
        },
        "CHISQ.INV": (probability, degFreedom) => {
          probability = H.accept(probability, Types.NUMBER);
          degFreedom = H.accept(degFreedom, Types.NUMBER);
          degFreedom = Math.trunc(degFreedom);
          if (probability < 0 || probability > 1 || degFreedom < 1 || degFreedom > 10 ** 10)
            throw FormulaError2.NUM;
          return jStat.chisquare.inv(probability, degFreedom);
        },
        "CHISQ.INV.RT": (probability, degFreedom) => {
          probability = H.accept(probability, Types.NUMBER);
          degFreedom = H.accept(degFreedom, Types.NUMBER);
          degFreedom = Math.trunc(degFreedom);
          if (probability < 0 || probability > 1 || degFreedom < 1 || degFreedom > 10 ** 10)
            throw FormulaError2.NUM;
          return jStat.chisquare.inv(1 - probability, degFreedom);
        },
        "CHISQ.TEST": (actualRange, expectedRange) => {
          const actual = H.accept(actualRange, Types.ARRAY, void 0, false, false);
          const expected = H.accept(expectedRange, Types.ARRAY, void 0, false, false);
          if (actual.length !== expected.length || actual[0].length !== expected[0].length || actual.length === 1 && actual[0].length === 1)
            throw FormulaError2.NA;
          const row = actual.length;
          const col = actual[0].length;
          let dof = (row - 1) * (col - 1);
          if (row === 1)
            dof = col - 1;
          else
            dof = row - 1;
          let xsqr = 0;
          for (let i = 0; i < row; i++) {
            for (let j = 0; j < col; j++) {
              if (typeof actual[i][j] !== "number" || typeof expected[i][j] !== "number")
                continue;
              if (expected[i][j] === 0) throw FormulaError2.DIV0;
              xsqr += Math.pow(actual[i][j] - expected[i][j], 2) / expected[i][j];
            }
          }
          let p = Math.exp(-0.5 * xsqr);
          if (dof % 2 === 1) {
            p = p * Math.sqrt(2 * xsqr / Math.PI);
          }
          let k = dof;
          while (k >= 2) {
            p = p * xsqr / k;
            k = k - 2;
          }
          let t = p, a = dof;
          while (t > 1e-15 * p) {
            a = a + 2;
            t = t * xsqr / a;
            p = p + t;
          }
          return 1 - p;
        },
        "CONFIDENCE.NORM": (alpha, std, size) => {
          alpha = H.accept(alpha, Types.NUMBER);
          std = H.accept(std, Types.NUMBER);
          size = H.accept(size, Types.NUMBER);
          size = Math.trunc(size);
          if (alpha <= 0 || alpha >= 1 || std <= 0 || size < 1)
            throw FormulaError2.NUM;
          return jStat.normalci(1, alpha, std, size)[1] - 1;
        },
        "CONFIDENCE.T": (alpha, std, size) => {
          alpha = H.accept(alpha, Types.NUMBER);
          std = H.accept(std, Types.NUMBER);
          size = H.accept(size, Types.NUMBER);
          size = Math.trunc(size);
          if (alpha <= 0 || alpha >= 1 || std <= 0 || size < 1)
            throw FormulaError2.NUM;
          if (size === 1)
            throw FormulaError2.DIV0;
          return jStat.tci(1, alpha, std, size)[1] - 1;
        },
        CORREL: (array1, array2) => {
          array1 = H.accept(array1, Types.ARRAY, void 0, true, true);
          array2 = H.accept(array2, Types.ARRAY, void 0, true, true);
          if (array1.length !== array2.length)
            throw FormulaError2.NA;
          const filterArr1 = [], filterArr2 = [];
          for (let i = 0; i < array1.length; i++) {
            if (typeof array1[i] !== "number" || typeof array2[i] !== "number")
              continue;
            filterArr1.push(array1[i]);
            filterArr2.push(array2[i]);
          }
          if (filterArr1.length <= 1)
            throw FormulaError2.DIV0;
          return jStat.corrcoeff(filterArr1, filterArr2);
        },
        "COVARIANCE.P": (array1, array2) => {
          array1 = H.accept(array1, Types.ARRAY, void 0, true, true);
          array2 = H.accept(array2, Types.ARRAY, void 0, true, true);
          if (array1.length !== array2.length)
            throw FormulaError2.NA;
          const filterArr1 = [], filterArr2 = [];
          for (let i = 0; i < array1.length; i++) {
            if (typeof array1[i] !== "number" || typeof array2[i] !== "number")
              continue;
            filterArr1.push(array1[i]);
            filterArr2.push(array2[i]);
          }
          const mean1 = jStat.mean(filterArr1), mean2 = jStat.mean(filterArr2);
          let result = 0;
          for (let i = 0; i < filterArr1.length; i++) {
            result += (filterArr1[i] - mean1) * (filterArr2[i] - mean2);
          }
          return result / filterArr1.length;
        },
        "COVARIANCE.S": (array1, array2) => {
          array1 = H.accept(array1, Types.ARRAY, void 0, true, true);
          array2 = H.accept(array2, Types.ARRAY, void 0, true, true);
          if (array1.length !== array2.length)
            throw FormulaError2.NA;
          const filterArr1 = [], filterArr2 = [];
          for (let i = 0; i < array1.length; i++) {
            if (typeof array1[i] !== "number" || typeof array2[i] !== "number")
              continue;
            filterArr1.push(array1[i]);
            filterArr2.push(array2[i]);
          }
          if (filterArr1.length <= 1)
            throw FormulaError2.DIV0;
          return jStat.covariance(filterArr1, filterArr2);
        },
        DEVSQ: (...numbers) => {
          let sum = 0, x = [];
          H.flattenParams(numbers, Types.NUMBER, true, (item, info) => {
            if (typeof item === "number") {
              sum += item;
              x.push(item);
            }
          });
          const mean = sum / x.length;
          sum = 0;
          for (let i = 0; i < x.length; i++) {
            sum += (x[i] - mean) ** 2;
          }
          return sum;
        },
        "EXPON.DIST": (x, lambda, cumulative) => {
          x = H.accept(x, Types.NUMBER);
          lambda = H.accept(lambda, Types.NUMBER);
          cumulative = H.accept(cumulative, Types.BOOLEAN);
          if (x < 0 || lambda <= 0)
            throw FormulaError2.NUM;
          return cumulative ? jStat.exponential.cdf(x, lambda) : jStat.exponential.pdf(x, lambda);
        },
        "F.DIST": (x, d1, d2, cumulative) => {
          x = H.accept(x, Types.NUMBER);
          d1 = H.accept(d1, Types.NUMBER);
          d2 = H.accept(d2, Types.NUMBER);
          cumulative = H.accept(cumulative, Types.BOOLEAN);
          if (x < 0 || d1 < 1 || d2 < 1) {
            throw FormulaError2.NUM;
          }
          d1 = Math.trunc(d1);
          d2 = Math.trunc(d2);
          return cumulative ? jStat.centralF.cdf(x, d1, d2) : jStat.centralF.pdf(x, d1, d2);
        },
        "F.DIST.RT": (x, d1, d2) => {
          x = H.accept(x, Types.NUMBER);
          d1 = H.accept(d1, Types.NUMBER);
          d2 = H.accept(d2, Types.NUMBER);
          if (x < 0 || d1 < 1 || d2 < 1) {
            throw FormulaError2.NUM;
          }
          d1 = Math.trunc(d1);
          d2 = Math.trunc(d2);
          return 1 - jStat.centralF.cdf(x, d1, d2);
        },
        "F.INV": (probability, d1, d2) => {
          probability = H.accept(probability, Types.NUMBER);
          d1 = H.accept(d1, Types.NUMBER);
          d2 = H.accept(d2, Types.NUMBER);
          if (probability < 0 || probability > 1) {
            throw FormulaError2.NUM;
          }
          if (d1 < 1 || d2 < 1) {
            throw FormulaError2.NUM;
          }
          d1 = Math.trunc(d1);
          d2 = Math.trunc(d2);
          return jStat.centralF.inv(probability, d1, d2);
        },
        "F.INV.RT": (probability, d1, d2) => {
          probability = H.accept(probability, Types.NUMBER);
          d1 = H.accept(d1, Types.NUMBER);
          d2 = H.accept(d2, Types.NUMBER);
          if (probability < 0 || probability > 1) {
            throw FormulaError2.NUM;
          }
          if (d1 < 1 || d1 >= Math.pow(10, 10)) {
            throw FormulaError2.NUM;
          }
          if (d2 < 1 || d2 >= Math.pow(10, 10)) {
            throw FormulaError2.NUM;
          }
          d1 = Math.trunc(d1);
          d2 = Math.trunc(d2);
          return jStat.centralF.inv(1 - probability, d1, d2);
        },
        /**
         * https://en.wikipedia.org/wiki/F-test_of_equality_of_variances
         */
        "F.TEST": (array1, array2) => {
          array1 = H.accept(array1, Types.ARRAY, void 0, true, true);
          array2 = H.accept(array2, Types.ARRAY, void 0, true, true);
          const x1 = [], x2 = [];
          let x1Mean = 0, x2Mean = 0;
          for (let i = 0; i < Math.max(array1.length, array2.length); i++) {
            if (typeof array1[i] === "number") {
              x1.push(array1[i]);
              x1Mean += array1[i];
            }
            if (typeof array2[i] === "number") {
              x2.push(array2[i]);
              x2Mean += array2[i];
            }
          }
          if (x1.length <= 1 || x2.length <= 1)
            throw FormulaError2.DIV0;
          x1Mean /= x1.length;
          x2Mean /= x2.length;
          let s1 = 0, s2 = 0;
          for (let i = 0; i < x1.length; i++) {
            s1 += (x1Mean - x1[i]) ** 2;
          }
          s1 /= x1.length - 1;
          for (let i = 0; i < x2.length; i++) {
            s2 += (x2Mean - x2[i]) ** 2;
          }
          s2 /= x2.length - 1;
          return jStat.centralF.cdf(s1 / s2, x1.length - 1, x2.length - 1) * 2;
        },
        FISHER: (x) => {
          x = H.accept(x, Types.NUMBER);
          if (x <= -1 || x >= 1) {
            throw FormulaError2.NUM;
          }
          return Math.log((1 + x) / (1 - x)) / 2;
        },
        FISHERINV: (x) => {
          x = H.accept(x, Types.NUMBER);
          let e2y = Math.exp(2 * x);
          return (e2y - 1) / (e2y + 1);
        },
        // FIXME
        FORECAST: (x, knownYs, knownXs) => {
          x = H.accept(x, Types.NUMBER);
          knownYs = H.accept(knownYs, Types.ARRAY, void 0, true, true);
          knownXs = H.accept(knownXs, Types.ARRAY, void 0, true, true);
          if (knownXs.length !== knownYs.length)
            throw FormulaError2.NA;
          const filteredY = [], filteredX = [];
          let xAllEqual = true;
          for (let i = 0; i < knownYs.length; i++) {
            if (typeof knownYs[i] !== "number" || typeof knownXs[i] !== "number")
              continue;
            filteredY.push(knownYs[i]);
            filteredX.push(knownXs[i]);
            if (knownXs[i] !== knownXs[0])
              xAllEqual = false;
          }
          if (xAllEqual)
            throw FormulaError2.DIV0;
          const yMean = jStat.mean(filteredY);
          const xMean = jStat.mean(filteredX);
          let numerator = 0, denominator = 0;
          for (let i = 0; i < filteredY.length; i++) {
            numerator += (filteredX[i] - xMean) * (filteredY[i] - yMean);
            denominator += (filteredX[i] - xMean) ** 2;
          }
          const b = numerator / denominator;
          const a = yMean - b * xMean;
          return a + b * x;
        },
        "FORECAST.ETS": () => {
        },
        "FORECAST.ETS.CONFINT": () => {
        },
        "FORECAST.ETS.SEASONALITY": () => {
        },
        "FORECAST.ETS.STAT": () => {
        },
        "FORECAST.LINEAR": (...params) => {
          return DistributionFunctions.FORECAST(...params);
        },
        FREQUENCY: (dataArray, binsArray) => {
          dataArray = H.accept(dataArray, Types.ARRAY, void 0, true, true);
          binsArray = H.accept(binsArray, Types.ARRAY, void 0, true, true);
          const binsArrayFiltered = [];
          for (let i = 0; i < binsArray.length; i++) {
            if (typeof binsArray[i] !== "number")
              continue;
            binsArrayFiltered.push(binsArray[i]);
          }
          binsArrayFiltered.sort();
          binsArrayFiltered.push(Infinity);
          const result = [];
          for (let j = 0; j < binsArrayFiltered.length; j++) {
            result[j] = [];
            result[j][0] = 0;
            for (let i = 0; i < dataArray.length; i++) {
              if (typeof dataArray[i] !== "number") {
                continue;
              }
              const curr = dataArray[i];
              if (curr <= binsArrayFiltered[j]) {
                result[j][0]++;
                dataArray[i] = null;
              }
            }
          }
          return result;
        },
        GAMMA: (x) => {
          x = H.accept(x, Types.NUMBER);
          if (x === 0 || x < 0 && x === Math.trunc(x)) {
            throw FormulaError2.NUM;
          }
          return jStat.gammafn(x);
        },
        "GAMMA.DIST": (x, alpha, beta, cumulative) => {
          x = H.accept(x, Types.NUMBER);
          alpha = H.accept(alpha, Types.NUMBER);
          beta = H.accept(beta, Types.NUMBER);
          cumulative = H.accept(cumulative, Types.BOOLEAN);
          if (x < 0 || alpha <= 0 || beta <= 0) {
            throw FormulaError2.NUM;
          }
          return cumulative ? jStat.gamma.cdf(x, alpha, beta, true) : jStat.gamma.pdf(x, alpha, beta, false);
        },
        "GAMMA.INV": (probability, alpha, beta) => {
          probability = H.accept(probability, Types.NUMBER);
          alpha = H.accept(alpha, Types.NUMBER);
          beta = H.accept(beta, Types.NUMBER);
          if (probability < 0 || probability > 1 || alpha <= 0 || beta <= 0) {
            throw FormulaError2.NUM;
          }
          return jStat.gamma.inv(probability, alpha, beta);
        },
        GAMMALN: (x) => {
          x = H.accept(x, Types.NUMBER);
          if (x <= 0) {
            throw FormulaError2.NUM;
          }
          return jStat.gammaln(x);
        },
        "GAMMALN.PRECISE": (x) => {
          x = H.accept(x, Types.NUMBER);
          if (x <= 0) {
            throw FormulaError2.NUM;
          }
          return jStat.gammaln(x);
        },
        GAUSS: (z) => {
          z = H.accept(z, Types.NUMBER);
          return jStat.normal.cdf(z, 0, 1) - 0.5;
        },
        GEOMEAN: (...numbers) => {
          const filterArr = [];
          H.flattenParams(numbers, Types.NUMBER, true, (item, info) => {
            if (typeof item === "number") {
              filterArr.push(item);
            }
          });
          return jStat.geomean(filterArr);
        },
        GROWTH: (knownY, knownX, newX, useConst) => {
          knownY = H.accept(knownY, Types.ARRAY, void 0, true, true);
          for (let i = 0; i < knownY.length; i++) {
            if (typeof knownY[i] !== "number")
              throw FormulaError2.VALUE;
          }
          knownX = H.accept(knownX, Types.ARRAY, null, true, true);
          const isKnownXOmitted = knownX == null;
          if (knownX == null) {
            knownX = [];
            for (let i = 1; i <= knownY.length; i++) {
              knownX.push(i);
            }
          } else {
            if (knownX.length !== knownY.length)
              throw FormulaError2.REF;
            for (let i = 0; i < knownX.length; i++) {
              if (typeof knownX[i] !== "number")
                throw FormulaError2.VALUE;
            }
          }
          newX = H.accept(newX, Types.ARRAY, null, false, true);
          if (newX == null && isKnownXOmitted) {
            newX = [];
            for (let i = 1; i <= knownY.length; i++) {
              newX.push(i);
            }
            newX = [newX];
          } else if (newX == null) {
            newX = Array.isArray(knownX[0]) ? knownX : [knownX];
          }
          useConst = H.accept(useConst, Types.BOOLEAN, true);
          const n = knownY.length;
          let avg_x = 0, avg_y = 0, avg_xy = 0, avg_xx = 0;
          for (let i = 0; i < n; i++) {
            const x = knownX[i];
            const y = Math.log(knownY[i]);
            avg_x += x;
            avg_y += y;
            avg_xy += x * y;
            avg_xx += x * x;
          }
          avg_x /= n;
          avg_y /= n;
          avg_xy /= n;
          avg_xx /= n;
          let beta;
          let alpha;
          if (useConst) {
            beta = (avg_xy - avg_x * avg_y) / (avg_xx - avg_x * avg_x);
            alpha = avg_y - beta * avg_x;
          } else {
            beta = avg_xy / avg_xx;
            alpha = 0;
          }
          const new_y = [];
          for (let i = 0; i < newX.length; i++) {
            new_y[i] = [];
            for (let j = 0; j < newX[0].length; j++) {
              if (typeof newX[i][j] !== "number")
                throw FormulaError2.VALUE;
              new_y[i][j] = Math.exp(alpha + beta * newX[i][j]);
            }
          }
          return new_y;
        },
        HARMEAN: (...numbers) => {
          let cnt = 0, denominator = 0;
          H.flattenParams(numbers, Types.NUMBER, true, (item, info) => {
            if (typeof item === "number") {
              denominator += 1 / item;
              cnt++;
            }
          });
          return cnt / denominator;
        },
        "HYPGEOM.DIST": (sample_s, number_sample, population_s, number_pop, cumulative) => {
          sample_s = H.accept(sample_s, Types.NUMBER);
          number_sample = H.accept(number_sample, Types.NUMBER);
          population_s = H.accept(population_s, Types.NUMBER);
          number_pop = H.accept(number_pop, Types.NUMBER);
          cumulative = H.accept(cumulative, Types.BOOLEAN);
          sample_s = Math.trunc(sample_s);
          number_sample = Math.trunc(number_sample);
          population_s = Math.trunc(population_s);
          number_pop = Math.trunc(number_pop);
          if (number_pop <= 0 || sample_s < 0 || number_sample <= 0 || population_s <= 0) {
            throw FormulaError2.NUM;
          }
          if (number_sample > number_pop) {
            throw FormulaError2.NUM;
          }
          if (population_s > number_pop) {
            throw FormulaError2.NUM;
          }
          if (number_sample < sample_s || population_s < sample_s) {
            throw FormulaError2.NUM;
          }
          if (sample_s < number_sample - number_pop + population_s) {
            throw FormulaError2.NUM;
          }
          function pdf(x, n, M, N) {
            return MathFunctions.COMBIN(M, x) * MathFunctions.COMBIN(N - M, n - x) / MathFunctions.COMBIN(N, n);
          }
          function cdf(x, n, M, N) {
            let result = 0;
            for (let i = 0; i <= x; i++) {
              result += pdf(i, n, M, N);
            }
            return result;
          }
          return cumulative ? cdf(sample_s, number_sample, population_s, number_pop) : pdf(sample_s, number_sample, population_s, number_pop);
        },
        INTERCEPT: (knownYs, knownXs) => {
          knownYs = H.accept(knownYs, Types.ARRAY, void 0, true, true);
          knownXs = H.accept(knownXs, Types.ARRAY, void 0, true, true);
          if (knownXs.length !== knownYs.length)
            throw FormulaError2.NA;
          const filteredY = [], filteredX = [];
          for (let i = 0; i < knownYs.length; i++) {
            if (typeof knownYs[i] !== "number" || typeof knownXs[i] !== "number")
              continue;
            filteredY.push(knownYs[i]);
            filteredX.push(knownXs[i]);
          }
          if (filteredY.length <= 1)
            throw FormulaError2.DIV0;
          const yMean = jStat.mean(filteredY);
          const xMean = jStat.mean(filteredX);
          let numerator = 0, denominator = 0;
          for (let i = 0; i < filteredY.length; i++) {
            numerator += (filteredX[i] - xMean) * (filteredY[i] - yMean);
            denominator += (filteredX[i] - xMean) ** 2;
          }
          const b = numerator / denominator;
          return yMean - b * xMean;
        },
        KURT: (...numbers) => {
          let mean = 0, range2 = [];
          H.flattenParams(numbers, Types.NUMBER, true, (item, info) => {
            if (typeof item === "number") {
              mean += item;
              range2.push(item);
            }
          });
          const n = range2.length;
          mean /= n;
          let sigma = 0;
          for (let i = 0; i < n; i++) {
            sigma += Math.pow(range2[i] - mean, 4);
          }
          sigma = sigma / Math.pow(jStat.stdev(range2, true), 4);
          return n * (n + 1) / ((n - 1) * (n - 2) * (n - 3)) * sigma - 3 * (n - 1) * (n - 1) / ((n - 2) * (n - 3));
        },
        LINEST: () => {
        },
        LOGEST: () => {
        },
        "LOGNORM.DIST": (x, mean, standard_dev, cumulative) => {
          x = H.accept(x, Types.NUMBER);
          mean = H.accept(mean, Types.NUMBER);
          standard_dev = H.accept(standard_dev, Types.NUMBER);
          cumulative = H.accept(cumulative, Types.BOOLEAN);
          if (x <= 0 || standard_dev <= 0) {
            throw FormulaError2.NUM;
          }
          return cumulative ? jStat.lognormal.cdf(x, mean, standard_dev) : jStat.lognormal.pdf(x, mean, standard_dev);
        },
        "LOGNORM.INV": (probability, mean, standard_dev) => {
          probability = H.accept(probability, Types.NUMBER);
          mean = H.accept(mean, Types.NUMBER);
          standard_dev = H.accept(standard_dev, Types.NUMBER);
          if (probability <= 0 || probability >= 1) {
            throw FormulaError2.NUM;
          }
          if (standard_dev <= 0) {
            throw FormulaError2.NUM;
          }
          return jStat.lognormal.inv(probability, mean, standard_dev);
        },
        "MODE.MULT": () => {
        },
        "MODE.SNGL": () => {
        },
        "NEGBINOM.DIST": (number_f, number_s, probability_s, cumulative) => {
          number_f = H.accept(number_f, Types.NUMBER);
          number_s = H.accept(number_s, Types.NUMBER);
          probability_s = H.accept(probability_s, Types.NUMBER);
          cumulative = H.accept(cumulative, Types.BOOLEAN);
          number_f = Math.trunc(number_f);
          number_s = Math.trunc(number_s);
          if (probability_s < 0 || probability_s > 1) {
            throw FormulaError2.NUM;
          }
          if (number_f < 0 || number_s < 1) {
            throw FormulaError2.NUM;
          }
          return cumulative ? jStat.negbin.cdf(number_f, number_s, probability_s) : jStat.negbin.pdf(number_f, number_s, probability_s);
        },
        "NORM.DIST": (x, mean, standard_dev, cumulative) => {
          x = H.accept(x, Types.NUMBER);
          mean = H.accept(mean, Types.NUMBER);
          standard_dev = H.accept(standard_dev, Types.NUMBER);
          cumulative = H.accept(cumulative, Types.BOOLEAN);
          if (standard_dev <= 0) {
            throw FormulaError2.NUM;
          }
          return cumulative ? jStat.normal.cdf(x, mean, standard_dev) : jStat.normal.pdf(x, mean, standard_dev);
        },
        "NORM.INV": (probability, mean, standard_dev) => {
          probability = H.accept(probability, Types.NUMBER);
          mean = H.accept(mean, Types.NUMBER);
          standard_dev = H.accept(standard_dev, Types.NUMBER);
          if (probability <= 0 || probability >= 1) {
            throw FormulaError2.NUM;
          }
          if (standard_dev <= 0) {
            throw FormulaError2.NUM;
          }
          return jStat.normal.inv(probability, mean, standard_dev);
        },
        "NORM.S.DIST": (z, cumulative) => {
          z = H.accept(z, Types.NUMBER);
          cumulative = H.accept(cumulative, Types.BOOLEAN);
          return cumulative ? jStat.normal.cdf(z, 0, 1) : jStat.normal.pdf(z, 0, 1);
        },
        "NORM.S.INV": (probability) => {
          probability = H.accept(probability, Types.NUMBER);
          if (probability <= 0 || probability >= 1) {
            throw FormulaError2.NUM;
          }
          return jStat.normal.inv(probability, 0, 1);
        },
        PEARSON: () => {
        },
        "PERCENTILE.EXC": () => {
        },
        "PERCENTILE.INC": () => {
        },
        "PERCENTRANK.EXC": () => {
        },
        "PERCENTRANK.INC": () => {
        },
        PERMUTATIONA: () => {
        },
        PHI: (x) => {
          x = H.accept(x, Types.NUMBER);
          return Math.exp(-0.5 * x * x) / SQRT2PI;
        },
        "POISSON.DIST": (x, mean, cumulative) => {
          x = H.accept(x, Types.NUMBER);
          mean = H.accept(mean, Types.NUMBER);
          cumulative = H.accept(cumulative, Types.BOOLEAN);
          if (x < 0 || mean < 0) {
            throw FormulaError2.NUM;
          }
          x = Math.trunc(x);
          return cumulative ? jStat.poisson.cdf(x, mean) : jStat.poisson.pdf(x, mean);
        },
        "PROB": () => {
        },
        "QUARTILE.EXC": () => {
        },
        "QUARTILE.INC": () => {
        },
        "RANK.AVG": () => {
        },
        "RANK.EQ": () => {
        },
        RSQ: () => {
        },
        SKEW: () => {
        },
        "SKEW.P": () => {
        },
        SLOPE: () => {
        },
        STANDARDIZE: (x, mean, standard_dev) => {
          x = H.accept(x, Types.NUMBER);
          mean = H.accept(mean, Types.NUMBER);
          standard_dev = H.accept(standard_dev, Types.NUMBER);
          if (standard_dev <= 0) {
            throw FormulaError2.NUM;
          }
          return (x - mean) / standard_dev;
        },
        "STDEV.P": () => {
        },
        "STDEV.S": () => {
        },
        STDEVA: () => {
        },
        STDEVPA: () => {
        },
        STEYX: () => {
        },
        "T.DIST": (x, deg_freedom, cumulative) => {
          x = H.accept(x, Types.NUMBER);
          deg_freedom = H.accept(deg_freedom, Types.NUMBER);
          cumulative = H.accept(cumulative, Types.BOOLEAN);
          if (deg_freedom < 1) {
            throw FormulaError2.NUM;
          }
          return cumulative ? jStat.studentt.cdf(x, deg_freedom) : jStat.studentt.pdf(x, deg_freedom);
        },
        "T.DIST.2T": (x, deg_freedom) => {
          x = H.accept(x, Types.NUMBER);
          deg_freedom = H.accept(deg_freedom, Types.NUMBER);
          if (deg_freedom < 1 || x < 0) {
            throw FormulaError2.NUM;
          }
          return (1 - jStat.studentt.cdf(x, deg_freedom)) * 2;
        },
        "T.DIST.RT": (x, deg_freedom) => {
          x = H.accept(x, Types.NUMBER);
          deg_freedom = H.accept(deg_freedom, Types.NUMBER);
          if (deg_freedom < 1) {
            throw FormulaError2.NUM;
          }
          return 1 - jStat.studentt.cdf(x, deg_freedom);
        },
        "T.INV": (probability, deg_freedom) => {
          probability = H.accept(probability, Types.NUMBER);
          deg_freedom = H.accept(deg_freedom, Types.NUMBER);
          if (probability <= 0 || probability > 1 || deg_freedom < 1) {
            throw FormulaError2.NUM;
          }
          deg_freedom = deg_freedom % 1 === 0 ? deg_freedom : Math.trunc(deg_freedom);
          return jStat.studentt.inv(probability, deg_freedom);
        },
        "T.INV.2T": (probability, deg_freedom) => {
          probability = H.accept(probability, Types.NUMBER);
          deg_freedom = H.accept(deg_freedom, Types.NUMBER);
          if (probability <= 0 || probability > 1 || deg_freedom < 1) {
            throw FormulaError2.NUM;
          }
          deg_freedom = deg_freedom % 1 === 0 ? deg_freedom : Math.trunc(deg_freedom);
          return Math.abs(jStat.studentt.inv(probability / 2, deg_freedom));
        },
        "T.TEST": () => {
        },
        TREND: () => {
        },
        TRIMMEAN: () => {
        },
        "VAR.P": () => {
        },
        "VAR.S": () => {
        },
        "VARA": () => {
        },
        "VARPA": () => {
        },
        "WEIBULL.DIST": (x, alpha, beta, cumulative) => {
          x = H.accept(x, Types.NUMBER);
          alpha = H.accept(alpha, Types.NUMBER);
          beta = H.accept(beta, Types.NUMBER);
          cumulative = H.accept(cumulative, Types.BOOLEAN);
          if (x < 0 || alpha <= 0 || beta <= 0) {
            throw FormulaError2.NUM;
          }
          return cumulative ? 1 - Math.exp(-Math.pow(x / beta, alpha)) : Math.pow(x, alpha - 1) * Math.exp(-Math.pow(x / beta, alpha)) * alpha / Math.pow(beta, alpha);
        },
        "Z.TEST": () => {
        }
      };
      module2.exports = {
        DistributionFunctions
      };
    }
  });

  // node_modules/fast-formula-parser/formulas/functions/statistical.js
  var require_statistical = __commonJS({
    "node_modules/fast-formula-parser/formulas/functions/statistical.js"(exports2, module2) {
      var FormulaError2 = require_error();
      var { FormulaHelpers, Types, Criteria, Address } = require_helpers();
      var { Infix } = require_operators();
      var H = FormulaHelpers;
      var { DistributionFunctions } = require_distribution();
      var StatisticalFunctions = {
        AVEDEV: (...numbers) => {
          let sum = 0;
          const arr = [];
          H.flattenParams(numbers, Types.NUMBER, true, (item, info) => {
            if (typeof item === "number") {
              sum += item;
              arr.push(item);
            }
          });
          const avg = sum / arr.length;
          sum = 0;
          for (let i = 0; i < arr.length; i++) {
            sum += Math.abs(arr[i] - avg);
          }
          return sum / arr.length;
        },
        AVERAGE: (...numbers) => {
          let sum = 0, cnt = 0;
          H.flattenParams(numbers, Types.NUMBER, true, (item, info) => {
            if (typeof item === "number") {
              sum += item;
              cnt++;
            }
          });
          return sum / cnt;
        },
        AVERAGEA: (...numbers) => {
          let sum = 0, cnt = 0;
          H.flattenParams(numbers, Types.NUMBER, true, (item, info) => {
            const type = typeof item;
            if (type === "number") {
              sum += item;
              cnt++;
            } else if (type === "string") {
              cnt++;
            }
          });
          return sum / cnt;
        },
        // special
        AVERAGEIF: (context2, range2, criteria, averageRange) => {
          const ranges = H.retrieveRanges(context2, range2, averageRange);
          range2 = ranges[0];
          averageRange = ranges[1];
          criteria = H.retrieveArg(context2, criteria);
          const isCriteriaArray = criteria.isArray;
          criteria = Criteria.parse(H.accept(criteria));
          let sum = 0, cnt = 0;
          range2.forEach((row, rowNum) => {
            row.forEach((value, colNum) => {
              const valueToAdd = averageRange[rowNum][colNum];
              if (typeof valueToAdd !== "number")
                return;
              if (criteria.op === "wc") {
                if (criteria.match === criteria.value.test(value)) {
                  sum += valueToAdd;
                  cnt++;
                }
              } else if (Infix.compareOp(value, criteria.op, criteria.value, Array.isArray(value), isCriteriaArray)) {
                sum += valueToAdd;
                cnt++;
              }
            });
          });
          if (cnt === 0) throw FormulaError2.DIV0;
          return sum / cnt;
        },
        AVERAGEIFS: () => {
        },
        COUNT: (...ranges) => {
          let cnt = 0;
          H.flattenParams(
            ranges,
            null,
            true,
            (item, info) => {
              if (info.isLiteral && !isNaN(item)) {
                cnt++;
              } else {
                if (typeof item === "number")
                  cnt++;
              }
            }
          );
          return cnt;
        },
        COUNTIF: (range2, criteria) => {
          range2 = H.accept(range2, Types.ARRAY, void 0, false, true);
          const isCriteriaArray = criteria.isArray;
          criteria = H.accept(criteria);
          let cnt = 0;
          criteria = Criteria.parse(criteria);
          range2.forEach((row) => {
            row.forEach((value) => {
              if (criteria.op === "wc") {
                if (criteria.match === criteria.value.test(value))
                  cnt++;
              } else if (Infix.compareOp(value, criteria.op, criteria.value, Array.isArray(value), isCriteriaArray)) {
                cnt++;
              }
            });
          });
          return cnt;
        },
        LARGE: () => {
        },
        MAX: () => {
        },
        MAXA: () => {
        },
        MAXIFS: () => {
        },
        MEDIAN: () => {
        },
        MIN: () => {
        },
        MINA: () => {
        },
        MINIFS: () => {
        },
        PERMUT: () => {
        },
        PERMUTATIONA: () => {
        },
        SMALL: () => {
        }
      };
      module2.exports = Object.assign(StatisticalFunctions, DistributionFunctions);
    }
  });

  // node_modules/fast-formula-parser/formulas/functions/date.js
  var require_date = __commonJS({
    "node_modules/fast-formula-parser/formulas/functions/date.js"(exports2, module2) {
      var FormulaError2 = require_error();
      var { FormulaHelpers, Types } = require_helpers();
      var H = FormulaHelpers;
      var MS_PER_DAY = 1e3 * 60 * 60 * 24;
      var d1900 = new Date(Date.UTC(1900, 0, 1));
      var WEEK_STARTS = [
        void 0,
        0,
        1,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        1,
        2,
        3,
        4,
        5,
        6,
        0
      ];
      var WEEK_TYPES = [
        void 0,
        [1, 2, 3, 4, 5, 6, 7],
        [7, 1, 2, 3, 4, 5, 6],
        [6, 0, 1, 2, 3, 4, 5],
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        [7, 1, 2, 3, 4, 5, 6],
        [6, 7, 1, 2, 3, 4, 5],
        [5, 6, 7, 1, 2, 3, 4],
        [4, 5, 6, 7, 1, 2, 3],
        [3, 4, 5, 6, 7, 1, 2],
        [2, 3, 4, 5, 6, 7, 1],
        [1, 2, 3, 4, 5, 6, 7]
      ];
      var WEEKEND_TYPES = [
        void 0,
        [6, 0],
        [0, 1],
        [1, 2],
        [2, 3],
        [3, 4],
        [4, 5],
        [5, 6],
        void 0,
        void 0,
        void 0,
        [0],
        [1],
        [2],
        [3],
        [4],
        [5],
        [6]
      ];
      var timeRegex = /^\s*(\d\d?)\s*(:\s*\d\d?)?\s*(:\s*\d\d?)?\s*(pm|am)?\s*$/i;
      var dateRegex1 = /^\s*((\d\d?)\s*([-\/])\s*(\d\d?))([\d:.apm\s]*)$/i;
      var dateRegex2 = /^\s*((\d\d?)\s*([-/])\s*(jan\w*|feb\w*|mar\w*|apr\w*|may\w*|jun\w*|jul\w*|aug\w*|sep\w*|oct\w*|nov\w*|dec\w*))([\d:.apm\s]*)$/i;
      var dateRegex3 = /^\s*((jan\w*|feb\w*|mar\w*|apr\w*|may\w*|jun\w*|jul\w*|aug\w*|sep\w*|oct\w*|nov\w*|dec\w*)\s*([-/])\s*(\d\d?))([\d:.apm\s]*)$/i;
      function parseSimplifiedDate(text) {
        const fmt1 = text.match(dateRegex1);
        const fmt2 = text.match(dateRegex2);
        const fmt3 = text.match(dateRegex3);
        if (fmt1) {
          text = fmt1[1] + fmt1[3] + (/* @__PURE__ */ new Date()).getFullYear() + fmt1[5];
        } else if (fmt2) {
          text = fmt2[1] + fmt2[3] + (/* @__PURE__ */ new Date()).getFullYear() + fmt2[5];
        } else if (fmt3) {
          text = fmt3[1] + fmt3[3] + (/* @__PURE__ */ new Date()).getFullYear() + fmt3[5];
        }
        return new Date(Date.parse(`${text} UTC`));
      }
      function parseTime(text) {
        const res = text.match(timeRegex);
        if (!res) return;
        const minutes = res[2] ? res[2] : ":00";
        const seconds = res[3] ? res[3] : ":00";
        const ampm = res[4] ? " " + res[4] : "";
        const date = new Date(Date.parse(`1/1/1900 ${res[1] + minutes + seconds + ampm} UTC`));
        let now = /* @__PURE__ */ new Date();
        now = new Date(Date.UTC(
          now.getFullYear(),
          now.getMonth(),
          now.getDate(),
          now.getHours(),
          now.getMinutes(),
          now.getSeconds(),
          now.getMilliseconds()
        ));
        return new Date(Date.UTC(
          now.getUTCFullYear(),
          now.getUTCMonth(),
          now.getUTCDate(),
          date.getUTCHours(),
          date.getUTCMinutes(),
          date.getUTCSeconds(),
          date.getUTCMilliseconds()
        ));
      }
      function toSerial(date) {
        const addOn = date > -22038912e5 ? 2 : 1;
        return Math.floor((date - d1900) / 864e5) + addOn;
      }
      function toDate(serial) {
        if (serial < 0) {
          throw FormulaError2.VALUE;
        }
        if (serial <= 60) {
          return new Date(d1900.getTime() + (serial - 1) * 864e5);
        }
        return new Date(d1900.getTime() + (serial - 2) * 864e5);
      }
      function parseDateWithExtra(serialOrString) {
        if (serialOrString instanceof Date) return { date: serialOrString };
        serialOrString = H.accept(serialOrString);
        let isDateGiven = true, date;
        if (!isNaN(serialOrString)) {
          serialOrString = Number(serialOrString);
          date = toDate(serialOrString);
        } else {
          date = parseTime(serialOrString);
          if (!date) {
            date = parseSimplifiedDate(serialOrString);
          } else {
            isDateGiven = false;
          }
        }
        return { date, isDateGiven };
      }
      function parseDate(serialOrString) {
        return parseDateWithExtra(serialOrString).date;
      }
      function compareDateIgnoreTime(date1, date2) {
        return date1.getUTCFullYear() === date2.getUTCFullYear() && date1.getUTCMonth() === date2.getUTCMonth() && date1.getUTCDate() === date2.getUTCDate();
      }
      function isLeapYear(year) {
        if (year === 1900) {
          return true;
        }
        return new Date(year, 1, 29).getMonth() === 1;
      }
      var DateFunctions = {
        DATE: (year, month, day) => {
          year = H.accept(year, Types.NUMBER);
          month = H.accept(month, Types.NUMBER);
          day = H.accept(day, Types.NUMBER);
          if (year < 0 || year >= 1e4)
            throw FormulaError2.NUM;
          if (year < 1900) {
            year += 1900;
          }
          return toSerial(Date.UTC(year, month - 1, day));
        },
        DATEDIF: (startDate, endDate, unit) => {
          startDate = parseDate(startDate);
          endDate = parseDate(endDate);
          unit = H.accept(unit, Types.STRING).toLowerCase();
          if (startDate > endDate)
            throw FormulaError2.NUM;
          const yearDiff = endDate.getUTCFullYear() - startDate.getUTCFullYear();
          const monthDiff = endDate.getUTCMonth() - startDate.getUTCMonth();
          const dayDiff = endDate.getUTCDate() - startDate.getUTCDate();
          let offset;
          switch (unit) {
            case "y":
              offset = monthDiff < 0 || monthDiff === 0 && dayDiff < 0 ? -1 : 0;
              return offset + yearDiff;
            case "m":
              offset = dayDiff < 0 ? -1 : 0;
              return yearDiff * 12 + monthDiff + offset;
            case "d":
              return Math.floor(endDate - startDate) / MS_PER_DAY;
            case "md":
              startDate.setUTCFullYear(endDate.getUTCFullYear());
              if (dayDiff < 0) {
                startDate.setUTCMonth(endDate.getUTCMonth() - 1);
              } else {
                startDate.setUTCMonth(endDate.getUTCMonth());
              }
              return Math.floor(endDate - startDate) / MS_PER_DAY;
            case "ym":
              offset = dayDiff < 0 ? -1 : 0;
              return (offset + yearDiff * 12 + monthDiff) % 12;
            case "yd":
              if (monthDiff < 0 || monthDiff === 0 && dayDiff < 0) {
                startDate.setUTCFullYear(endDate.getUTCFullYear() - 1);
              } else {
                startDate.setUTCFullYear(endDate.getUTCFullYear());
              }
              return Math.floor(endDate - startDate) / MS_PER_DAY;
          }
        },
        /**
         * Limitation: Year must be four digit, only support ISO 8016 date format.
         * Does not support date without year, i.e. "5-JUL".
         * @param {string} dateText
         */
        DATEVALUE: (dateText) => {
          dateText = H.accept(dateText, Types.STRING);
          const { date, isDateGiven } = parseDateWithExtra(dateText);
          if (!isDateGiven) return 0;
          const serial = toSerial(date);
          if (serial < 0 || serial > 2958465)
            throw FormulaError2.VALUE;
          return serial;
        },
        DAY: (serialOrString) => {
          const date = parseDate(serialOrString);
          return date.getUTCDate();
        },
        DAYS: (endDate, startDate) => {
          endDate = parseDate(endDate);
          startDate = parseDate(startDate);
          let offset = 0;
          if (startDate < -22038912e5 && -22038912e5 < endDate) {
            offset = 1;
          }
          return Math.floor(endDate - startDate) / MS_PER_DAY + offset;
        },
        DAYS360: (startDate, endDate, method) => {
          startDate = parseDate(startDate);
          endDate = parseDate(endDate);
          method = H.accept(method, Types.BOOLEAN, false);
          if (startDate.getUTCDate() === 31) {
            startDate.setUTCDate(30);
          }
          if (!method && startDate.getUTCDate() < 30 && endDate.getUTCDate() > 30) {
            endDate.setUTCMonth(endDate.getUTCMonth() + 1, 1);
          } else {
            if (endDate.getUTCDate() === 31) {
              endDate.setUTCDate(30);
            }
          }
          const yearDiff = endDate.getUTCFullYear() - startDate.getUTCFullYear();
          const monthDiff = endDate.getUTCMonth() - startDate.getUTCMonth();
          const dayDiff = endDate.getUTCDate() - startDate.getUTCDate();
          return monthDiff * 30 + dayDiff + yearDiff * 12 * 30;
        },
        EDATE: (startDate, months) => {
          startDate = parseDate(startDate);
          months = H.accept(months, Types.NUMBER);
          startDate.setUTCMonth(startDate.getUTCMonth() + months);
          return toSerial(startDate);
        },
        EOMONTH: (startDate, months) => {
          startDate = parseDate(startDate);
          months = H.accept(months, Types.NUMBER);
          startDate.setUTCMonth(startDate.getUTCMonth() + months + 1, 0);
          return toSerial(startDate);
        },
        HOUR: (serialOrString) => {
          const date = parseDate(serialOrString);
          return date.getUTCHours();
        },
        ISOWEEKNUM: (serialOrString) => {
          const date = parseDate(serialOrString);
          const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
          const dayNum = d.getUTCDay();
          d.setUTCDate(d.getUTCDate() + 4 - dayNum);
          const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
          return Math.ceil(((d - yearStart) / 864e5 + 1) / 7);
        },
        MINUTE: (serialOrString) => {
          const date = parseDate(serialOrString);
          return date.getUTCMinutes();
        },
        MONTH: (serialOrString) => {
          const date = parseDate(serialOrString);
          return date.getUTCMonth() + 1;
        },
        NETWORKDAYS: (startDate, endDate, holidays) => {
          startDate = parseDate(startDate);
          endDate = parseDate(endDate);
          let sign = 1;
          if (startDate > endDate) {
            sign = -1;
            const temp = startDate;
            startDate = endDate;
            endDate = temp;
          }
          const holidaysArr = [];
          if (holidays != null) {
            H.flattenParams([holidays], Types.NUMBER, false, (item) => {
              holidaysArr.push(parseDate(item));
            });
          }
          let numWorkDays = 0;
          while (startDate <= endDate) {
            if (startDate.getUTCDay() !== 0 && startDate.getUTCDay() !== 6) {
              let found = false;
              for (let i = 0; i < holidaysArr.length; i++) {
                if (compareDateIgnoreTime(startDate, holidaysArr[i])) {
                  found = true;
                  break;
                }
              }
              if (!found) numWorkDays++;
            }
            startDate.setUTCDate(startDate.getUTCDate() + 1);
          }
          return sign * numWorkDays;
        },
        "NETWORKDAYS.INTL": (startDate, endDate, weekend, holidays) => {
          startDate = parseDate(startDate);
          endDate = parseDate(endDate);
          let sign = 1;
          if (startDate > endDate) {
            sign = -1;
            const temp = startDate;
            startDate = endDate;
            endDate = temp;
          }
          weekend = H.accept(weekend, null, 1);
          if (weekend === "1111111")
            return 0;
          if (typeof weekend === "string" && Number(weekend).toString() !== weekend) {
            if (weekend.length !== 7) throw FormulaError2.VALUE;
            weekend = weekend.charAt(6) + weekend.slice(0, 6);
            const weekendArr = [];
            for (let i = 0; i < weekend.length; i++) {
              if (weekend.charAt(i) === "1")
                weekendArr.push(i);
            }
            weekend = weekendArr;
          } else {
            if (typeof weekend !== "number")
              throw FormulaError2.VALUE;
            weekend = WEEKEND_TYPES[weekend];
          }
          const holidaysArr = [];
          if (holidays != null) {
            H.flattenParams([holidays], Types.NUMBER, false, (item) => {
              holidaysArr.push(parseDate(item));
            });
          }
          let numWorkDays = 0;
          while (startDate <= endDate) {
            let skip = false;
            for (let i = 0; i < weekend.length; i++) {
              if (weekend[i] === startDate.getUTCDay()) {
                skip = true;
                break;
              }
            }
            if (!skip) {
              let found = false;
              for (let i = 0; i < holidaysArr.length; i++) {
                if (compareDateIgnoreTime(startDate, holidaysArr[i])) {
                  found = true;
                  break;
                }
              }
              if (!found) numWorkDays++;
            }
            startDate.setUTCDate(startDate.getUTCDate() + 1);
          }
          return sign * numWorkDays;
        },
        NOW: () => {
          const now = /* @__PURE__ */ new Date();
          return toSerial(Date.UTC(
            now.getFullYear(),
            now.getMonth(),
            now.getDate(),
            now.getHours(),
            now.getMinutes(),
            now.getSeconds(),
            now.getMilliseconds()
          )) + (3600 * now.getHours() + 60 * now.getMinutes() + now.getSeconds()) / 86400;
        },
        SECOND: (serialOrString) => {
          const date = parseDate(serialOrString);
          return date.getUTCSeconds();
        },
        TIME: (hour, minute, second) => {
          hour = H.accept(hour, Types.NUMBER);
          minute = H.accept(minute, Types.NUMBER);
          second = H.accept(second, Types.NUMBER);
          if (hour < 0 || hour > 32767 || minute < 0 || minute > 32767 || second < 0 || second > 32767)
            throw FormulaError2.NUM;
          return (3600 * hour + 60 * minute + second) / 86400;
        },
        TIMEVALUE: (timeText) => {
          timeText = parseDate(timeText);
          return (3600 * timeText.getUTCHours() + 60 * timeText.getUTCMinutes() + timeText.getUTCSeconds()) / 86400;
        },
        TODAY: () => {
          const now = /* @__PURE__ */ new Date();
          return toSerial(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));
        },
        WEEKDAY: (serialOrString, returnType) => {
          const date = parseDate(serialOrString);
          returnType = H.accept(returnType, Types.NUMBER, 1);
          const day = date.getUTCDay();
          const weekTypes = WEEK_TYPES[returnType];
          if (!weekTypes)
            throw FormulaError2.NUM;
          return weekTypes[day];
        },
        WEEKNUM: (serialOrString, returnType) => {
          const date = parseDate(serialOrString);
          returnType = H.accept(returnType, Types.NUMBER, 1);
          if (returnType === 21) {
            return DateFunctions.ISOWEEKNUM(serialOrString);
          }
          const weekStart = WEEK_STARTS[returnType];
          const yearStart = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));
          const offset = yearStart.getUTCDay() < weekStart ? 1 : 0;
          return Math.ceil(((date - yearStart) / 864e5 + 1) / 7) + offset;
        },
        WORKDAY: (startDate, days, holidays) => {
          return DateFunctions["WORKDAY.INTL"](startDate, days, 1, holidays);
        },
        "WORKDAY.INTL": (startDate, days, weekend, holidays) => {
          startDate = parseDate(startDate);
          days = H.accept(days, Types.NUMBER);
          weekend = H.accept(weekend, null, 1);
          if (weekend === "1111111")
            throw FormulaError2.VALUE;
          if (typeof weekend === "string" && Number(weekend).toString() !== weekend) {
            if (weekend.length !== 7)
              throw FormulaError2.VALUE;
            weekend = weekend.charAt(6) + weekend.slice(0, 6);
            const weekendArr = [];
            for (let i = 0; i < weekend.length; i++) {
              if (weekend.charAt(i) === "1")
                weekendArr.push(i);
            }
            weekend = weekendArr;
          } else {
            if (typeof weekend !== "number")
              throw FormulaError2.VALUE;
            weekend = WEEKEND_TYPES[weekend];
            if (weekend == null)
              throw FormulaError2.NUM;
          }
          const holidaysArr = [];
          if (holidays != null) {
            H.flattenParams([holidays], Types.NUMBER, false, (item) => {
              holidaysArr.push(parseDate(item));
            });
          }
          startDate.setUTCDate(startDate.getUTCDate() + 1);
          let cnt = 0;
          while (cnt < days) {
            let skip = false;
            for (let i = 0; i < weekend.length; i++) {
              if (weekend[i] === startDate.getUTCDay()) {
                skip = true;
                break;
              }
            }
            if (!skip) {
              let found = false;
              for (let i = 0; i < holidaysArr.length; i++) {
                if (compareDateIgnoreTime(startDate, holidaysArr[i])) {
                  found = true;
                  break;
                }
              }
              if (!found) cnt++;
            }
            startDate.setUTCDate(startDate.getUTCDate() + 1);
          }
          return toSerial(startDate) - 1;
        },
        YEAR: (serialOrString) => {
          const date = parseDate(serialOrString);
          return date.getUTCFullYear();
        },
        // Warning: may have bugs
        YEARFRAC: (startDate, endDate, basis) => {
          startDate = parseDate(startDate);
          endDate = parseDate(endDate);
          if (startDate > endDate) {
            const temp = startDate;
            startDate = endDate;
            endDate = temp;
          }
          basis = H.accept(basis, Types.NUMBER, 0);
          basis = Math.trunc(basis);
          if (basis < 0 || basis > 4)
            throw FormulaError2.VALUE;
          let sd = startDate.getUTCDate();
          const sm = startDate.getUTCMonth() + 1;
          const sy = startDate.getUTCFullYear();
          let ed = endDate.getUTCDate();
          const em = endDate.getUTCMonth() + 1;
          const ey = endDate.getUTCFullYear();
          switch (basis) {
            case 0:
              if (sd === 31 && ed === 31) {
                sd = 30;
                ed = 30;
              } else if (sd === 31) {
                sd = 30;
              } else if (sd === 30 && ed === 31) {
                ed = 30;
              }
              return Math.abs(ed + em * 30 + ey * 360 - (sd + sm * 30 + sy * 360)) / 360;
            case 1:
              if (ey - sy < 2) {
                const yLength = isLeapYear(sy) && sy !== 1900 ? 366 : 365;
                const days = DateFunctions.DAYS(endDate, startDate);
                return days / yLength;
              } else {
                const years = ey - sy + 1;
                const days = (new Date(ey + 1, 0, 1) - new Date(sy, 0, 1)) / 1e3 / 60 / 60 / 24;
                const average = days / years;
                return DateFunctions.DAYS(endDate, startDate) / average;
              }
            case 2:
              return Math.abs(DateFunctions.DAYS(endDate, startDate) / 360);
            case 3:
              return Math.abs(DateFunctions.DAYS(endDate, startDate) / 365);
            case 4:
              return Math.abs(ed + em * 30 + ey * 360 - (sd + sm * 30 + sy * 360)) / 360;
          }
        }
      };
      module2.exports = DateFunctions;
    }
  });

  // node_modules/fast-formula-parser/formulas/functions/web.js
  var require_web = __commonJS({
    "node_modules/fast-formula-parser/formulas/functions/web.js"(exports2, module2) {
      var FormulaError2 = require_error();
      var { FormulaHelpers, Types } = require_helpers();
      var H = FormulaHelpers;
      var WebFunctions = {
        ENCODEURL: (text) => {
          return encodeURIComponent(H.accept(text, Types.STRING));
        },
        FILTERXML: () => {
        },
        WEBSERVICE: (context2, url) => {
          throw FormulaError2.ERROR("WEBSERVICE is not supported in sync mode.");
          if (typeof fetch === "function") {
            url = H.accept(url, Types.STRING);
            return fetch(url).then((res) => res.text());
          } else {
            throw FormulaError2.ERROR("WEBSERVICE only available to browser with fetch.If you want to use WEBSERVICE in Node.js, please override this function: \nnew FormulaParser({\n    functionsNeedContext: {\n        WEBSERVICE: (context, url) => {...}}\n})");
          }
        }
      };
      module2.exports = WebFunctions;
    }
  });

  // node_modules/chevrotain/lib/src/version.js
  var require_version = __commonJS({
    "node_modules/chevrotain/lib/src/version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.VERSION = void 0;
      exports2.VERSION = "7.1.2";
    }
  });

  // node_modules/chevrotain/lib/src/utils/utils.js
  var require_utils = __commonJS({
    "node_modules/chevrotain/lib/src/utils/utils.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.peek = exports.toFastProperties = exports.applyMixins = exports.isES2015MapSupported = exports.PRINT_WARNING = exports.PRINT_ERROR = exports.packArray = exports.IDENTITY = exports.NOOP = exports.merge = exports.groupBy = exports.defaults = exports.assignNoOverwrite = exports.assign = exports.zipObject = exports.sortBy = exports.indexOf = exports.some = exports.difference = exports.every = exports.isObject = exports.isRegExp = exports.isArray = exports.partial = exports.uniq = exports.compact = exports.reduce = exports.findAll = exports.find = exports.cloneObj = exports.cloneArr = exports.contains = exports.has = exports.pick = exports.reject = exports.filter = exports.dropRight = exports.drop = exports.isFunction = exports.isUndefined = exports.isString = exports.forEach = exports.last = exports.first = exports.flatten = exports.map = exports.mapValues = exports.values = exports.keys = exports.isEmpty = void 0;
      exports.timer = void 0;
      function isEmpty(arr) {
        return arr && arr.length === 0;
      }
      exports.isEmpty = isEmpty;
      function keys(obj) {
        if (obj === void 0 || obj === null) {
          return [];
        }
        return Object.keys(obj);
      }
      exports.keys = keys;
      function values(obj) {
        var vals = [];
        var keys3 = Object.keys(obj);
        for (var i = 0; i < keys3.length; i++) {
          vals.push(obj[keys3[i]]);
        }
        return vals;
      }
      exports.values = values;
      function mapValues(obj, callback) {
        var result = [];
        var objKeys = keys(obj);
        for (var idx = 0; idx < objKeys.length; idx++) {
          var currKey = objKeys[idx];
          result.push(callback.call(null, obj[currKey], currKey));
        }
        return result;
      }
      exports.mapValues = mapValues;
      function map(arr, callback) {
        var result = [];
        for (var idx = 0; idx < arr.length; idx++) {
          result.push(callback.call(null, arr[idx], idx));
        }
        return result;
      }
      exports.map = map;
      function flatten(arr) {
        var result = [];
        for (var idx = 0; idx < arr.length; idx++) {
          var currItem = arr[idx];
          if (Array.isArray(currItem)) {
            result = result.concat(flatten(currItem));
          } else {
            result.push(currItem);
          }
        }
        return result;
      }
      exports.flatten = flatten;
      function first(arr) {
        return isEmpty(arr) ? void 0 : arr[0];
      }
      exports.first = first;
      function last(arr) {
        var len = arr && arr.length;
        return len ? arr[len - 1] : void 0;
      }
      exports.last = last;
      function forEach(collection, iteratorCallback) {
        if (Array.isArray(collection)) {
          for (var i = 0; i < collection.length; i++) {
            iteratorCallback.call(null, collection[i], i);
          }
        } else if (isObject(collection)) {
          var colKeys = keys(collection);
          for (var i = 0; i < colKeys.length; i++) {
            var key = colKeys[i];
            var value = collection[key];
            iteratorCallback.call(null, value, key);
          }
        } else {
          throw Error("non exhaustive match");
        }
      }
      exports.forEach = forEach;
      function isString(item) {
        return typeof item === "string";
      }
      exports.isString = isString;
      function isUndefined(item) {
        return item === void 0;
      }
      exports.isUndefined = isUndefined;
      function isFunction(item) {
        return item instanceof Function;
      }
      exports.isFunction = isFunction;
      function drop(arr, howMuch) {
        if (howMuch === void 0) {
          howMuch = 1;
        }
        return arr.slice(howMuch, arr.length);
      }
      exports.drop = drop;
      function dropRight(arr, howMuch) {
        if (howMuch === void 0) {
          howMuch = 1;
        }
        return arr.slice(0, arr.length - howMuch);
      }
      exports.dropRight = dropRight;
      function filter(arr, predicate) {
        var result = [];
        if (Array.isArray(arr)) {
          for (var i = 0; i < arr.length; i++) {
            var item = arr[i];
            if (predicate.call(null, item)) {
              result.push(item);
            }
          }
        }
        return result;
      }
      exports.filter = filter;
      function reject(arr, predicate) {
        return filter(arr, function(item) {
          return !predicate(item);
        });
      }
      exports.reject = reject;
      function pick(obj, predicate) {
        var keys3 = Object.keys(obj);
        var result = {};
        for (var i = 0; i < keys3.length; i++) {
          var currKey = keys3[i];
          var currItem = obj[currKey];
          if (predicate(currItem)) {
            result[currKey] = currItem;
          }
        }
        return result;
      }
      exports.pick = pick;
      function has(obj, prop) {
        if (isObject(obj)) {
          return obj.hasOwnProperty(prop);
        }
        return false;
      }
      exports.has = has;
      function contains(arr, item) {
        return find(arr, function(currItem) {
          return currItem === item;
        }) !== void 0 ? true : false;
      }
      exports.contains = contains;
      function cloneArr(arr) {
        var newArr = [];
        for (var i = 0; i < arr.length; i++) {
          newArr.push(arr[i]);
        }
        return newArr;
      }
      exports.cloneArr = cloneArr;
      function cloneObj(obj) {
        var clonedObj = {};
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            clonedObj[key] = obj[key];
          }
        }
        return clonedObj;
      }
      exports.cloneObj = cloneObj;
      function find(arr, predicate) {
        for (var i = 0; i < arr.length; i++) {
          var item = arr[i];
          if (predicate.call(null, item)) {
            return item;
          }
        }
        return void 0;
      }
      exports.find = find;
      function findAll(arr, predicate) {
        var found = [];
        for (var i = 0; i < arr.length; i++) {
          var item = arr[i];
          if (predicate.call(null, item)) {
            found.push(item);
          }
        }
        return found;
      }
      exports.findAll = findAll;
      function reduce(arrOrObj, iterator, initial) {
        var isArr = Array.isArray(arrOrObj);
        var vals = isArr ? arrOrObj : values(arrOrObj);
        var objKeys = isArr ? [] : keys(arrOrObj);
        var accumulator = initial;
        for (var i = 0; i < vals.length; i++) {
          accumulator = iterator.call(null, accumulator, vals[i], isArr ? i : objKeys[i]);
        }
        return accumulator;
      }
      exports.reduce = reduce;
      function compact(arr) {
        return reject(arr, function(item) {
          return item === null || item === void 0;
        });
      }
      exports.compact = compact;
      function uniq(arr, identity) {
        if (identity === void 0) {
          identity = function(item) {
            return item;
          };
        }
        var identities = [];
        return reduce(arr, function(result, currItem) {
          var currIdentity = identity(currItem);
          if (contains(identities, currIdentity)) {
            return result;
          } else {
            identities.push(currIdentity);
            return result.concat(currItem);
          }
        }, []);
      }
      exports.uniq = uniq;
      function partial(func) {
        var restArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          restArgs[_i - 1] = arguments[_i];
        }
        var firstArg = [null];
        var allArgs = firstArg.concat(restArgs);
        return Function.bind.apply(func, allArgs);
      }
      exports.partial = partial;
      function isArray(obj) {
        return Array.isArray(obj);
      }
      exports.isArray = isArray;
      function isRegExp(obj) {
        return obj instanceof RegExp;
      }
      exports.isRegExp = isRegExp;
      function isObject(obj) {
        return obj instanceof Object;
      }
      exports.isObject = isObject;
      function every(arr, predicate) {
        for (var i = 0; i < arr.length; i++) {
          if (!predicate(arr[i], i)) {
            return false;
          }
        }
        return true;
      }
      exports.every = every;
      function difference(arr, values2) {
        return reject(arr, function(item) {
          return contains(values2, item);
        });
      }
      exports.difference = difference;
      function some(arr, predicate) {
        for (var i = 0; i < arr.length; i++) {
          if (predicate(arr[i])) {
            return true;
          }
        }
        return false;
      }
      exports.some = some;
      function indexOf(arr, value) {
        for (var i = 0; i < arr.length; i++) {
          if (arr[i] === value) {
            return i;
          }
        }
        return -1;
      }
      exports.indexOf = indexOf;
      function sortBy(arr, orderFunc) {
        var result = cloneArr(arr);
        result.sort(function(a, b) {
          return orderFunc(a) - orderFunc(b);
        });
        return result;
      }
      exports.sortBy = sortBy;
      function zipObject(keys3, values2) {
        if (keys3.length !== values2.length) {
          throw Error("can't zipObject with different number of keys and values!");
        }
        var result = {};
        for (var i = 0; i < keys3.length; i++) {
          result[keys3[i]] = values2[i];
        }
        return result;
      }
      exports.zipObject = zipObject;
      function assign(target) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          sources[_i - 1] = arguments[_i];
        }
        for (var i = 0; i < sources.length; i++) {
          var curSource = sources[i];
          var currSourceKeys = keys(curSource);
          for (var j = 0; j < currSourceKeys.length; j++) {
            var currKey = currSourceKeys[j];
            target[currKey] = curSource[currKey];
          }
        }
        return target;
      }
      exports.assign = assign;
      function assignNoOverwrite(target) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          sources[_i - 1] = arguments[_i];
        }
        for (var i = 0; i < sources.length; i++) {
          var curSource = sources[i];
          var currSourceKeys = keys(curSource);
          for (var j = 0; j < currSourceKeys.length; j++) {
            var currKey = currSourceKeys[j];
            if (!has(target, currKey)) {
              target[currKey] = curSource[currKey];
            }
          }
        }
        return target;
      }
      exports.assignNoOverwrite = assignNoOverwrite;
      function defaults() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          sources[_i] = arguments[_i];
        }
        return assignNoOverwrite.apply(null, [{}].concat(sources));
      }
      exports.defaults = defaults;
      function groupBy(arr, groupKeyFunc) {
        var result = {};
        forEach(arr, function(item) {
          var currGroupKey = groupKeyFunc(item);
          var currGroupArr = result[currGroupKey];
          if (currGroupArr) {
            currGroupArr.push(item);
          } else {
            result[currGroupKey] = [item];
          }
        });
        return result;
      }
      exports.groupBy = groupBy;
      function merge(obj1, obj2) {
        var result = cloneObj(obj1);
        var keys22 = keys(obj2);
        for (var i = 0; i < keys22.length; i++) {
          var key = keys22[i];
          var value = obj2[key];
          result[key] = value;
        }
        return result;
      }
      exports.merge = merge;
      function NOOP() {
      }
      exports.NOOP = NOOP;
      function IDENTITY(item) {
        return item;
      }
      exports.IDENTITY = IDENTITY;
      function packArray(holeyArr) {
        var result = [];
        for (var i = 0; i < holeyArr.length; i++) {
          var orgValue = holeyArr[i];
          result.push(orgValue !== void 0 ? orgValue : void 0);
        }
        return result;
      }
      exports.packArray = packArray;
      function PRINT_ERROR(msg) {
        if (console && console.error) {
          console.error("Error: " + msg);
        }
      }
      exports.PRINT_ERROR = PRINT_ERROR;
      function PRINT_WARNING(msg) {
        if (console && console.warn) {
          console.warn("Warning: " + msg);
        }
      }
      exports.PRINT_WARNING = PRINT_WARNING;
      function isES2015MapSupported() {
        return typeof Map === "function";
      }
      exports.isES2015MapSupported = isES2015MapSupported;
      function applyMixins(derivedCtor, baseCtors) {
        baseCtors.forEach(function(baseCtor) {
          var baseProto = baseCtor.prototype;
          Object.getOwnPropertyNames(baseProto).forEach(function(propName) {
            if (propName === "constructor") {
              return;
            }
            var basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);
            if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) {
              Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);
            } else {
              derivedCtor.prototype[propName] = baseCtor.prototype[propName];
            }
          });
        });
      }
      exports.applyMixins = applyMixins;
      function toFastProperties(toBecomeFast) {
        function FakeConstructor() {
        }
        FakeConstructor.prototype = toBecomeFast;
        var fakeInstance = new FakeConstructor();
        function fakeAccess() {
          return typeof fakeInstance.bar;
        }
        fakeAccess();
        fakeAccess();
        return toBecomeFast;
        eval(toBecomeFast);
      }
      exports.toFastProperties = toFastProperties;
      function peek(arr) {
        return arr[arr.length - 1];
      }
      exports.peek = peek;
      function timer(func) {
        var start = (/* @__PURE__ */ new Date()).getTime();
        var val = func();
        var end = (/* @__PURE__ */ new Date()).getTime();
        var total = end - start;
        return { time: total, value: val };
      }
      exports.timer = timer;
    }
  });

  // node_modules/regexp-to-ast/lib/regexp-to-ast.js
  var require_regexp_to_ast = __commonJS({
    "node_modules/regexp-to-ast/lib/regexp-to-ast.js"(exports2, module2) {
      (function(root, factory) {
        if (typeof define === "function" && define.amd) {
          define([], factory);
        } else if (typeof module2 === "object" && module2.exports) {
          module2.exports = factory();
        } else {
          root.regexpToAst = factory();
        }
      })(
        typeof self !== "undefined" ? (
          // istanbul ignore next
          self
        ) : exports2,
        function() {
          function RegExpParser() {
          }
          RegExpParser.prototype.saveState = function() {
            return {
              idx: this.idx,
              input: this.input,
              groupIdx: this.groupIdx
            };
          };
          RegExpParser.prototype.restoreState = function(newState) {
            this.idx = newState.idx;
            this.input = newState.input;
            this.groupIdx = newState.groupIdx;
          };
          RegExpParser.prototype.pattern = function(input) {
            this.idx = 0;
            this.input = input;
            this.groupIdx = 0;
            this.consumeChar("/");
            var value = this.disjunction();
            this.consumeChar("/");
            var flags = {
              type: "Flags",
              loc: { begin: this.idx, end: input.length },
              global: false,
              ignoreCase: false,
              multiLine: false,
              unicode: false,
              sticky: false
            };
            while (this.isRegExpFlag()) {
              switch (this.popChar()) {
                case "g":
                  addFlag(flags, "global");
                  break;
                case "i":
                  addFlag(flags, "ignoreCase");
                  break;
                case "m":
                  addFlag(flags, "multiLine");
                  break;
                case "u":
                  addFlag(flags, "unicode");
                  break;
                case "y":
                  addFlag(flags, "sticky");
                  break;
              }
            }
            if (this.idx !== this.input.length) {
              throw Error(
                "Redundant input: " + this.input.substring(this.idx)
              );
            }
            return {
              type: "Pattern",
              flags,
              value,
              loc: this.loc(0)
            };
          };
          RegExpParser.prototype.disjunction = function() {
            var alts = [];
            var begin = this.idx;
            alts.push(this.alternative());
            while (this.peekChar() === "|") {
              this.consumeChar("|");
              alts.push(this.alternative());
            }
            return { type: "Disjunction", value: alts, loc: this.loc(begin) };
          };
          RegExpParser.prototype.alternative = function() {
            var terms = [];
            var begin = this.idx;
            while (this.isTerm()) {
              terms.push(this.term());
            }
            return { type: "Alternative", value: terms, loc: this.loc(begin) };
          };
          RegExpParser.prototype.term = function() {
            if (this.isAssertion()) {
              return this.assertion();
            } else {
              return this.atom();
            }
          };
          RegExpParser.prototype.assertion = function() {
            var begin = this.idx;
            switch (this.popChar()) {
              case "^":
                return {
                  type: "StartAnchor",
                  loc: this.loc(begin)
                };
              case "$":
                return { type: "EndAnchor", loc: this.loc(begin) };
              // '\b' or '\B'
              case "\\":
                switch (this.popChar()) {
                  case "b":
                    return {
                      type: "WordBoundary",
                      loc: this.loc(begin)
                    };
                  case "B":
                    return {
                      type: "NonWordBoundary",
                      loc: this.loc(begin)
                    };
                }
                throw Error("Invalid Assertion Escape");
              // '(?=' or '(?!'
              case "(":
                this.consumeChar("?");
                var type;
                switch (this.popChar()) {
                  case "=":
                    type = "Lookahead";
                    break;
                  case "!":
                    type = "NegativeLookahead";
                    break;
                }
                ASSERT_EXISTS(type);
                var disjunction = this.disjunction();
                this.consumeChar(")");
                return {
                  type,
                  value: disjunction,
                  loc: this.loc(begin)
                };
            }
            ASSERT_NEVER_REACH_HERE();
          };
          RegExpParser.prototype.quantifier = function(isBacktracking) {
            var range2;
            var begin = this.idx;
            switch (this.popChar()) {
              case "*":
                range2 = {
                  atLeast: 0,
                  atMost: Infinity
                };
                break;
              case "+":
                range2 = {
                  atLeast: 1,
                  atMost: Infinity
                };
                break;
              case "?":
                range2 = {
                  atLeast: 0,
                  atMost: 1
                };
                break;
              case "{":
                var atLeast = this.integerIncludingZero();
                switch (this.popChar()) {
                  case "}":
                    range2 = {
                      atLeast,
                      atMost: atLeast
                    };
                    break;
                  case ",":
                    var atMost;
                    if (this.isDigit()) {
                      atMost = this.integerIncludingZero();
                      range2 = {
                        atLeast,
                        atMost
                      };
                    } else {
                      range2 = {
                        atLeast,
                        atMost: Infinity
                      };
                    }
                    this.consumeChar("}");
                    break;
                }
                if (isBacktracking === true && range2 === void 0) {
                  return void 0;
                }
                ASSERT_EXISTS(range2);
                break;
            }
            if (isBacktracking === true && range2 === void 0) {
              return void 0;
            }
            ASSERT_EXISTS(range2);
            if (this.peekChar(0) === "?") {
              this.consumeChar("?");
              range2.greedy = false;
            } else {
              range2.greedy = true;
            }
            range2.type = "Quantifier";
            range2.loc = this.loc(begin);
            return range2;
          };
          RegExpParser.prototype.atom = function() {
            var atom;
            var begin = this.idx;
            switch (this.peekChar()) {
              case ".":
                atom = this.dotAll();
                break;
              case "\\":
                atom = this.atomEscape();
                break;
              case "[":
                atom = this.characterClass();
                break;
              case "(":
                atom = this.group();
                break;
            }
            if (atom === void 0 && this.isPatternCharacter()) {
              atom = this.patternCharacter();
            }
            ASSERT_EXISTS(atom);
            atom.loc = this.loc(begin);
            if (this.isQuantifier()) {
              atom.quantifier = this.quantifier();
            }
            return atom;
          };
          RegExpParser.prototype.dotAll = function() {
            this.consumeChar(".");
            return {
              type: "Set",
              complement: true,
              value: [cc("\n"), cc("\r"), cc("\u2028"), cc("\u2029")]
            };
          };
          RegExpParser.prototype.atomEscape = function() {
            this.consumeChar("\\");
            switch (this.peekChar()) {
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
                return this.decimalEscapeAtom();
              case "d":
              case "D":
              case "s":
              case "S":
              case "w":
              case "W":
                return this.characterClassEscape();
              case "f":
              case "n":
              case "r":
              case "t":
              case "v":
                return this.controlEscapeAtom();
              case "c":
                return this.controlLetterEscapeAtom();
              case "0":
                return this.nulCharacterAtom();
              case "x":
                return this.hexEscapeSequenceAtom();
              case "u":
                return this.regExpUnicodeEscapeSequenceAtom();
              default:
                return this.identityEscapeAtom();
            }
          };
          RegExpParser.prototype.decimalEscapeAtom = function() {
            var value = this.positiveInteger();
            return { type: "GroupBackReference", value };
          };
          RegExpParser.prototype.characterClassEscape = function() {
            var set2;
            var complement = false;
            switch (this.popChar()) {
              case "d":
                set2 = digitsCharCodes;
                break;
              case "D":
                set2 = digitsCharCodes;
                complement = true;
                break;
              case "s":
                set2 = whitespaceCodes;
                break;
              case "S":
                set2 = whitespaceCodes;
                complement = true;
                break;
              case "w":
                set2 = wordCharCodes;
                break;
              case "W":
                set2 = wordCharCodes;
                complement = true;
                break;
            }
            ASSERT_EXISTS(set2);
            return { type: "Set", value: set2, complement };
          };
          RegExpParser.prototype.controlEscapeAtom = function() {
            var escapeCode;
            switch (this.popChar()) {
              case "f":
                escapeCode = cc("\f");
                break;
              case "n":
                escapeCode = cc("\n");
                break;
              case "r":
                escapeCode = cc("\r");
                break;
              case "t":
                escapeCode = cc("	");
                break;
              case "v":
                escapeCode = cc("\v");
                break;
            }
            ASSERT_EXISTS(escapeCode);
            return { type: "Character", value: escapeCode };
          };
          RegExpParser.prototype.controlLetterEscapeAtom = function() {
            this.consumeChar("c");
            var letter = this.popChar();
            if (/[a-zA-Z]/.test(letter) === false) {
              throw Error("Invalid ");
            }
            var letterCode = letter.toUpperCase().charCodeAt(0) - 64;
            return { type: "Character", value: letterCode };
          };
          RegExpParser.prototype.nulCharacterAtom = function() {
            this.consumeChar("0");
            return { type: "Character", value: cc("\0") };
          };
          RegExpParser.prototype.hexEscapeSequenceAtom = function() {
            this.consumeChar("x");
            return this.parseHexDigits(2);
          };
          RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {
            this.consumeChar("u");
            return this.parseHexDigits(4);
          };
          RegExpParser.prototype.identityEscapeAtom = function() {
            var escapedChar = this.popChar();
            return { type: "Character", value: cc(escapedChar) };
          };
          RegExpParser.prototype.classPatternCharacterAtom = function() {
            switch (this.peekChar()) {
              // istanbul ignore next
              case "\n":
              // istanbul ignore next
              case "\r":
              // istanbul ignore next
              case "\u2028":
              // istanbul ignore next
              case "\u2029":
              // istanbul ignore next
              case "\\":
              // istanbul ignore next
              case "]":
                throw Error("TBD");
              default:
                var nextChar = this.popChar();
                return { type: "Character", value: cc(nextChar) };
            }
          };
          RegExpParser.prototype.characterClass = function() {
            var set2 = [];
            var complement = false;
            this.consumeChar("[");
            if (this.peekChar(0) === "^") {
              this.consumeChar("^");
              complement = true;
            }
            while (this.isClassAtom()) {
              var from = this.classAtom();
              var isFromSingleChar = from.type === "Character";
              if (isFromSingleChar && this.isRangeDash()) {
                this.consumeChar("-");
                var to = this.classAtom();
                var isToSingleChar = to.type === "Character";
                if (isToSingleChar) {
                  if (to.value < from.value) {
                    throw Error("Range out of order in character class");
                  }
                  set2.push({ from: from.value, to: to.value });
                } else {
                  insertToSet(from.value, set2);
                  set2.push(cc("-"));
                  insertToSet(to.value, set2);
                }
              } else {
                insertToSet(from.value, set2);
              }
            }
            this.consumeChar("]");
            return { type: "Set", complement, value: set2 };
          };
          RegExpParser.prototype.classAtom = function() {
            switch (this.peekChar()) {
              // istanbul ignore next
              case "]":
              // istanbul ignore next
              case "\n":
              // istanbul ignore next
              case "\r":
              // istanbul ignore next
              case "\u2028":
              // istanbul ignore next
              case "\u2029":
                throw Error("TBD");
              case "\\":
                return this.classEscape();
              default:
                return this.classPatternCharacterAtom();
            }
          };
          RegExpParser.prototype.classEscape = function() {
            this.consumeChar("\\");
            switch (this.peekChar()) {
              // Matches a backspace.
              // (Not to be confused with \b word boundary outside characterClass)
              case "b":
                this.consumeChar("b");
                return { type: "Character", value: cc("\b") };
              case "d":
              case "D":
              case "s":
              case "S":
              case "w":
              case "W":
                return this.characterClassEscape();
              case "f":
              case "n":
              case "r":
              case "t":
              case "v":
                return this.controlEscapeAtom();
              case "c":
                return this.controlLetterEscapeAtom();
              case "0":
                return this.nulCharacterAtom();
              case "x":
                return this.hexEscapeSequenceAtom();
              case "u":
                return this.regExpUnicodeEscapeSequenceAtom();
              default:
                return this.identityEscapeAtom();
            }
          };
          RegExpParser.prototype.group = function() {
            var capturing = true;
            this.consumeChar("(");
            switch (this.peekChar(0)) {
              case "?":
                this.consumeChar("?");
                this.consumeChar(":");
                capturing = false;
                break;
              default:
                this.groupIdx++;
                break;
            }
            var value = this.disjunction();
            this.consumeChar(")");
            var groupAst = {
              type: "Group",
              capturing,
              value
            };
            if (capturing) {
              groupAst.idx = this.groupIdx;
            }
            return groupAst;
          };
          RegExpParser.prototype.positiveInteger = function() {
            var number = this.popChar();
            if (decimalPatternNoZero.test(number) === false) {
              throw Error("Expecting a positive integer");
            }
            while (decimalPattern.test(this.peekChar(0))) {
              number += this.popChar();
            }
            return parseInt(number, 10);
          };
          RegExpParser.prototype.integerIncludingZero = function() {
            var number = this.popChar();
            if (decimalPattern.test(number) === false) {
              throw Error("Expecting an integer");
            }
            while (decimalPattern.test(this.peekChar(0))) {
              number += this.popChar();
            }
            return parseInt(number, 10);
          };
          RegExpParser.prototype.patternCharacter = function() {
            var nextChar = this.popChar();
            switch (nextChar) {
              // istanbul ignore next
              case "\n":
              // istanbul ignore next
              case "\r":
              // istanbul ignore next
              case "\u2028":
              // istanbul ignore next
              case "\u2029":
              // istanbul ignore next
              case "^":
              // istanbul ignore next
              case "$":
              // istanbul ignore next
              case "\\":
              // istanbul ignore next
              case ".":
              // istanbul ignore next
              case "*":
              // istanbul ignore next
              case "+":
              // istanbul ignore next
              case "?":
              // istanbul ignore next
              case "(":
              // istanbul ignore next
              case ")":
              // istanbul ignore next
              case "[":
              // istanbul ignore next
              case "|":
                throw Error("TBD");
              default:
                return { type: "Character", value: cc(nextChar) };
            }
          };
          RegExpParser.prototype.isRegExpFlag = function() {
            switch (this.peekChar(0)) {
              case "g":
              case "i":
              case "m":
              case "u":
              case "y":
                return true;
              default:
                return false;
            }
          };
          RegExpParser.prototype.isRangeDash = function() {
            return this.peekChar() === "-" && this.isClassAtom(1);
          };
          RegExpParser.prototype.isDigit = function() {
            return decimalPattern.test(this.peekChar(0));
          };
          RegExpParser.prototype.isClassAtom = function(howMuch) {
            if (howMuch === void 0) {
              howMuch = 0;
            }
            switch (this.peekChar(howMuch)) {
              case "]":
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
                return false;
              default:
                return true;
            }
          };
          RegExpParser.prototype.isTerm = function() {
            return this.isAtom() || this.isAssertion();
          };
          RegExpParser.prototype.isAtom = function() {
            if (this.isPatternCharacter()) {
              return true;
            }
            switch (this.peekChar(0)) {
              case ".":
              case "\\":
              // atomEscape
              case "[":
              // characterClass
              // TODO: isAtom must be called before isAssertion - disambiguate
              case "(":
                return true;
              default:
                return false;
            }
          };
          RegExpParser.prototype.isAssertion = function() {
            switch (this.peekChar(0)) {
              case "^":
              case "$":
                return true;
              // '\b' or '\B'
              case "\\":
                switch (this.peekChar(1)) {
                  case "b":
                  case "B":
                    return true;
                  default:
                    return false;
                }
              // '(?=' or '(?!'
              case "(":
                return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!");
              default:
                return false;
            }
          };
          RegExpParser.prototype.isQuantifier = function() {
            var prevState = this.saveState();
            try {
              return this.quantifier(true) !== void 0;
            } catch (e) {
              return false;
            } finally {
              this.restoreState(prevState);
            }
          };
          RegExpParser.prototype.isPatternCharacter = function() {
            switch (this.peekChar()) {
              case "^":
              case "$":
              case "\\":
              case ".":
              case "*":
              case "+":
              case "?":
              case "(":
              case ")":
              case "[":
              case "|":
              case "/":
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
                return false;
              default:
                return true;
            }
          };
          RegExpParser.prototype.parseHexDigits = function(howMany) {
            var hexString = "";
            for (var i2 = 0; i2 < howMany; i2++) {
              var hexChar = this.popChar();
              if (hexDigitPattern.test(hexChar) === false) {
                throw Error("Expecting a HexDecimal digits");
              }
              hexString += hexChar;
            }
            var charCode = parseInt(hexString, 16);
            return { type: "Character", value: charCode };
          };
          RegExpParser.prototype.peekChar = function(howMuch) {
            if (howMuch === void 0) {
              howMuch = 0;
            }
            return this.input[this.idx + howMuch];
          };
          RegExpParser.prototype.popChar = function() {
            var nextChar = this.peekChar(0);
            this.consumeChar();
            return nextChar;
          };
          RegExpParser.prototype.consumeChar = function(char) {
            if (char !== void 0 && this.input[this.idx] !== char) {
              throw Error(
                "Expected: '" + char + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx
              );
            }
            if (this.idx >= this.input.length) {
              throw Error("Unexpected end of input");
            }
            this.idx++;
          };
          RegExpParser.prototype.loc = function(begin) {
            return { begin, end: this.idx };
          };
          var hexDigitPattern = /[0-9a-fA-F]/;
          var decimalPattern = /[0-9]/;
          var decimalPatternNoZero = /[1-9]/;
          function cc(char) {
            return char.charCodeAt(0);
          }
          function insertToSet(item, set2) {
            if (item.length !== void 0) {
              item.forEach(function(subItem) {
                set2.push(subItem);
              });
            } else {
              set2.push(item);
            }
          }
          function addFlag(flagObj, flagKey) {
            if (flagObj[flagKey] === true) {
              throw "duplicate flag " + flagKey;
            }
            flagObj[flagKey] = true;
          }
          function ASSERT_EXISTS(obj) {
            if (obj === void 0) {
              throw Error("Internal Error - Should never get here!");
            }
          }
          function ASSERT_NEVER_REACH_HERE() {
            throw Error("Internal Error - Should never get here!");
          }
          var i;
          var digitsCharCodes = [];
          for (i = cc("0"); i <= cc("9"); i++) {
            digitsCharCodes.push(i);
          }
          var wordCharCodes = [cc("_")].concat(digitsCharCodes);
          for (i = cc("a"); i <= cc("z"); i++) {
            wordCharCodes.push(i);
          }
          for (i = cc("A"); i <= cc("Z"); i++) {
            wordCharCodes.push(i);
          }
          var whitespaceCodes = [
            cc(" "),
            cc("\f"),
            cc("\n"),
            cc("\r"),
            cc("	"),
            cc("\v"),
            cc("	"),
            cc("\xA0"),
            cc("\u1680"),
            cc("\u2000"),
            cc("\u2001"),
            cc("\u2002"),
            cc("\u2003"),
            cc("\u2004"),
            cc("\u2005"),
            cc("\u2006"),
            cc("\u2007"),
            cc("\u2008"),
            cc("\u2009"),
            cc("\u200A"),
            cc("\u2028"),
            cc("\u2029"),
            cc("\u202F"),
            cc("\u205F"),
            cc("\u3000"),
            cc("\uFEFF")
          ];
          function BaseRegExpVisitor() {
          }
          BaseRegExpVisitor.prototype.visitChildren = function(node) {
            for (var key in node) {
              var child = node[key];
              if (node.hasOwnProperty(key)) {
                if (child.type !== void 0) {
                  this.visit(child);
                } else if (Array.isArray(child)) {
                  child.forEach(function(subChild) {
                    this.visit(subChild);
                  }, this);
                }
              }
            }
          };
          BaseRegExpVisitor.prototype.visit = function(node) {
            switch (node.type) {
              case "Pattern":
                this.visitPattern(node);
                break;
              case "Flags":
                this.visitFlags(node);
                break;
              case "Disjunction":
                this.visitDisjunction(node);
                break;
              case "Alternative":
                this.visitAlternative(node);
                break;
              case "StartAnchor":
                this.visitStartAnchor(node);
                break;
              case "EndAnchor":
                this.visitEndAnchor(node);
                break;
              case "WordBoundary":
                this.visitWordBoundary(node);
                break;
              case "NonWordBoundary":
                this.visitNonWordBoundary(node);
                break;
              case "Lookahead":
                this.visitLookahead(node);
                break;
              case "NegativeLookahead":
                this.visitNegativeLookahead(node);
                break;
              case "Character":
                this.visitCharacter(node);
                break;
              case "Set":
                this.visitSet(node);
                break;
              case "Group":
                this.visitGroup(node);
                break;
              case "GroupBackReference":
                this.visitGroupBackReference(node);
                break;
              case "Quantifier":
                this.visitQuantifier(node);
                break;
            }
            this.visitChildren(node);
          };
          BaseRegExpVisitor.prototype.visitPattern = function(node) {
          };
          BaseRegExpVisitor.prototype.visitFlags = function(node) {
          };
          BaseRegExpVisitor.prototype.visitDisjunction = function(node) {
          };
          BaseRegExpVisitor.prototype.visitAlternative = function(node) {
          };
          BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {
          };
          BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {
          };
          BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {
          };
          BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {
          };
          BaseRegExpVisitor.prototype.visitLookahead = function(node) {
          };
          BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {
          };
          BaseRegExpVisitor.prototype.visitCharacter = function(node) {
          };
          BaseRegExpVisitor.prototype.visitSet = function(node) {
          };
          BaseRegExpVisitor.prototype.visitGroup = function(node) {
          };
          BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {
          };
          BaseRegExpVisitor.prototype.visitQuantifier = function(node) {
          };
          return {
            RegExpParser,
            BaseRegExpVisitor,
            VERSION: "0.5.0"
          };
        }
      );
    }
  });

  // node_modules/chevrotain/lib/src/scan/reg_exp_parser.js
  var require_reg_exp_parser = __commonJS({
    "node_modules/chevrotain/lib/src/scan/reg_exp_parser.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.clearRegExpParserCache = exports2.getRegExpAst = void 0;
      var regexp_to_ast_1 = require_regexp_to_ast();
      var regExpAstCache = {};
      var regExpParser = new regexp_to_ast_1.RegExpParser();
      function getRegExpAst(regExp) {
        var regExpStr = regExp.toString();
        if (regExpAstCache.hasOwnProperty(regExpStr)) {
          return regExpAstCache[regExpStr];
        } else {
          var regExpAst = regExpParser.pattern(regExpStr);
          regExpAstCache[regExpStr] = regExpAst;
          return regExpAst;
        }
      }
      exports2.getRegExpAst = getRegExpAst;
      function clearRegExpParserCache() {
        regExpAstCache = {};
      }
      exports2.clearRegExpParserCache = clearRegExpParserCache;
    }
  });

  // node_modules/chevrotain/lib/src/scan/reg_exp.js
  var require_reg_exp = __commonJS({
    "node_modules/chevrotain/lib/src/scan/reg_exp.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d, b) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics2(d, b);
        };
        return function(d, b) {
          extendStatics2(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      })();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.canMatchCharCode = exports2.firstCharOptimizedIndices = exports2.getOptimizedStartCodesIndices = exports2.failedOptimizationPrefixMsg = void 0;
      var regexp_to_ast_1 = require_regexp_to_ast();
      var utils_1 = require_utils();
      var reg_exp_parser_1 = require_reg_exp_parser();
      var lexer_1 = require_lexer();
      var complementErrorMessage = "Complement Sets are not supported for first char optimization";
      exports2.failedOptimizationPrefixMsg = 'Unable to use "first char" lexer optimizations:\n';
      function getOptimizedStartCodesIndices(regExp, ensureOptimizations) {
        if (ensureOptimizations === void 0) {
          ensureOptimizations = false;
        }
        try {
          var ast = reg_exp_parser_1.getRegExpAst(regExp);
          var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);
          return firstChars;
        } catch (e) {
          if (e.message === complementErrorMessage) {
            if (ensureOptimizations) {
              utils_1.PRINT_WARNING("" + exports2.failedOptimizationPrefixMsg + ("	Unable to optimize: < " + regExp.toString() + " >\n") + "	Complement Sets cannot be automatically optimized.\n	This will disable the lexer's first char optimizations.\n	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.");
            }
          } else {
            var msgSuffix = "";
            if (ensureOptimizations) {
              msgSuffix = "\n	This will disable the lexer's first char optimizations.\n	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.";
            }
            utils_1.PRINT_ERROR(exports2.failedOptimizationPrefixMsg + "\n" + ("	Failed parsing: < " + regExp.toString() + " >\n") + ("	Using the regexp-to-ast library version: " + regexp_to_ast_1.VERSION + "\n") + "	Please open an issue at: https://github.com/bd82/regexp-to-ast/issues" + msgSuffix);
          }
        }
        return [];
      }
      exports2.getOptimizedStartCodesIndices = getOptimizedStartCodesIndices;
      function firstCharOptimizedIndices(ast, result, ignoreCase) {
        switch (ast.type) {
          case "Disjunction":
            for (var i = 0; i < ast.value.length; i++) {
              firstCharOptimizedIndices(ast.value[i], result, ignoreCase);
            }
            break;
          case "Alternative":
            var terms = ast.value;
            for (var i = 0; i < terms.length; i++) {
              var term = terms[i];
              switch (term.type) {
                case "EndAnchor":
                // A group back reference cannot affect potential starting char.
                // because if a back reference is the first production than automatically
                // the group being referenced has had to come BEFORE so its codes have already been added
                case "GroupBackReference":
                // assertions do not affect potential starting codes
                case "Lookahead":
                case "NegativeLookahead":
                case "StartAnchor":
                case "WordBoundary":
                case "NonWordBoundary":
                  continue;
              }
              var atom = term;
              switch (atom.type) {
                case "Character":
                  addOptimizedIdxToResult(atom.value, result, ignoreCase);
                  break;
                case "Set":
                  if (atom.complement === true) {
                    throw Error(complementErrorMessage);
                  }
                  utils_1.forEach(atom.value, function(code) {
                    if (typeof code === "number") {
                      addOptimizedIdxToResult(code, result, ignoreCase);
                    } else {
                      var range2 = code;
                      if (ignoreCase === true) {
                        for (var rangeCode = range2.from; rangeCode <= range2.to; rangeCode++) {
                          addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                        }
                      } else {
                        for (var rangeCode = range2.from; rangeCode <= range2.to && rangeCode < lexer_1.minOptimizationVal; rangeCode++) {
                          addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                        }
                        if (range2.to >= lexer_1.minOptimizationVal) {
                          var minUnOptVal = range2.from >= lexer_1.minOptimizationVal ? range2.from : lexer_1.minOptimizationVal;
                          var maxUnOptVal = range2.to;
                          var minOptIdx = lexer_1.charCodeToOptimizedIndex(minUnOptVal);
                          var maxOptIdx = lexer_1.charCodeToOptimizedIndex(maxUnOptVal);
                          for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {
                            result[currOptIdx] = currOptIdx;
                          }
                        }
                      }
                    }
                  });
                  break;
                case "Group":
                  firstCharOptimizedIndices(atom.value, result, ignoreCase);
                  break;
                /* istanbul ignore next */
                default:
                  throw Error("Non Exhaustive Match");
              }
              var isOptionalQuantifier = atom.quantifier !== void 0 && atom.quantifier.atLeast === 0;
              if (
                // A group may be optional due to empty contents /(?:)/
                // or if everything inside it is optional /((a)?)/
                atom.type === "Group" && isWholeOptional(atom) === false || // If this term is not a group it may only be optional if it has an optional quantifier
                atom.type !== "Group" && isOptionalQuantifier === false
              ) {
                break;
              }
            }
            break;
          /* istanbul ignore next */
          default:
            throw Error("non exhaustive match!");
        }
        return utils_1.values(result);
      }
      exports2.firstCharOptimizedIndices = firstCharOptimizedIndices;
      function addOptimizedIdxToResult(code, result, ignoreCase) {
        var optimizedCharIdx = lexer_1.charCodeToOptimizedIndex(code);
        result[optimizedCharIdx] = optimizedCharIdx;
        if (ignoreCase === true) {
          handleIgnoreCase(code, result);
        }
      }
      function handleIgnoreCase(code, result) {
        var char = String.fromCharCode(code);
        var upperChar = char.toUpperCase();
        if (upperChar !== char) {
          var optimizedCharIdx = lexer_1.charCodeToOptimizedIndex(upperChar.charCodeAt(0));
          result[optimizedCharIdx] = optimizedCharIdx;
        } else {
          var lowerChar = char.toLowerCase();
          if (lowerChar !== char) {
            var optimizedCharIdx = lexer_1.charCodeToOptimizedIndex(lowerChar.charCodeAt(0));
            result[optimizedCharIdx] = optimizedCharIdx;
          }
        }
      }
      function findCode(setNode, targetCharCodes) {
        return utils_1.find(setNode.value, function(codeOrRange) {
          if (typeof codeOrRange === "number") {
            return utils_1.contains(targetCharCodes, codeOrRange);
          } else {
            var range_1 = codeOrRange;
            return utils_1.find(targetCharCodes, function(targetCode) {
              return range_1.from <= targetCode && targetCode <= range_1.to;
            }) !== void 0;
          }
        });
      }
      function isWholeOptional(ast) {
        if (ast.quantifier && ast.quantifier.atLeast === 0) {
          return true;
        }
        if (!ast.value) {
          return false;
        }
        return utils_1.isArray(ast.value) ? utils_1.every(ast.value, isWholeOptional) : isWholeOptional(ast.value);
      }
      var CharCodeFinder = (
        /** @class */
        (function(_super) {
          __extends2(CharCodeFinder2, _super);
          function CharCodeFinder2(targetCharCodes) {
            var _this = _super.call(this) || this;
            _this.targetCharCodes = targetCharCodes;
            _this.found = false;
            return _this;
          }
          CharCodeFinder2.prototype.visitChildren = function(node) {
            if (this.found === true) {
              return;
            }
            switch (node.type) {
              case "Lookahead":
                this.visitLookahead(node);
                return;
              case "NegativeLookahead":
                this.visitNegativeLookahead(node);
                return;
            }
            _super.prototype.visitChildren.call(this, node);
          };
          CharCodeFinder2.prototype.visitCharacter = function(node) {
            if (utils_1.contains(this.targetCharCodes, node.value)) {
              this.found = true;
            }
          };
          CharCodeFinder2.prototype.visitSet = function(node) {
            if (node.complement) {
              if (findCode(node, this.targetCharCodes) === void 0) {
                this.found = true;
              }
            } else {
              if (findCode(node, this.targetCharCodes) !== void 0) {
                this.found = true;
              }
            }
          };
          return CharCodeFinder2;
        })(regexp_to_ast_1.BaseRegExpVisitor)
      );
      function canMatchCharCode(charCodes, pattern) {
        if (pattern instanceof RegExp) {
          var ast = reg_exp_parser_1.getRegExpAst(pattern);
          var charCodeFinder = new CharCodeFinder(charCodes);
          charCodeFinder.visit(ast);
          return charCodeFinder.found;
        } else {
          return utils_1.find(pattern, function(char) {
            return utils_1.contains(charCodes, char.charCodeAt(0));
          }) !== void 0;
        }
      }
      exports2.canMatchCharCode = canMatchCharCode;
    }
  });

  // node_modules/chevrotain/lib/src/scan/lexer.js
  var require_lexer = __commonJS({
    "node_modules/chevrotain/lib/src/scan/lexer.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d, b) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics2(d, b);
        };
        return function(d, b) {
          extendStatics2(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      })();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.charCodeToOptimizedIndex = exports2.minOptimizationVal = exports2.buildLineBreakIssueMessage = exports2.LineTerminatorOptimizedTester = exports2.isShortPattern = exports2.isCustomPattern = exports2.cloneEmptyGroups = exports2.performWarningRuntimeChecks = exports2.performRuntimeChecks = exports2.addStickyFlag = exports2.addStartOfInput = exports2.findUnreachablePatterns = exports2.findModesThatDoNotExist = exports2.findInvalidGroupType = exports2.findDuplicatePatterns = exports2.findUnsupportedFlags = exports2.findStartOfInputAnchor = exports2.findEmptyMatchRegExps = exports2.findEndOfInputAnchor = exports2.findInvalidPatterns = exports2.findMissingPatterns = exports2.validatePatterns = exports2.analyzeTokenTypes = exports2.enableSticky = exports2.disableSticky = exports2.SUPPORT_STICKY = exports2.MODES = exports2.DEFAULT_MODE = void 0;
      var regexp_to_ast_1 = require_regexp_to_ast();
      var lexer_public_1 = require_lexer_public();
      var utils_1 = require_utils();
      var reg_exp_1 = require_reg_exp();
      var reg_exp_parser_1 = require_reg_exp_parser();
      var PATTERN = "PATTERN";
      exports2.DEFAULT_MODE = "defaultMode";
      exports2.MODES = "modes";
      exports2.SUPPORT_STICKY = typeof new RegExp("(?:)").sticky === "boolean";
      function disableSticky() {
        exports2.SUPPORT_STICKY = false;
      }
      exports2.disableSticky = disableSticky;
      function enableSticky() {
        exports2.SUPPORT_STICKY = true;
      }
      exports2.enableSticky = enableSticky;
      function analyzeTokenTypes(tokenTypes, options) {
        options = utils_1.defaults(options, {
          useSticky: exports2.SUPPORT_STICKY,
          debug: false,
          safeMode: false,
          positionTracking: "full",
          lineTerminatorCharacters: ["\r", "\n"],
          tracer: function(msg, action) {
            return action();
          }
        });
        var tracer = options.tracer;
        tracer("initCharCodeToOptimizedIndexMap", function() {
          initCharCodeToOptimizedIndexMap();
        });
        var onlyRelevantTypes;
        tracer("Reject Lexer.NA", function() {
          onlyRelevantTypes = utils_1.reject(tokenTypes, function(currType) {
            return currType[PATTERN] === lexer_public_1.Lexer.NA;
          });
        });
        var hasCustom = false;
        var allTransformedPatterns;
        tracer("Transform Patterns", function() {
          hasCustom = false;
          allTransformedPatterns = utils_1.map(onlyRelevantTypes, function(currType) {
            var currPattern = currType[PATTERN];
            if (utils_1.isRegExp(currPattern)) {
              var regExpSource = currPattern.source;
              if (regExpSource.length === 1 && // only these regExp meta characters which can appear in a length one regExp
              regExpSource !== "^" && regExpSource !== "$" && regExpSource !== "." && !currPattern.ignoreCase) {
                return regExpSource;
              } else if (regExpSource.length === 2 && regExpSource[0] === "\\" && // not a meta character
              !utils_1.contains([
                "d",
                "D",
                "s",
                "S",
                "t",
                "r",
                "n",
                "t",
                "0",
                "c",
                "b",
                "B",
                "f",
                "v",
                "w",
                "W"
              ], regExpSource[1])) {
                return regExpSource[1];
              } else {
                return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);
              }
            } else if (utils_1.isFunction(currPattern)) {
              hasCustom = true;
              return { exec: currPattern };
            } else if (utils_1.has(currPattern, "exec")) {
              hasCustom = true;
              return currPattern;
            } else if (typeof currPattern === "string") {
              if (currPattern.length === 1) {
                return currPattern;
              } else {
                var escapedRegExpString = currPattern.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
                var wrappedRegExp = new RegExp(escapedRegExpString);
                return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);
              }
            } else {
              throw Error("non exhaustive match");
            }
          });
        });
        var patternIdxToType;
        var patternIdxToGroup;
        var patternIdxToLongerAltIdx;
        var patternIdxToPushMode;
        var patternIdxToPopMode;
        tracer("misc mapping", function() {
          patternIdxToType = utils_1.map(onlyRelevantTypes, function(currType) {
            return currType.tokenTypeIdx;
          });
          patternIdxToGroup = utils_1.map(onlyRelevantTypes, function(clazz) {
            var groupName = clazz.GROUP;
            if (groupName === lexer_public_1.Lexer.SKIPPED) {
              return void 0;
            } else if (utils_1.isString(groupName)) {
              return groupName;
            } else if (utils_1.isUndefined(groupName)) {
              return false;
            } else {
              throw Error("non exhaustive match");
            }
          });
          patternIdxToLongerAltIdx = utils_1.map(onlyRelevantTypes, function(clazz) {
            var longerAltType = clazz.LONGER_ALT;
            if (longerAltType) {
              var longerAltIdx = utils_1.indexOf(onlyRelevantTypes, longerAltType);
              return longerAltIdx;
            }
          });
          patternIdxToPushMode = utils_1.map(onlyRelevantTypes, function(clazz) {
            return clazz.PUSH_MODE;
          });
          patternIdxToPopMode = utils_1.map(onlyRelevantTypes, function(clazz) {
            return utils_1.has(clazz, "POP_MODE");
          });
        });
        var patternIdxToCanLineTerminator;
        tracer("Line Terminator Handling", function() {
          var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);
          patternIdxToCanLineTerminator = utils_1.map(onlyRelevantTypes, function(tokType) {
            return false;
          });
          if (options.positionTracking !== "onlyOffset") {
            patternIdxToCanLineTerminator = utils_1.map(onlyRelevantTypes, function(tokType) {
              if (utils_1.has(tokType, "LINE_BREAKS")) {
                return tokType.LINE_BREAKS;
              } else {
                if (checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false) {
                  return reg_exp_1.canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);
                }
              }
            });
          }
        });
        var patternIdxToIsCustom;
        var patternIdxToShort;
        var emptyGroups;
        var patternIdxToConfig;
        tracer("Misc Mapping #2", function() {
          patternIdxToIsCustom = utils_1.map(onlyRelevantTypes, isCustomPattern);
          patternIdxToShort = utils_1.map(allTransformedPatterns, isShortPattern);
          emptyGroups = utils_1.reduce(onlyRelevantTypes, function(acc, clazz) {
            var groupName = clazz.GROUP;
            if (utils_1.isString(groupName) && !(groupName === lexer_public_1.Lexer.SKIPPED)) {
              acc[groupName] = [];
            }
            return acc;
          }, {});
          patternIdxToConfig = utils_1.map(allTransformedPatterns, function(x, idx) {
            return {
              pattern: allTransformedPatterns[idx],
              longerAlt: patternIdxToLongerAltIdx[idx],
              canLineTerminator: patternIdxToCanLineTerminator[idx],
              isCustom: patternIdxToIsCustom[idx],
              short: patternIdxToShort[idx],
              group: patternIdxToGroup[idx],
              push: patternIdxToPushMode[idx],
              pop: patternIdxToPopMode[idx],
              tokenTypeIdx: patternIdxToType[idx],
              tokenType: onlyRelevantTypes[idx]
            };
          });
        });
        var canBeOptimized = true;
        var charCodeToPatternIdxToConfig = [];
        if (!options.safeMode) {
          tracer("First Char Optimization", function() {
            charCodeToPatternIdxToConfig = utils_1.reduce(onlyRelevantTypes, function(result, currTokType, idx) {
              if (typeof currTokType.PATTERN === "string") {
                var charCode = currTokType.PATTERN.charCodeAt(0);
                var optimizedIdx = charCodeToOptimizedIndex(charCode);
                addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);
              } else if (utils_1.isArray(currTokType.START_CHARS_HINT)) {
                var lastOptimizedIdx_1;
                utils_1.forEach(currTokType.START_CHARS_HINT, function(charOrInt) {
                  var charCode2 = typeof charOrInt === "string" ? charOrInt.charCodeAt(0) : charOrInt;
                  var currOptimizedIdx = charCodeToOptimizedIndex(charCode2);
                  if (lastOptimizedIdx_1 !== currOptimizedIdx) {
                    lastOptimizedIdx_1 = currOptimizedIdx;
                    addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);
                  }
                });
              } else if (utils_1.isRegExp(currTokType.PATTERN)) {
                if (currTokType.PATTERN.unicode) {
                  canBeOptimized = false;
                  if (options.ensureOptimizations) {
                    utils_1.PRINT_ERROR("" + reg_exp_1.failedOptimizationPrefixMsg + ("	Unable to analyze < " + currTokType.PATTERN.toString() + " > pattern.\n") + "	The regexp unicode flag is not currently supported by the regexp-to-ast library.\n	This will disable the lexer's first char optimizations.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE");
                  }
                } else {
                  var optimizedCodes = reg_exp_1.getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);
                  if (utils_1.isEmpty(optimizedCodes)) {
                    canBeOptimized = false;
                  }
                  utils_1.forEach(optimizedCodes, function(code) {
                    addToMapOfArrays(result, code, patternIdxToConfig[idx]);
                  });
                }
              } else {
                if (options.ensureOptimizations) {
                  utils_1.PRINT_ERROR("" + reg_exp_1.failedOptimizationPrefixMsg + ("	TokenType: <" + currTokType.name + "> is using a custom token pattern without providing <start_chars_hint> parameter.\n") + "	This will disable the lexer's first char optimizations.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE");
                }
                canBeOptimized = false;
              }
              return result;
            }, []);
          });
        }
        tracer("ArrayPacking", function() {
          charCodeToPatternIdxToConfig = utils_1.packArray(charCodeToPatternIdxToConfig);
        });
        return {
          emptyGroups,
          patternIdxToConfig,
          charCodeToPatternIdxToConfig,
          hasCustom,
          canBeOptimized
        };
      }
      exports2.analyzeTokenTypes = analyzeTokenTypes;
      function validatePatterns(tokenTypes, validModesNames) {
        var errors = [];
        var missingResult = findMissingPatterns(tokenTypes);
        errors = errors.concat(missingResult.errors);
        var invalidResult = findInvalidPatterns(missingResult.valid);
        var validTokenTypes = invalidResult.valid;
        errors = errors.concat(invalidResult.errors);
        errors = errors.concat(validateRegExpPattern(validTokenTypes));
        errors = errors.concat(findInvalidGroupType(validTokenTypes));
        errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));
        errors = errors.concat(findUnreachablePatterns(validTokenTypes));
        return errors;
      }
      exports2.validatePatterns = validatePatterns;
      function validateRegExpPattern(tokenTypes) {
        var errors = [];
        var withRegExpPatterns = utils_1.filter(tokenTypes, function(currTokType) {
          return utils_1.isRegExp(currTokType[PATTERN]);
        });
        errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));
        errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));
        errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));
        errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));
        errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));
        return errors;
      }
      function findMissingPatterns(tokenTypes) {
        var tokenTypesWithMissingPattern = utils_1.filter(tokenTypes, function(currType) {
          return !utils_1.has(currType, PATTERN);
        });
        var errors = utils_1.map(tokenTypesWithMissingPattern, function(currType) {
          return {
            message: "Token Type: ->" + currType.name + "<- missing static 'PATTERN' property",
            type: lexer_public_1.LexerDefinitionErrorType.MISSING_PATTERN,
            tokenTypes: [currType]
          };
        });
        var valid = utils_1.difference(tokenTypes, tokenTypesWithMissingPattern);
        return { errors, valid };
      }
      exports2.findMissingPatterns = findMissingPatterns;
      function findInvalidPatterns(tokenTypes) {
        var tokenTypesWithInvalidPattern = utils_1.filter(tokenTypes, function(currType) {
          var pattern = currType[PATTERN];
          return !utils_1.isRegExp(pattern) && !utils_1.isFunction(pattern) && !utils_1.has(pattern, "exec") && !utils_1.isString(pattern);
        });
        var errors = utils_1.map(tokenTypesWithInvalidPattern, function(currType) {
          return {
            message: "Token Type: ->" + currType.name + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
            type: lexer_public_1.LexerDefinitionErrorType.INVALID_PATTERN,
            tokenTypes: [currType]
          };
        });
        var valid = utils_1.difference(tokenTypes, tokenTypesWithInvalidPattern);
        return { errors, valid };
      }
      exports2.findInvalidPatterns = findInvalidPatterns;
      var end_of_input = /[^\\][\$]/;
      function findEndOfInputAnchor(tokenTypes) {
        var EndAnchorFinder = (
          /** @class */
          (function(_super) {
            __extends2(EndAnchorFinder2, _super);
            function EndAnchorFinder2() {
              var _this = _super !== null && _super.apply(this, arguments) || this;
              _this.found = false;
              return _this;
            }
            EndAnchorFinder2.prototype.visitEndAnchor = function(node) {
              this.found = true;
            };
            return EndAnchorFinder2;
          })(regexp_to_ast_1.BaseRegExpVisitor)
        );
        var invalidRegex = utils_1.filter(tokenTypes, function(currType) {
          var pattern = currType[PATTERN];
          try {
            var regexpAst = reg_exp_parser_1.getRegExpAst(pattern);
            var endAnchorVisitor = new EndAnchorFinder();
            endAnchorVisitor.visit(regexpAst);
            return endAnchorVisitor.found;
          } catch (e) {
            return end_of_input.test(pattern.source);
          }
        });
        var errors = utils_1.map(invalidRegex, function(currType) {
          return {
            message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain end of input anchor '$'\n	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",
            type: lexer_public_1.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,
            tokenTypes: [currType]
          };
        });
        return errors;
      }
      exports2.findEndOfInputAnchor = findEndOfInputAnchor;
      function findEmptyMatchRegExps(tokenTypes) {
        var matchesEmptyString = utils_1.filter(tokenTypes, function(currType) {
          var pattern = currType[PATTERN];
          return pattern.test("");
        });
        var errors = utils_1.map(matchesEmptyString, function(currType) {
          return {
            message: "Token Type: ->" + currType.name + "<- static 'PATTERN' must not match an empty string",
            type: lexer_public_1.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,
            tokenTypes: [currType]
          };
        });
        return errors;
      }
      exports2.findEmptyMatchRegExps = findEmptyMatchRegExps;
      var start_of_input = /[^\\[][\^]|^\^/;
      function findStartOfInputAnchor(tokenTypes) {
        var StartAnchorFinder = (
          /** @class */
          (function(_super) {
            __extends2(StartAnchorFinder2, _super);
            function StartAnchorFinder2() {
              var _this = _super !== null && _super.apply(this, arguments) || this;
              _this.found = false;
              return _this;
            }
            StartAnchorFinder2.prototype.visitStartAnchor = function(node) {
              this.found = true;
            };
            return StartAnchorFinder2;
          })(regexp_to_ast_1.BaseRegExpVisitor)
        );
        var invalidRegex = utils_1.filter(tokenTypes, function(currType) {
          var pattern = currType[PATTERN];
          try {
            var regexpAst = reg_exp_parser_1.getRegExpAst(pattern);
            var startAnchorVisitor = new StartAnchorFinder();
            startAnchorVisitor.visit(regexpAst);
            return startAnchorVisitor.found;
          } catch (e) {
            return start_of_input.test(pattern.source);
          }
        });
        var errors = utils_1.map(invalidRegex, function(currType) {
          return {
            message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain start of input anchor '^'\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",
            type: lexer_public_1.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,
            tokenTypes: [currType]
          };
        });
        return errors;
      }
      exports2.findStartOfInputAnchor = findStartOfInputAnchor;
      function findUnsupportedFlags(tokenTypes) {
        var invalidFlags = utils_1.filter(tokenTypes, function(currType) {
          var pattern = currType[PATTERN];
          return pattern instanceof RegExp && (pattern.multiline || pattern.global);
        });
        var errors = utils_1.map(invalidFlags, function(currType) {
          return {
            message: "Token Type: ->" + currType.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
            type: lexer_public_1.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,
            tokenTypes: [currType]
          };
        });
        return errors;
      }
      exports2.findUnsupportedFlags = findUnsupportedFlags;
      function findDuplicatePatterns(tokenTypes) {
        var found = [];
        var identicalPatterns = utils_1.map(tokenTypes, function(outerType) {
          return utils_1.reduce(tokenTypes, function(result, innerType) {
            if (outerType.PATTERN.source === innerType.PATTERN.source && !utils_1.contains(found, innerType) && innerType.PATTERN !== lexer_public_1.Lexer.NA) {
              found.push(innerType);
              result.push(innerType);
              return result;
            }
            return result;
          }, []);
        });
        identicalPatterns = utils_1.compact(identicalPatterns);
        var duplicatePatterns = utils_1.filter(identicalPatterns, function(currIdenticalSet) {
          return currIdenticalSet.length > 1;
        });
        var errors = utils_1.map(duplicatePatterns, function(setOfIdentical) {
          var tokenTypeNames = utils_1.map(setOfIdentical, function(currType) {
            return currType.name;
          });
          var dupPatternSrc = utils_1.first(setOfIdentical).PATTERN;
          return {
            message: "The same RegExp pattern ->" + dupPatternSrc + "<-" + ("has been used in all of the following Token Types: " + tokenTypeNames.join(", ") + " <-"),
            type: lexer_public_1.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,
            tokenTypes: setOfIdentical
          };
        });
        return errors;
      }
      exports2.findDuplicatePatterns = findDuplicatePatterns;
      function findInvalidGroupType(tokenTypes) {
        var invalidTypes = utils_1.filter(tokenTypes, function(clazz) {
          if (!utils_1.has(clazz, "GROUP")) {
            return false;
          }
          var group = clazz.GROUP;
          return group !== lexer_public_1.Lexer.SKIPPED && group !== lexer_public_1.Lexer.NA && !utils_1.isString(group);
        });
        var errors = utils_1.map(invalidTypes, function(currType) {
          return {
            message: "Token Type: ->" + currType.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
            type: lexer_public_1.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,
            tokenTypes: [currType]
          };
        });
        return errors;
      }
      exports2.findInvalidGroupType = findInvalidGroupType;
      function findModesThatDoNotExist(tokenTypes, validModes) {
        var invalidModes = utils_1.filter(tokenTypes, function(clazz) {
          return clazz.PUSH_MODE !== void 0 && !utils_1.contains(validModes, clazz.PUSH_MODE);
        });
        var errors = utils_1.map(invalidModes, function(tokType) {
          var msg = "Token Type: ->" + tokType.name + "<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->" + tokType.PUSH_MODE + "<-which does not exist";
          return {
            message: msg,
            type: lexer_public_1.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,
            tokenTypes: [tokType]
          };
        });
        return errors;
      }
      exports2.findModesThatDoNotExist = findModesThatDoNotExist;
      function findUnreachablePatterns(tokenTypes) {
        var errors = [];
        var canBeTested = utils_1.reduce(tokenTypes, function(result, tokType, idx) {
          var pattern = tokType.PATTERN;
          if (pattern === lexer_public_1.Lexer.NA) {
            return result;
          }
          if (utils_1.isString(pattern)) {
            result.push({ str: pattern, idx, tokenType: tokType });
          } else if (utils_1.isRegExp(pattern) && noMetaChar(pattern)) {
            result.push({ str: pattern.source, idx, tokenType: tokType });
          }
          return result;
        }, []);
        utils_1.forEach(tokenTypes, function(tokType, testIdx) {
          utils_1.forEach(canBeTested, function(_a) {
            var str = _a.str, idx = _a.idx, tokenType = _a.tokenType;
            if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {
              var msg = "Token: ->" + tokenType.name + "<- can never be matched.\n" + ("Because it appears AFTER the Token Type ->" + tokType.name + "<-") + "in the lexer's definition.\nSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE";
              errors.push({
                message: msg,
                type: lexer_public_1.LexerDefinitionErrorType.UNREACHABLE_PATTERN,
                tokenTypes: [tokType, tokenType]
              });
            }
          });
        });
        return errors;
      }
      exports2.findUnreachablePatterns = findUnreachablePatterns;
      function testTokenType(str, pattern) {
        if (utils_1.isRegExp(pattern)) {
          var regExpArray = pattern.exec(str);
          return regExpArray !== null && regExpArray.index === 0;
        } else if (utils_1.isFunction(pattern)) {
          return pattern(str, 0, [], {});
        } else if (utils_1.has(pattern, "exec")) {
          return pattern.exec(str, 0, [], {});
        } else if (typeof pattern === "string") {
          return pattern === str;
        } else {
          throw Error("non exhaustive match");
        }
      }
      function noMetaChar(regExp) {
        var metaChars = [
          ".",
          "\\",
          "[",
          "]",
          "|",
          "^",
          "$",
          "(",
          ")",
          "?",
          "*",
          "+",
          "{"
        ];
        return utils_1.find(metaChars, function(char) {
          return regExp.source.indexOf(char) !== -1;
        }) === void 0;
      }
      function addStartOfInput(pattern) {
        var flags = pattern.ignoreCase ? "i" : "";
        return new RegExp("^(?:" + pattern.source + ")", flags);
      }
      exports2.addStartOfInput = addStartOfInput;
      function addStickyFlag(pattern) {
        var flags = pattern.ignoreCase ? "iy" : "y";
        return new RegExp("" + pattern.source, flags);
      }
      exports2.addStickyFlag = addStickyFlag;
      function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
        var errors = [];
        if (!utils_1.has(lexerDefinition, exports2.DEFAULT_MODE)) {
          errors.push({
            message: "A MultiMode Lexer cannot be initialized without a <" + exports2.DEFAULT_MODE + "> property in its definition\n",
            type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
          });
        }
        if (!utils_1.has(lexerDefinition, exports2.MODES)) {
          errors.push({
            message: "A MultiMode Lexer cannot be initialized without a <" + exports2.MODES + "> property in its definition\n",
            type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
          });
        }
        if (utils_1.has(lexerDefinition, exports2.MODES) && utils_1.has(lexerDefinition, exports2.DEFAULT_MODE) && !utils_1.has(lexerDefinition.modes, lexerDefinition.defaultMode)) {
          errors.push({
            message: "A MultiMode Lexer cannot be initialized with a " + exports2.DEFAULT_MODE + ": <" + lexerDefinition.defaultMode + ">which does not exist\n",
            type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
          });
        }
        if (utils_1.has(lexerDefinition, exports2.MODES)) {
          utils_1.forEach(lexerDefinition.modes, function(currModeValue, currModeName) {
            utils_1.forEach(currModeValue, function(currTokType, currIdx) {
              if (utils_1.isUndefined(currTokType)) {
                errors.push({
                  message: "A Lexer cannot be initialized using an undefined Token Type. Mode:" + ("<" + currModeName + "> at index: <" + currIdx + ">\n"),
                  type: lexer_public_1.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
                });
              }
            });
          });
        }
        return errors;
      }
      exports2.performRuntimeChecks = performRuntimeChecks;
      function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
        var warnings = [];
        var hasAnyLineBreak = false;
        var allTokenTypes = utils_1.compact(utils_1.flatten(utils_1.mapValues(lexerDefinition.modes, function(tokTypes) {
          return tokTypes;
        })));
        var concreteTokenTypes = utils_1.reject(allTokenTypes, function(currType) {
          return currType[PATTERN] === lexer_public_1.Lexer.NA;
        });
        var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);
        if (trackLines) {
          utils_1.forEach(concreteTokenTypes, function(tokType) {
            var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);
            if (currIssue !== false) {
              var message = buildLineBreakIssueMessage(tokType, currIssue);
              var warningDescriptor = {
                message,
                type: currIssue.issue,
                tokenType: tokType
              };
              warnings.push(warningDescriptor);
            } else {
              if (utils_1.has(tokType, "LINE_BREAKS")) {
                if (tokType.LINE_BREAKS === true) {
                  hasAnyLineBreak = true;
                }
              } else {
                if (reg_exp_1.canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {
                  hasAnyLineBreak = true;
                }
              }
            }
          });
        }
        if (trackLines && !hasAnyLineBreak) {
          warnings.push({
            message: "Warning: No LINE_BREAKS Found.\n	This Lexer has been defined to track line and column information,\n	But none of the Token Types can be identified as matching a line terminator.\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n	for details.",
            type: lexer_public_1.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS
          });
        }
        return warnings;
      }
      exports2.performWarningRuntimeChecks = performWarningRuntimeChecks;
      function cloneEmptyGroups(emptyGroups) {
        var clonedResult = {};
        var groupKeys = utils_1.keys(emptyGroups);
        utils_1.forEach(groupKeys, function(currKey) {
          var currGroupValue = emptyGroups[currKey];
          if (utils_1.isArray(currGroupValue)) {
            clonedResult[currKey] = [];
          } else {
            throw Error("non exhaustive match");
          }
        });
        return clonedResult;
      }
      exports2.cloneEmptyGroups = cloneEmptyGroups;
      function isCustomPattern(tokenType) {
        var pattern = tokenType.PATTERN;
        if (utils_1.isRegExp(pattern)) {
          return false;
        } else if (utils_1.isFunction(pattern)) {
          return true;
        } else if (utils_1.has(pattern, "exec")) {
          return true;
        } else if (utils_1.isString(pattern)) {
          return false;
        } else {
          throw Error("non exhaustive match");
        }
      }
      exports2.isCustomPattern = isCustomPattern;
      function isShortPattern(pattern) {
        if (utils_1.isString(pattern) && pattern.length === 1) {
          return pattern.charCodeAt(0);
        } else {
          return false;
        }
      }
      exports2.isShortPattern = isShortPattern;
      exports2.LineTerminatorOptimizedTester = {
        // implements /\n|\r\n?/g.test
        test: function(text) {
          var len = text.length;
          for (var i = this.lastIndex; i < len; i++) {
            var c = text.charCodeAt(i);
            if (c === 10) {
              this.lastIndex = i + 1;
              return true;
            } else if (c === 13) {
              if (text.charCodeAt(i + 1) === 10) {
                this.lastIndex = i + 2;
              } else {
                this.lastIndex = i + 1;
              }
              return true;
            }
          }
          return false;
        },
        lastIndex: 0
      };
      function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {
        if (utils_1.has(tokType, "LINE_BREAKS")) {
          return false;
        } else {
          if (utils_1.isRegExp(tokType.PATTERN)) {
            try {
              reg_exp_1.canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);
            } catch (e) {
              return {
                issue: lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,
                errMsg: e.message
              };
            }
            return false;
          } else if (utils_1.isString(tokType.PATTERN)) {
            return false;
          } else if (isCustomPattern(tokType)) {
            return { issue: lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK };
          } else {
            throw Error("non exhaustive match");
          }
        }
      }
      function buildLineBreakIssueMessage(tokType, details) {
        if (details.issue === lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {
          return "Warning: unable to identify line terminator usage in pattern.\n" + ("	The problem is in the <" + tokType.name + "> Token Type\n") + ("	 Root cause: " + details.errMsg + ".\n") + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR";
        } else if (details.issue === lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {
          return "Warning: A Custom Token Pattern should specify the <line_breaks> option.\n" + ("	The problem is in the <" + tokType.name + "> Token Type\n") + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK";
        } else {
          throw Error("non exhaustive match");
        }
      }
      exports2.buildLineBreakIssueMessage = buildLineBreakIssueMessage;
      function getCharCodes(charsOrCodes) {
        var charCodes = utils_1.map(charsOrCodes, function(numOrString) {
          if (utils_1.isString(numOrString) && numOrString.length > 0) {
            return numOrString.charCodeAt(0);
          } else {
            return numOrString;
          }
        });
        return charCodes;
      }
      function addToMapOfArrays(map3, key, value) {
        if (map3[key] === void 0) {
          map3[key] = [value];
        } else {
          map3[key].push(value);
        }
      }
      exports2.minOptimizationVal = 256;
      function charCodeToOptimizedIndex(charCode) {
        return charCode < exports2.minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];
      }
      exports2.charCodeToOptimizedIndex = charCodeToOptimizedIndex;
      var charCodeToOptimizedIdxMap = [];
      function initCharCodeToOptimizedIndexMap() {
        if (utils_1.isEmpty(charCodeToOptimizedIdxMap)) {
          charCodeToOptimizedIdxMap = new Array(65536);
          for (var i = 0; i < 65536; i++) {
            charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;
          }
        }
      }
    }
  });

  // node_modules/chevrotain/lib/src/scan/tokens.js
  var require_tokens = __commonJS({
    "node_modules/chevrotain/lib/src/scan/tokens.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isTokenType = exports2.hasExtendingTokensTypesMapProperty = exports2.hasExtendingTokensTypesProperty = exports2.hasCategoriesProperty = exports2.hasShortKeyProperty = exports2.singleAssignCategoriesToksMap = exports2.assignCategoriesMapProp = exports2.assignCategoriesTokensProp = exports2.assignTokenDefaultProps = exports2.expandCategories = exports2.augmentTokenTypes = exports2.tokenIdxToClass = exports2.tokenShortNameIdx = exports2.tokenStructuredMatcherNoCategories = exports2.tokenStructuredMatcher = void 0;
      var utils_1 = require_utils();
      function tokenStructuredMatcher(tokInstance, tokConstructor) {
        var instanceType = tokInstance.tokenTypeIdx;
        if (instanceType === tokConstructor.tokenTypeIdx) {
          return true;
        } else {
          return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;
        }
      }
      exports2.tokenStructuredMatcher = tokenStructuredMatcher;
      function tokenStructuredMatcherNoCategories(token, tokType) {
        return token.tokenTypeIdx === tokType.tokenTypeIdx;
      }
      exports2.tokenStructuredMatcherNoCategories = tokenStructuredMatcherNoCategories;
      exports2.tokenShortNameIdx = 1;
      exports2.tokenIdxToClass = {};
      function augmentTokenTypes(tokenTypes) {
        var tokenTypesAndParents = expandCategories(tokenTypes);
        assignTokenDefaultProps(tokenTypesAndParents);
        assignCategoriesMapProp(tokenTypesAndParents);
        assignCategoriesTokensProp(tokenTypesAndParents);
        utils_1.forEach(tokenTypesAndParents, function(tokType) {
          tokType.isParent = tokType.categoryMatches.length > 0;
        });
      }
      exports2.augmentTokenTypes = augmentTokenTypes;
      function expandCategories(tokenTypes) {
        var result = utils_1.cloneArr(tokenTypes);
        var categories = tokenTypes;
        var searching = true;
        while (searching) {
          categories = utils_1.compact(utils_1.flatten(utils_1.map(categories, function(currTokType) {
            return currTokType.CATEGORIES;
          })));
          var newCategories = utils_1.difference(categories, result);
          result = result.concat(newCategories);
          if (utils_1.isEmpty(newCategories)) {
            searching = false;
          } else {
            categories = newCategories;
          }
        }
        return result;
      }
      exports2.expandCategories = expandCategories;
      function assignTokenDefaultProps(tokenTypes) {
        utils_1.forEach(tokenTypes, function(currTokType) {
          if (!hasShortKeyProperty(currTokType)) {
            exports2.tokenIdxToClass[exports2.tokenShortNameIdx] = currTokType;
            currTokType.tokenTypeIdx = exports2.tokenShortNameIdx++;
          }
          if (hasCategoriesProperty(currTokType) && !utils_1.isArray(currTokType.CATEGORIES)) {
            currTokType.CATEGORIES = [currTokType.CATEGORIES];
          }
          if (!hasCategoriesProperty(currTokType)) {
            currTokType.CATEGORIES = [];
          }
          if (!hasExtendingTokensTypesProperty(currTokType)) {
            currTokType.categoryMatches = [];
          }
          if (!hasExtendingTokensTypesMapProperty(currTokType)) {
            currTokType.categoryMatchesMap = {};
          }
        });
      }
      exports2.assignTokenDefaultProps = assignTokenDefaultProps;
      function assignCategoriesTokensProp(tokenTypes) {
        utils_1.forEach(tokenTypes, function(currTokType) {
          currTokType.categoryMatches = [];
          utils_1.forEach(currTokType.categoryMatchesMap, function(val, key) {
            currTokType.categoryMatches.push(exports2.tokenIdxToClass[key].tokenTypeIdx);
          });
        });
      }
      exports2.assignCategoriesTokensProp = assignCategoriesTokensProp;
      function assignCategoriesMapProp(tokenTypes) {
        utils_1.forEach(tokenTypes, function(currTokType) {
          singleAssignCategoriesToksMap([], currTokType);
        });
      }
      exports2.assignCategoriesMapProp = assignCategoriesMapProp;
      function singleAssignCategoriesToksMap(path, nextNode) {
        utils_1.forEach(path, function(pathNode) {
          nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;
        });
        utils_1.forEach(nextNode.CATEGORIES, function(nextCategory) {
          var newPath = path.concat(nextNode);
          if (!utils_1.contains(newPath, nextCategory)) {
            singleAssignCategoriesToksMap(newPath, nextCategory);
          }
        });
      }
      exports2.singleAssignCategoriesToksMap = singleAssignCategoriesToksMap;
      function hasShortKeyProperty(tokType) {
        return utils_1.has(tokType, "tokenTypeIdx");
      }
      exports2.hasShortKeyProperty = hasShortKeyProperty;
      function hasCategoriesProperty(tokType) {
        return utils_1.has(tokType, "CATEGORIES");
      }
      exports2.hasCategoriesProperty = hasCategoriesProperty;
      function hasExtendingTokensTypesProperty(tokType) {
        return utils_1.has(tokType, "categoryMatches");
      }
      exports2.hasExtendingTokensTypesProperty = hasExtendingTokensTypesProperty;
      function hasExtendingTokensTypesMapProperty(tokType) {
        return utils_1.has(tokType, "categoryMatchesMap");
      }
      exports2.hasExtendingTokensTypesMapProperty = hasExtendingTokensTypesMapProperty;
      function isTokenType(tokType) {
        return utils_1.has(tokType, "tokenTypeIdx");
      }
      exports2.isTokenType = isTokenType;
    }
  });

  // node_modules/chevrotain/lib/src/scan/lexer_errors_public.js
  var require_lexer_errors_public = __commonJS({
    "node_modules/chevrotain/lib/src/scan/lexer_errors_public.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.defaultLexerErrorProvider = void 0;
      exports2.defaultLexerErrorProvider = {
        buildUnableToPopLexerModeMessage: function(token) {
          return "Unable to pop Lexer Mode after encountering Token ->" + token.image + "<- The Mode Stack is empty";
        },
        buildUnexpectedCharactersMessage: function(fullText, startOffset, length, line, column) {
          return "unexpected character: ->" + fullText.charAt(startOffset) + "<- at offset: " + startOffset + "," + (" skipped " + length + " characters.");
        }
      };
    }
  });

  // node_modules/chevrotain/lib/src/scan/lexer_public.js
  var require_lexer_public = __commonJS({
    "node_modules/chevrotain/lib/src/scan/lexer_public.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Lexer = exports2.LexerDefinitionErrorType = void 0;
      var lexer_1 = require_lexer();
      var utils_1 = require_utils();
      var tokens_1 = require_tokens();
      var lexer_errors_public_1 = require_lexer_errors_public();
      var reg_exp_parser_1 = require_reg_exp_parser();
      var LexerDefinitionErrorType;
      (function(LexerDefinitionErrorType2) {
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["MISSING_PATTERN"] = 0] = "MISSING_PATTERN";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["INVALID_PATTERN"] = 1] = "INVALID_PATTERN";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["EOI_ANCHOR_FOUND"] = 2] = "EOI_ANCHOR_FOUND";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["UNSUPPORTED_FLAGS_FOUND"] = 3] = "UNSUPPORTED_FLAGS_FOUND";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["DUPLICATE_PATTERNS_FOUND"] = 4] = "DUPLICATE_PATTERNS_FOUND";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["INVALID_GROUP_TYPE_FOUND"] = 5] = "INVALID_GROUP_TYPE_FOUND";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["PUSH_MODE_DOES_NOT_EXIST"] = 6] = "PUSH_MODE_DOES_NOT_EXIST";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE"] = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY"] = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST"] = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED"] = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["SOI_ANCHOR_FOUND"] = 11] = "SOI_ANCHOR_FOUND";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["EMPTY_MATCH_PATTERN"] = 12] = "EMPTY_MATCH_PATTERN";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["NO_LINE_BREAKS_FLAGS"] = 13] = "NO_LINE_BREAKS_FLAGS";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["UNREACHABLE_PATTERN"] = 14] = "UNREACHABLE_PATTERN";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["IDENTIFY_TERMINATOR"] = 15] = "IDENTIFY_TERMINATOR";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["CUSTOM_LINE_BREAK"] = 16] = "CUSTOM_LINE_BREAK";
      })(LexerDefinitionErrorType = exports2.LexerDefinitionErrorType || (exports2.LexerDefinitionErrorType = {}));
      var DEFAULT_LEXER_CONFIG = {
        deferDefinitionErrorsHandling: false,
        positionTracking: "full",
        lineTerminatorsPattern: /\n|\r\n?/g,
        lineTerminatorCharacters: ["\n", "\r"],
        ensureOptimizations: false,
        safeMode: false,
        errorMessageProvider: lexer_errors_public_1.defaultLexerErrorProvider,
        traceInitPerf: false,
        skipValidations: false
      };
      Object.freeze(DEFAULT_LEXER_CONFIG);
      var Lexer = (
        /** @class */
        (function() {
          function Lexer2(lexerDefinition, config) {
            var _this = this;
            if (config === void 0) {
              config = DEFAULT_LEXER_CONFIG;
            }
            this.lexerDefinition = lexerDefinition;
            this.lexerDefinitionErrors = [];
            this.lexerDefinitionWarning = [];
            this.patternIdxToConfig = {};
            this.charCodeToPatternIdxToConfig = {};
            this.modes = [];
            this.emptyGroups = {};
            this.config = void 0;
            this.trackStartLines = true;
            this.trackEndLines = true;
            this.hasCustom = false;
            this.canModeBeOptimized = {};
            if (typeof config === "boolean") {
              throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\na boolean 2nd argument is no longer supported");
            }
            this.config = utils_1.merge(DEFAULT_LEXER_CONFIG, config);
            var traceInitVal = this.config.traceInitPerf;
            if (traceInitVal === true) {
              this.traceInitMaxIdent = Infinity;
              this.traceInitPerf = true;
            } else if (typeof traceInitVal === "number") {
              this.traceInitMaxIdent = traceInitVal;
              this.traceInitPerf = true;
            }
            this.traceInitIndent = -1;
            this.TRACE_INIT("Lexer Constructor", function() {
              var actualDefinition;
              var hasOnlySingleMode = true;
              _this.TRACE_INIT("Lexer Config handling", function() {
                if (_this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {
                  _this.config.lineTerminatorsPattern = lexer_1.LineTerminatorOptimizedTester;
                } else {
                  if (_this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {
                    throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");
                  }
                }
                if (config.safeMode && config.ensureOptimizations) {
                  throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
                }
                _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);
                _this.trackEndLines = /full/i.test(_this.config.positionTracking);
                if (utils_1.isArray(lexerDefinition)) {
                  actualDefinition = { modes: {} };
                  actualDefinition.modes[lexer_1.DEFAULT_MODE] = utils_1.cloneArr(lexerDefinition);
                  actualDefinition[lexer_1.DEFAULT_MODE] = lexer_1.DEFAULT_MODE;
                } else {
                  hasOnlySingleMode = false;
                  actualDefinition = utils_1.cloneObj(lexerDefinition);
                }
              });
              if (_this.config.skipValidations === false) {
                _this.TRACE_INIT("performRuntimeChecks", function() {
                  _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(lexer_1.performRuntimeChecks(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
                });
                _this.TRACE_INIT("performWarningRuntimeChecks", function() {
                  _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat(lexer_1.performWarningRuntimeChecks(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
                });
              }
              actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {};
              utils_1.forEach(actualDefinition.modes, function(currModeValue, currModeName) {
                actualDefinition.modes[currModeName] = utils_1.reject(currModeValue, function(currTokType) {
                  return utils_1.isUndefined(currTokType);
                });
              });
              var allModeNames = utils_1.keys(actualDefinition.modes);
              utils_1.forEach(actualDefinition.modes, function(currModDef, currModName) {
                _this.TRACE_INIT("Mode: <" + currModName + "> processing", function() {
                  _this.modes.push(currModName);
                  if (_this.config.skipValidations === false) {
                    _this.TRACE_INIT("validatePatterns", function() {
                      _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(lexer_1.validatePatterns(currModDef, allModeNames));
                    });
                  }
                  if (utils_1.isEmpty(_this.lexerDefinitionErrors)) {
                    tokens_1.augmentTokenTypes(currModDef);
                    var currAnalyzeResult_1;
                    _this.TRACE_INIT("analyzeTokenTypes", function() {
                      currAnalyzeResult_1 = lexer_1.analyzeTokenTypes(currModDef, {
                        lineTerminatorCharacters: _this.config.lineTerminatorCharacters,
                        positionTracking: config.positionTracking,
                        ensureOptimizations: config.ensureOptimizations,
                        safeMode: config.safeMode,
                        tracer: _this.TRACE_INIT.bind(_this)
                      });
                    });
                    _this.patternIdxToConfig[currModName] = currAnalyzeResult_1.patternIdxToConfig;
                    _this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult_1.charCodeToPatternIdxToConfig;
                    _this.emptyGroups = utils_1.merge(_this.emptyGroups, currAnalyzeResult_1.emptyGroups);
                    _this.hasCustom = currAnalyzeResult_1.hasCustom || _this.hasCustom;
                    _this.canModeBeOptimized[currModName] = currAnalyzeResult_1.canBeOptimized;
                  }
                });
              });
              _this.defaultMode = actualDefinition.defaultMode;
              if (!utils_1.isEmpty(_this.lexerDefinitionErrors) && !_this.config.deferDefinitionErrorsHandling) {
                var allErrMessages = utils_1.map(_this.lexerDefinitionErrors, function(error) {
                  return error.message;
                });
                var allErrMessagesString = allErrMessages.join("-----------------------\n");
                throw new Error("Errors detected in definition of Lexer:\n" + allErrMessagesString);
              }
              utils_1.forEach(_this.lexerDefinitionWarning, function(warningDescriptor) {
                utils_1.PRINT_WARNING(warningDescriptor.message);
              });
              _this.TRACE_INIT("Choosing sub-methods implementations", function() {
                if (lexer_1.SUPPORT_STICKY) {
                  _this.chopInput = utils_1.IDENTITY;
                  _this.match = _this.matchWithTest;
                } else {
                  _this.updateLastIndex = utils_1.NOOP;
                  _this.match = _this.matchWithExec;
                }
                if (hasOnlySingleMode) {
                  _this.handleModes = utils_1.NOOP;
                }
                if (_this.trackStartLines === false) {
                  _this.computeNewColumn = utils_1.IDENTITY;
                }
                if (_this.trackEndLines === false) {
                  _this.updateTokenEndLineColumnLocation = utils_1.NOOP;
                }
                if (/full/i.test(_this.config.positionTracking)) {
                  _this.createTokenInstance = _this.createFullToken;
                } else if (/onlyStart/i.test(_this.config.positionTracking)) {
                  _this.createTokenInstance = _this.createStartOnlyToken;
                } else if (/onlyOffset/i.test(_this.config.positionTracking)) {
                  _this.createTokenInstance = _this.createOffsetOnlyToken;
                } else {
                  throw Error('Invalid <positionTracking> config option: "' + _this.config.positionTracking + '"');
                }
                if (_this.hasCustom) {
                  _this.addToken = _this.addTokenUsingPush;
                  _this.handlePayload = _this.handlePayloadWithCustom;
                } else {
                  _this.addToken = _this.addTokenUsingMemberAccess;
                  _this.handlePayload = _this.handlePayloadNoCustom;
                }
              });
              _this.TRACE_INIT("Failed Optimization Warnings", function() {
                var unOptimizedModes = utils_1.reduce(_this.canModeBeOptimized, function(cannotBeOptimized, canBeOptimized, modeName) {
                  if (canBeOptimized === false) {
                    cannotBeOptimized.push(modeName);
                  }
                  return cannotBeOptimized;
                }, []);
                if (config.ensureOptimizations && !utils_1.isEmpty(unOptimizedModes)) {
                  throw Error("Lexer Modes: < " + unOptimizedModes.join(", ") + ' > cannot be optimized.\n	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n	 Or inspect the console log for details on how to resolve these issues.');
                }
              });
              _this.TRACE_INIT("clearRegExpParserCache", function() {
                reg_exp_parser_1.clearRegExpParserCache();
              });
              _this.TRACE_INIT("toFastProperties", function() {
                utils_1.toFastProperties(_this);
              });
            });
          }
          Lexer2.prototype.tokenize = function(text, initialMode) {
            if (initialMode === void 0) {
              initialMode = this.defaultMode;
            }
            if (!utils_1.isEmpty(this.lexerDefinitionErrors)) {
              var allErrMessages = utils_1.map(this.lexerDefinitionErrors, function(error) {
                return error.message;
              });
              var allErrMessagesString = allErrMessages.join("-----------------------\n");
              throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n" + allErrMessagesString);
            }
            var lexResult = this.tokenizeInternal(text, initialMode);
            return lexResult;
          };
          Lexer2.prototype.tokenizeInternal = function(text, initialMode) {
            var _this = this;
            var i, j, matchAltImage, longerAltIdx, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;
            var orgText = text;
            var orgLength = orgText.length;
            var offset = 0;
            var matchedTokensIndex = 0;
            var guessedNumberOfTokens = this.hasCustom ? 0 : Math.floor(text.length / 10);
            var matchedTokens = new Array(guessedNumberOfTokens);
            var errors = [];
            var line = this.trackStartLines ? 1 : void 0;
            var column = this.trackStartLines ? 1 : void 0;
            var groups = lexer_1.cloneEmptyGroups(this.emptyGroups);
            var trackLines = this.trackStartLines;
            var lineTerminatorPattern = this.config.lineTerminatorsPattern;
            var currModePatternsLength = 0;
            var patternIdxToConfig = [];
            var currCharCodeToPatternIdxToConfig = [];
            var modeStack = [];
            var emptyArray = [];
            Object.freeze(emptyArray);
            var getPossiblePatterns = void 0;
            function getPossiblePatternsSlow() {
              return patternIdxToConfig;
            }
            function getPossiblePatternsOptimized(charCode) {
              var optimizedCharIdx = lexer_1.charCodeToOptimizedIndex(charCode);
              var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];
              if (possiblePatterns === void 0) {
                return emptyArray;
              } else {
                return possiblePatterns;
              }
            }
            var pop_mode = function(popToken) {
              if (modeStack.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a "transition"
              // So no error should occur.
              popToken.tokenType.PUSH_MODE === void 0) {
                var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);
                errors.push({
                  offset: popToken.startOffset,
                  line: popToken.startLine !== void 0 ? popToken.startLine : void 0,
                  column: popToken.startColumn !== void 0 ? popToken.startColumn : void 0,
                  length: popToken.image.length,
                  message: msg_1
                });
              } else {
                modeStack.pop();
                var newMode = utils_1.last(modeStack);
                patternIdxToConfig = _this.patternIdxToConfig[newMode];
                currCharCodeToPatternIdxToConfig = _this.charCodeToPatternIdxToConfig[newMode];
                currModePatternsLength = patternIdxToConfig.length;
                var modeCanBeOptimized = _this.canModeBeOptimized[newMode] && _this.config.safeMode === false;
                if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
                  getPossiblePatterns = getPossiblePatternsOptimized;
                } else {
                  getPossiblePatterns = getPossiblePatternsSlow;
                }
              }
            };
            function push_mode(newMode) {
              modeStack.push(newMode);
              currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];
              patternIdxToConfig = this.patternIdxToConfig[newMode];
              currModePatternsLength = patternIdxToConfig.length;
              currModePatternsLength = patternIdxToConfig.length;
              var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;
              if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
                getPossiblePatterns = getPossiblePatternsOptimized;
              } else {
                getPossiblePatterns = getPossiblePatternsSlow;
              }
            }
            push_mode.call(this, initialMode);
            var currConfig;
            while (offset < orgLength) {
              matchedImage = null;
              var nextCharCode = orgText.charCodeAt(offset);
              var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);
              var chosenPatternsLength = chosenPatternIdxToConfig.length;
              for (i = 0; i < chosenPatternsLength; i++) {
                currConfig = chosenPatternIdxToConfig[i];
                var currPattern = currConfig.pattern;
                payload = null;
                var singleCharCode = currConfig.short;
                if (singleCharCode !== false) {
                  if (nextCharCode === singleCharCode) {
                    matchedImage = currPattern;
                  }
                } else if (currConfig.isCustom === true) {
                  match = currPattern.exec(orgText, offset, matchedTokens, groups);
                  if (match !== null) {
                    matchedImage = match[0];
                    if (match.payload !== void 0) {
                      payload = match.payload;
                    }
                  } else {
                    matchedImage = null;
                  }
                } else {
                  this.updateLastIndex(currPattern, offset);
                  matchedImage = this.match(currPattern, text, offset);
                }
                if (matchedImage !== null) {
                  longerAltIdx = currConfig.longerAlt;
                  if (longerAltIdx !== void 0) {
                    var longerAltConfig = patternIdxToConfig[longerAltIdx];
                    var longerAltPattern = longerAltConfig.pattern;
                    altPayload = null;
                    if (longerAltConfig.isCustom === true) {
                      match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);
                      if (match !== null) {
                        matchAltImage = match[0];
                        if (match.payload !== void 0) {
                          altPayload = match.payload;
                        }
                      } else {
                        matchAltImage = null;
                      }
                    } else {
                      this.updateLastIndex(longerAltPattern, offset);
                      matchAltImage = this.match(longerAltPattern, text, offset);
                    }
                    if (matchAltImage && matchAltImage.length > matchedImage.length) {
                      matchedImage = matchAltImage;
                      payload = altPayload;
                      currConfig = longerAltConfig;
                    }
                  }
                  break;
                }
              }
              if (matchedImage !== null) {
                imageLength = matchedImage.length;
                group = currConfig.group;
                if (group !== void 0) {
                  tokType = currConfig.tokenTypeIdx;
                  newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);
                  this.handlePayload(newToken, payload);
                  if (group === false) {
                    matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);
                  } else {
                    groups[group].push(newToken);
                  }
                }
                text = this.chopInput(text, imageLength);
                offset = offset + imageLength;
                column = this.computeNewColumn(column, imageLength);
                if (trackLines === true && currConfig.canLineTerminator === true) {
                  var numOfLTsInMatch = 0;
                  var foundTerminator = void 0;
                  var lastLTEndOffset = void 0;
                  lineTerminatorPattern.lastIndex = 0;
                  do {
                    foundTerminator = lineTerminatorPattern.test(matchedImage);
                    if (foundTerminator === true) {
                      lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;
                      numOfLTsInMatch++;
                    }
                  } while (foundTerminator === true);
                  if (numOfLTsInMatch !== 0) {
                    line = line + numOfLTsInMatch;
                    column = imageLength - lastLTEndOffset;
                    this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);
                  }
                }
                this.handleModes(currConfig, pop_mode, push_mode, newToken);
              } else {
                var errorStartOffset = offset;
                var errorLine = line;
                var errorColumn = column;
                var foundResyncPoint = false;
                while (!foundResyncPoint && offset < orgLength) {
                  droppedChar = orgText.charCodeAt(offset);
                  text = this.chopInput(text, 1);
                  offset++;
                  for (j = 0; j < currModePatternsLength; j++) {
                    var currConfig_1 = patternIdxToConfig[j];
                    var currPattern = currConfig_1.pattern;
                    var singleCharCode = currConfig_1.short;
                    if (singleCharCode !== false) {
                      if (orgText.charCodeAt(offset) === singleCharCode) {
                        foundResyncPoint = true;
                      }
                    } else if (currConfig_1.isCustom === true) {
                      foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;
                    } else {
                      this.updateLastIndex(currPattern, offset);
                      foundResyncPoint = currPattern.exec(text) !== null;
                    }
                    if (foundResyncPoint === true) {
                      break;
                    }
                  }
                }
                errLength = offset - errorStartOffset;
                msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);
                errors.push({
                  offset: errorStartOffset,
                  line: errorLine,
                  column: errorColumn,
                  length: errLength,
                  message: msg
                });
              }
            }
            if (!this.hasCustom) {
              matchedTokens.length = matchedTokensIndex;
            }
            return {
              tokens: matchedTokens,
              groups,
              errors
            };
          };
          Lexer2.prototype.handleModes = function(config, pop_mode, push_mode, newToken) {
            if (config.pop === true) {
              var pushMode = config.push;
              pop_mode(newToken);
              if (pushMode !== void 0) {
                push_mode.call(this, pushMode);
              }
            } else if (config.push !== void 0) {
              push_mode.call(this, config.push);
            }
          };
          Lexer2.prototype.chopInput = function(text, length) {
            return text.substring(length);
          };
          Lexer2.prototype.updateLastIndex = function(regExp, newLastIndex) {
            regExp.lastIndex = newLastIndex;
          };
          Lexer2.prototype.updateTokenEndLineColumnLocation = function(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {
            var lastCharIsLT, fixForEndingInLT;
            if (group !== void 0) {
              lastCharIsLT = lastLTIdx === imageLength - 1;
              fixForEndingInLT = lastCharIsLT ? -1 : 0;
              if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {
                newToken.endLine = line + fixForEndingInLT;
                newToken.endColumn = column - 1 + -fixForEndingInLT;
              }
            }
          };
          Lexer2.prototype.computeNewColumn = function(oldColumn, imageLength) {
            return oldColumn + imageLength;
          };
          Lexer2.prototype.createTokenInstance = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return null;
          };
          Lexer2.prototype.createOffsetOnlyToken = function(image, startOffset, tokenTypeIdx, tokenType) {
            return {
              image,
              startOffset,
              tokenTypeIdx,
              tokenType
            };
          };
          Lexer2.prototype.createStartOnlyToken = function(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {
            return {
              image,
              startOffset,
              startLine,
              startColumn,
              tokenTypeIdx,
              tokenType
            };
          };
          Lexer2.prototype.createFullToken = function(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {
            return {
              image,
              startOffset,
              endOffset: startOffset + imageLength - 1,
              startLine,
              endLine: startLine,
              startColumn,
              endColumn: startColumn + imageLength - 1,
              tokenTypeIdx,
              tokenType
            };
          };
          Lexer2.prototype.addToken = function(tokenVector, index, tokenToAdd) {
            return 666;
          };
          Lexer2.prototype.addTokenUsingPush = function(tokenVector, index, tokenToAdd) {
            tokenVector.push(tokenToAdd);
            return index;
          };
          Lexer2.prototype.addTokenUsingMemberAccess = function(tokenVector, index, tokenToAdd) {
            tokenVector[index] = tokenToAdd;
            index++;
            return index;
          };
          Lexer2.prototype.handlePayload = function(token, payload) {
          };
          Lexer2.prototype.handlePayloadNoCustom = function(token, payload) {
          };
          Lexer2.prototype.handlePayloadWithCustom = function(token, payload) {
            if (payload !== null) {
              token.payload = payload;
            }
          };
          Lexer2.prototype.match = function(pattern, text, offset) {
            return null;
          };
          Lexer2.prototype.matchWithTest = function(pattern, text, offset) {
            var found = pattern.test(text);
            if (found === true) {
              return text.substring(offset, pattern.lastIndex);
            }
            return null;
          };
          Lexer2.prototype.matchWithExec = function(pattern, text) {
            var regExpArray = pattern.exec(text);
            return regExpArray !== null ? regExpArray[0] : regExpArray;
          };
          Lexer2.prototype.TRACE_INIT = function(phaseDesc, phaseImpl) {
            if (this.traceInitPerf === true) {
              this.traceInitIndent++;
              var indent = new Array(this.traceInitIndent + 1).join("	");
              if (this.traceInitIndent < this.traceInitMaxIdent) {
                console.log(indent + "--> <" + phaseDesc + ">");
              }
              var _a = utils_1.timer(phaseImpl), time = _a.time, value = _a.value;
              var traceMethod = time > 10 ? console.warn : console.log;
              if (this.traceInitIndent < this.traceInitMaxIdent) {
                traceMethod(indent + "<-- <" + phaseDesc + "> time: " + time + "ms");
              }
              this.traceInitIndent--;
              return value;
            } else {
              return phaseImpl();
            }
          };
          Lexer2.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";
          Lexer2.NA = /NOT_APPLICABLE/;
          return Lexer2;
        })()
      );
      exports2.Lexer = Lexer;
    }
  });

  // node_modules/chevrotain/lib/src/scan/tokens_public.js
  var require_tokens_public = __commonJS({
    "node_modules/chevrotain/lib/src/scan/tokens_public.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.tokenMatcher = exports2.createTokenInstance = exports2.EOF = exports2.createToken = exports2.hasTokenLabel = exports2.tokenName = exports2.tokenLabel = void 0;
      var utils_1 = require_utils();
      var lexer_public_1 = require_lexer_public();
      var tokens_1 = require_tokens();
      function tokenLabel(tokType) {
        if (hasTokenLabel(tokType)) {
          return tokType.LABEL;
        } else {
          return tokType.name;
        }
      }
      exports2.tokenLabel = tokenLabel;
      function tokenName(tokType) {
        return tokType.name;
      }
      exports2.tokenName = tokenName;
      function hasTokenLabel(obj) {
        return utils_1.isString(obj.LABEL) && obj.LABEL !== "";
      }
      exports2.hasTokenLabel = hasTokenLabel;
      var PARENT = "parent";
      var CATEGORIES = "categories";
      var LABEL = "label";
      var GROUP = "group";
      var PUSH_MODE = "push_mode";
      var POP_MODE = "pop_mode";
      var LONGER_ALT = "longer_alt";
      var LINE_BREAKS = "line_breaks";
      var START_CHARS_HINT = "start_chars_hint";
      function createToken(config) {
        return createTokenInternal(config);
      }
      exports2.createToken = createToken;
      function createTokenInternal(config) {
        var pattern = config.pattern;
        var tokenType = {};
        tokenType.name = config.name;
        if (!utils_1.isUndefined(pattern)) {
          tokenType.PATTERN = pattern;
        }
        if (utils_1.has(config, PARENT)) {
          throw "The parent property is no longer supported.\nSee: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.";
        }
        if (utils_1.has(config, CATEGORIES)) {
          tokenType.CATEGORIES = config[CATEGORIES];
        }
        tokens_1.augmentTokenTypes([tokenType]);
        if (utils_1.has(config, LABEL)) {
          tokenType.LABEL = config[LABEL];
        }
        if (utils_1.has(config, GROUP)) {
          tokenType.GROUP = config[GROUP];
        }
        if (utils_1.has(config, POP_MODE)) {
          tokenType.POP_MODE = config[POP_MODE];
        }
        if (utils_1.has(config, PUSH_MODE)) {
          tokenType.PUSH_MODE = config[PUSH_MODE];
        }
        if (utils_1.has(config, LONGER_ALT)) {
          tokenType.LONGER_ALT = config[LONGER_ALT];
        }
        if (utils_1.has(config, LINE_BREAKS)) {
          tokenType.LINE_BREAKS = config[LINE_BREAKS];
        }
        if (utils_1.has(config, START_CHARS_HINT)) {
          tokenType.START_CHARS_HINT = config[START_CHARS_HINT];
        }
        return tokenType;
      }
      exports2.EOF = createToken({ name: "EOF", pattern: lexer_public_1.Lexer.NA });
      tokens_1.augmentTokenTypes([exports2.EOF]);
      function createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {
        return {
          image,
          startOffset,
          endOffset,
          startLine,
          endLine,
          startColumn,
          endColumn,
          tokenTypeIdx: tokType.tokenTypeIdx,
          tokenType: tokType
        };
      }
      exports2.createTokenInstance = createTokenInstance;
      function tokenMatcher(token, tokType) {
        return tokens_1.tokenStructuredMatcher(token, tokType);
      }
      exports2.tokenMatcher = tokenMatcher;
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/gast/gast_public.js
  var require_gast_public = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/gast/gast_public.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d, b) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics2(d, b);
        };
        return function(d, b) {
          extendStatics2(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      })();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.serializeProduction = exports2.serializeGrammar = exports2.Terminal = exports2.Alternation = exports2.RepetitionWithSeparator = exports2.Repetition = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Option = exports2.Alternative = exports2.Rule = exports2.NonTerminal = exports2.AbstractProduction = void 0;
      var utils_1 = require_utils();
      var tokens_public_1 = require_tokens_public();
      var AbstractProduction = (
        /** @class */
        (function() {
          function AbstractProduction2(_definition) {
            this._definition = _definition;
          }
          Object.defineProperty(AbstractProduction2.prototype, "definition", {
            get: function() {
              return this._definition;
            },
            set: function(value) {
              this._definition = value;
            },
            enumerable: false,
            configurable: true
          });
          AbstractProduction2.prototype.accept = function(visitor) {
            visitor.visit(this);
            utils_1.forEach(this.definition, function(prod) {
              prod.accept(visitor);
            });
          };
          return AbstractProduction2;
        })()
      );
      exports2.AbstractProduction = AbstractProduction;
      var NonTerminal = (
        /** @class */
        (function(_super) {
          __extends2(NonTerminal2, _super);
          function NonTerminal2(options) {
            var _this = _super.call(this, []) || this;
            _this.idx = 1;
            utils_1.assign(_this, utils_1.pick(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          Object.defineProperty(NonTerminal2.prototype, "definition", {
            get: function() {
              if (this.referencedRule !== void 0) {
                return this.referencedRule.definition;
              }
              return [];
            },
            set: function(definition) {
            },
            enumerable: false,
            configurable: true
          });
          NonTerminal2.prototype.accept = function(visitor) {
            visitor.visit(this);
          };
          return NonTerminal2;
        })(AbstractProduction)
      );
      exports2.NonTerminal = NonTerminal;
      var Rule = (
        /** @class */
        (function(_super) {
          __extends2(Rule2, _super);
          function Rule2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.orgText = "";
            utils_1.assign(_this, utils_1.pick(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          return Rule2;
        })(AbstractProduction)
      );
      exports2.Rule = Rule;
      var Alternative = (
        /** @class */
        (function(_super) {
          __extends2(Alternative2, _super);
          function Alternative2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.ignoreAmbiguities = false;
            utils_1.assign(_this, utils_1.pick(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          return Alternative2;
        })(AbstractProduction)
      );
      exports2.Alternative = Alternative;
      var Option = (
        /** @class */
        (function(_super) {
          __extends2(Option2, _super);
          function Option2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.idx = 1;
            utils_1.assign(_this, utils_1.pick(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          return Option2;
        })(AbstractProduction)
      );
      exports2.Option = Option;
      var RepetitionMandatory = (
        /** @class */
        (function(_super) {
          __extends2(RepetitionMandatory2, _super);
          function RepetitionMandatory2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.idx = 1;
            utils_1.assign(_this, utils_1.pick(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          return RepetitionMandatory2;
        })(AbstractProduction)
      );
      exports2.RepetitionMandatory = RepetitionMandatory;
      var RepetitionMandatoryWithSeparator = (
        /** @class */
        (function(_super) {
          __extends2(RepetitionMandatoryWithSeparator2, _super);
          function RepetitionMandatoryWithSeparator2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.idx = 1;
            utils_1.assign(_this, utils_1.pick(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          return RepetitionMandatoryWithSeparator2;
        })(AbstractProduction)
      );
      exports2.RepetitionMandatoryWithSeparator = RepetitionMandatoryWithSeparator;
      var Repetition = (
        /** @class */
        (function(_super) {
          __extends2(Repetition2, _super);
          function Repetition2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.idx = 1;
            utils_1.assign(_this, utils_1.pick(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          return Repetition2;
        })(AbstractProduction)
      );
      exports2.Repetition = Repetition;
      var RepetitionWithSeparator = (
        /** @class */
        (function(_super) {
          __extends2(RepetitionWithSeparator2, _super);
          function RepetitionWithSeparator2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.idx = 1;
            utils_1.assign(_this, utils_1.pick(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          return RepetitionWithSeparator2;
        })(AbstractProduction)
      );
      exports2.RepetitionWithSeparator = RepetitionWithSeparator;
      var Alternation = (
        /** @class */
        (function(_super) {
          __extends2(Alternation2, _super);
          function Alternation2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.idx = 1;
            _this.ignoreAmbiguities = false;
            _this.hasPredicates = false;
            utils_1.assign(_this, utils_1.pick(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          Object.defineProperty(Alternation2.prototype, "definition", {
            get: function() {
              return this._definition;
            },
            set: function(value) {
              this._definition = value;
            },
            enumerable: false,
            configurable: true
          });
          return Alternation2;
        })(AbstractProduction)
      );
      exports2.Alternation = Alternation;
      var Terminal = (
        /** @class */
        (function() {
          function Terminal2(options) {
            this.idx = 1;
            utils_1.assign(this, utils_1.pick(options, function(v) {
              return v !== void 0;
            }));
          }
          Terminal2.prototype.accept = function(visitor) {
            visitor.visit(this);
          };
          return Terminal2;
        })()
      );
      exports2.Terminal = Terminal;
      function serializeGrammar(topRules) {
        return utils_1.map(topRules, serializeProduction);
      }
      exports2.serializeGrammar = serializeGrammar;
      function serializeProduction(node) {
        function convertDefinition(definition) {
          return utils_1.map(definition, serializeProduction);
        }
        if (node instanceof NonTerminal) {
          return {
            type: "NonTerminal",
            name: node.nonTerminalName,
            idx: node.idx
          };
        } else if (node instanceof Alternative) {
          return {
            type: "Alternative",
            definition: convertDefinition(node.definition)
          };
        } else if (node instanceof Option) {
          return {
            type: "Option",
            idx: node.idx,
            definition: convertDefinition(node.definition)
          };
        } else if (node instanceof RepetitionMandatory) {
          return {
            type: "RepetitionMandatory",
            idx: node.idx,
            definition: convertDefinition(node.definition)
          };
        } else if (node instanceof RepetitionMandatoryWithSeparator) {
          return {
            type: "RepetitionMandatoryWithSeparator",
            idx: node.idx,
            separator: serializeProduction(new Terminal({ terminalType: node.separator })),
            definition: convertDefinition(node.definition)
          };
        } else if (node instanceof RepetitionWithSeparator) {
          return {
            type: "RepetitionWithSeparator",
            idx: node.idx,
            separator: serializeProduction(new Terminal({ terminalType: node.separator })),
            definition: convertDefinition(node.definition)
          };
        } else if (node instanceof Repetition) {
          return {
            type: "Repetition",
            idx: node.idx,
            definition: convertDefinition(node.definition)
          };
        } else if (node instanceof Alternation) {
          return {
            type: "Alternation",
            idx: node.idx,
            definition: convertDefinition(node.definition)
          };
        } else if (node instanceof Terminal) {
          var serializedTerminal = {
            type: "Terminal",
            name: node.terminalType.name,
            label: tokens_public_1.tokenLabel(node.terminalType),
            idx: node.idx
          };
          var pattern = node.terminalType.PATTERN;
          if (node.terminalType.PATTERN) {
            serializedTerminal.pattern = utils_1.isRegExp(pattern) ? pattern.source : pattern;
          }
          return serializedTerminal;
        } else if (node instanceof Rule) {
          return {
            type: "Rule",
            name: node.name,
            orgText: node.orgText,
            definition: convertDefinition(node.definition)
          };
        } else {
          throw Error("non exhaustive match");
        }
      }
      exports2.serializeProduction = serializeProduction;
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/rest.js
  var require_rest = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/rest.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.RestWalker = void 0;
      var utils_1 = require_utils();
      var gast_public_1 = require_gast_public();
      var RestWalker = (
        /** @class */
        (function() {
          function RestWalker2() {
          }
          RestWalker2.prototype.walk = function(prod, prevRest) {
            var _this = this;
            if (prevRest === void 0) {
              prevRest = [];
            }
            utils_1.forEach(prod.definition, function(subProd, index) {
              var currRest = utils_1.drop(prod.definition, index + 1);
              if (subProd instanceof gast_public_1.NonTerminal) {
                _this.walkProdRef(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_public_1.Terminal) {
                _this.walkTerminal(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_public_1.Alternative) {
                _this.walkFlat(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_public_1.Option) {
                _this.walkOption(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_public_1.RepetitionMandatory) {
                _this.walkAtLeastOne(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_public_1.RepetitionMandatoryWithSeparator) {
                _this.walkAtLeastOneSep(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_public_1.RepetitionWithSeparator) {
                _this.walkManySep(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_public_1.Repetition) {
                _this.walkMany(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_public_1.Alternation) {
                _this.walkOr(subProd, currRest, prevRest);
              } else {
                throw Error("non exhaustive match");
              }
            });
          };
          RestWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
          };
          RestWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
          };
          RestWalker2.prototype.walkFlat = function(flatProd, currRest, prevRest) {
            var fullOrRest = currRest.concat(prevRest);
            this.walk(flatProd, fullOrRest);
          };
          RestWalker2.prototype.walkOption = function(optionProd, currRest, prevRest) {
            var fullOrRest = currRest.concat(prevRest);
            this.walk(optionProd, fullOrRest);
          };
          RestWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
            var fullAtLeastOneRest = [
              new gast_public_1.Option({ definition: atLeastOneProd.definition })
            ].concat(currRest, prevRest);
            this.walk(atLeastOneProd, fullAtLeastOneRest);
          };
          RestWalker2.prototype.walkAtLeastOneSep = function(atLeastOneSepProd, currRest, prevRest) {
            var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);
            this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);
          };
          RestWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
            var fullManyRest = [
              new gast_public_1.Option({ definition: manyProd.definition })
            ].concat(currRest, prevRest);
            this.walk(manyProd, fullManyRest);
          };
          RestWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
            var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);
            this.walk(manySepProd, fullManySepRest);
          };
          RestWalker2.prototype.walkOr = function(orProd, currRest, prevRest) {
            var _this = this;
            var fullOrRest = currRest.concat(prevRest);
            utils_1.forEach(orProd.definition, function(alt) {
              var prodWrapper = new gast_public_1.Alternative({ definition: [alt] });
              _this.walk(prodWrapper, fullOrRest);
            });
          };
          return RestWalker2;
        })()
      );
      exports2.RestWalker = RestWalker;
      function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {
        var repSepRest = [
          new gast_public_1.Option({
            definition: [new gast_public_1.Terminal({ terminalType: repSepProd.separator })].concat(repSepProd.definition)
          })
        ];
        var fullRepSepRest = repSepRest.concat(currRest, prevRest);
        return fullRepSepRest;
      }
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/gast/gast_visitor_public.js
  var require_gast_visitor_public = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/gast/gast_visitor_public.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.GAstVisitor = void 0;
      var gast_public_1 = require_gast_public();
      var GAstVisitor = (
        /** @class */
        (function() {
          function GAstVisitor2() {
          }
          GAstVisitor2.prototype.visit = function(node) {
            var nodeAny = node;
            switch (nodeAny.constructor) {
              case gast_public_1.NonTerminal:
                return this.visitNonTerminal(nodeAny);
              case gast_public_1.Alternative:
                return this.visitAlternative(nodeAny);
              case gast_public_1.Option:
                return this.visitOption(nodeAny);
              case gast_public_1.RepetitionMandatory:
                return this.visitRepetitionMandatory(nodeAny);
              case gast_public_1.RepetitionMandatoryWithSeparator:
                return this.visitRepetitionMandatoryWithSeparator(nodeAny);
              case gast_public_1.RepetitionWithSeparator:
                return this.visitRepetitionWithSeparator(nodeAny);
              case gast_public_1.Repetition:
                return this.visitRepetition(nodeAny);
              case gast_public_1.Alternation:
                return this.visitAlternation(nodeAny);
              case gast_public_1.Terminal:
                return this.visitTerminal(nodeAny);
              case gast_public_1.Rule:
                return this.visitRule(nodeAny);
              /* istanbul ignore next */
              default:
                throw Error("non exhaustive match");
            }
          };
          GAstVisitor2.prototype.visitNonTerminal = function(node) {
          };
          GAstVisitor2.prototype.visitAlternative = function(node) {
          };
          GAstVisitor2.prototype.visitOption = function(node) {
          };
          GAstVisitor2.prototype.visitRepetition = function(node) {
          };
          GAstVisitor2.prototype.visitRepetitionMandatory = function(node) {
          };
          GAstVisitor2.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
          };
          GAstVisitor2.prototype.visitRepetitionWithSeparator = function(node) {
          };
          GAstVisitor2.prototype.visitAlternation = function(node) {
          };
          GAstVisitor2.prototype.visitTerminal = function(node) {
          };
          GAstVisitor2.prototype.visitRule = function(node) {
          };
          return GAstVisitor2;
        })()
      );
      exports2.GAstVisitor = GAstVisitor;
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/gast/gast.js
  var require_gast = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/gast/gast.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d, b) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics2(d, b);
        };
        return function(d, b) {
          extendStatics2(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      })();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.collectMethods = exports2.DslMethodsCollectorVisitor = exports2.getProductionDslName = exports2.isBranchingProd = exports2.isOptionalProd = exports2.isSequenceProd = void 0;
      var utils_1 = require_utils();
      var gast_public_1 = require_gast_public();
      var gast_visitor_public_1 = require_gast_visitor_public();
      function isSequenceProd(prod) {
        return prod instanceof gast_public_1.Alternative || prod instanceof gast_public_1.Option || prod instanceof gast_public_1.Repetition || prod instanceof gast_public_1.RepetitionMandatory || prod instanceof gast_public_1.RepetitionMandatoryWithSeparator || prod instanceof gast_public_1.RepetitionWithSeparator || prod instanceof gast_public_1.Terminal || prod instanceof gast_public_1.Rule;
      }
      exports2.isSequenceProd = isSequenceProd;
      function isOptionalProd(prod, alreadyVisited) {
        if (alreadyVisited === void 0) {
          alreadyVisited = [];
        }
        var isDirectlyOptional = prod instanceof gast_public_1.Option || prod instanceof gast_public_1.Repetition || prod instanceof gast_public_1.RepetitionWithSeparator;
        if (isDirectlyOptional) {
          return true;
        }
        if (prod instanceof gast_public_1.Alternation) {
          return utils_1.some(prod.definition, function(subProd) {
            return isOptionalProd(subProd, alreadyVisited);
          });
        } else if (prod instanceof gast_public_1.NonTerminal && utils_1.contains(alreadyVisited, prod)) {
          return false;
        } else if (prod instanceof gast_public_1.AbstractProduction) {
          if (prod instanceof gast_public_1.NonTerminal) {
            alreadyVisited.push(prod);
          }
          return utils_1.every(prod.definition, function(subProd) {
            return isOptionalProd(subProd, alreadyVisited);
          });
        } else {
          return false;
        }
      }
      exports2.isOptionalProd = isOptionalProd;
      function isBranchingProd(prod) {
        return prod instanceof gast_public_1.Alternation;
      }
      exports2.isBranchingProd = isBranchingProd;
      function getProductionDslName(prod) {
        if (prod instanceof gast_public_1.NonTerminal) {
          return "SUBRULE";
        } else if (prod instanceof gast_public_1.Option) {
          return "OPTION";
        } else if (prod instanceof gast_public_1.Alternation) {
          return "OR";
        } else if (prod instanceof gast_public_1.RepetitionMandatory) {
          return "AT_LEAST_ONE";
        } else if (prod instanceof gast_public_1.RepetitionMandatoryWithSeparator) {
          return "AT_LEAST_ONE_SEP";
        } else if (prod instanceof gast_public_1.RepetitionWithSeparator) {
          return "MANY_SEP";
        } else if (prod instanceof gast_public_1.Repetition) {
          return "MANY";
        } else if (prod instanceof gast_public_1.Terminal) {
          return "CONSUME";
        } else {
          throw Error("non exhaustive match");
        }
      }
      exports2.getProductionDslName = getProductionDslName;
      var DslMethodsCollectorVisitor = (
        /** @class */
        (function(_super) {
          __extends2(DslMethodsCollectorVisitor2, _super);
          function DslMethodsCollectorVisitor2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.separator = "-";
            _this.dslMethods = {
              option: [],
              alternation: [],
              repetition: [],
              repetitionWithSeparator: [],
              repetitionMandatory: [],
              repetitionMandatoryWithSeparator: []
            };
            return _this;
          }
          DslMethodsCollectorVisitor2.prototype.reset = function() {
            this.dslMethods = {
              option: [],
              alternation: [],
              repetition: [],
              repetitionWithSeparator: [],
              repetitionMandatory: [],
              repetitionMandatoryWithSeparator: []
            };
          };
          DslMethodsCollectorVisitor2.prototype.visitTerminal = function(terminal) {
            var key = terminal.terminalType.name + this.separator + "Terminal";
            if (!utils_1.has(this.dslMethods, key)) {
              this.dslMethods[key] = [];
            }
            this.dslMethods[key].push(terminal);
          };
          DslMethodsCollectorVisitor2.prototype.visitNonTerminal = function(subrule) {
            var key = subrule.nonTerminalName + this.separator + "Terminal";
            if (!utils_1.has(this.dslMethods, key)) {
              this.dslMethods[key] = [];
            }
            this.dslMethods[key].push(subrule);
          };
          DslMethodsCollectorVisitor2.prototype.visitOption = function(option) {
            this.dslMethods.option.push(option);
          };
          DslMethodsCollectorVisitor2.prototype.visitRepetitionWithSeparator = function(manySep) {
            this.dslMethods.repetitionWithSeparator.push(manySep);
          };
          DslMethodsCollectorVisitor2.prototype.visitRepetitionMandatory = function(atLeastOne) {
            this.dslMethods.repetitionMandatory.push(atLeastOne);
          };
          DslMethodsCollectorVisitor2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
            this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);
          };
          DslMethodsCollectorVisitor2.prototype.visitRepetition = function(many) {
            this.dslMethods.repetition.push(many);
          };
          DslMethodsCollectorVisitor2.prototype.visitAlternation = function(or) {
            this.dslMethods.alternation.push(or);
          };
          return DslMethodsCollectorVisitor2;
        })(gast_visitor_public_1.GAstVisitor)
      );
      exports2.DslMethodsCollectorVisitor = DslMethodsCollectorVisitor;
      var collectorVisitor = new DslMethodsCollectorVisitor();
      function collectMethods(rule) {
        collectorVisitor.reset();
        rule.accept(collectorVisitor);
        var dslMethods = collectorVisitor.dslMethods;
        collectorVisitor.reset();
        return dslMethods;
      }
      exports2.collectMethods = collectMethods;
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/first.js
  var require_first = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/first.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.firstForTerminal = exports2.firstForBranching = exports2.firstForSequence = exports2.first = void 0;
      var utils_1 = require_utils();
      var gast_public_1 = require_gast_public();
      var gast_1 = require_gast();
      function first2(prod) {
        if (prod instanceof gast_public_1.NonTerminal) {
          return first2(prod.referencedRule);
        } else if (prod instanceof gast_public_1.Terminal) {
          return firstForTerminal(prod);
        } else if (gast_1.isSequenceProd(prod)) {
          return firstForSequence(prod);
        } else if (gast_1.isBranchingProd(prod)) {
          return firstForBranching(prod);
        } else {
          throw Error("non exhaustive match");
        }
      }
      exports2.first = first2;
      function firstForSequence(prod) {
        var firstSet = [];
        var seq = prod.definition;
        var nextSubProdIdx = 0;
        var hasInnerProdsRemaining = seq.length > nextSubProdIdx;
        var currSubProd;
        var isLastInnerProdOptional = true;
        while (hasInnerProdsRemaining && isLastInnerProdOptional) {
          currSubProd = seq[nextSubProdIdx];
          isLastInnerProdOptional = gast_1.isOptionalProd(currSubProd);
          firstSet = firstSet.concat(first2(currSubProd));
          nextSubProdIdx = nextSubProdIdx + 1;
          hasInnerProdsRemaining = seq.length > nextSubProdIdx;
        }
        return utils_1.uniq(firstSet);
      }
      exports2.firstForSequence = firstForSequence;
      function firstForBranching(prod) {
        var allAlternativesFirsts = utils_1.map(prod.definition, function(innerProd) {
          return first2(innerProd);
        });
        return utils_1.uniq(utils_1.flatten(allAlternativesFirsts));
      }
      exports2.firstForBranching = firstForBranching;
      function firstForTerminal(terminal) {
        return [terminal.terminalType];
      }
      exports2.firstForTerminal = firstForTerminal;
    }
  });

  // node_modules/chevrotain/lib/src/parse/constants.js
  var require_constants = __commonJS({
    "node_modules/chevrotain/lib/src/parse/constants.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.IN = void 0;
      exports2.IN = "_~IN~_";
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/follow.js
  var require_follow = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/follow.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d, b) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics2(d, b);
        };
        return function(d, b) {
          extendStatics2(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      })();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.buildInProdFollowPrefix = exports2.buildBetweenProdsFollowPrefix = exports2.computeAllProdsFollows = exports2.ResyncFollowsWalker = void 0;
      var rest_1 = require_rest();
      var first_1 = require_first();
      var utils_1 = require_utils();
      var constants_1 = require_constants();
      var gast_public_1 = require_gast_public();
      var ResyncFollowsWalker = (
        /** @class */
        (function(_super) {
          __extends2(ResyncFollowsWalker2, _super);
          function ResyncFollowsWalker2(topProd) {
            var _this = _super.call(this) || this;
            _this.topProd = topProd;
            _this.follows = {};
            return _this;
          }
          ResyncFollowsWalker2.prototype.startWalking = function() {
            this.walk(this.topProd);
            return this.follows;
          };
          ResyncFollowsWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
          };
          ResyncFollowsWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
            var followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) + this.topProd.name;
            var fullRest = currRest.concat(prevRest);
            var restProd = new gast_public_1.Alternative({ definition: fullRest });
            var t_in_topProd_follows = first_1.first(restProd);
            this.follows[followName] = t_in_topProd_follows;
          };
          return ResyncFollowsWalker2;
        })(rest_1.RestWalker)
      );
      exports2.ResyncFollowsWalker = ResyncFollowsWalker;
      function computeAllProdsFollows(topProductions) {
        var reSyncFollows = {};
        utils_1.forEach(topProductions, function(topProd) {
          var currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();
          utils_1.assign(reSyncFollows, currRefsFollow);
        });
        return reSyncFollows;
      }
      exports2.computeAllProdsFollows = computeAllProdsFollows;
      function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {
        return inner.name + occurenceInParent + constants_1.IN;
      }
      exports2.buildBetweenProdsFollowPrefix = buildBetweenProdsFollowPrefix;
      function buildInProdFollowPrefix(terminal) {
        var terminalName = terminal.terminalType.name;
        return terminalName + terminal.idx + constants_1.IN;
      }
      exports2.buildInProdFollowPrefix = buildInProdFollowPrefix;
    }
  });

  // node_modules/chevrotain/lib/src/parse/errors_public.js
  var require_errors_public = __commonJS({
    "node_modules/chevrotain/lib/src/parse/errors_public.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.defaultGrammarValidatorErrorProvider = exports2.defaultGrammarResolverErrorProvider = exports2.defaultParserErrorProvider = void 0;
      var tokens_public_1 = require_tokens_public();
      var utils = require_utils();
      var utils_1 = require_utils();
      var gast_public_1 = require_gast_public();
      var gast_1 = require_gast();
      exports2.defaultParserErrorProvider = {
        buildMismatchTokenMessage: function(_a) {
          var expected = _a.expected, actual = _a.actual, previous = _a.previous, ruleName = _a.ruleName;
          var hasLabel = tokens_public_1.hasTokenLabel(expected);
          var expectedMsg = hasLabel ? "--> " + tokens_public_1.tokenLabel(expected) + " <--" : "token of type --> " + expected.name + " <--";
          var msg = "Expecting " + expectedMsg + " but found --> '" + actual.image + "' <--";
          return msg;
        },
        buildNotAllInputParsedMessage: function(_a) {
          var firstRedundant = _a.firstRedundant, ruleName = _a.ruleName;
          return "Redundant input, expecting EOF but found: " + firstRedundant.image;
        },
        buildNoViableAltMessage: function(_a) {
          var expectedPathsPerAlt = _a.expectedPathsPerAlt, actual = _a.actual, previous = _a.previous, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;
          var errPrefix = "Expecting: ";
          var actualText = utils_1.first(actual).image;
          var errSuffix = "\nbut found: '" + actualText + "'";
          if (customUserDescription) {
            return errPrefix + customUserDescription + errSuffix;
          } else {
            var allLookAheadPaths = utils_1.reduce(expectedPathsPerAlt, function(result, currAltPaths) {
              return result.concat(currAltPaths);
            }, []);
            var nextValidTokenSequences = utils_1.map(allLookAheadPaths, function(currPath) {
              return "[" + utils_1.map(currPath, function(currTokenType) {
                return tokens_public_1.tokenLabel(currTokenType);
              }).join(", ") + "]";
            });
            var nextValidSequenceItems = utils_1.map(nextValidTokenSequences, function(itemMsg, idx) {
              return "  " + (idx + 1) + ". " + itemMsg;
            });
            var calculatedDescription = "one of these possible Token sequences:\n" + nextValidSequenceItems.join("\n");
            return errPrefix + calculatedDescription + errSuffix;
          }
        },
        buildEarlyExitMessage: function(_a) {
          var expectedIterationPaths = _a.expectedIterationPaths, actual = _a.actual, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;
          var errPrefix = "Expecting: ";
          var actualText = utils_1.first(actual).image;
          var errSuffix = "\nbut found: '" + actualText + "'";
          if (customUserDescription) {
            return errPrefix + customUserDescription + errSuffix;
          } else {
            var nextValidTokenSequences = utils_1.map(expectedIterationPaths, function(currPath) {
              return "[" + utils_1.map(currPath, function(currTokenType) {
                return tokens_public_1.tokenLabel(currTokenType);
              }).join(",") + "]";
            });
            var calculatedDescription = "expecting at least one iteration which starts with one of these possible Token sequences::\n  " + ("<" + nextValidTokenSequences.join(" ,") + ">");
            return errPrefix + calculatedDescription + errSuffix;
          }
        }
      };
      Object.freeze(exports2.defaultParserErrorProvider);
      exports2.defaultGrammarResolverErrorProvider = {
        buildRuleNotFoundError: function(topLevelRule, undefinedRule) {
          var msg = "Invalid grammar, reference to a rule which is not defined: ->" + undefinedRule.nonTerminalName + "<-\ninside top level rule: ->" + topLevelRule.name + "<-";
          return msg;
        }
      };
      exports2.defaultGrammarValidatorErrorProvider = {
        buildDuplicateFoundError: function(topLevelRule, duplicateProds) {
          function getExtraProductionArgument(prod) {
            if (prod instanceof gast_public_1.Terminal) {
              return prod.terminalType.name;
            } else if (prod instanceof gast_public_1.NonTerminal) {
              return prod.nonTerminalName;
            } else {
              return "";
            }
          }
          var topLevelName = topLevelRule.name;
          var duplicateProd = utils_1.first(duplicateProds);
          var index = duplicateProd.idx;
          var dslName = gast_1.getProductionDslName(duplicateProd);
          var extraArgument = getExtraProductionArgument(duplicateProd);
          var hasExplicitIndex = index > 0;
          var msg = "->" + dslName + (hasExplicitIndex ? index : "") + "<- " + (extraArgument ? "with argument: ->" + extraArgument + "<-" : "") + "\n                  appears more than once (" + duplicateProds.length + " times) in the top level rule: ->" + topLevelName + "<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  ";
          msg = msg.replace(/[ \t]+/g, " ");
          msg = msg.replace(/\s\s+/g, "\n");
          return msg;
        },
        buildNamespaceConflictError: function(rule) {
          var errMsg = "Namespace conflict found in grammar.\n" + ("The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <" + rule.name + ">.\n") + "To resolve this make sure each Terminal and Non-Terminal names are unique\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\nand Non-Terminal names start with a lower case letter.";
          return errMsg;
        },
        buildAlternationPrefixAmbiguityError: function(options) {
          var pathMsg = utils_1.map(options.prefixPath, function(currTok) {
            return tokens_public_1.tokenLabel(currTok);
          }).join(", ");
          var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
          var errMsg = "Ambiguous alternatives: <" + options.ambiguityIndices.join(" ,") + "> due to common lookahead prefix\n" + ("in <OR" + occurrence + "> inside <" + options.topLevelRule.name + "> Rule,\n") + ("<" + pathMsg + "> may appears as a prefix path in all these alternatives.\n") + "See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\nFor Further details.";
          return errMsg;
        },
        buildAlternationAmbiguityError: function(options) {
          var pathMsg = utils_1.map(options.prefixPath, function(currtok) {
            return tokens_public_1.tokenLabel(currtok);
          }).join(", ");
          var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
          var currMessage = "Ambiguous Alternatives Detected: <" + options.ambiguityIndices.join(" ,") + "> in <OR" + occurrence + ">" + (" inside <" + options.topLevelRule.name + "> Rule,\n") + ("<" + pathMsg + "> may appears as a prefix path in all these alternatives.\n");
          currMessage = currMessage + "See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\nFor Further details.";
          return currMessage;
        },
        buildEmptyRepetitionError: function(options) {
          var dslName = gast_1.getProductionDslName(options.repetition);
          if (options.repetition.idx !== 0) {
            dslName += options.repetition.idx;
          }
          var errMsg = "The repetition <" + dslName + "> within Rule <" + options.topLevelRule.name + "> can never consume any tokens.\nThis could lead to an infinite loop.";
          return errMsg;
        },
        // TODO: remove - `errors_public` from nyc.config.js exclude
        //       once this method is fully removed from this file
        buildTokenNameError: function(options) {
          return "deprecated";
        },
        buildEmptyAlternationError: function(options) {
          var errMsg = "Ambiguous empty alternative: <" + (options.emptyChoiceIdx + 1) + ">" + (" in <OR" + options.alternation.idx + "> inside <" + options.topLevelRule.name + "> Rule.\n") + "Only the last alternative may be an empty alternative.";
          return errMsg;
        },
        buildTooManyAlternativesError: function(options) {
          var errMsg = "An Alternation cannot have more than 256 alternatives:\n" + ("<OR" + options.alternation.idx + "> inside <" + options.topLevelRule.name + "> Rule.\n has " + (options.alternation.definition.length + 1) + " alternatives.");
          return errMsg;
        },
        buildLeftRecursionError: function(options) {
          var ruleName = options.topLevelRule.name;
          var pathNames = utils.map(options.leftRecursionPath, function(currRule) {
            return currRule.name;
          });
          var leftRecursivePath = ruleName + " --> " + pathNames.concat([ruleName]).join(" --> ");
          var errMsg = "Left Recursion found in grammar.\n" + ("rule: <" + ruleName + "> can be invoked from itself (directly or indirectly)\n") + ("without consuming any Tokens. The grammar path that causes this is: \n " + leftRecursivePath + "\n") + " To fix this refactor your grammar to remove the left recursion.\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.";
          return errMsg;
        },
        // TODO: remove - `errors_public` from nyc.config.js exclude
        //       once this method is fully removed from this file
        buildInvalidRuleNameError: function(options) {
          return "deprecated";
        },
        buildDuplicateRuleNameError: function(options) {
          var ruleName;
          if (options.topLevelRule instanceof gast_public_1.Rule) {
            ruleName = options.topLevelRule.name;
          } else {
            ruleName = options.topLevelRule;
          }
          var errMsg = "Duplicate definition, rule: ->" + ruleName + "<- is already defined in the grammar: ->" + options.grammarName + "<-";
          return errMsg;
        }
      };
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/resolver.js
  var require_resolver = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/resolver.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d, b) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics2(d, b);
        };
        return function(d, b) {
          extendStatics2(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      })();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.GastRefResolverVisitor = exports2.resolveGrammar = void 0;
      var parser_1 = require_parser();
      var utils_1 = require_utils();
      var gast_visitor_public_1 = require_gast_visitor_public();
      function resolveGrammar(topLevels, errMsgProvider) {
        var refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);
        refResolver.resolveRefs();
        return refResolver.errors;
      }
      exports2.resolveGrammar = resolveGrammar;
      var GastRefResolverVisitor = (
        /** @class */
        (function(_super) {
          __extends2(GastRefResolverVisitor2, _super);
          function GastRefResolverVisitor2(nameToTopRule, errMsgProvider) {
            var _this = _super.call(this) || this;
            _this.nameToTopRule = nameToTopRule;
            _this.errMsgProvider = errMsgProvider;
            _this.errors = [];
            return _this;
          }
          GastRefResolverVisitor2.prototype.resolveRefs = function() {
            var _this = this;
            utils_1.forEach(utils_1.values(this.nameToTopRule), function(prod) {
              _this.currTopLevel = prod;
              prod.accept(_this);
            });
          };
          GastRefResolverVisitor2.prototype.visitNonTerminal = function(node) {
            var ref = this.nameToTopRule[node.nonTerminalName];
            if (!ref) {
              var msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);
              this.errors.push({
                message: msg,
                type: parser_1.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,
                ruleName: this.currTopLevel.name,
                unresolvedRefName: node.nonTerminalName
              });
            } else {
              node.referencedRule = ref;
            }
          };
          return GastRefResolverVisitor2;
        })(gast_visitor_public_1.GAstVisitor)
      );
      exports2.GastRefResolverVisitor = GastRefResolverVisitor;
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/interpreter.js
  var require_interpreter = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/interpreter.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d, b) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics2(d, b);
        };
        return function(d, b) {
          extendStatics2(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      })();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.nextPossibleTokensAfter = exports2.possiblePathsFrom = exports2.NextTerminalAfterAtLeastOneSepWalker = exports2.NextTerminalAfterAtLeastOneWalker = exports2.NextTerminalAfterManySepWalker = exports2.NextTerminalAfterManyWalker = exports2.AbstractNextTerminalAfterProductionWalker = exports2.NextAfterTokenWalker = exports2.AbstractNextPossibleTokensWalker = void 0;
      var rest_1 = require_rest();
      var utils_1 = require_utils();
      var first_1 = require_first();
      var gast_public_1 = require_gast_public();
      var AbstractNextPossibleTokensWalker = (
        /** @class */
        (function(_super) {
          __extends2(AbstractNextPossibleTokensWalker2, _super);
          function AbstractNextPossibleTokensWalker2(topProd, path) {
            var _this = _super.call(this) || this;
            _this.topProd = topProd;
            _this.path = path;
            _this.possibleTokTypes = [];
            _this.nextProductionName = "";
            _this.nextProductionOccurrence = 0;
            _this.found = false;
            _this.isAtEndOfPath = false;
            return _this;
          }
          AbstractNextPossibleTokensWalker2.prototype.startWalking = function() {
            this.found = false;
            if (this.path.ruleStack[0] !== this.topProd.name) {
              throw Error("The path does not start with the walker's top Rule!");
            }
            this.ruleStack = utils_1.cloneArr(this.path.ruleStack).reverse();
            this.occurrenceStack = utils_1.cloneArr(this.path.occurrenceStack).reverse();
            this.ruleStack.pop();
            this.occurrenceStack.pop();
            this.updateExpectedNext();
            this.walk(this.topProd);
            return this.possibleTokTypes;
          };
          AbstractNextPossibleTokensWalker2.prototype.walk = function(prod, prevRest) {
            if (prevRest === void 0) {
              prevRest = [];
            }
            if (!this.found) {
              _super.prototype.walk.call(this, prod, prevRest);
            }
          };
          AbstractNextPossibleTokensWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
            if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {
              var fullRest = currRest.concat(prevRest);
              this.updateExpectedNext();
              this.walk(refProd.referencedRule, fullRest);
            }
          };
          AbstractNextPossibleTokensWalker2.prototype.updateExpectedNext = function() {
            if (utils_1.isEmpty(this.ruleStack)) {
              this.nextProductionName = "";
              this.nextProductionOccurrence = 0;
              this.isAtEndOfPath = true;
            } else {
              this.nextProductionName = this.ruleStack.pop();
              this.nextProductionOccurrence = this.occurrenceStack.pop();
            }
          };
          return AbstractNextPossibleTokensWalker2;
        })(rest_1.RestWalker)
      );
      exports2.AbstractNextPossibleTokensWalker = AbstractNextPossibleTokensWalker;
      var NextAfterTokenWalker = (
        /** @class */
        (function(_super) {
          __extends2(NextAfterTokenWalker2, _super);
          function NextAfterTokenWalker2(topProd, path) {
            var _this = _super.call(this, topProd, path) || this;
            _this.path = path;
            _this.nextTerminalName = "";
            _this.nextTerminalOccurrence = 0;
            _this.nextTerminalName = _this.path.lastTok.name;
            _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;
            return _this;
          }
          NextAfterTokenWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
            if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {
              var fullRest = currRest.concat(prevRest);
              var restProd = new gast_public_1.Alternative({ definition: fullRest });
              this.possibleTokTypes = first_1.first(restProd);
              this.found = true;
            }
          };
          return NextAfterTokenWalker2;
        })(AbstractNextPossibleTokensWalker)
      );
      exports2.NextAfterTokenWalker = NextAfterTokenWalker;
      var AbstractNextTerminalAfterProductionWalker = (
        /** @class */
        (function(_super) {
          __extends2(AbstractNextTerminalAfterProductionWalker2, _super);
          function AbstractNextTerminalAfterProductionWalker2(topRule, occurrence) {
            var _this = _super.call(this) || this;
            _this.topRule = topRule;
            _this.occurrence = occurrence;
            _this.result = {
              token: void 0,
              occurrence: void 0,
              isEndOfRule: void 0
            };
            return _this;
          }
          AbstractNextTerminalAfterProductionWalker2.prototype.startWalking = function() {
            this.walk(this.topRule);
            return this.result;
          };
          return AbstractNextTerminalAfterProductionWalker2;
        })(rest_1.RestWalker)
      );
      exports2.AbstractNextTerminalAfterProductionWalker = AbstractNextTerminalAfterProductionWalker;
      var NextTerminalAfterManyWalker = (
        /** @class */
        (function(_super) {
          __extends2(NextTerminalAfterManyWalker2, _super);
          function NextTerminalAfterManyWalker2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          NextTerminalAfterManyWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
            if (manyProd.idx === this.occurrence) {
              var firstAfterMany = utils_1.first(currRest.concat(prevRest));
              this.result.isEndOfRule = firstAfterMany === void 0;
              if (firstAfterMany instanceof gast_public_1.Terminal) {
                this.result.token = firstAfterMany.terminalType;
                this.result.occurrence = firstAfterMany.idx;
              }
            } else {
              _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);
            }
          };
          return NextTerminalAfterManyWalker2;
        })(AbstractNextTerminalAfterProductionWalker)
      );
      exports2.NextTerminalAfterManyWalker = NextTerminalAfterManyWalker;
      var NextTerminalAfterManySepWalker = (
        /** @class */
        (function(_super) {
          __extends2(NextTerminalAfterManySepWalker2, _super);
          function NextTerminalAfterManySepWalker2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          NextTerminalAfterManySepWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
            if (manySepProd.idx === this.occurrence) {
              var firstAfterManySep = utils_1.first(currRest.concat(prevRest));
              this.result.isEndOfRule = firstAfterManySep === void 0;
              if (firstAfterManySep instanceof gast_public_1.Terminal) {
                this.result.token = firstAfterManySep.terminalType;
                this.result.occurrence = firstAfterManySep.idx;
              }
            } else {
              _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);
            }
          };
          return NextTerminalAfterManySepWalker2;
        })(AbstractNextTerminalAfterProductionWalker)
      );
      exports2.NextTerminalAfterManySepWalker = NextTerminalAfterManySepWalker;
      var NextTerminalAfterAtLeastOneWalker = (
        /** @class */
        (function(_super) {
          __extends2(NextTerminalAfterAtLeastOneWalker2, _super);
          function NextTerminalAfterAtLeastOneWalker2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          NextTerminalAfterAtLeastOneWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
            if (atLeastOneProd.idx === this.occurrence) {
              var firstAfterAtLeastOne = utils_1.first(currRest.concat(prevRest));
              this.result.isEndOfRule = firstAfterAtLeastOne === void 0;
              if (firstAfterAtLeastOne instanceof gast_public_1.Terminal) {
                this.result.token = firstAfterAtLeastOne.terminalType;
                this.result.occurrence = firstAfterAtLeastOne.idx;
              }
            } else {
              _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);
            }
          };
          return NextTerminalAfterAtLeastOneWalker2;
        })(AbstractNextTerminalAfterProductionWalker)
      );
      exports2.NextTerminalAfterAtLeastOneWalker = NextTerminalAfterAtLeastOneWalker;
      var NextTerminalAfterAtLeastOneSepWalker = (
        /** @class */
        (function(_super) {
          __extends2(NextTerminalAfterAtLeastOneSepWalker2, _super);
          function NextTerminalAfterAtLeastOneSepWalker2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          NextTerminalAfterAtLeastOneSepWalker2.prototype.walkAtLeastOneSep = function(atleastOneSepProd, currRest, prevRest) {
            if (atleastOneSepProd.idx === this.occurrence) {
              var firstAfterfirstAfterAtLeastOneSep = utils_1.first(currRest.concat(prevRest));
              this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === void 0;
              if (firstAfterfirstAfterAtLeastOneSep instanceof gast_public_1.Terminal) {
                this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;
                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;
              }
            } else {
              _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);
            }
          };
          return NextTerminalAfterAtLeastOneSepWalker2;
        })(AbstractNextTerminalAfterProductionWalker)
      );
      exports2.NextTerminalAfterAtLeastOneSepWalker = NextTerminalAfterAtLeastOneSepWalker;
      function possiblePathsFrom(targetDef, maxLength, currPath) {
        if (currPath === void 0) {
          currPath = [];
        }
        currPath = utils_1.cloneArr(currPath);
        var result = [];
        var i = 0;
        function remainingPathWith(nextDef) {
          return nextDef.concat(utils_1.drop(targetDef, i + 1));
        }
        function getAlternativesForProd(definition) {
          var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);
          return result.concat(alternatives);
        }
        while (currPath.length < maxLength && i < targetDef.length) {
          var prod = targetDef[i];
          if (prod instanceof gast_public_1.Alternative) {
            return getAlternativesForProd(prod.definition);
          } else if (prod instanceof gast_public_1.NonTerminal) {
            return getAlternativesForProd(prod.definition);
          } else if (prod instanceof gast_public_1.Option) {
            result = getAlternativesForProd(prod.definition);
          } else if (prod instanceof gast_public_1.RepetitionMandatory) {
            var newDef = prod.definition.concat([
              new gast_public_1.Repetition({
                definition: prod.definition
              })
            ]);
            return getAlternativesForProd(newDef);
          } else if (prod instanceof gast_public_1.RepetitionMandatoryWithSeparator) {
            var newDef = [
              new gast_public_1.Alternative({ definition: prod.definition }),
              new gast_public_1.Repetition({
                definition: [new gast_public_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)
              })
            ];
            return getAlternativesForProd(newDef);
          } else if (prod instanceof gast_public_1.RepetitionWithSeparator) {
            var newDef = prod.definition.concat([
              new gast_public_1.Repetition({
                definition: [new gast_public_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)
              })
            ]);
            result = getAlternativesForProd(newDef);
          } else if (prod instanceof gast_public_1.Repetition) {
            var newDef = prod.definition.concat([
              new gast_public_1.Repetition({
                definition: prod.definition
              })
            ]);
            result = getAlternativesForProd(newDef);
          } else if (prod instanceof gast_public_1.Alternation) {
            utils_1.forEach(prod.definition, function(currAlt) {
              if (utils_1.isEmpty(currAlt.definition) === false) {
                result = getAlternativesForProd(currAlt.definition);
              }
            });
            return result;
          } else if (prod instanceof gast_public_1.Terminal) {
            currPath.push(prod.terminalType);
          } else {
            throw Error("non exhaustive match");
          }
          i++;
        }
        result.push({
          partialPath: currPath,
          suffixDef: utils_1.drop(targetDef, i)
        });
        return result;
      }
      exports2.possiblePathsFrom = possiblePathsFrom;
      function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {
        var EXIT_NON_TERMINAL = "EXIT_NONE_TERMINAL";
        var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];
        var EXIT_ALTERNATIVE = "EXIT_ALTERNATIVE";
        var foundCompletePath = false;
        var tokenVectorLength = tokenVector.length;
        var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;
        var result = [];
        var possiblePaths = [];
        possiblePaths.push({
          idx: -1,
          def: initialDef,
          ruleStack: [],
          occurrenceStack: []
        });
        while (!utils_1.isEmpty(possiblePaths)) {
          var currPath = possiblePaths.pop();
          if (currPath === EXIT_ALTERNATIVE) {
            if (foundCompletePath && utils_1.last(possiblePaths).idx <= minimalAlternativesIndex) {
              possiblePaths.pop();
            }
            continue;
          }
          var currDef = currPath.def;
          var currIdx = currPath.idx;
          var currRuleStack = currPath.ruleStack;
          var currOccurrenceStack = currPath.occurrenceStack;
          if (utils_1.isEmpty(currDef)) {
            continue;
          }
          var prod = currDef[0];
          if (prod === EXIT_NON_TERMINAL) {
            var nextPath = {
              idx: currIdx,
              def: utils_1.drop(currDef),
              ruleStack: utils_1.dropRight(currRuleStack),
              occurrenceStack: utils_1.dropRight(currOccurrenceStack)
            };
            possiblePaths.push(nextPath);
          } else if (prod instanceof gast_public_1.Terminal) {
            if (currIdx < tokenVectorLength - 1) {
              var nextIdx = currIdx + 1;
              var actualToken = tokenVector[nextIdx];
              if (tokMatcher(actualToken, prod.terminalType)) {
                var nextPath = {
                  idx: nextIdx,
                  def: utils_1.drop(currDef),
                  ruleStack: currRuleStack,
                  occurrenceStack: currOccurrenceStack
                };
                possiblePaths.push(nextPath);
              }
            } else if (currIdx === tokenVectorLength - 1) {
              result.push({
                nextTokenType: prod.terminalType,
                nextTokenOccurrence: prod.idx,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
              });
              foundCompletePath = true;
            } else {
              throw Error("non exhaustive match");
            }
          } else if (prod instanceof gast_public_1.NonTerminal) {
            var newRuleStack = utils_1.cloneArr(currRuleStack);
            newRuleStack.push(prod.nonTerminalName);
            var newOccurrenceStack = utils_1.cloneArr(currOccurrenceStack);
            newOccurrenceStack.push(prod.idx);
            var nextPath = {
              idx: currIdx,
              def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, utils_1.drop(currDef)),
              ruleStack: newRuleStack,
              occurrenceStack: newOccurrenceStack
            };
            possiblePaths.push(nextPath);
          } else if (prod instanceof gast_public_1.Option) {
            var nextPathWithout = {
              idx: currIdx,
              def: utils_1.drop(currDef),
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWithout);
            possiblePaths.push(EXIT_ALTERNATIVE);
            var nextPathWith = {
              idx: currIdx,
              def: prod.definition.concat(utils_1.drop(currDef)),
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWith);
          } else if (prod instanceof gast_public_1.RepetitionMandatory) {
            var secondIteration = new gast_public_1.Repetition({
              definition: prod.definition,
              idx: prod.idx
            });
            var nextDef = prod.definition.concat([secondIteration], utils_1.drop(currDef));
            var nextPath = {
              idx: currIdx,
              def: nextDef,
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPath);
          } else if (prod instanceof gast_public_1.RepetitionMandatoryWithSeparator) {
            var separatorGast = new gast_public_1.Terminal({
              terminalType: prod.separator
            });
            var secondIteration = new gast_public_1.Repetition({
              definition: [separatorGast].concat(prod.definition),
              idx: prod.idx
            });
            var nextDef = prod.definition.concat([secondIteration], utils_1.drop(currDef));
            var nextPath = {
              idx: currIdx,
              def: nextDef,
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPath);
          } else if (prod instanceof gast_public_1.RepetitionWithSeparator) {
            var nextPathWithout = {
              idx: currIdx,
              def: utils_1.drop(currDef),
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWithout);
            possiblePaths.push(EXIT_ALTERNATIVE);
            var separatorGast = new gast_public_1.Terminal({
              terminalType: prod.separator
            });
            var nthRepetition = new gast_public_1.Repetition({
              definition: [separatorGast].concat(prod.definition),
              idx: prod.idx
            });
            var nextDef = prod.definition.concat([nthRepetition], utils_1.drop(currDef));
            var nextPathWith = {
              idx: currIdx,
              def: nextDef,
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWith);
          } else if (prod instanceof gast_public_1.Repetition) {
            var nextPathWithout = {
              idx: currIdx,
              def: utils_1.drop(currDef),
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWithout);
            possiblePaths.push(EXIT_ALTERNATIVE);
            var nthRepetition = new gast_public_1.Repetition({
              definition: prod.definition,
              idx: prod.idx
            });
            var nextDef = prod.definition.concat([nthRepetition], utils_1.drop(currDef));
            var nextPathWith = {
              idx: currIdx,
              def: nextDef,
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWith);
          } else if (prod instanceof gast_public_1.Alternation) {
            for (var i = prod.definition.length - 1; i >= 0; i--) {
              var currAlt = prod.definition[i];
              var currAltPath = {
                idx: currIdx,
                def: currAlt.definition.concat(utils_1.drop(currDef)),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
              };
              possiblePaths.push(currAltPath);
              possiblePaths.push(EXIT_ALTERNATIVE);
            }
          } else if (prod instanceof gast_public_1.Alternative) {
            possiblePaths.push({
              idx: currIdx,
              def: prod.definition.concat(utils_1.drop(currDef)),
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            });
          } else if (prod instanceof gast_public_1.Rule) {
            possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));
          } else {
            throw Error("non exhaustive match");
          }
        }
        return result;
      }
      exports2.nextPossibleTokensAfter = nextPossibleTokensAfter;
      function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {
        var newRuleStack = utils_1.cloneArr(currRuleStack);
        newRuleStack.push(topRule.name);
        var newCurrOccurrenceStack = utils_1.cloneArr(currOccurrenceStack);
        newCurrOccurrenceStack.push(1);
        return {
          idx: currIdx,
          def: topRule.definition,
          ruleStack: newRuleStack,
          occurrenceStack: newCurrOccurrenceStack
        };
      }
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/lookahead.js
  var require_lookahead = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/lookahead.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d, b) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics2(d, b);
        };
        return function(d, b) {
          extendStatics2(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      })();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.areTokenCategoriesNotUsed = exports2.isStrictPrefixOfPath = exports2.containsPath = exports2.getLookaheadPathsForOptionalProd = exports2.getLookaheadPathsForOr = exports2.lookAheadSequenceFromAlternatives = exports2.buildSingleAlternativeLookaheadFunction = exports2.buildAlternativesLookAheadFunc = exports2.buildLookaheadFuncForOptionalProd = exports2.buildLookaheadFuncForOr = exports2.getProdType = exports2.PROD_TYPE = void 0;
      var utils_1 = require_utils();
      var interpreter_1 = require_interpreter();
      var rest_1 = require_rest();
      var tokens_1 = require_tokens();
      var gast_public_1 = require_gast_public();
      var gast_visitor_public_1 = require_gast_visitor_public();
      var PROD_TYPE;
      (function(PROD_TYPE2) {
        PROD_TYPE2[PROD_TYPE2["OPTION"] = 0] = "OPTION";
        PROD_TYPE2[PROD_TYPE2["REPETITION"] = 1] = "REPETITION";
        PROD_TYPE2[PROD_TYPE2["REPETITION_MANDATORY"] = 2] = "REPETITION_MANDATORY";
        PROD_TYPE2[PROD_TYPE2["REPETITION_MANDATORY_WITH_SEPARATOR"] = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR";
        PROD_TYPE2[PROD_TYPE2["REPETITION_WITH_SEPARATOR"] = 4] = "REPETITION_WITH_SEPARATOR";
        PROD_TYPE2[PROD_TYPE2["ALTERNATION"] = 5] = "ALTERNATION";
      })(PROD_TYPE = exports2.PROD_TYPE || (exports2.PROD_TYPE = {}));
      function getProdType(prod) {
        if (prod instanceof gast_public_1.Option) {
          return PROD_TYPE.OPTION;
        } else if (prod instanceof gast_public_1.Repetition) {
          return PROD_TYPE.REPETITION;
        } else if (prod instanceof gast_public_1.RepetitionMandatory) {
          return PROD_TYPE.REPETITION_MANDATORY;
        } else if (prod instanceof gast_public_1.RepetitionMandatoryWithSeparator) {
          return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;
        } else if (prod instanceof gast_public_1.RepetitionWithSeparator) {
          return PROD_TYPE.REPETITION_WITH_SEPARATOR;
        } else if (prod instanceof gast_public_1.Alternation) {
          return PROD_TYPE.ALTERNATION;
        } else {
          throw Error("non exhaustive match");
        }
      }
      exports2.getProdType = getProdType;
      function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {
        var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);
        var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
        return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);
      }
      exports2.buildLookaheadFuncForOr = buildLookaheadFuncForOr;
      function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {
        var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);
        var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
        return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);
      }
      exports2.buildLookaheadFuncForOptionalProd = buildLookaheadFuncForOptionalProd;
      function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {
        var numOfAlts = alts.length;
        var areAllOneTokenLookahead = utils_1.every(alts, function(currAlt) {
          return utils_1.every(currAlt, function(currPath) {
            return currPath.length === 1;
          });
        });
        if (hasPredicates) {
          return function(orAlts) {
            var predicates = utils_1.map(orAlts, function(currAlt2) {
              return currAlt2.GATE;
            });
            for (var t = 0; t < numOfAlts; t++) {
              var currAlt = alts[t];
              var currNumOfPaths = currAlt.length;
              var currPredicate = predicates[t];
              if (currPredicate !== void 0 && currPredicate.call(this) === false) {
                continue;
              }
              nextPath: for (var j = 0; j < currNumOfPaths; j++) {
                var currPath = currAlt[j];
                var currPathLength = currPath.length;
                for (var i = 0; i < currPathLength; i++) {
                  var nextToken = this.LA(i + 1);
                  if (tokenMatcher(nextToken, currPath[i]) === false) {
                    continue nextPath;
                  }
                }
                return t;
              }
            }
            return void 0;
          };
        } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
          var singleTokenAlts = utils_1.map(alts, function(currAlt) {
            return utils_1.flatten(currAlt);
          });
          var choiceToAlt_1 = utils_1.reduce(singleTokenAlts, function(result, currAlt, idx) {
            utils_1.forEach(currAlt, function(currTokType) {
              if (!utils_1.has(result, currTokType.tokenTypeIdx)) {
                result[currTokType.tokenTypeIdx] = idx;
              }
              utils_1.forEach(currTokType.categoryMatches, function(currExtendingType) {
                if (!utils_1.has(result, currExtendingType)) {
                  result[currExtendingType] = idx;
                }
              });
            });
            return result;
          }, []);
          return function() {
            var nextToken = this.LA(1);
            return choiceToAlt_1[nextToken.tokenTypeIdx];
          };
        } else {
          return function() {
            for (var t = 0; t < numOfAlts; t++) {
              var currAlt = alts[t];
              var currNumOfPaths = currAlt.length;
              nextPath: for (var j = 0; j < currNumOfPaths; j++) {
                var currPath = currAlt[j];
                var currPathLength = currPath.length;
                for (var i = 0; i < currPathLength; i++) {
                  var nextToken = this.LA(i + 1);
                  if (tokenMatcher(nextToken, currPath[i]) === false) {
                    continue nextPath;
                  }
                }
                return t;
              }
            }
            return void 0;
          };
        }
      }
      exports2.buildAlternativesLookAheadFunc = buildAlternativesLookAheadFunc;
      function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {
        var areAllOneTokenLookahead = utils_1.every(alt, function(currPath) {
          return currPath.length === 1;
        });
        var numOfPaths = alt.length;
        if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
          var singleTokensTypes = utils_1.flatten(alt);
          if (singleTokensTypes.length === 1 && utils_1.isEmpty(singleTokensTypes[0].categoryMatches)) {
            var expectedTokenType = singleTokensTypes[0];
            var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;
            return function() {
              return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;
            };
          } else {
            var choiceToAlt_2 = utils_1.reduce(singleTokensTypes, function(result, currTokType, idx) {
              result[currTokType.tokenTypeIdx] = true;
              utils_1.forEach(currTokType.categoryMatches, function(currExtendingType) {
                result[currExtendingType] = true;
              });
              return result;
            }, []);
            return function() {
              var nextToken = this.LA(1);
              return choiceToAlt_2[nextToken.tokenTypeIdx] === true;
            };
          }
        } else {
          return function() {
            nextPath: for (var j = 0; j < numOfPaths; j++) {
              var currPath = alt[j];
              var currPathLength = currPath.length;
              for (var i = 0; i < currPathLength; i++) {
                var nextToken = this.LA(i + 1);
                if (tokenMatcher(nextToken, currPath[i]) === false) {
                  continue nextPath;
                }
              }
              return true;
            }
            return false;
          };
        }
      }
      exports2.buildSingleAlternativeLookaheadFunction = buildSingleAlternativeLookaheadFunction;
      var RestDefinitionFinderWalker = (
        /** @class */
        (function(_super) {
          __extends2(RestDefinitionFinderWalker2, _super);
          function RestDefinitionFinderWalker2(topProd, targetOccurrence, targetProdType) {
            var _this = _super.call(this) || this;
            _this.topProd = topProd;
            _this.targetOccurrence = targetOccurrence;
            _this.targetProdType = targetProdType;
            return _this;
          }
          RestDefinitionFinderWalker2.prototype.startWalking = function() {
            this.walk(this.topProd);
            return this.restDef;
          };
          RestDefinitionFinderWalker2.prototype.checkIsTarget = function(node, expectedProdType, currRest, prevRest) {
            if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {
              this.restDef = currRest.concat(prevRest);
              return true;
            }
            return false;
          };
          RestDefinitionFinderWalker2.prototype.walkOption = function(optionProd, currRest, prevRest) {
            if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {
              _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);
            }
          };
          RestDefinitionFinderWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
            if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {
              _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);
            }
          };
          RestDefinitionFinderWalker2.prototype.walkAtLeastOneSep = function(atLeastOneSepProd, currRest, prevRest) {
            if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {
              _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);
            }
          };
          RestDefinitionFinderWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
            if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {
              _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);
            }
          };
          RestDefinitionFinderWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
            if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {
              _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);
            }
          };
          return RestDefinitionFinderWalker2;
        })(rest_1.RestWalker)
      );
      var InsideDefinitionFinderVisitor = (
        /** @class */
        (function(_super) {
          __extends2(InsideDefinitionFinderVisitor2, _super);
          function InsideDefinitionFinderVisitor2(targetOccurrence, targetProdType, targetRef) {
            var _this = _super.call(this) || this;
            _this.targetOccurrence = targetOccurrence;
            _this.targetProdType = targetProdType;
            _this.targetRef = targetRef;
            _this.result = [];
            return _this;
          }
          InsideDefinitionFinderVisitor2.prototype.checkIsTarget = function(node, expectedProdName) {
            if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === void 0 || node === this.targetRef)) {
              this.result = node.definition;
            }
          };
          InsideDefinitionFinderVisitor2.prototype.visitOption = function(node) {
            this.checkIsTarget(node, PROD_TYPE.OPTION);
          };
          InsideDefinitionFinderVisitor2.prototype.visitRepetition = function(node) {
            this.checkIsTarget(node, PROD_TYPE.REPETITION);
          };
          InsideDefinitionFinderVisitor2.prototype.visitRepetitionMandatory = function(node) {
            this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);
          };
          InsideDefinitionFinderVisitor2.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
            this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);
          };
          InsideDefinitionFinderVisitor2.prototype.visitRepetitionWithSeparator = function(node) {
            this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);
          };
          InsideDefinitionFinderVisitor2.prototype.visitAlternation = function(node) {
            this.checkIsTarget(node, PROD_TYPE.ALTERNATION);
          };
          return InsideDefinitionFinderVisitor2;
        })(gast_visitor_public_1.GAstVisitor)
      );
      function initializeArrayOfArrays(size) {
        var result = new Array(size);
        for (var i = 0; i < size; i++) {
          result[i] = [];
        }
        return result;
      }
      function pathToHashKeys(path) {
        var keys3 = [""];
        for (var i = 0; i < path.length; i++) {
          var tokType = path[i];
          var longerKeys = [];
          for (var j = 0; j < keys3.length; j++) {
            var currShorterKey = keys3[j];
            longerKeys.push(currShorterKey + "_" + tokType.tokenTypeIdx);
            for (var t = 0; t < tokType.categoryMatches.length; t++) {
              var categoriesKeySuffix = "_" + tokType.categoryMatches[t];
              longerKeys.push(currShorterKey + categoriesKeySuffix);
            }
          }
          keys3 = longerKeys;
        }
        return keys3;
      }
      function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {
        for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {
          if (currAltIdx === idx) {
            continue;
          }
          var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];
          for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {
            var searchKey = searchPathKeys[searchIdx];
            if (otherAltKnownPathsKeys[searchKey] === true) {
              return false;
            }
          }
        }
        return true;
      }
      function lookAheadSequenceFromAlternatives(altsDefs, k) {
        var partialAlts = utils_1.map(altsDefs, function(currAlt) {
          return interpreter_1.possiblePathsFrom([currAlt], 1);
        });
        var finalResult = initializeArrayOfArrays(partialAlts.length);
        var altsHashes = utils_1.map(partialAlts, function(currAltPaths) {
          var dict = {};
          utils_1.forEach(currAltPaths, function(item) {
            var keys3 = pathToHashKeys(item.partialPath);
            utils_1.forEach(keys3, function(currKey) {
              dict[currKey] = true;
            });
          });
          return dict;
        });
        var newData = partialAlts;
        for (var pathLength = 1; pathLength <= k; pathLength++) {
          var currDataset = newData;
          newData = initializeArrayOfArrays(currDataset.length);
          var _loop_1 = function(altIdx2) {
            var currAltPathsAndSuffixes = currDataset[altIdx2];
            for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {
              var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;
              var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;
              var prefixKeys = pathToHashKeys(currPathPrefix);
              var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx2);
              if (isUnique || utils_1.isEmpty(suffixDef) || currPathPrefix.length === k) {
                var currAltResult = finalResult[altIdx2];
                if (containsPath(currAltResult, currPathPrefix) === false) {
                  currAltResult.push(currPathPrefix);
                  for (var j = 0; j < prefixKeys.length; j++) {
                    var currKey = prefixKeys[j];
                    altsHashes[altIdx2][currKey] = true;
                  }
                }
              } else {
                var newPartialPathsAndSuffixes = interpreter_1.possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);
                newData[altIdx2] = newData[altIdx2].concat(newPartialPathsAndSuffixes);
                utils_1.forEach(newPartialPathsAndSuffixes, function(item) {
                  var prefixKeys2 = pathToHashKeys(item.partialPath);
                  utils_1.forEach(prefixKeys2, function(key) {
                    altsHashes[altIdx2][key] = true;
                  });
                });
              }
            }
          };
          for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {
            _loop_1(altIdx);
          }
        }
        return finalResult;
      }
      exports2.lookAheadSequenceFromAlternatives = lookAheadSequenceFromAlternatives;
      function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {
        var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);
        ruleGrammar.accept(visitor);
        return lookAheadSequenceFromAlternatives(visitor.result, k);
      }
      exports2.getLookaheadPathsForOr = getLookaheadPathsForOr;
      function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {
        var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);
        ruleGrammar.accept(insideDefVisitor);
        var insideDef = insideDefVisitor.result;
        var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);
        var afterDef = afterDefWalker.startWalking();
        var insideFlat = new gast_public_1.Alternative({ definition: insideDef });
        var afterFlat = new gast_public_1.Alternative({ definition: afterDef });
        return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);
      }
      exports2.getLookaheadPathsForOptionalProd = getLookaheadPathsForOptionalProd;
      function containsPath(alternative, searchPath) {
        compareOtherPath: for (var i = 0; i < alternative.length; i++) {
          var otherPath = alternative[i];
          if (otherPath.length !== searchPath.length) {
            continue;
          }
          for (var j = 0; j < otherPath.length; j++) {
            var searchTok = searchPath[j];
            var otherTok = otherPath[j];
            var matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== void 0;
            if (matchingTokens === false) {
              continue compareOtherPath;
            }
          }
          return true;
        }
        return false;
      }
      exports2.containsPath = containsPath;
      function isStrictPrefixOfPath(prefix, other) {
        return prefix.length < other.length && utils_1.every(prefix, function(tokType, idx) {
          var otherTokType = other[idx];
          return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];
        });
      }
      exports2.isStrictPrefixOfPath = isStrictPrefixOfPath;
      function areTokenCategoriesNotUsed(lookAheadPaths) {
        return utils_1.every(lookAheadPaths, function(singleAltPaths) {
          return utils_1.every(singleAltPaths, function(singlePath) {
            return utils_1.every(singlePath, function(token) {
              return utils_1.isEmpty(token.categoryMatches);
            });
          });
        });
      }
      exports2.areTokenCategoriesNotUsed = areTokenCategoriesNotUsed;
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/checks.js
  var require_checks = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/checks.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d, b) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics2(d, b);
        };
        return function(d, b) {
          extendStatics2(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      })();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.checkPrefixAlternativesAmbiguities = exports2.validateSomeNonEmptyLookaheadPath = exports2.validateTooManyAlts = exports2.RepetionCollector = exports2.validateAmbiguousAlternationAlternatives = exports2.validateEmptyOrAlternative = exports2.getFirstNoneTerminal = exports2.validateNoLeftRecursion = exports2.validateRuleIsOverridden = exports2.validateRuleDoesNotAlreadyExist = exports2.OccurrenceValidationCollector = exports2.identifyProductionForDuplicates = exports2.validateGrammar = void 0;
      var utils = require_utils();
      var utils_1 = require_utils();
      var parser_1 = require_parser();
      var gast_1 = require_gast();
      var lookahead_1 = require_lookahead();
      var interpreter_1 = require_interpreter();
      var gast_public_1 = require_gast_public();
      var gast_visitor_public_1 = require_gast_visitor_public();
      function validateGrammar(topLevels, globalMaxLookahead, tokenTypes, errMsgProvider, grammarName) {
        var duplicateErrors = utils.map(topLevels, function(currTopLevel) {
          return validateDuplicateProductions(currTopLevel, errMsgProvider);
        });
        var leftRecursionErrors = utils.map(topLevels, function(currTopRule) {
          return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);
        });
        var emptyAltErrors = [];
        var ambiguousAltsErrors = [];
        var emptyRepetitionErrors = [];
        if (utils_1.every(leftRecursionErrors, utils_1.isEmpty)) {
          emptyAltErrors = utils_1.map(topLevels, function(currTopRule) {
            return validateEmptyOrAlternative(currTopRule, errMsgProvider);
          });
          ambiguousAltsErrors = utils_1.map(topLevels, function(currTopRule) {
            return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, errMsgProvider);
          });
          emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);
        }
        var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);
        var tooManyAltsErrors = utils_1.map(topLevels, function(curRule) {
          return validateTooManyAlts(curRule, errMsgProvider);
        });
        var duplicateRulesError = utils_1.map(topLevels, function(curRule) {
          return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);
        });
        return utils.flatten(duplicateErrors.concat(emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError));
      }
      exports2.validateGrammar = validateGrammar;
      function validateDuplicateProductions(topLevelRule, errMsgProvider) {
        var collectorVisitor = new OccurrenceValidationCollector();
        topLevelRule.accept(collectorVisitor);
        var allRuleProductions = collectorVisitor.allProductions;
        var productionGroups = utils.groupBy(allRuleProductions, identifyProductionForDuplicates);
        var duplicates = utils.pick(productionGroups, function(currGroup) {
          return currGroup.length > 1;
        });
        var errors = utils.map(utils.values(duplicates), function(currDuplicates) {
          var firstProd = utils.first(currDuplicates);
          var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);
          var dslName = gast_1.getProductionDslName(firstProd);
          var defError = {
            message: msg,
            type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,
            ruleName: topLevelRule.name,
            dslName,
            occurrence: firstProd.idx
          };
          var param = getExtraProductionArgument(firstProd);
          if (param) {
            defError.parameter = param;
          }
          return defError;
        });
        return errors;
      }
      function identifyProductionForDuplicates(prod) {
        return gast_1.getProductionDslName(prod) + "_#_" + prod.idx + "_#_" + getExtraProductionArgument(prod);
      }
      exports2.identifyProductionForDuplicates = identifyProductionForDuplicates;
      function getExtraProductionArgument(prod) {
        if (prod instanceof gast_public_1.Terminal) {
          return prod.terminalType.name;
        } else if (prod instanceof gast_public_1.NonTerminal) {
          return prod.nonTerminalName;
        } else {
          return "";
        }
      }
      var OccurrenceValidationCollector = (
        /** @class */
        (function(_super) {
          __extends2(OccurrenceValidationCollector2, _super);
          function OccurrenceValidationCollector2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.allProductions = [];
            return _this;
          }
          OccurrenceValidationCollector2.prototype.visitNonTerminal = function(subrule) {
            this.allProductions.push(subrule);
          };
          OccurrenceValidationCollector2.prototype.visitOption = function(option) {
            this.allProductions.push(option);
          };
          OccurrenceValidationCollector2.prototype.visitRepetitionWithSeparator = function(manySep) {
            this.allProductions.push(manySep);
          };
          OccurrenceValidationCollector2.prototype.visitRepetitionMandatory = function(atLeastOne) {
            this.allProductions.push(atLeastOne);
          };
          OccurrenceValidationCollector2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
            this.allProductions.push(atLeastOneSep);
          };
          OccurrenceValidationCollector2.prototype.visitRepetition = function(many) {
            this.allProductions.push(many);
          };
          OccurrenceValidationCollector2.prototype.visitAlternation = function(or) {
            this.allProductions.push(or);
          };
          OccurrenceValidationCollector2.prototype.visitTerminal = function(terminal) {
            this.allProductions.push(terminal);
          };
          return OccurrenceValidationCollector2;
        })(gast_visitor_public_1.GAstVisitor)
      );
      exports2.OccurrenceValidationCollector = OccurrenceValidationCollector;
      function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {
        var errors = [];
        var occurrences = utils_1.reduce(allRules, function(result, curRule) {
          if (curRule.name === rule.name) {
            return result + 1;
          }
          return result;
        }, 0);
        if (occurrences > 1) {
          var errMsg = errMsgProvider.buildDuplicateRuleNameError({
            topLevelRule: rule,
            grammarName: className
          });
          errors.push({
            message: errMsg,
            type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
            ruleName: rule.name
          });
        }
        return errors;
      }
      exports2.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist;
      function validateRuleIsOverridden(ruleName, definedRulesNames, className) {
        var errors = [];
        var errMsg;
        if (!utils.contains(definedRulesNames, ruleName)) {
          errMsg = "Invalid rule override, rule: ->" + ruleName + "<- cannot be overridden in the grammar: ->" + className + "<-as it is not defined in any of the super grammars ";
          errors.push({
            message: errMsg,
            type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,
            ruleName
          });
        }
        return errors;
      }
      exports2.validateRuleIsOverridden = validateRuleIsOverridden;
      function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {
        if (path === void 0) {
          path = [];
        }
        var errors = [];
        var nextNonTerminals = getFirstNoneTerminal(currRule.definition);
        if (utils.isEmpty(nextNonTerminals)) {
          return [];
        } else {
          var ruleName = topRule.name;
          var foundLeftRecursion = utils.contains(nextNonTerminals, topRule);
          if (foundLeftRecursion) {
            errors.push({
              message: errMsgProvider.buildLeftRecursionError({
                topLevelRule: topRule,
                leftRecursionPath: path
              }),
              type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,
              ruleName
            });
          }
          var validNextSteps = utils.difference(nextNonTerminals, path.concat([topRule]));
          var errorsFromNextSteps = utils.map(validNextSteps, function(currRefRule) {
            var newPath = utils.cloneArr(path);
            newPath.push(currRefRule);
            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);
          });
          return errors.concat(utils.flatten(errorsFromNextSteps));
        }
      }
      exports2.validateNoLeftRecursion = validateNoLeftRecursion;
      function getFirstNoneTerminal(definition) {
        var result = [];
        if (utils.isEmpty(definition)) {
          return result;
        }
        var firstProd = utils.first(definition);
        if (firstProd instanceof gast_public_1.NonTerminal) {
          result.push(firstProd.referencedRule);
        } else if (firstProd instanceof gast_public_1.Alternative || firstProd instanceof gast_public_1.Option || firstProd instanceof gast_public_1.RepetitionMandatory || firstProd instanceof gast_public_1.RepetitionMandatoryWithSeparator || firstProd instanceof gast_public_1.RepetitionWithSeparator || firstProd instanceof gast_public_1.Repetition) {
          result = result.concat(getFirstNoneTerminal(firstProd.definition));
        } else if (firstProd instanceof gast_public_1.Alternation) {
          result = utils.flatten(utils.map(firstProd.definition, function(currSubDef) {
            return getFirstNoneTerminal(currSubDef.definition);
          }));
        } else if (firstProd instanceof gast_public_1.Terminal) {
        } else {
          throw Error("non exhaustive match");
        }
        var isFirstOptional = gast_1.isOptionalProd(firstProd);
        var hasMore = definition.length > 1;
        if (isFirstOptional && hasMore) {
          var rest = utils.drop(definition);
          return result.concat(getFirstNoneTerminal(rest));
        } else {
          return result;
        }
      }
      exports2.getFirstNoneTerminal = getFirstNoneTerminal;
      var OrCollector = (
        /** @class */
        (function(_super) {
          __extends2(OrCollector2, _super);
          function OrCollector2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.alternations = [];
            return _this;
          }
          OrCollector2.prototype.visitAlternation = function(node) {
            this.alternations.push(node);
          };
          return OrCollector2;
        })(gast_visitor_public_1.GAstVisitor)
      );
      function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {
        var orCollector = new OrCollector();
        topLevelRule.accept(orCollector);
        var ors = orCollector.alternations;
        var errors = utils.reduce(ors, function(errors2, currOr) {
          var exceptLast = utils.dropRight(currOr.definition);
          var currErrors = utils.map(exceptLast, function(currAlternative, currAltIdx) {
            var possibleFirstInAlt = interpreter_1.nextPossibleTokensAfter([currAlternative], [], null, 1);
            if (utils.isEmpty(possibleFirstInAlt)) {
              return {
                message: errMsgProvider.buildEmptyAlternationError({
                  topLevelRule,
                  alternation: currOr,
                  emptyChoiceIdx: currAltIdx
                }),
                type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,
                ruleName: topLevelRule.name,
                occurrence: currOr.idx,
                alternative: currAltIdx + 1
              };
            } else {
              return null;
            }
          });
          return errors2.concat(utils.compact(currErrors));
        }, []);
        return errors;
      }
      exports2.validateEmptyOrAlternative = validateEmptyOrAlternative;
      function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {
        var orCollector = new OrCollector();
        topLevelRule.accept(orCollector);
        var ors = orCollector.alternations;
        ors = utils_1.reject(ors, function(currOr) {
          return currOr.ignoreAmbiguities === true;
        });
        var errors = utils.reduce(ors, function(result, currOr) {
          var currOccurrence = currOr.idx;
          var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;
          var alternatives = lookahead_1.getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);
          var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
          var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
          return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);
        }, []);
        return errors;
      }
      exports2.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;
      var RepetionCollector = (
        /** @class */
        (function(_super) {
          __extends2(RepetionCollector2, _super);
          function RepetionCollector2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.allProductions = [];
            return _this;
          }
          RepetionCollector2.prototype.visitRepetitionWithSeparator = function(manySep) {
            this.allProductions.push(manySep);
          };
          RepetionCollector2.prototype.visitRepetitionMandatory = function(atLeastOne) {
            this.allProductions.push(atLeastOne);
          };
          RepetionCollector2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
            this.allProductions.push(atLeastOneSep);
          };
          RepetionCollector2.prototype.visitRepetition = function(many) {
            this.allProductions.push(many);
          };
          return RepetionCollector2;
        })(gast_visitor_public_1.GAstVisitor)
      );
      exports2.RepetionCollector = RepetionCollector;
      function validateTooManyAlts(topLevelRule, errMsgProvider) {
        var orCollector = new OrCollector();
        topLevelRule.accept(orCollector);
        var ors = orCollector.alternations;
        var errors = utils.reduce(ors, function(errors2, currOr) {
          if (currOr.definition.length > 255) {
            errors2.push({
              message: errMsgProvider.buildTooManyAlternativesError({
                topLevelRule,
                alternation: currOr
              }),
              type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,
              ruleName: topLevelRule.name,
              occurrence: currOr.idx
            });
          }
          return errors2;
        }, []);
        return errors;
      }
      exports2.validateTooManyAlts = validateTooManyAlts;
      function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {
        var errors = [];
        utils_1.forEach(topLevelRules, function(currTopRule) {
          var collectorVisitor = new RepetionCollector();
          currTopRule.accept(collectorVisitor);
          var allRuleProductions = collectorVisitor.allProductions;
          utils_1.forEach(allRuleProductions, function(currProd) {
            var prodType = lookahead_1.getProdType(currProd);
            var actualMaxLookahead = currProd.maxLookahead || maxLookahead;
            var currOccurrence = currProd.idx;
            var paths = lookahead_1.getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);
            var pathsInsideProduction = paths[0];
            if (utils_1.isEmpty(utils_1.flatten(pathsInsideProduction))) {
              var errMsg = errMsgProvider.buildEmptyRepetitionError({
                topLevelRule: currTopRule,
                repetition: currProd
              });
              errors.push({
                message: errMsg,
                type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,
                ruleName: currTopRule.name
              });
            }
          });
        });
        return errors;
      }
      exports2.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;
      function checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
        var foundAmbiguousPaths = [];
        var identicalAmbiguities = utils_1.reduce(alternatives, function(result, currAlt, currAltIdx) {
          if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {
            return result;
          }
          utils_1.forEach(currAlt, function(currPath) {
            var altsCurrPathAppearsIn = [currAltIdx];
            utils_1.forEach(alternatives, function(currOtherAlt, currOtherAltIdx) {
              if (currAltIdx !== currOtherAltIdx && lookahead_1.containsPath(currOtherAlt, currPath) && // ignore (skip) ambiguities with this "other" alternative
              alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {
                altsCurrPathAppearsIn.push(currOtherAltIdx);
              }
            });
            if (altsCurrPathAppearsIn.length > 1 && !lookahead_1.containsPath(foundAmbiguousPaths, currPath)) {
              foundAmbiguousPaths.push(currPath);
              result.push({
                alts: altsCurrPathAppearsIn,
                path: currPath
              });
            }
          });
          return result;
        }, []);
        var currErrors = utils.map(identicalAmbiguities, function(currAmbDescriptor) {
          var ambgIndices = utils_1.map(currAmbDescriptor.alts, function(currAltIdx) {
            return currAltIdx + 1;
          });
          var currMessage = errMsgProvider.buildAlternationAmbiguityError({
            topLevelRule: rule,
            alternation,
            ambiguityIndices: ambgIndices,
            prefixPath: currAmbDescriptor.path
          });
          return {
            message: currMessage,
            type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,
            ruleName: rule.name,
            occurrence: alternation.idx,
            alternatives: [currAmbDescriptor.alts]
          };
        });
        return currErrors;
      }
      function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
        var errors = [];
        var pathsAndIndices = utils_1.reduce(alternatives, function(result, currAlt, idx) {
          var currPathsAndIdx = utils_1.map(currAlt, function(currPath) {
            return { idx, path: currPath };
          });
          return result.concat(currPathsAndIdx);
        }, []);
        utils_1.forEach(pathsAndIndices, function(currPathAndIdx) {
          var alternativeGast = alternation.definition[currPathAndIdx.idx];
          if (alternativeGast.ignoreAmbiguities === true) {
            return;
          }
          var targetIdx = currPathAndIdx.idx;
          var targetPath = currPathAndIdx.path;
          var prefixAmbiguitiesPathsAndIndices = utils_1.findAll(pathsAndIndices, function(searchPathAndIdx) {
            return (
              // ignore (skip) ambiguities with this "other" alternative
              alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads
              // will be be detected using a different validation.
              lookahead_1.isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)
            );
          });
          var currPathPrefixErrors = utils_1.map(prefixAmbiguitiesPathsAndIndices, function(currAmbPathAndIdx) {
            var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];
            var occurrence = alternation.idx === 0 ? "" : alternation.idx;
            var message = errMsgProvider.buildAlternationPrefixAmbiguityError({
              topLevelRule: rule,
              alternation,
              ambiguityIndices: ambgIndices,
              prefixPath: currAmbPathAndIdx.path
            });
            return {
              message,
              type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,
              ruleName: rule.name,
              occurrence,
              alternatives: ambgIndices
            };
          });
          errors = errors.concat(currPathPrefixErrors);
        });
        return errors;
      }
      exports2.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;
      function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {
        var errors = [];
        var tokenNames = utils_1.map(tokenTypes, function(currToken) {
          return currToken.name;
        });
        utils_1.forEach(topLevels, function(currRule) {
          var currRuleName = currRule.name;
          if (utils_1.contains(tokenNames, currRuleName)) {
            var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);
            errors.push({
              message: errMsg,
              type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,
              ruleName: currRuleName
            });
          }
        });
        return errors;
      }
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js
  var require_gast_resolver_public = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.assignOccurrenceIndices = exports2.validateGrammar = exports2.resolveGrammar = void 0;
      var utils_1 = require_utils();
      var resolver_1 = require_resolver();
      var checks_1 = require_checks();
      var errors_public_1 = require_errors_public();
      var gast_1 = require_gast();
      function resolveGrammar(options) {
        options = utils_1.defaults(options, {
          errMsgProvider: errors_public_1.defaultGrammarResolverErrorProvider
        });
        var topRulesTable = {};
        utils_1.forEach(options.rules, function(rule) {
          topRulesTable[rule.name] = rule;
        });
        return resolver_1.resolveGrammar(topRulesTable, options.errMsgProvider);
      }
      exports2.resolveGrammar = resolveGrammar;
      function validateGrammar(options) {
        options = utils_1.defaults(options, {
          errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider
        });
        return checks_1.validateGrammar(options.rules, options.maxLookahead, options.tokenTypes, options.errMsgProvider, options.grammarName);
      }
      exports2.validateGrammar = validateGrammar;
      function assignOccurrenceIndices(options) {
        utils_1.forEach(options.rules, function(currRule) {
          var methodsCollector = new gast_1.DslMethodsCollectorVisitor();
          currRule.accept(methodsCollector);
          utils_1.forEach(methodsCollector.dslMethods, function(methods) {
            utils_1.forEach(methods, function(currMethod, arrIdx) {
              currMethod.idx = arrIdx + 1;
            });
          });
        });
      }
      exports2.assignOccurrenceIndices = assignOccurrenceIndices;
    }
  });

  // node_modules/chevrotain/lib/src/parse/exceptions_public.js
  var require_exceptions_public = __commonJS({
    "node_modules/chevrotain/lib/src/parse/exceptions_public.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d, b) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics2(d, b);
        };
        return function(d, b) {
          extendStatics2(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      })();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.EarlyExitException = exports2.NotAllInputParsedException = exports2.NoViableAltException = exports2.MismatchedTokenException = exports2.isRecognitionException = void 0;
      var utils_1 = require_utils();
      var MISMATCHED_TOKEN_EXCEPTION = "MismatchedTokenException";
      var NO_VIABLE_ALT_EXCEPTION = "NoViableAltException";
      var EARLY_EXIT_EXCEPTION = "EarlyExitException";
      var NOT_ALL_INPUT_PARSED_EXCEPTION = "NotAllInputParsedException";
      var RECOGNITION_EXCEPTION_NAMES = [
        MISMATCHED_TOKEN_EXCEPTION,
        NO_VIABLE_ALT_EXCEPTION,
        EARLY_EXIT_EXCEPTION,
        NOT_ALL_INPUT_PARSED_EXCEPTION
      ];
      Object.freeze(RECOGNITION_EXCEPTION_NAMES);
      function isRecognitionException(error) {
        return utils_1.contains(RECOGNITION_EXCEPTION_NAMES, error.name);
      }
      exports2.isRecognitionException = isRecognitionException;
      var RecognitionException = (
        /** @class */
        (function(_super) {
          __extends2(RecognitionException2, _super);
          function RecognitionException2(message, token) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            _this.token = token;
            _this.resyncedTokens = [];
            Object.setPrototypeOf(_this, _newTarget.prototype);
            if (Error.captureStackTrace) {
              Error.captureStackTrace(_this, _this.constructor);
            }
            return _this;
          }
          return RecognitionException2;
        })(Error)
      );
      var MismatchedTokenException = (
        /** @class */
        (function(_super) {
          __extends2(MismatchedTokenException2, _super);
          function MismatchedTokenException2(message, token, previousToken) {
            var _this = _super.call(this, message, token) || this;
            _this.previousToken = previousToken;
            _this.name = MISMATCHED_TOKEN_EXCEPTION;
            return _this;
          }
          return MismatchedTokenException2;
        })(RecognitionException)
      );
      exports2.MismatchedTokenException = MismatchedTokenException;
      var NoViableAltException = (
        /** @class */
        (function(_super) {
          __extends2(NoViableAltException2, _super);
          function NoViableAltException2(message, token, previousToken) {
            var _this = _super.call(this, message, token) || this;
            _this.previousToken = previousToken;
            _this.name = NO_VIABLE_ALT_EXCEPTION;
            return _this;
          }
          return NoViableAltException2;
        })(RecognitionException)
      );
      exports2.NoViableAltException = NoViableAltException;
      var NotAllInputParsedException = (
        /** @class */
        (function(_super) {
          __extends2(NotAllInputParsedException2, _super);
          function NotAllInputParsedException2(message, token) {
            var _this = _super.call(this, message, token) || this;
            _this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;
            return _this;
          }
          return NotAllInputParsedException2;
        })(RecognitionException)
      );
      exports2.NotAllInputParsedException = NotAllInputParsedException;
      var EarlyExitException = (
        /** @class */
        (function(_super) {
          __extends2(EarlyExitException2, _super);
          function EarlyExitException2(message, token, previousToken) {
            var _this = _super.call(this, message, token) || this;
            _this.previousToken = previousToken;
            _this.name = EARLY_EXIT_EXCEPTION;
            return _this;
          }
          return EarlyExitException2;
        })(RecognitionException)
      );
      exports2.EarlyExitException = EarlyExitException;
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js
  var require_recoverable = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.attemptInRepetitionRecovery = exports2.Recoverable = exports2.InRuleRecoveryException = exports2.IN_RULE_RECOVERY_EXCEPTION = exports2.EOF_FOLLOW_KEY = void 0;
      var tokens_public_1 = require_tokens_public();
      var utils_1 = require_utils();
      var exceptions_public_1 = require_exceptions_public();
      var constants_1 = require_constants();
      var parser_1 = require_parser();
      exports2.EOF_FOLLOW_KEY = {};
      exports2.IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";
      function InRuleRecoveryException(message) {
        this.name = exports2.IN_RULE_RECOVERY_EXCEPTION;
        this.message = message;
      }
      exports2.InRuleRecoveryException = InRuleRecoveryException;
      InRuleRecoveryException.prototype = Error.prototype;
      var Recoverable = (
        /** @class */
        (function() {
          function Recoverable2() {
          }
          Recoverable2.prototype.initRecoverable = function(config) {
            this.firstAfterRepMap = {};
            this.resyncFollows = {};
            this.recoveryEnabled = utils_1.has(config, "recoveryEnabled") ? config.recoveryEnabled : parser_1.DEFAULT_PARSER_CONFIG.recoveryEnabled;
            if (this.recoveryEnabled) {
              this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
            }
          };
          Recoverable2.prototype.getTokenToInsert = function(tokType) {
            var tokToInsert = tokens_public_1.createTokenInstance(tokType, "", NaN, NaN, NaN, NaN, NaN, NaN);
            tokToInsert.isInsertedInRecovery = true;
            return tokToInsert;
          };
          Recoverable2.prototype.canTokenTypeBeInsertedInRecovery = function(tokType) {
            return true;
          };
          Recoverable2.prototype.tryInRepetitionRecovery = function(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {
            var _this = this;
            var reSyncTokType = this.findReSyncTokenType();
            var savedLexerState = this.exportLexerState();
            var resyncedTokens = [];
            var passedResyncPoint = false;
            var nextTokenWithoutResync = this.LA(1);
            var currToken = this.LA(1);
            var generateErrorMessage = function() {
              var previousToken = _this.LA(0);
              var msg = _this.errorMessageProvider.buildMismatchTokenMessage({
                expected: expectedTokType,
                actual: nextTokenWithoutResync,
                previous: previousToken,
                ruleName: _this.getCurrRuleFullName()
              });
              var error = new exceptions_public_1.MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0));
              error.resyncedTokens = utils_1.dropRight(resyncedTokens);
              _this.SAVE_ERROR(error);
            };
            while (!passedResyncPoint) {
              if (this.tokenMatcher(currToken, expectedTokType)) {
                generateErrorMessage();
                return;
              } else if (lookAheadFunc.call(this)) {
                generateErrorMessage();
                grammarRule.apply(this, grammarRuleArgs);
                return;
              } else if (this.tokenMatcher(currToken, reSyncTokType)) {
                passedResyncPoint = true;
              } else {
                currToken = this.SKIP_TOKEN();
                this.addToResyncTokens(currToken, resyncedTokens);
              }
            }
            this.importLexerState(savedLexerState);
          };
          Recoverable2.prototype.shouldInRepetitionRecoveryBeTried = function(expectTokAfterLastMatch, nextTokIdx, notStuck) {
            if (notStuck === false) {
              return false;
            }
            if (expectTokAfterLastMatch === void 0 || nextTokIdx === void 0) {
              return false;
            }
            if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {
              return false;
            }
            if (this.isBackTracking()) {
              return false;
            }
            if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {
              return false;
            }
            return true;
          };
          Recoverable2.prototype.getFollowsForInRuleRecovery = function(tokType, tokIdxInRule) {
            var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);
            var follows = this.getNextPossibleTokenTypes(grammarPath);
            return follows;
          };
          Recoverable2.prototype.tryInRuleRecovery = function(expectedTokType, follows) {
            if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {
              var tokToInsert = this.getTokenToInsert(expectedTokType);
              return tokToInsert;
            }
            if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {
              var nextTok = this.SKIP_TOKEN();
              this.consumeToken();
              return nextTok;
            }
            throw new InRuleRecoveryException("sad sad panda");
          };
          Recoverable2.prototype.canPerformInRuleRecovery = function(expectedToken, follows) {
            return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);
          };
          Recoverable2.prototype.canRecoverWithSingleTokenInsertion = function(expectedTokType, follows) {
            var _this = this;
            if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {
              return false;
            }
            if (utils_1.isEmpty(follows)) {
              return false;
            }
            var mismatchedTok = this.LA(1);
            var isMisMatchedTokInFollows = utils_1.find(follows, function(possibleFollowsTokType) {
              return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);
            }) !== void 0;
            return isMisMatchedTokInFollows;
          };
          Recoverable2.prototype.canRecoverWithSingleTokenDeletion = function(expectedTokType) {
            var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);
            return isNextTokenWhatIsExpected;
          };
          Recoverable2.prototype.isInCurrentRuleReSyncSet = function(tokenTypeIdx) {
            var followKey = this.getCurrFollowKey();
            var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);
            return utils_1.contains(currentRuleReSyncSet, tokenTypeIdx);
          };
          Recoverable2.prototype.findReSyncTokenType = function() {
            var allPossibleReSyncTokTypes = this.flattenFollowSet();
            var nextToken = this.LA(1);
            var k = 2;
            while (true) {
              var nextTokenType = nextToken.tokenType;
              if (utils_1.contains(allPossibleReSyncTokTypes, nextTokenType)) {
                return nextTokenType;
              }
              nextToken = this.LA(k);
              k++;
            }
          };
          Recoverable2.prototype.getCurrFollowKey = function() {
            if (this.RULE_STACK.length === 1) {
              return exports2.EOF_FOLLOW_KEY;
            }
            var currRuleShortName = this.getLastExplicitRuleShortName();
            var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();
            var prevRuleShortName = this.getPreviousExplicitRuleShortName();
            return {
              ruleName: this.shortRuleNameToFullName(currRuleShortName),
              idxInCallingRule: currRuleIdx,
              inRule: this.shortRuleNameToFullName(prevRuleShortName)
            };
          };
          Recoverable2.prototype.buildFullFollowKeyStack = function() {
            var _this = this;
            var explicitRuleStack = this.RULE_STACK;
            var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;
            return utils_1.map(explicitRuleStack, function(ruleName, idx) {
              if (idx === 0) {
                return exports2.EOF_FOLLOW_KEY;
              }
              return {
                ruleName: _this.shortRuleNameToFullName(ruleName),
                idxInCallingRule: explicitOccurrenceStack[idx],
                inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])
              };
            });
          };
          Recoverable2.prototype.flattenFollowSet = function() {
            var _this = this;
            var followStack = utils_1.map(this.buildFullFollowKeyStack(), function(currKey) {
              return _this.getFollowSetFromFollowKey(currKey);
            });
            return utils_1.flatten(followStack);
          };
          Recoverable2.prototype.getFollowSetFromFollowKey = function(followKey) {
            if (followKey === exports2.EOF_FOLLOW_KEY) {
              return [tokens_public_1.EOF];
            }
            var followName = followKey.ruleName + followKey.idxInCallingRule + constants_1.IN + followKey.inRule;
            return this.resyncFollows[followName];
          };
          Recoverable2.prototype.addToResyncTokens = function(token, resyncTokens) {
            if (!this.tokenMatcher(token, tokens_public_1.EOF)) {
              resyncTokens.push(token);
            }
            return resyncTokens;
          };
          Recoverable2.prototype.reSyncTo = function(tokType) {
            var resyncedTokens = [];
            var nextTok = this.LA(1);
            while (this.tokenMatcher(nextTok, tokType) === false) {
              nextTok = this.SKIP_TOKEN();
              this.addToResyncTokens(nextTok, resyncedTokens);
            }
            return utils_1.dropRight(resyncedTokens);
          };
          Recoverable2.prototype.attemptInRepetitionRecovery = function(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
          };
          Recoverable2.prototype.getCurrentGrammarPath = function(tokType, tokIdxInRule) {
            var pathRuleStack = this.getHumanReadableRuleStack();
            var pathOccurrenceStack = utils_1.cloneArr(this.RULE_OCCURRENCE_STACK);
            var grammarPath = {
              ruleStack: pathRuleStack,
              occurrenceStack: pathOccurrenceStack,
              lastTok: tokType,
              lastTokOccurrence: tokIdxInRule
            };
            return grammarPath;
          };
          Recoverable2.prototype.getHumanReadableRuleStack = function() {
            var _this = this;
            return utils_1.map(this.RULE_STACK, function(currShortName) {
              return _this.shortRuleNameToFullName(currShortName);
            });
          };
          return Recoverable2;
        })()
      );
      exports2.Recoverable = Recoverable;
      function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
        var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);
        var firstAfterRepInfo = this.firstAfterRepMap[key];
        if (firstAfterRepInfo === void 0) {
          var currRuleName = this.getCurrRuleFullName();
          var ruleGrammar = this.getGAstProductions()[currRuleName];
          var walker = new nextToksWalker(ruleGrammar, prodOccurrence);
          firstAfterRepInfo = walker.startWalking();
          this.firstAfterRepMap[key] = firstAfterRepInfo;
        }
        var expectTokAfterLastMatch = firstAfterRepInfo.token;
        var nextTokIdx = firstAfterRepInfo.occurrence;
        var isEndOfRule = firstAfterRepInfo.isEndOfRule;
        if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === void 0) {
          expectTokAfterLastMatch = tokens_public_1.EOF;
          nextTokIdx = 1;
        }
        if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {
          this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);
        }
      }
      exports2.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/keys.js
  var require_keys = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/keys.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getKeyForAutomaticLookahead = exports2.AT_LEAST_ONE_SEP_IDX = exports2.MANY_SEP_IDX = exports2.AT_LEAST_ONE_IDX = exports2.MANY_IDX = exports2.OPTION_IDX = exports2.OR_IDX = exports2.BITS_FOR_ALT_IDX = exports2.BITS_FOR_RULE_IDX = exports2.BITS_FOR_OCCURRENCE_IDX = exports2.BITS_FOR_METHOD_TYPE = void 0;
      exports2.BITS_FOR_METHOD_TYPE = 4;
      exports2.BITS_FOR_OCCURRENCE_IDX = 8;
      exports2.BITS_FOR_RULE_IDX = 12;
      exports2.BITS_FOR_ALT_IDX = 8;
      exports2.OR_IDX = 1 << exports2.BITS_FOR_OCCURRENCE_IDX;
      exports2.OPTION_IDX = 2 << exports2.BITS_FOR_OCCURRENCE_IDX;
      exports2.MANY_IDX = 3 << exports2.BITS_FOR_OCCURRENCE_IDX;
      exports2.AT_LEAST_ONE_IDX = 4 << exports2.BITS_FOR_OCCURRENCE_IDX;
      exports2.MANY_SEP_IDX = 5 << exports2.BITS_FOR_OCCURRENCE_IDX;
      exports2.AT_LEAST_ONE_SEP_IDX = 6 << exports2.BITS_FOR_OCCURRENCE_IDX;
      function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {
        return occurrence | dslMethodIdx | ruleIdx;
      }
      exports2.getKeyForAutomaticLookahead = getKeyForAutomaticLookahead;
      var BITS_START_FOR_ALT_IDX = 32 - exports2.BITS_FOR_ALT_IDX;
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js
  var require_looksahead = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LooksAhead = void 0;
      var lookahead_1 = require_lookahead();
      var utils_1 = require_utils();
      var parser_1 = require_parser();
      var keys_1 = require_keys();
      var gast_1 = require_gast();
      var LooksAhead = (
        /** @class */
        (function() {
          function LooksAhead2() {
          }
          LooksAhead2.prototype.initLooksAhead = function(config) {
            this.dynamicTokensEnabled = utils_1.has(config, "dynamicTokensEnabled") ? config.dynamicTokensEnabled : parser_1.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;
            this.maxLookahead = utils_1.has(config, "maxLookahead") ? config.maxLookahead : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;
            this.lookAheadFuncsCache = utils_1.isES2015MapSupported() ? /* @__PURE__ */ new Map() : [];
            if (utils_1.isES2015MapSupported()) {
              this.getLaFuncFromCache = this.getLaFuncFromMap;
              this.setLaFuncCache = this.setLaFuncCacheUsingMap;
            } else {
              this.getLaFuncFromCache = this.getLaFuncFromObj;
              this.setLaFuncCache = this.setLaFuncUsingObj;
            }
          };
          LooksAhead2.prototype.preComputeLookaheadFunctions = function(rules) {
            var _this = this;
            utils_1.forEach(rules, function(currRule) {
              _this.TRACE_INIT(currRule.name + " Rule Lookahead", function() {
                var _a = gast_1.collectMethods(currRule), alternation = _a.alternation, repetition = _a.repetition, option = _a.option, repetitionMandatory = _a.repetitionMandatory, repetitionMandatoryWithSeparator = _a.repetitionMandatoryWithSeparator, repetitionWithSeparator = _a.repetitionWithSeparator;
                utils_1.forEach(alternation, function(currProd) {
                  var prodIdx = currProd.idx === 0 ? "" : currProd.idx;
                  _this.TRACE_INIT("" + gast_1.getProductionDslName(currProd) + prodIdx, function() {
                    var laFunc = lookahead_1.buildLookaheadFuncForOr(currProd.idx, currRule, currProd.maxLookahead || _this.maxLookahead, currProd.hasPredicates, _this.dynamicTokensEnabled, _this.lookAheadBuilderForAlternatives);
                    var key = keys_1.getKeyForAutomaticLookahead(_this.fullRuleNameToShort[currRule.name], keys_1.OR_IDX, currProd.idx);
                    _this.setLaFuncCache(key, laFunc);
                  });
                });
                utils_1.forEach(repetition, function(currProd) {
                  _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_IDX, lookahead_1.PROD_TYPE.REPETITION, currProd.maxLookahead, gast_1.getProductionDslName(currProd));
                });
                utils_1.forEach(option, function(currProd) {
                  _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.OPTION_IDX, lookahead_1.PROD_TYPE.OPTION, currProd.maxLookahead, gast_1.getProductionDslName(currProd));
                });
                utils_1.forEach(repetitionMandatory, function(currProd) {
                  _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_IDX, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, currProd.maxLookahead, gast_1.getProductionDslName(currProd));
                });
                utils_1.forEach(repetitionMandatoryWithSeparator, function(currProd) {
                  _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_SEP_IDX, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currProd.maxLookahead, gast_1.getProductionDslName(currProd));
                });
                utils_1.forEach(repetitionWithSeparator, function(currProd) {
                  _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_SEP_IDX, lookahead_1.PROD_TYPE.REPETITION_WITH_SEPARATOR, currProd.maxLookahead, gast_1.getProductionDslName(currProd));
                });
              });
            });
          };
          LooksAhead2.prototype.computeLookaheadFunc = function(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {
            var _this = this;
            this.TRACE_INIT("" + dslMethodName + (prodOccurrence === 0 ? "" : prodOccurrence), function() {
              var laFunc = lookahead_1.buildLookaheadFuncForOptionalProd(prodOccurrence, rule, prodMaxLookahead || _this.maxLookahead, _this.dynamicTokensEnabled, prodType, _this.lookAheadBuilderForOptional);
              var key = keys_1.getKeyForAutomaticLookahead(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);
              _this.setLaFuncCache(key, laFunc);
            });
          };
          LooksAhead2.prototype.lookAheadBuilderForOptional = function(alt, tokenMatcher, dynamicTokensEnabled) {
            return lookahead_1.buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled);
          };
          LooksAhead2.prototype.lookAheadBuilderForAlternatives = function(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {
            return lookahead_1.buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled);
          };
          LooksAhead2.prototype.getKeyForAutomaticLookahead = function(dslMethodIdx, occurrence) {
            var currRuleShortName = this.getLastExplicitRuleShortName();
            return keys_1.getKeyForAutomaticLookahead(currRuleShortName, dslMethodIdx, occurrence);
          };
          LooksAhead2.prototype.getLaFuncFromCache = function(key) {
            return void 0;
          };
          LooksAhead2.prototype.getLaFuncFromMap = function(key) {
            return this.lookAheadFuncsCache.get(key);
          };
          LooksAhead2.prototype.getLaFuncFromObj = function(key) {
            return this.lookAheadFuncsCache[key];
          };
          LooksAhead2.prototype.setLaFuncCache = function(key, value) {
          };
          LooksAhead2.prototype.setLaFuncCacheUsingMap = function(key, value) {
            this.lookAheadFuncsCache.set(key, value);
          };
          LooksAhead2.prototype.setLaFuncUsingObj = function(key, value) {
            this.lookAheadFuncsCache[key] = value;
          };
          return LooksAhead2;
        })()
      );
      exports2.LooksAhead = LooksAhead;
    }
  });

  // node_modules/chevrotain/lib/src/parse/cst/cst.js
  var require_cst = __commonJS({
    "node_modules/chevrotain/lib/src/parse/cst/cst.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.addNoneTerminalToCst = exports2.addTerminalToCst = exports2.setNodeLocationFull = exports2.setNodeLocationOnlyOffset = void 0;
      function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {
        if (isNaN(currNodeLocation.startOffset) === true) {
          currNodeLocation.startOffset = newLocationInfo.startOffset;
          currNodeLocation.endOffset = newLocationInfo.endOffset;
        } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
          currNodeLocation.endOffset = newLocationInfo.endOffset;
        }
      }
      exports2.setNodeLocationOnlyOffset = setNodeLocationOnlyOffset;
      function setNodeLocationFull(currNodeLocation, newLocationInfo) {
        if (isNaN(currNodeLocation.startOffset) === true) {
          currNodeLocation.startOffset = newLocationInfo.startOffset;
          currNodeLocation.startColumn = newLocationInfo.startColumn;
          currNodeLocation.startLine = newLocationInfo.startLine;
          currNodeLocation.endOffset = newLocationInfo.endOffset;
          currNodeLocation.endColumn = newLocationInfo.endColumn;
          currNodeLocation.endLine = newLocationInfo.endLine;
        } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
          currNodeLocation.endOffset = newLocationInfo.endOffset;
          currNodeLocation.endColumn = newLocationInfo.endColumn;
          currNodeLocation.endLine = newLocationInfo.endLine;
        }
      }
      exports2.setNodeLocationFull = setNodeLocationFull;
      function addTerminalToCst(node, token, tokenTypeName) {
        if (node.children[tokenTypeName] === void 0) {
          node.children[tokenTypeName] = [token];
        } else {
          node.children[tokenTypeName].push(token);
        }
      }
      exports2.addTerminalToCst = addTerminalToCst;
      function addNoneTerminalToCst(node, ruleName, ruleResult) {
        if (node.children[ruleName] === void 0) {
          node.children[ruleName] = [ruleResult];
        } else {
          node.children[ruleName].push(ruleResult);
        }
      }
      exports2.addNoneTerminalToCst = addNoneTerminalToCst;
    }
  });

  // node_modules/chevrotain/lib/src/lang/lang_extensions.js
  var require_lang_extensions = __commonJS({
    "node_modules/chevrotain/lib/src/lang/lang_extensions.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.defineNameProp = exports2.functionName = exports2.classNameFromInstance = void 0;
      var utils_1 = require_utils();
      function classNameFromInstance(instance) {
        return functionName(instance.constructor);
      }
      exports2.classNameFromInstance = classNameFromInstance;
      var NAME = "name";
      function functionName(func) {
        var existingNameProp = func.name;
        if (existingNameProp) {
          return existingNameProp;
        } else {
          return "anonymous";
        }
      }
      exports2.functionName = functionName;
      function defineNameProp(obj, nameValue) {
        var namePropDescriptor = Object.getOwnPropertyDescriptor(obj, NAME);
        if (utils_1.isUndefined(namePropDescriptor) || namePropDescriptor.configurable) {
          Object.defineProperty(obj, NAME, {
            enumerable: false,
            configurable: true,
            writable: false,
            value: nameValue
          });
          return true;
        }
        return false;
      }
      exports2.defineNameProp = defineNameProp;
    }
  });

  // node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js
  var require_cst_visitor = __commonJS({
    "node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.validateRedundantMethods = exports2.validateMissingCstMethods = exports2.validateVisitor = exports2.CstVisitorDefinitionError = exports2.createBaseVisitorConstructorWithDefaults = exports2.createBaseSemanticVisitorConstructor = exports2.defaultVisit = void 0;
      var utils_1 = require_utils();
      var lang_extensions_1 = require_lang_extensions();
      function defaultVisit(ctx, param) {
        var childrenNames = utils_1.keys(ctx);
        var childrenNamesLength = childrenNames.length;
        for (var i = 0; i < childrenNamesLength; i++) {
          var currChildName = childrenNames[i];
          var currChildArray = ctx[currChildName];
          var currChildArrayLength = currChildArray.length;
          for (var j = 0; j < currChildArrayLength; j++) {
            var currChild = currChildArray[j];
            if (currChild.tokenTypeIdx === void 0) {
              this[currChild.name](currChild.children, param);
            }
          }
        }
        return void 0;
      }
      exports2.defaultVisit = defaultVisit;
      function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {
        var derivedConstructor = function() {
        };
        lang_extensions_1.defineNameProp(derivedConstructor, grammarName + "BaseSemantics");
        var semanticProto = {
          visit: function(cstNode, param) {
            if (utils_1.isArray(cstNode)) {
              cstNode = cstNode[0];
            }
            if (utils_1.isUndefined(cstNode)) {
              return void 0;
            }
            return this[cstNode.name](cstNode.children, param);
          },
          validateVisitor: function() {
            var semanticDefinitionErrors = validateVisitor(this, ruleNames);
            if (!utils_1.isEmpty(semanticDefinitionErrors)) {
              var errorMessages = utils_1.map(semanticDefinitionErrors, function(currDefError) {
                return currDefError.msg;
              });
              throw Error("Errors Detected in CST Visitor <" + lang_extensions_1.functionName(this.constructor) + ">:\n	" + ("" + errorMessages.join("\n\n").replace(/\n/g, "\n	")));
            }
          }
        };
        derivedConstructor.prototype = semanticProto;
        derivedConstructor.prototype.constructor = derivedConstructor;
        derivedConstructor._RULE_NAMES = ruleNames;
        return derivedConstructor;
      }
      exports2.createBaseSemanticVisitorConstructor = createBaseSemanticVisitorConstructor;
      function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {
        var derivedConstructor = function() {
        };
        lang_extensions_1.defineNameProp(derivedConstructor, grammarName + "BaseSemanticsWithDefaults");
        var withDefaultsProto = Object.create(baseConstructor.prototype);
        utils_1.forEach(ruleNames, function(ruleName) {
          withDefaultsProto[ruleName] = defaultVisit;
        });
        derivedConstructor.prototype = withDefaultsProto;
        derivedConstructor.prototype.constructor = derivedConstructor;
        return derivedConstructor;
      }
      exports2.createBaseVisitorConstructorWithDefaults = createBaseVisitorConstructorWithDefaults;
      var CstVisitorDefinitionError;
      (function(CstVisitorDefinitionError2) {
        CstVisitorDefinitionError2[CstVisitorDefinitionError2["REDUNDANT_METHOD"] = 0] = "REDUNDANT_METHOD";
        CstVisitorDefinitionError2[CstVisitorDefinitionError2["MISSING_METHOD"] = 1] = "MISSING_METHOD";
      })(CstVisitorDefinitionError = exports2.CstVisitorDefinitionError || (exports2.CstVisitorDefinitionError = {}));
      function validateVisitor(visitorInstance, ruleNames) {
        var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);
        var redundantErrors = validateRedundantMethods(visitorInstance, ruleNames);
        return missingErrors.concat(redundantErrors);
      }
      exports2.validateVisitor = validateVisitor;
      function validateMissingCstMethods(visitorInstance, ruleNames) {
        var errors = utils_1.map(ruleNames, function(currRuleName) {
          if (!utils_1.isFunction(visitorInstance[currRuleName])) {
            return {
              msg: "Missing visitor method: <" + currRuleName + "> on " + lang_extensions_1.functionName(visitorInstance.constructor) + " CST Visitor.",
              type: CstVisitorDefinitionError.MISSING_METHOD,
              methodName: currRuleName
            };
          }
        });
        return utils_1.compact(errors);
      }
      exports2.validateMissingCstMethods = validateMissingCstMethods;
      var VALID_PROP_NAMES = ["constructor", "visit", "validateVisitor"];
      function validateRedundantMethods(visitorInstance, ruleNames) {
        var errors = [];
        for (var prop in visitorInstance) {
          if (utils_1.isFunction(visitorInstance[prop]) && !utils_1.contains(VALID_PROP_NAMES, prop) && !utils_1.contains(ruleNames, prop)) {
            errors.push({
              msg: "Redundant visitor method: <" + prop + "> on " + lang_extensions_1.functionName(visitorInstance.constructor) + " CST Visitor\nThere is no Grammar Rule corresponding to this method's name.\n",
              type: CstVisitorDefinitionError.REDUNDANT_METHOD,
              methodName: prop
            });
          }
        }
        return errors;
      }
      exports2.validateRedundantMethods = validateRedundantMethods;
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js
  var require_tree_builder = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TreeBuilder = void 0;
      var cst_1 = require_cst();
      var utils_1 = require_utils();
      var cst_visitor_1 = require_cst_visitor();
      var parser_1 = require_parser();
      var TreeBuilder = (
        /** @class */
        (function() {
          function TreeBuilder2() {
          }
          TreeBuilder2.prototype.initTreeBuilder = function(config) {
            this.CST_STACK = [];
            this.outputCst = config.outputCst;
            this.nodeLocationTracking = utils_1.has(config, "nodeLocationTracking") ? config.nodeLocationTracking : parser_1.DEFAULT_PARSER_CONFIG.nodeLocationTracking;
            if (!this.outputCst) {
              this.cstInvocationStateUpdate = utils_1.NOOP;
              this.cstFinallyStateUpdate = utils_1.NOOP;
              this.cstPostTerminal = utils_1.NOOP;
              this.cstPostNonTerminal = utils_1.NOOP;
              this.cstPostRule = utils_1.NOOP;
            } else {
              if (/full/i.test(this.nodeLocationTracking)) {
                if (this.recoveryEnabled) {
                  this.setNodeLocationFromToken = cst_1.setNodeLocationFull;
                  this.setNodeLocationFromNode = cst_1.setNodeLocationFull;
                  this.cstPostRule = utils_1.NOOP;
                  this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;
                } else {
                  this.setNodeLocationFromToken = utils_1.NOOP;
                  this.setNodeLocationFromNode = utils_1.NOOP;
                  this.cstPostRule = this.cstPostRuleFull;
                  this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;
                }
              } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {
                if (this.recoveryEnabled) {
                  this.setNodeLocationFromToken = cst_1.setNodeLocationOnlyOffset;
                  this.setNodeLocationFromNode = cst_1.setNodeLocationOnlyOffset;
                  this.cstPostRule = utils_1.NOOP;
                  this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;
                } else {
                  this.setNodeLocationFromToken = utils_1.NOOP;
                  this.setNodeLocationFromNode = utils_1.NOOP;
                  this.cstPostRule = this.cstPostRuleOnlyOffset;
                  this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;
                }
              } else if (/none/i.test(this.nodeLocationTracking)) {
                this.setNodeLocationFromToken = utils_1.NOOP;
                this.setNodeLocationFromNode = utils_1.NOOP;
                this.cstPostRule = utils_1.NOOP;
                this.setInitialNodeLocation = utils_1.NOOP;
              } else {
                throw Error('Invalid <nodeLocationTracking> config option: "' + config.nodeLocationTracking + '"');
              }
            }
          };
          TreeBuilder2.prototype.setInitialNodeLocationOnlyOffsetRecovery = function(cstNode) {
            cstNode.location = {
              startOffset: NaN,
              endOffset: NaN
            };
          };
          TreeBuilder2.prototype.setInitialNodeLocationOnlyOffsetRegular = function(cstNode) {
            cstNode.location = {
              // without error recovery the starting Location of a new CstNode is guaranteed
              // To be the next Token's startOffset (for valid inputs).
              // For invalid inputs there won't be any CSTOutput so this potential
              // inaccuracy does not matter
              startOffset: this.LA(1).startOffset,
              endOffset: NaN
            };
          };
          TreeBuilder2.prototype.setInitialNodeLocationFullRecovery = function(cstNode) {
            cstNode.location = {
              startOffset: NaN,
              startLine: NaN,
              startColumn: NaN,
              endOffset: NaN,
              endLine: NaN,
              endColumn: NaN
            };
          };
          TreeBuilder2.prototype.setInitialNodeLocationFullRegular = function(cstNode) {
            var nextToken = this.LA(1);
            cstNode.location = {
              startOffset: nextToken.startOffset,
              startLine: nextToken.startLine,
              startColumn: nextToken.startColumn,
              endOffset: NaN,
              endLine: NaN,
              endColumn: NaN
            };
          };
          TreeBuilder2.prototype.cstInvocationStateUpdate = function(fullRuleName, shortName) {
            var cstNode = {
              name: fullRuleName,
              children: {}
            };
            this.setInitialNodeLocation(cstNode);
            this.CST_STACK.push(cstNode);
          };
          TreeBuilder2.prototype.cstFinallyStateUpdate = function() {
            this.CST_STACK.pop();
          };
          TreeBuilder2.prototype.cstPostRuleFull = function(ruleCstNode) {
            var prevToken = this.LA(0);
            var loc = ruleCstNode.location;
            if (loc.startOffset <= prevToken.startOffset === true) {
              loc.endOffset = prevToken.endOffset;
              loc.endLine = prevToken.endLine;
              loc.endColumn = prevToken.endColumn;
            } else {
              loc.startOffset = NaN;
              loc.startLine = NaN;
              loc.startColumn = NaN;
            }
          };
          TreeBuilder2.prototype.cstPostRuleOnlyOffset = function(ruleCstNode) {
            var prevToken = this.LA(0);
            var loc = ruleCstNode.location;
            if (loc.startOffset <= prevToken.startOffset === true) {
              loc.endOffset = prevToken.endOffset;
            } else {
              loc.startOffset = NaN;
            }
          };
          TreeBuilder2.prototype.cstPostTerminal = function(key, consumedToken) {
            var rootCst = this.CST_STACK[this.CST_STACK.length - 1];
            cst_1.addTerminalToCst(rootCst, consumedToken, key);
            this.setNodeLocationFromToken(rootCst.location, consumedToken);
          };
          TreeBuilder2.prototype.cstPostNonTerminal = function(ruleCstResult, ruleName) {
            var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];
            cst_1.addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);
            this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);
          };
          TreeBuilder2.prototype.getBaseCstVisitorConstructor = function() {
            if (utils_1.isUndefined(this.baseCstVisitorConstructor)) {
              var newBaseCstVisitorConstructor = cst_visitor_1.createBaseSemanticVisitorConstructor(this.className, utils_1.keys(this.gastProductionsCache));
              this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;
              return newBaseCstVisitorConstructor;
            }
            return this.baseCstVisitorConstructor;
          };
          TreeBuilder2.prototype.getBaseCstVisitorConstructorWithDefaults = function() {
            if (utils_1.isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {
              var newConstructor = cst_visitor_1.createBaseVisitorConstructorWithDefaults(this.className, utils_1.keys(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
              this.baseCstVisitorWithDefaultsConstructor = newConstructor;
              return newConstructor;
            }
            return this.baseCstVisitorWithDefaultsConstructor;
          };
          TreeBuilder2.prototype.getLastExplicitRuleShortName = function() {
            var ruleStack = this.RULE_STACK;
            return ruleStack[ruleStack.length - 1];
          };
          TreeBuilder2.prototype.getPreviousExplicitRuleShortName = function() {
            var ruleStack = this.RULE_STACK;
            return ruleStack[ruleStack.length - 2];
          };
          TreeBuilder2.prototype.getLastExplicitRuleOccurrenceIndex = function() {
            var occurrenceStack = this.RULE_OCCURRENCE_STACK;
            return occurrenceStack[occurrenceStack.length - 1];
          };
          return TreeBuilder2;
        })()
      );
      exports2.TreeBuilder = TreeBuilder;
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js
  var require_lexer_adapter = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LexerAdapter = void 0;
      var parser_1 = require_parser();
      var LexerAdapter = (
        /** @class */
        (function() {
          function LexerAdapter2() {
          }
          LexerAdapter2.prototype.initLexerAdapter = function() {
            this.tokVector = [];
            this.tokVectorLength = 0;
            this.currIdx = -1;
          };
          Object.defineProperty(LexerAdapter2.prototype, "input", {
            get: function() {
              return this.tokVector;
            },
            set: function(newInput) {
              if (this.selfAnalysisDone !== true) {
                throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
              }
              this.reset();
              this.tokVector = newInput;
              this.tokVectorLength = newInput.length;
            },
            enumerable: false,
            configurable: true
          });
          LexerAdapter2.prototype.SKIP_TOKEN = function() {
            if (this.currIdx <= this.tokVector.length - 2) {
              this.consumeToken();
              return this.LA(1);
            } else {
              return parser_1.END_OF_FILE;
            }
          };
          LexerAdapter2.prototype.LA = function(howMuch) {
            var soughtIdx = this.currIdx + howMuch;
            if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {
              return parser_1.END_OF_FILE;
            } else {
              return this.tokVector[soughtIdx];
            }
          };
          LexerAdapter2.prototype.consumeToken = function() {
            this.currIdx++;
          };
          LexerAdapter2.prototype.exportLexerState = function() {
            return this.currIdx;
          };
          LexerAdapter2.prototype.importLexerState = function(newState) {
            this.currIdx = newState;
          };
          LexerAdapter2.prototype.resetLexerState = function() {
            this.currIdx = -1;
          };
          LexerAdapter2.prototype.moveToTerminatedState = function() {
            this.currIdx = this.tokVector.length - 1;
          };
          LexerAdapter2.prototype.getLexerPosition = function() {
            return this.exportLexerState();
          };
          return LexerAdapter2;
        })()
      );
      exports2.LexerAdapter = LexerAdapter;
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js
  var require_recognizer_api = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.RecognizerApi = void 0;
      var utils_1 = require_utils();
      var exceptions_public_1 = require_exceptions_public();
      var parser_1 = require_parser();
      var errors_public_1 = require_errors_public();
      var checks_1 = require_checks();
      var gast_public_1 = require_gast_public();
      var RecognizerApi = (
        /** @class */
        (function() {
          function RecognizerApi2() {
          }
          RecognizerApi2.prototype.ACTION = function(impl) {
            return impl.call(this);
          };
          RecognizerApi2.prototype.consume = function(idx, tokType, options) {
            return this.consumeInternal(tokType, idx, options);
          };
          RecognizerApi2.prototype.subrule = function(idx, ruleToCall, options) {
            return this.subruleInternal(ruleToCall, idx, options);
          };
          RecognizerApi2.prototype.option = function(idx, actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, idx);
          };
          RecognizerApi2.prototype.or = function(idx, altsOrOpts) {
            return this.orInternal(altsOrOpts, idx);
          };
          RecognizerApi2.prototype.many = function(idx, actionORMethodDef) {
            return this.manyInternal(idx, actionORMethodDef);
          };
          RecognizerApi2.prototype.atLeastOne = function(idx, actionORMethodDef) {
            return this.atLeastOneInternal(idx, actionORMethodDef);
          };
          RecognizerApi2.prototype.CONSUME = function(tokType, options) {
            return this.consumeInternal(tokType, 0, options);
          };
          RecognizerApi2.prototype.CONSUME1 = function(tokType, options) {
            return this.consumeInternal(tokType, 1, options);
          };
          RecognizerApi2.prototype.CONSUME2 = function(tokType, options) {
            return this.consumeInternal(tokType, 2, options);
          };
          RecognizerApi2.prototype.CONSUME3 = function(tokType, options) {
            return this.consumeInternal(tokType, 3, options);
          };
          RecognizerApi2.prototype.CONSUME4 = function(tokType, options) {
            return this.consumeInternal(tokType, 4, options);
          };
          RecognizerApi2.prototype.CONSUME5 = function(tokType, options) {
            return this.consumeInternal(tokType, 5, options);
          };
          RecognizerApi2.prototype.CONSUME6 = function(tokType, options) {
            return this.consumeInternal(tokType, 6, options);
          };
          RecognizerApi2.prototype.CONSUME7 = function(tokType, options) {
            return this.consumeInternal(tokType, 7, options);
          };
          RecognizerApi2.prototype.CONSUME8 = function(tokType, options) {
            return this.consumeInternal(tokType, 8, options);
          };
          RecognizerApi2.prototype.CONSUME9 = function(tokType, options) {
            return this.consumeInternal(tokType, 9, options);
          };
          RecognizerApi2.prototype.SUBRULE = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 0, options);
          };
          RecognizerApi2.prototype.SUBRULE1 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 1, options);
          };
          RecognizerApi2.prototype.SUBRULE2 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 2, options);
          };
          RecognizerApi2.prototype.SUBRULE3 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 3, options);
          };
          RecognizerApi2.prototype.SUBRULE4 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 4, options);
          };
          RecognizerApi2.prototype.SUBRULE5 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 5, options);
          };
          RecognizerApi2.prototype.SUBRULE6 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 6, options);
          };
          RecognizerApi2.prototype.SUBRULE7 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 7, options);
          };
          RecognizerApi2.prototype.SUBRULE8 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 8, options);
          };
          RecognizerApi2.prototype.SUBRULE9 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 9, options);
          };
          RecognizerApi2.prototype.OPTION = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 0);
          };
          RecognizerApi2.prototype.OPTION1 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 1);
          };
          RecognizerApi2.prototype.OPTION2 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 2);
          };
          RecognizerApi2.prototype.OPTION3 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 3);
          };
          RecognizerApi2.prototype.OPTION4 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 4);
          };
          RecognizerApi2.prototype.OPTION5 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 5);
          };
          RecognizerApi2.prototype.OPTION6 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 6);
          };
          RecognizerApi2.prototype.OPTION7 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 7);
          };
          RecognizerApi2.prototype.OPTION8 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 8);
          };
          RecognizerApi2.prototype.OPTION9 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 9);
          };
          RecognizerApi2.prototype.OR = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 0);
          };
          RecognizerApi2.prototype.OR1 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 1);
          };
          RecognizerApi2.prototype.OR2 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 2);
          };
          RecognizerApi2.prototype.OR3 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 3);
          };
          RecognizerApi2.prototype.OR4 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 4);
          };
          RecognizerApi2.prototype.OR5 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 5);
          };
          RecognizerApi2.prototype.OR6 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 6);
          };
          RecognizerApi2.prototype.OR7 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 7);
          };
          RecognizerApi2.prototype.OR8 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 8);
          };
          RecognizerApi2.prototype.OR9 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 9);
          };
          RecognizerApi2.prototype.MANY = function(actionORMethodDef) {
            this.manyInternal(0, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY1 = function(actionORMethodDef) {
            this.manyInternal(1, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY2 = function(actionORMethodDef) {
            this.manyInternal(2, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY3 = function(actionORMethodDef) {
            this.manyInternal(3, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY4 = function(actionORMethodDef) {
            this.manyInternal(4, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY5 = function(actionORMethodDef) {
            this.manyInternal(5, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY6 = function(actionORMethodDef) {
            this.manyInternal(6, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY7 = function(actionORMethodDef) {
            this.manyInternal(7, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY8 = function(actionORMethodDef) {
            this.manyInternal(8, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY9 = function(actionORMethodDef) {
            this.manyInternal(9, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY_SEP = function(options) {
            this.manySepFirstInternal(0, options);
          };
          RecognizerApi2.prototype.MANY_SEP1 = function(options) {
            this.manySepFirstInternal(1, options);
          };
          RecognizerApi2.prototype.MANY_SEP2 = function(options) {
            this.manySepFirstInternal(2, options);
          };
          RecognizerApi2.prototype.MANY_SEP3 = function(options) {
            this.manySepFirstInternal(3, options);
          };
          RecognizerApi2.prototype.MANY_SEP4 = function(options) {
            this.manySepFirstInternal(4, options);
          };
          RecognizerApi2.prototype.MANY_SEP5 = function(options) {
            this.manySepFirstInternal(5, options);
          };
          RecognizerApi2.prototype.MANY_SEP6 = function(options) {
            this.manySepFirstInternal(6, options);
          };
          RecognizerApi2.prototype.MANY_SEP7 = function(options) {
            this.manySepFirstInternal(7, options);
          };
          RecognizerApi2.prototype.MANY_SEP8 = function(options) {
            this.manySepFirstInternal(8, options);
          };
          RecognizerApi2.prototype.MANY_SEP9 = function(options) {
            this.manySepFirstInternal(9, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE = function(actionORMethodDef) {
            this.atLeastOneInternal(0, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE1 = function(actionORMethodDef) {
            return this.atLeastOneInternal(1, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE2 = function(actionORMethodDef) {
            this.atLeastOneInternal(2, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE3 = function(actionORMethodDef) {
            this.atLeastOneInternal(3, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE4 = function(actionORMethodDef) {
            this.atLeastOneInternal(4, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE5 = function(actionORMethodDef) {
            this.atLeastOneInternal(5, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE6 = function(actionORMethodDef) {
            this.atLeastOneInternal(6, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE7 = function(actionORMethodDef) {
            this.atLeastOneInternal(7, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE8 = function(actionORMethodDef) {
            this.atLeastOneInternal(8, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE9 = function(actionORMethodDef) {
            this.atLeastOneInternal(9, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP = function(options) {
            this.atLeastOneSepFirstInternal(0, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP1 = function(options) {
            this.atLeastOneSepFirstInternal(1, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP2 = function(options) {
            this.atLeastOneSepFirstInternal(2, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP3 = function(options) {
            this.atLeastOneSepFirstInternal(3, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP4 = function(options) {
            this.atLeastOneSepFirstInternal(4, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP5 = function(options) {
            this.atLeastOneSepFirstInternal(5, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP6 = function(options) {
            this.atLeastOneSepFirstInternal(6, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP7 = function(options) {
            this.atLeastOneSepFirstInternal(7, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP8 = function(options) {
            this.atLeastOneSepFirstInternal(8, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP9 = function(options) {
            this.atLeastOneSepFirstInternal(9, options);
          };
          RecognizerApi2.prototype.RULE = function(name, implementation, config) {
            if (config === void 0) {
              config = parser_1.DEFAULT_RULE_CONFIG;
            }
            if (utils_1.contains(this.definedRulesNames, name)) {
              var errMsg = errors_public_1.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({
                topLevelRule: name,
                grammarName: this.className
              });
              var error = {
                message: errMsg,
                type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
                ruleName: name
              };
              this.definitionErrors.push(error);
            }
            this.definedRulesNames.push(name);
            var ruleImplementation = this.defineRule(name, implementation, config);
            this[name] = ruleImplementation;
            return ruleImplementation;
          };
          RecognizerApi2.prototype.OVERRIDE_RULE = function(name, impl, config) {
            if (config === void 0) {
              config = parser_1.DEFAULT_RULE_CONFIG;
            }
            var ruleErrors = [];
            ruleErrors = ruleErrors.concat(checks_1.validateRuleIsOverridden(name, this.definedRulesNames, this.className));
            this.definitionErrors.push.apply(this.definitionErrors, ruleErrors);
            var ruleImplementation = this.defineRule(name, impl, config);
            this[name] = ruleImplementation;
            return ruleImplementation;
          };
          RecognizerApi2.prototype.BACKTRACK = function(grammarRule, args) {
            return function() {
              this.isBackTrackingStack.push(1);
              var orgState = this.saveRecogState();
              try {
                grammarRule.apply(this, args);
                return true;
              } catch (e) {
                if (exceptions_public_1.isRecognitionException(e)) {
                  return false;
                } else {
                  throw e;
                }
              } finally {
                this.reloadRecogState(orgState);
                this.isBackTrackingStack.pop();
              }
            };
          };
          RecognizerApi2.prototype.getGAstProductions = function() {
            return this.gastProductionsCache;
          };
          RecognizerApi2.prototype.getSerializedGastProductions = function() {
            return gast_public_1.serializeGrammar(utils_1.values(this.gastProductionsCache));
          };
          return RecognizerApi2;
        })()
      );
      exports2.RecognizerApi = RecognizerApi;
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js
  var require_recognizer_engine = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.RecognizerEngine = void 0;
      var utils_1 = require_utils();
      var keys_1 = require_keys();
      var exceptions_public_1 = require_exceptions_public();
      var lookahead_1 = require_lookahead();
      var interpreter_1 = require_interpreter();
      var parser_1 = require_parser();
      var recoverable_1 = require_recoverable();
      var tokens_public_1 = require_tokens_public();
      var tokens_1 = require_tokens();
      var lang_extensions_1 = require_lang_extensions();
      var RecognizerEngine = (
        /** @class */
        (function() {
          function RecognizerEngine2() {
          }
          RecognizerEngine2.prototype.initRecognizerEngine = function(tokenVocabulary, config) {
            this.className = lang_extensions_1.classNameFromInstance(this);
            this.shortRuleNameToFull = {};
            this.fullRuleNameToShort = {};
            this.ruleShortNameIdx = 256;
            this.tokenMatcher = tokens_1.tokenStructuredMatcherNoCategories;
            this.definedRulesNames = [];
            this.tokensMap = {};
            this.isBackTrackingStack = [];
            this.RULE_STACK = [];
            this.RULE_OCCURRENCE_STACK = [];
            this.gastProductionsCache = {};
            if (utils_1.has(config, "serializedGrammar")) {
              throw Error("The Parser's configuration can no longer contain a <serializedGrammar> property.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\n	For Further details.");
            }
            if (utils_1.isArray(tokenVocabulary)) {
              if (utils_1.isEmpty(tokenVocabulary)) {
                throw Error("A Token Vocabulary cannot be empty.\n	Note that the first argument for the parser constructor\n	is no longer a Token vector (since v4.0).");
              }
              if (typeof tokenVocabulary[0].startOffset === "number") {
                throw Error("The Parser constructor no longer accepts a token vector as the first argument.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\n	For Further details.");
              }
            }
            if (utils_1.isArray(tokenVocabulary)) {
              this.tokensMap = utils_1.reduce(tokenVocabulary, function(acc, tokType) {
                acc[tokType.name] = tokType;
                return acc;
              }, {});
            } else if (utils_1.has(tokenVocabulary, "modes") && utils_1.every(utils_1.flatten(utils_1.values(tokenVocabulary.modes)), tokens_1.isTokenType)) {
              var allTokenTypes = utils_1.flatten(utils_1.values(tokenVocabulary.modes));
              var uniqueTokens = utils_1.uniq(allTokenTypes);
              this.tokensMap = utils_1.reduce(uniqueTokens, function(acc, tokType) {
                acc[tokType.name] = tokType;
                return acc;
              }, {});
            } else if (utils_1.isObject(tokenVocabulary)) {
              this.tokensMap = utils_1.cloneObj(tokenVocabulary);
            } else {
              throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
            }
            this.tokensMap["EOF"] = tokens_public_1.EOF;
            var noTokenCategoriesUsed = utils_1.every(utils_1.values(tokenVocabulary), function(tokenConstructor) {
              return utils_1.isEmpty(tokenConstructor.categoryMatches);
            });
            this.tokenMatcher = noTokenCategoriesUsed ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
            tokens_1.augmentTokenTypes(utils_1.values(this.tokensMap));
          };
          RecognizerEngine2.prototype.defineRule = function(ruleName, impl, config) {
            if (this.selfAnalysisDone) {
              throw Error("Grammar rule <" + ruleName + "> may not be defined after the 'performSelfAnalysis' method has been called'\nMake sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.");
            }
            var resyncEnabled = utils_1.has(config, "resyncEnabled") ? config.resyncEnabled : parser_1.DEFAULT_RULE_CONFIG.resyncEnabled;
            var recoveryValueFunc = utils_1.has(config, "recoveryValueFunc") ? config.recoveryValueFunc : parser_1.DEFAULT_RULE_CONFIG.recoveryValueFunc;
            var shortName = this.ruleShortNameIdx << keys_1.BITS_FOR_METHOD_TYPE + keys_1.BITS_FOR_OCCURRENCE_IDX;
            this.ruleShortNameIdx++;
            this.shortRuleNameToFull[shortName] = ruleName;
            this.fullRuleNameToShort[ruleName] = shortName;
            function invokeRuleWithTry(args) {
              try {
                if (this.outputCst === true) {
                  impl.apply(this, args);
                  var cst = this.CST_STACK[this.CST_STACK.length - 1];
                  this.cstPostRule(cst);
                  return cst;
                } else {
                  return impl.apply(this, args);
                }
              } catch (e) {
                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
              } finally {
                this.ruleFinallyStateUpdate();
              }
            }
            var wrappedGrammarRule;
            wrappedGrammarRule = function(idxInCallingRule, args) {
              if (idxInCallingRule === void 0) {
                idxInCallingRule = 0;
              }
              this.ruleInvocationStateUpdate(shortName, ruleName, idxInCallingRule);
              return invokeRuleWithTry.call(this, args);
            };
            var ruleNamePropName = "ruleName";
            wrappedGrammarRule[ruleNamePropName] = ruleName;
            wrappedGrammarRule["originalGrammarAction"] = impl;
            return wrappedGrammarRule;
          };
          RecognizerEngine2.prototype.invokeRuleCatch = function(e, resyncEnabledConfig, recoveryValueFunc) {
            var isFirstInvokedRule = this.RULE_STACK.length === 1;
            var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;
            if (exceptions_public_1.isRecognitionException(e)) {
              var recogError = e;
              if (reSyncEnabled) {
                var reSyncTokType = this.findReSyncTokenType();
                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {
                  recogError.resyncedTokens = this.reSyncTo(reSyncTokType);
                  if (this.outputCst) {
                    var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                    partialCstResult.recoveredNode = true;
                    return partialCstResult;
                  } else {
                    return recoveryValueFunc();
                  }
                } else {
                  if (this.outputCst) {
                    var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                    partialCstResult.recoveredNode = true;
                    recogError.partialCstResult = partialCstResult;
                  }
                  throw recogError;
                }
              } else if (isFirstInvokedRule) {
                this.moveToTerminatedState();
                return recoveryValueFunc();
              } else {
                throw recogError;
              }
            } else {
              throw e;
            }
          };
          RecognizerEngine2.prototype.optionInternal = function(actionORMethodDef, occurrence) {
            var key = this.getKeyForAutomaticLookahead(keys_1.OPTION_IDX, occurrence);
            return this.optionInternalLogic(actionORMethodDef, occurrence, key);
          };
          RecognizerEngine2.prototype.optionInternalLogic = function(actionORMethodDef, occurrence, key) {
            var _this = this;
            var lookAheadFunc = this.getLaFuncFromCache(key);
            var action;
            var predicate;
            if (actionORMethodDef.DEF !== void 0) {
              action = actionORMethodDef.DEF;
              predicate = actionORMethodDef.GATE;
              if (predicate !== void 0) {
                var orgLookaheadFunction_1 = lookAheadFunc;
                lookAheadFunc = function() {
                  return predicate.call(_this) && orgLookaheadFunction_1.call(_this);
                };
              }
            } else {
              action = actionORMethodDef;
            }
            if (lookAheadFunc.call(this) === true) {
              return action.call(this);
            }
            return void 0;
          };
          RecognizerEngine2.prototype.atLeastOneInternal = function(prodOccurrence, actionORMethodDef) {
            var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_IDX, prodOccurrence);
            return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);
          };
          RecognizerEngine2.prototype.atLeastOneInternalLogic = function(prodOccurrence, actionORMethodDef, key) {
            var _this = this;
            var lookAheadFunc = this.getLaFuncFromCache(key);
            var action;
            var predicate;
            if (actionORMethodDef.DEF !== void 0) {
              action = actionORMethodDef.DEF;
              predicate = actionORMethodDef.GATE;
              if (predicate !== void 0) {
                var orgLookaheadFunction_2 = lookAheadFunc;
                lookAheadFunc = function() {
                  return predicate.call(_this) && orgLookaheadFunction_2.call(_this);
                };
              }
            } else {
              action = actionORMethodDef;
            }
            if (lookAheadFunc.call(this) === true) {
              var notStuck = this.doSingleRepetition(action);
              while (lookAheadFunc.call(this) === true && notStuck === true) {
                notStuck = this.doSingleRepetition(action);
              }
            } else {
              throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);
            }
            this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, keys_1.AT_LEAST_ONE_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneWalker);
          };
          RecognizerEngine2.prototype.atLeastOneSepFirstInternal = function(prodOccurrence, options) {
            var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence);
            this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);
          };
          RecognizerEngine2.prototype.atLeastOneSepFirstInternalLogic = function(prodOccurrence, options, key) {
            var _this = this;
            var action = options.DEF;
            var separator = options.SEP;
            var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);
            if (firstIterationLookaheadFunc.call(this) === true) {
              ;
              action.call(this);
              var separatorLookAheadFunc = function() {
                return _this.tokenMatcher(_this.LA(1), separator);
              };
              while (this.tokenMatcher(this.LA(1), separator) === true) {
                this.CONSUME(separator);
                action.call(this);
              }
              this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
                prodOccurrence,
                separator,
                separatorLookAheadFunc,
                action,
                interpreter_1.NextTerminalAfterAtLeastOneSepWalker
              ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneSepWalker);
            } else {
              throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);
            }
          };
          RecognizerEngine2.prototype.manyInternal = function(prodOccurrence, actionORMethodDef) {
            var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_IDX, prodOccurrence);
            return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);
          };
          RecognizerEngine2.prototype.manyInternalLogic = function(prodOccurrence, actionORMethodDef, key) {
            var _this = this;
            var lookaheadFunction = this.getLaFuncFromCache(key);
            var action;
            var predicate;
            if (actionORMethodDef.DEF !== void 0) {
              action = actionORMethodDef.DEF;
              predicate = actionORMethodDef.GATE;
              if (predicate !== void 0) {
                var orgLookaheadFunction_3 = lookaheadFunction;
                lookaheadFunction = function() {
                  return predicate.call(_this) && orgLookaheadFunction_3.call(_this);
                };
              }
            } else {
              action = actionORMethodDef;
            }
            var notStuck = true;
            while (lookaheadFunction.call(this) === true && notStuck === true) {
              notStuck = this.doSingleRepetition(action);
            }
            this.attemptInRepetitionRecovery(
              this.manyInternal,
              [prodOccurrence, actionORMethodDef],
              lookaheadFunction,
              keys_1.MANY_IDX,
              prodOccurrence,
              interpreter_1.NextTerminalAfterManyWalker,
              // The notStuck parameter is only relevant when "attemptInRepetitionRecovery"
              // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]
              // An infinite loop cannot occur as:
              // - Either the lookahead is guaranteed to consume something (Single Token Separator)
              // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).
              notStuck
            );
          };
          RecognizerEngine2.prototype.manySepFirstInternal = function(prodOccurrence, options) {
            var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_SEP_IDX, prodOccurrence);
            this.manySepFirstInternalLogic(prodOccurrence, options, laKey);
          };
          RecognizerEngine2.prototype.manySepFirstInternalLogic = function(prodOccurrence, options, key) {
            var _this = this;
            var action = options.DEF;
            var separator = options.SEP;
            var firstIterationLaFunc = this.getLaFuncFromCache(key);
            if (firstIterationLaFunc.call(this) === true) {
              action.call(this);
              var separatorLookAheadFunc = function() {
                return _this.tokenMatcher(_this.LA(1), separator);
              };
              while (this.tokenMatcher(this.LA(1), separator) === true) {
                this.CONSUME(separator);
                action.call(this);
              }
              this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
                prodOccurrence,
                separator,
                separatorLookAheadFunc,
                action,
                interpreter_1.NextTerminalAfterManySepWalker
              ], separatorLookAheadFunc, keys_1.MANY_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManySepWalker);
            }
          };
          RecognizerEngine2.prototype.repetitionSepSecondInternal = function(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {
            while (separatorLookAheadFunc()) {
              this.CONSUME(separator);
              action.call(this);
            }
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
              prodOccurrence,
              separator,
              separatorLookAheadFunc,
              action,
              nextTerminalAfterWalker
            ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);
          };
          RecognizerEngine2.prototype.doSingleRepetition = function(action) {
            var beforeIteration = this.getLexerPosition();
            action.call(this);
            var afterIteration = this.getLexerPosition();
            return afterIteration > beforeIteration;
          };
          RecognizerEngine2.prototype.orInternal = function(altsOrOpts, occurrence) {
            var laKey = this.getKeyForAutomaticLookahead(keys_1.OR_IDX, occurrence);
            var alts = utils_1.isArray(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;
            var laFunc = this.getLaFuncFromCache(laKey);
            var altIdxToTake = laFunc.call(this, alts);
            if (altIdxToTake !== void 0) {
              var chosenAlternative = alts[altIdxToTake];
              return chosenAlternative.ALT.call(this);
            }
            this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);
          };
          RecognizerEngine2.prototype.ruleFinallyStateUpdate = function() {
            this.RULE_STACK.pop();
            this.RULE_OCCURRENCE_STACK.pop();
            this.cstFinallyStateUpdate();
            if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {
              var firstRedundantTok = this.LA(1);
              var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({
                firstRedundant: firstRedundantTok,
                ruleName: this.getCurrRuleFullName()
              });
              this.SAVE_ERROR(new exceptions_public_1.NotAllInputParsedException(errMsg, firstRedundantTok));
            }
          };
          RecognizerEngine2.prototype.subruleInternal = function(ruleToCall, idx, options) {
            var ruleResult;
            try {
              var args = options !== void 0 ? options.ARGS : void 0;
              ruleResult = ruleToCall.call(this, idx, args);
              this.cstPostNonTerminal(ruleResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleToCall.ruleName);
              return ruleResult;
            } catch (e) {
              this.subruleInternalError(e, options, ruleToCall.ruleName);
            }
          };
          RecognizerEngine2.prototype.subruleInternalError = function(e, options, ruleName) {
            if (exceptions_public_1.isRecognitionException(e) && e.partialCstResult !== void 0) {
              this.cstPostNonTerminal(e.partialCstResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleName);
              delete e.partialCstResult;
            }
            throw e;
          };
          RecognizerEngine2.prototype.consumeInternal = function(tokType, idx, options) {
            var consumedToken;
            try {
              var nextToken = this.LA(1);
              if (this.tokenMatcher(nextToken, tokType) === true) {
                this.consumeToken();
                consumedToken = nextToken;
              } else {
                this.consumeInternalError(tokType, nextToken, options);
              }
            } catch (eFromConsumption) {
              consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);
            }
            this.cstPostTerminal(options !== void 0 && options.LABEL !== void 0 ? options.LABEL : tokType.name, consumedToken);
            return consumedToken;
          };
          RecognizerEngine2.prototype.consumeInternalError = function(tokType, nextToken, options) {
            var msg;
            var previousToken = this.LA(0);
            if (options !== void 0 && options.ERR_MSG) {
              msg = options.ERR_MSG;
            } else {
              msg = this.errorMessageProvider.buildMismatchTokenMessage({
                expected: tokType,
                actual: nextToken,
                previous: previousToken,
                ruleName: this.getCurrRuleFullName()
              });
            }
            throw this.SAVE_ERROR(new exceptions_public_1.MismatchedTokenException(msg, nextToken, previousToken));
          };
          RecognizerEngine2.prototype.consumeInternalRecovery = function(tokType, idx, eFromConsumption) {
            if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?
            eFromConsumption.name === "MismatchedTokenException" && !this.isBackTracking()) {
              var follows = this.getFollowsForInRuleRecovery(tokType, idx);
              try {
                return this.tryInRuleRecovery(tokType, follows);
              } catch (eFromInRuleRecovery) {
                if (eFromInRuleRecovery.name === recoverable_1.IN_RULE_RECOVERY_EXCEPTION) {
                  throw eFromConsumption;
                } else {
                  throw eFromInRuleRecovery;
                }
              }
            } else {
              throw eFromConsumption;
            }
          };
          RecognizerEngine2.prototype.saveRecogState = function() {
            var savedErrors = this.errors;
            var savedRuleStack = utils_1.cloneArr(this.RULE_STACK);
            return {
              errors: savedErrors,
              lexerState: this.exportLexerState(),
              RULE_STACK: savedRuleStack,
              CST_STACK: this.CST_STACK
            };
          };
          RecognizerEngine2.prototype.reloadRecogState = function(newState) {
            this.errors = newState.errors;
            this.importLexerState(newState.lexerState);
            this.RULE_STACK = newState.RULE_STACK;
          };
          RecognizerEngine2.prototype.ruleInvocationStateUpdate = function(shortName, fullName, idxInCallingRule) {
            this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);
            this.RULE_STACK.push(shortName);
            this.cstInvocationStateUpdate(fullName, shortName);
          };
          RecognizerEngine2.prototype.isBackTracking = function() {
            return this.isBackTrackingStack.length !== 0;
          };
          RecognizerEngine2.prototype.getCurrRuleFullName = function() {
            var shortName = this.getLastExplicitRuleShortName();
            return this.shortRuleNameToFull[shortName];
          };
          RecognizerEngine2.prototype.shortRuleNameToFullName = function(shortName) {
            return this.shortRuleNameToFull[shortName];
          };
          RecognizerEngine2.prototype.isAtEndOfInput = function() {
            return this.tokenMatcher(this.LA(1), tokens_public_1.EOF);
          };
          RecognizerEngine2.prototype.reset = function() {
            this.resetLexerState();
            this.isBackTrackingStack = [];
            this.errors = [];
            this.RULE_STACK = [];
            this.CST_STACK = [];
            this.RULE_OCCURRENCE_STACK = [];
          };
          return RecognizerEngine2;
        })()
      );
      exports2.RecognizerEngine = RecognizerEngine;
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js
  var require_error_handler = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ErrorHandler = void 0;
      var exceptions_public_1 = require_exceptions_public();
      var utils_1 = require_utils();
      var lookahead_1 = require_lookahead();
      var parser_1 = require_parser();
      var ErrorHandler = (
        /** @class */
        (function() {
          function ErrorHandler2() {
          }
          ErrorHandler2.prototype.initErrorHandler = function(config) {
            this._errors = [];
            this.errorMessageProvider = utils_1.has(config, "errorMessageProvider") ? config.errorMessageProvider : parser_1.DEFAULT_PARSER_CONFIG.errorMessageProvider;
          };
          ErrorHandler2.prototype.SAVE_ERROR = function(error) {
            if (exceptions_public_1.isRecognitionException(error)) {
              error.context = {
                ruleStack: this.getHumanReadableRuleStack(),
                ruleOccurrenceStack: utils_1.cloneArr(this.RULE_OCCURRENCE_STACK)
              };
              this._errors.push(error);
              return error;
            } else {
              throw Error("Trying to save an Error which is not a RecognitionException");
            }
          };
          Object.defineProperty(ErrorHandler2.prototype, "errors", {
            get: function() {
              return utils_1.cloneArr(this._errors);
            },
            set: function(newErrors) {
              this._errors = newErrors;
            },
            enumerable: false,
            configurable: true
          });
          ErrorHandler2.prototype.raiseEarlyExitException = function(occurrence, prodType, userDefinedErrMsg) {
            var ruleName = this.getCurrRuleFullName();
            var ruleGrammar = this.getGAstProductions()[ruleName];
            var lookAheadPathsPerAlternative = lookahead_1.getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);
            var insideProdPaths = lookAheadPathsPerAlternative[0];
            var actualTokens = [];
            for (var i = 1; i <= this.maxLookahead; i++) {
              actualTokens.push(this.LA(i));
            }
            var msg = this.errorMessageProvider.buildEarlyExitMessage({
              expectedIterationPaths: insideProdPaths,
              actual: actualTokens,
              previous: this.LA(0),
              customUserDescription: userDefinedErrMsg,
              ruleName
            });
            throw this.SAVE_ERROR(new exceptions_public_1.EarlyExitException(msg, this.LA(1), this.LA(0)));
          };
          ErrorHandler2.prototype.raiseNoAltException = function(occurrence, errMsgTypes) {
            var ruleName = this.getCurrRuleFullName();
            var ruleGrammar = this.getGAstProductions()[ruleName];
            var lookAheadPathsPerAlternative = lookahead_1.getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);
            var actualTokens = [];
            for (var i = 1; i <= this.maxLookahead; i++) {
              actualTokens.push(this.LA(i));
            }
            var previousToken = this.LA(0);
            var errMsg = this.errorMessageProvider.buildNoViableAltMessage({
              expectedPathsPerAlt: lookAheadPathsPerAlternative,
              actual: actualTokens,
              previous: previousToken,
              customUserDescription: errMsgTypes,
              ruleName: this.getCurrRuleFullName()
            });
            throw this.SAVE_ERROR(new exceptions_public_1.NoViableAltException(errMsg, this.LA(1), previousToken));
          };
          return ErrorHandler2;
        })()
      );
      exports2.ErrorHandler = ErrorHandler;
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js
  var require_context_assist = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ContentAssist = void 0;
      var interpreter_1 = require_interpreter();
      var utils_1 = require_utils();
      var ContentAssist = (
        /** @class */
        (function() {
          function ContentAssist2() {
          }
          ContentAssist2.prototype.initContentAssist = function() {
          };
          ContentAssist2.prototype.computeContentAssist = function(startRuleName, precedingInput) {
            var startRuleGast = this.gastProductionsCache[startRuleName];
            if (utils_1.isUndefined(startRuleGast)) {
              throw Error("Rule ->" + startRuleName + "<- does not exist in this grammar.");
            }
            return interpreter_1.nextPossibleTokensAfter([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);
          };
          ContentAssist2.prototype.getNextPossibleTokenTypes = function(grammarPath) {
            var topRuleName = utils_1.first(grammarPath.ruleStack);
            var gastProductions = this.getGAstProductions();
            var topProduction = gastProductions[topRuleName];
            var nextPossibleTokenTypes = new interpreter_1.NextAfterTokenWalker(topProduction, grammarPath).startWalking();
            return nextPossibleTokenTypes;
          };
          return ContentAssist2;
        })()
      );
      exports2.ContentAssist = ContentAssist;
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js
  var require_gast_recorder = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.GastRecorder = void 0;
      var utils_1 = require_utils();
      var gast_public_1 = require_gast_public();
      var lexer_public_1 = require_lexer_public();
      var tokens_1 = require_tokens();
      var tokens_public_1 = require_tokens_public();
      var parser_1 = require_parser();
      var keys_1 = require_keys();
      var RECORDING_NULL_OBJECT = {
        description: "This Object indicates the Parser is during Recording Phase"
      };
      Object.freeze(RECORDING_NULL_OBJECT);
      var HANDLE_SEPARATOR = true;
      var MAX_METHOD_IDX = Math.pow(2, keys_1.BITS_FOR_OCCURRENCE_IDX) - 1;
      var RFT = tokens_public_1.createToken({ name: "RECORDING_PHASE_TOKEN", pattern: lexer_public_1.Lexer.NA });
      tokens_1.augmentTokenTypes([RFT]);
      var RECORDING_PHASE_TOKEN = tokens_public_1.createTokenInstance(
        RFT,
        "This IToken indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
        // Using "-1" instead of NaN (as in EOF) because an actual number is less likely to
        // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.
        -1,
        -1,
        -1,
        -1,
        -1,
        -1
      );
      Object.freeze(RECORDING_PHASE_TOKEN);
      var RECORDING_PHASE_CSTNODE = {
        name: "This CSTNode indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
        children: {}
      };
      var GastRecorder = (
        /** @class */
        (function() {
          function GastRecorder2() {
          }
          GastRecorder2.prototype.initGastRecorder = function(config) {
            this.recordingProdStack = [];
            this.RECORDING_PHASE = false;
          };
          GastRecorder2.prototype.enableRecording = function() {
            var _this = this;
            this.RECORDING_PHASE = true;
            this.TRACE_INIT("Enable Recording", function() {
              var _loop_1 = function(i2) {
                var idx = i2 > 0 ? i2 : "";
                _this["CONSUME" + idx] = function(arg1, arg2) {
                  return this.consumeInternalRecord(arg1, i2, arg2);
                };
                _this["SUBRULE" + idx] = function(arg1, arg2) {
                  return this.subruleInternalRecord(arg1, i2, arg2);
                };
                _this["OPTION" + idx] = function(arg1) {
                  return this.optionInternalRecord(arg1, i2);
                };
                _this["OR" + idx] = function(arg1) {
                  return this.orInternalRecord(arg1, i2);
                };
                _this["MANY" + idx] = function(arg1) {
                  this.manyInternalRecord(i2, arg1);
                };
                _this["MANY_SEP" + idx] = function(arg1) {
                  this.manySepFirstInternalRecord(i2, arg1);
                };
                _this["AT_LEAST_ONE" + idx] = function(arg1) {
                  this.atLeastOneInternalRecord(i2, arg1);
                };
                _this["AT_LEAST_ONE_SEP" + idx] = function(arg1) {
                  this.atLeastOneSepFirstInternalRecord(i2, arg1);
                };
              };
              for (var i = 0; i < 10; i++) {
                _loop_1(i);
              }
              _this["consume"] = function(idx, arg1, arg2) {
                return this.consumeInternalRecord(arg1, idx, arg2);
              };
              _this["subrule"] = function(idx, arg1, arg2) {
                return this.subruleInternalRecord(arg1, idx, arg2);
              };
              _this["option"] = function(idx, arg1) {
                return this.optionInternalRecord(arg1, idx);
              };
              _this["or"] = function(idx, arg1) {
                return this.orInternalRecord(arg1, idx);
              };
              _this["many"] = function(idx, arg1) {
                this.manyInternalRecord(idx, arg1);
              };
              _this["atLeastOne"] = function(idx, arg1) {
                this.atLeastOneInternalRecord(idx, arg1);
              };
              _this.ACTION = _this.ACTION_RECORD;
              _this.BACKTRACK = _this.BACKTRACK_RECORD;
              _this.LA = _this.LA_RECORD;
            });
          };
          GastRecorder2.prototype.disableRecording = function() {
            var _this = this;
            this.RECORDING_PHASE = false;
            this.TRACE_INIT("Deleting Recording methods", function() {
              for (var i = 0; i < 10; i++) {
                var idx = i > 0 ? i : "";
                delete _this["CONSUME" + idx];
                delete _this["SUBRULE" + idx];
                delete _this["OPTION" + idx];
                delete _this["OR" + idx];
                delete _this["MANY" + idx];
                delete _this["MANY_SEP" + idx];
                delete _this["AT_LEAST_ONE" + idx];
                delete _this["AT_LEAST_ONE_SEP" + idx];
              }
              delete _this["consume"];
              delete _this["subrule"];
              delete _this["option"];
              delete _this["or"];
              delete _this["many"];
              delete _this["atLeastOne"];
              delete _this.ACTION;
              delete _this.BACKTRACK;
              delete _this.LA;
            });
          };
          GastRecorder2.prototype.ACTION_RECORD = function(impl) {
            return;
          };
          GastRecorder2.prototype.BACKTRACK_RECORD = function(grammarRule, args) {
            return function() {
              return true;
            };
          };
          GastRecorder2.prototype.LA_RECORD = function(howMuch) {
            return parser_1.END_OF_FILE;
          };
          GastRecorder2.prototype.topLevelRuleRecord = function(name, def) {
            try {
              var newTopLevelRule = new gast_public_1.Rule({ definition: [], name });
              newTopLevelRule.name = name;
              this.recordingProdStack.push(newTopLevelRule);
              def.call(this);
              this.recordingProdStack.pop();
              return newTopLevelRule;
            } catch (originalError) {
              if (originalError.KNOWN_RECORDER_ERROR !== true) {
                try {
                  originalError.message = originalError.message + '\n	 This error was thrown during the "grammar recording phase" For more info see:\n	https://chevrotain.io/docs/guide/internals.html#grammar-recording';
                } catch (mutabilityError) {
                  throw originalError;
                }
              }
              throw originalError;
            }
          };
          GastRecorder2.prototype.optionInternalRecord = function(actionORMethodDef, occurrence) {
            return recordProd.call(this, gast_public_1.Option, actionORMethodDef, occurrence);
          };
          GastRecorder2.prototype.atLeastOneInternalRecord = function(occurrence, actionORMethodDef) {
            recordProd.call(this, gast_public_1.RepetitionMandatory, actionORMethodDef, occurrence);
          };
          GastRecorder2.prototype.atLeastOneSepFirstInternalRecord = function(occurrence, options) {
            recordProd.call(this, gast_public_1.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);
          };
          GastRecorder2.prototype.manyInternalRecord = function(occurrence, actionORMethodDef) {
            recordProd.call(this, gast_public_1.Repetition, actionORMethodDef, occurrence);
          };
          GastRecorder2.prototype.manySepFirstInternalRecord = function(occurrence, options) {
            recordProd.call(this, gast_public_1.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);
          };
          GastRecorder2.prototype.orInternalRecord = function(altsOrOpts, occurrence) {
            return recordOrProd.call(this, altsOrOpts, occurrence);
          };
          GastRecorder2.prototype.subruleInternalRecord = function(ruleToCall, occurrence, options) {
            assertMethodIdxIsValid(occurrence);
            if (!ruleToCall || utils_1.has(ruleToCall, "ruleName") === false) {
              var error = new Error("<SUBRULE" + getIdxSuffix(occurrence) + "> argument is invalid" + (" expecting a Parser method reference but got: <" + JSON.stringify(ruleToCall) + ">") + ("\n inside top level rule: <" + this.recordingProdStack[0].name + ">"));
              error.KNOWN_RECORDER_ERROR = true;
              throw error;
            }
            var prevProd = utils_1.peek(this.recordingProdStack);
            var ruleName = ruleToCall["ruleName"];
            var newNoneTerminal = new gast_public_1.NonTerminal({
              idx: occurrence,
              nonTerminalName: ruleName,
              // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created
              referencedRule: void 0
            });
            prevProd.definition.push(newNoneTerminal);
            return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;
          };
          GastRecorder2.prototype.consumeInternalRecord = function(tokType, occurrence, options) {
            assertMethodIdxIsValid(occurrence);
            if (!tokens_1.hasShortKeyProperty(tokType)) {
              var error = new Error("<CONSUME" + getIdxSuffix(occurrence) + "> argument is invalid" + (" expecting a TokenType reference but got: <" + JSON.stringify(tokType) + ">") + ("\n inside top level rule: <" + this.recordingProdStack[0].name + ">"));
              error.KNOWN_RECORDER_ERROR = true;
              throw error;
            }
            var prevProd = utils_1.peek(this.recordingProdStack);
            var newNoneTerminal = new gast_public_1.Terminal({
              idx: occurrence,
              terminalType: tokType
            });
            prevProd.definition.push(newNoneTerminal);
            return RECORDING_PHASE_TOKEN;
          };
          return GastRecorder2;
        })()
      );
      exports2.GastRecorder = GastRecorder;
      function recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {
        if (handleSep === void 0) {
          handleSep = false;
        }
        assertMethodIdxIsValid(occurrence);
        var prevProd = utils_1.peek(this.recordingProdStack);
        var grammarAction = utils_1.isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF;
        var newProd = new prodConstructor({ definition: [], idx: occurrence });
        if (handleSep) {
          newProd.separator = mainProdArg.SEP;
        }
        if (utils_1.has(mainProdArg, "MAX_LOOKAHEAD")) {
          newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
        }
        this.recordingProdStack.push(newProd);
        grammarAction.call(this);
        prevProd.definition.push(newProd);
        this.recordingProdStack.pop();
        return RECORDING_NULL_OBJECT;
      }
      function recordOrProd(mainProdArg, occurrence) {
        var _this = this;
        assertMethodIdxIsValid(occurrence);
        var prevProd = utils_1.peek(this.recordingProdStack);
        var hasOptions = utils_1.isArray(mainProdArg) === false;
        var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;
        var newOrProd = new gast_public_1.Alternation({
          definition: [],
          idx: occurrence,
          ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true
        });
        if (utils_1.has(mainProdArg, "MAX_LOOKAHEAD")) {
          newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
        }
        var hasPredicates = utils_1.some(alts, function(currAlt) {
          return utils_1.isFunction(currAlt.GATE);
        });
        newOrProd.hasPredicates = hasPredicates;
        prevProd.definition.push(newOrProd);
        utils_1.forEach(alts, function(currAlt) {
          var currAltFlat = new gast_public_1.Alternative({ definition: [] });
          newOrProd.definition.push(currAltFlat);
          if (utils_1.has(currAlt, "IGNORE_AMBIGUITIES")) {
            currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;
          } else if (utils_1.has(currAlt, "GATE")) {
            currAltFlat.ignoreAmbiguities = true;
          }
          _this.recordingProdStack.push(currAltFlat);
          currAlt.ALT.call(_this);
          _this.recordingProdStack.pop();
        });
        return RECORDING_NULL_OBJECT;
      }
      function getIdxSuffix(idx) {
        return idx === 0 ? "" : "" + idx;
      }
      function assertMethodIdxIsValid(idx) {
        if (idx < 0 || idx > MAX_METHOD_IDX) {
          var error = new Error(
            // The stack trace will contain all the needed details
            "Invalid DSL Method idx value: <" + idx + ">\n	" + ("Idx value must be a none negative value smaller than " + (MAX_METHOD_IDX + 1))
          );
          error.KNOWN_RECORDER_ERROR = true;
          throw error;
        }
      }
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js
  var require_perf_tracer = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PerformanceTracer = void 0;
      var utils_1 = require_utils();
      var parser_1 = require_parser();
      var PerformanceTracer = (
        /** @class */
        (function() {
          function PerformanceTracer2() {
          }
          PerformanceTracer2.prototype.initPerformanceTracer = function(config) {
            if (utils_1.has(config, "traceInitPerf")) {
              var userTraceInitPerf = config.traceInitPerf;
              var traceIsNumber = typeof userTraceInitPerf === "number";
              this.traceInitMaxIdent = traceIsNumber ? userTraceInitPerf : Infinity;
              this.traceInitPerf = traceIsNumber ? userTraceInitPerf > 0 : userTraceInitPerf;
            } else {
              this.traceInitMaxIdent = 0;
              this.traceInitPerf = parser_1.DEFAULT_PARSER_CONFIG.traceInitPerf;
            }
            this.traceInitIndent = -1;
          };
          PerformanceTracer2.prototype.TRACE_INIT = function(phaseDesc, phaseImpl) {
            if (this.traceInitPerf === true) {
              this.traceInitIndent++;
              var indent = new Array(this.traceInitIndent + 1).join("	");
              if (this.traceInitIndent < this.traceInitMaxIdent) {
                console.log(indent + "--> <" + phaseDesc + ">");
              }
              var _a = utils_1.timer(phaseImpl), time = _a.time, value = _a.value;
              var traceMethod = time > 10 ? console.warn : console.log;
              if (this.traceInitIndent < this.traceInitMaxIdent) {
                traceMethod(indent + "<-- <" + phaseDesc + "> time: " + time + "ms");
              }
              this.traceInitIndent--;
              return value;
            } else {
              return phaseImpl();
            }
          };
          return PerformanceTracer2;
        })()
      );
      exports2.PerformanceTracer = PerformanceTracer;
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/parser.js
  var require_parser = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/parser.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d, b) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics2(d, b);
        };
        return function(d, b) {
          extendStatics2(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      })();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.EmbeddedActionsParser = exports2.CstParser = exports2.Parser = exports2.EMPTY_ALT = exports2.ParserDefinitionErrorType = exports2.DEFAULT_RULE_CONFIG = exports2.DEFAULT_PARSER_CONFIG = exports2.END_OF_FILE = void 0;
      var utils_1 = require_utils();
      var follow_1 = require_follow();
      var tokens_public_1 = require_tokens_public();
      var errors_public_1 = require_errors_public();
      var gast_resolver_public_1 = require_gast_resolver_public();
      var recoverable_1 = require_recoverable();
      var looksahead_1 = require_looksahead();
      var tree_builder_1 = require_tree_builder();
      var lexer_adapter_1 = require_lexer_adapter();
      var recognizer_api_1 = require_recognizer_api();
      var recognizer_engine_1 = require_recognizer_engine();
      var error_handler_1 = require_error_handler();
      var context_assist_1 = require_context_assist();
      var gast_recorder_1 = require_gast_recorder();
      var perf_tracer_1 = require_perf_tracer();
      exports2.END_OF_FILE = tokens_public_1.createTokenInstance(tokens_public_1.EOF, "", NaN, NaN, NaN, NaN, NaN, NaN);
      Object.freeze(exports2.END_OF_FILE);
      exports2.DEFAULT_PARSER_CONFIG = Object.freeze({
        recoveryEnabled: false,
        maxLookahead: 3,
        dynamicTokensEnabled: false,
        outputCst: true,
        errorMessageProvider: errors_public_1.defaultParserErrorProvider,
        nodeLocationTracking: "none",
        traceInitPerf: false,
        skipValidations: false
      });
      exports2.DEFAULT_RULE_CONFIG = Object.freeze({
        recoveryValueFunc: function() {
          return void 0;
        },
        resyncEnabled: true
      });
      var ParserDefinitionErrorType;
      (function(ParserDefinitionErrorType2) {
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["INVALID_RULE_NAME"] = 0] = "INVALID_RULE_NAME";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["DUPLICATE_RULE_NAME"] = 1] = "DUPLICATE_RULE_NAME";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["INVALID_RULE_OVERRIDE"] = 2] = "INVALID_RULE_OVERRIDE";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["DUPLICATE_PRODUCTIONS"] = 3] = "DUPLICATE_PRODUCTIONS";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["UNRESOLVED_SUBRULE_REF"] = 4] = "UNRESOLVED_SUBRULE_REF";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["LEFT_RECURSION"] = 5] = "LEFT_RECURSION";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["NONE_LAST_EMPTY_ALT"] = 6] = "NONE_LAST_EMPTY_ALT";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["AMBIGUOUS_ALTS"] = 7] = "AMBIGUOUS_ALTS";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["CONFLICT_TOKENS_RULES_NAMESPACE"] = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["INVALID_TOKEN_NAME"] = 9] = "INVALID_TOKEN_NAME";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["NO_NON_EMPTY_LOOKAHEAD"] = 10] = "NO_NON_EMPTY_LOOKAHEAD";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["AMBIGUOUS_PREFIX_ALTS"] = 11] = "AMBIGUOUS_PREFIX_ALTS";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["TOO_MANY_ALTS"] = 12] = "TOO_MANY_ALTS";
      })(ParserDefinitionErrorType = exports2.ParserDefinitionErrorType || (exports2.ParserDefinitionErrorType = {}));
      function EMPTY_ALT(value) {
        if (value === void 0) {
          value = void 0;
        }
        return function() {
          return value;
        };
      }
      exports2.EMPTY_ALT = EMPTY_ALT;
      var Parser = (
        /** @class */
        (function() {
          function Parser2(tokenVocabulary, config) {
            this.definitionErrors = [];
            this.selfAnalysisDone = false;
            var that = this;
            that.initErrorHandler(config);
            that.initLexerAdapter();
            that.initLooksAhead(config);
            that.initRecognizerEngine(tokenVocabulary, config);
            that.initRecoverable(config);
            that.initTreeBuilder(config);
            that.initContentAssist();
            that.initGastRecorder(config);
            that.initPerformanceTracer(config);
            if (utils_1.has(config, "ignoredIssues")) {
              throw new Error("The <ignoredIssues> IParserConfig property has been deprecated.\n	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\n	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\n	For further details.");
            }
            this.skipValidations = utils_1.has(config, "skipValidations") ? config.skipValidations : exports2.DEFAULT_PARSER_CONFIG.skipValidations;
          }
          Parser2.performSelfAnalysis = function(parserInstance) {
            throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.");
          };
          Parser2.prototype.performSelfAnalysis = function() {
            var _this = this;
            this.TRACE_INIT("performSelfAnalysis", function() {
              var defErrorsMsgs;
              _this.selfAnalysisDone = true;
              var className = _this.className;
              _this.TRACE_INIT("toFastProps", function() {
                utils_1.toFastProperties(_this);
              });
              _this.TRACE_INIT("Grammar Recording", function() {
                try {
                  _this.enableRecording();
                  utils_1.forEach(_this.definedRulesNames, function(currRuleName) {
                    var wrappedRule = _this[currRuleName];
                    var originalGrammarAction = wrappedRule["originalGrammarAction"];
                    var recordedRuleGast = void 0;
                    _this.TRACE_INIT(currRuleName + " Rule", function() {
                      recordedRuleGast = _this.topLevelRuleRecord(currRuleName, originalGrammarAction);
                    });
                    _this.gastProductionsCache[currRuleName] = recordedRuleGast;
                  });
                } finally {
                  _this.disableRecording();
                }
              });
              var resolverErrors = [];
              _this.TRACE_INIT("Grammar Resolving", function() {
                resolverErrors = gast_resolver_public_1.resolveGrammar({
                  rules: utils_1.values(_this.gastProductionsCache)
                });
                _this.definitionErrors.push.apply(_this.definitionErrors, resolverErrors);
              });
              _this.TRACE_INIT("Grammar Validations", function() {
                if (utils_1.isEmpty(resolverErrors) && _this.skipValidations === false) {
                  var validationErrors = gast_resolver_public_1.validateGrammar({
                    rules: utils_1.values(_this.gastProductionsCache),
                    maxLookahead: _this.maxLookahead,
                    tokenTypes: utils_1.values(_this.tokensMap),
                    errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider,
                    grammarName: className
                  });
                  _this.definitionErrors.push.apply(_this.definitionErrors, validationErrors);
                }
              });
              if (utils_1.isEmpty(_this.definitionErrors)) {
                if (_this.recoveryEnabled) {
                  _this.TRACE_INIT("computeAllProdsFollows", function() {
                    var allFollows = follow_1.computeAllProdsFollows(utils_1.values(_this.gastProductionsCache));
                    _this.resyncFollows = allFollows;
                  });
                }
                _this.TRACE_INIT("ComputeLookaheadFunctions", function() {
                  _this.preComputeLookaheadFunctions(utils_1.values(_this.gastProductionsCache));
                });
              }
              if (!Parser2.DEFER_DEFINITION_ERRORS_HANDLING && !utils_1.isEmpty(_this.definitionErrors)) {
                defErrorsMsgs = utils_1.map(_this.definitionErrors, function(defError) {
                  return defError.message;
                });
                throw new Error("Parser Definition Errors detected:\n " + defErrorsMsgs.join("\n-------------------------------\n"));
              }
            });
          };
          Parser2.DEFER_DEFINITION_ERRORS_HANDLING = false;
          return Parser2;
        })()
      );
      exports2.Parser = Parser;
      utils_1.applyMixins(Parser, [
        recoverable_1.Recoverable,
        looksahead_1.LooksAhead,
        tree_builder_1.TreeBuilder,
        lexer_adapter_1.LexerAdapter,
        recognizer_engine_1.RecognizerEngine,
        recognizer_api_1.RecognizerApi,
        error_handler_1.ErrorHandler,
        context_assist_1.ContentAssist,
        gast_recorder_1.GastRecorder,
        perf_tracer_1.PerformanceTracer
      ]);
      var CstParser = (
        /** @class */
        (function(_super) {
          __extends2(CstParser2, _super);
          function CstParser2(tokenVocabulary, config) {
            if (config === void 0) {
              config = exports2.DEFAULT_PARSER_CONFIG;
            }
            var _this = this;
            var configClone = utils_1.cloneObj(config);
            configClone.outputCst = true;
            _this = _super.call(this, tokenVocabulary, configClone) || this;
            return _this;
          }
          return CstParser2;
        })(Parser)
      );
      exports2.CstParser = CstParser;
      var EmbeddedActionsParser = (
        /** @class */
        (function(_super) {
          __extends2(EmbeddedActionsParser2, _super);
          function EmbeddedActionsParser2(tokenVocabulary, config) {
            if (config === void 0) {
              config = exports2.DEFAULT_PARSER_CONFIG;
            }
            var _this = this;
            var configClone = utils_1.cloneObj(config);
            configClone.outputCst = false;
            _this = _super.call(this, tokenVocabulary, configClone) || this;
            return _this;
          }
          return EmbeddedActionsParser2;
        })(Parser)
      );
      exports2.EmbeddedActionsParser = EmbeddedActionsParser;
    }
  });

  // node_modules/chevrotain/lib/src/diagrams/render_public.js
  var require_render_public = __commonJS({
    "node_modules/chevrotain/lib/src/diagrams/render_public.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createSyntaxDiagramsCode = void 0;
      var version_1 = require_version();
      function createSyntaxDiagramsCode(grammar, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.resourceBase, resourceBase = _c === void 0 ? "https://unpkg.com/chevrotain@" + version_1.VERSION + "/diagrams/" : _c, _d = _b.css, css = _d === void 0 ? "https://unpkg.com/chevrotain@" + version_1.VERSION + "/diagrams/diagrams.css" : _d;
        var header = '\n<!-- This is a generated file -->\n<!DOCTYPE html>\n<meta charset="utf-8">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n';
        var cssHtml = "\n<link rel='stylesheet' href='" + css + "'>\n";
        var scripts = "\n<script src='" + resourceBase + "vendor/railroad-diagrams.js'><\/script>\n<script src='" + resourceBase + "src/diagrams_builder.js'><\/script>\n<script src='" + resourceBase + "src/diagrams_behavior.js'><\/script>\n<script src='" + resourceBase + "src/main.js'><\/script>\n";
        var diagramsDiv = '\n<div id="diagrams" align="center"></div>    \n';
        var serializedGrammar = "\n<script>\n    window.serializedGrammar = " + JSON.stringify(grammar, null, "  ") + ";\n<\/script>\n";
        var initLogic = '\n<script>\n    var diagramsDiv = document.getElementById("diagrams");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n<\/script>\n';
        return header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic;
      }
      exports2.createSyntaxDiagramsCode = createSyntaxDiagramsCode;
    }
  });

  // node_modules/chevrotain/lib/src/generate/generate.js
  var require_generate = __commonJS({
    "node_modules/chevrotain/lib/src/generate/generate.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.genSingleAlt = exports2.genAlternation = exports2.genNonTerminal = exports2.genTerminal = exports2.genRule = exports2.genAllRules = exports2.genClass = exports2.genWrapperFunction = exports2.genUmdModule = void 0;
      var utils_1 = require_utils();
      var gast_public_1 = require_gast_public();
      var NL = "\n";
      function genUmdModule(options) {
        return "\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['chevrotain'], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory(require('chevrotain'));\n    } else {\n        // Browser globals (root is window)\n        root.returnExports = factory(root.b);\n    }\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\n\n" + genClass(options) + "\n    \nreturn {\n    " + options.name + ": " + options.name + " \n}\n}));\n";
      }
      exports2.genUmdModule = genUmdModule;
      function genWrapperFunction(options) {
        return "    \n" + genClass(options) + "\nreturn new " + options.name + "(tokenVocabulary, config)    \n";
      }
      exports2.genWrapperFunction = genWrapperFunction;
      function genClass(options) {
        var result = "\nfunction " + options.name + "(tokenVocabulary, config) {\n    // invoke super constructor\n    // No support for embedded actions currently, so we can 'hardcode'\n    // The use of CstParser.\n    chevrotain.CstParser.call(this, tokenVocabulary, config)\n\n    const $ = this\n\n    " + genAllRules(options.rules) + "\n\n    // very important to call this after all the rules have been defined.\n    // otherwise the parser may not work correctly as it will lack information\n    // derived during the self analysis phase.\n    this.performSelfAnalysis(this)\n}\n\n// inheritance as implemented in javascript in the previous decade... :(\n" + options.name + ".prototype = Object.create(chevrotain.CstParser.prototype)\n" + options.name + ".prototype.constructor = " + options.name + "    \n    ";
        return result;
      }
      exports2.genClass = genClass;
      function genAllRules(rules) {
        var rulesText = utils_1.map(rules, function(currRule) {
          return genRule(currRule, 1);
        });
        return rulesText.join("\n");
      }
      exports2.genAllRules = genAllRules;
      function genRule(prod, n) {
        var result = indent(n, '$.RULE("' + prod.name + '", function() {') + NL;
        result += genDefinition(prod.definition, n + 1);
        result += indent(n + 1, "})") + NL;
        return result;
      }
      exports2.genRule = genRule;
      function genTerminal(prod, n) {
        var name = prod.terminalType.name;
        return indent(n, "$.CONSUME" + prod.idx + "(this.tokensMap." + name + ")" + NL);
      }
      exports2.genTerminal = genTerminal;
      function genNonTerminal(prod, n) {
        return indent(n, "$.SUBRULE" + prod.idx + "($." + prod.nonTerminalName + ")" + NL);
      }
      exports2.genNonTerminal = genNonTerminal;
      function genAlternation(prod, n) {
        var result = indent(n, "$.OR" + prod.idx + "([") + NL;
        var alts = utils_1.map(prod.definition, function(altDef) {
          return genSingleAlt(altDef, n + 1);
        });
        result += alts.join("," + NL);
        result += NL + indent(n, "])" + NL);
        return result;
      }
      exports2.genAlternation = genAlternation;
      function genSingleAlt(prod, n) {
        var result = indent(n, "{") + NL;
        result += indent(n + 1, "ALT: function() {") + NL;
        result += genDefinition(prod.definition, n + 1);
        result += indent(n + 1, "}") + NL;
        result += indent(n, "}");
        return result;
      }
      exports2.genSingleAlt = genSingleAlt;
      function genProd(prod, n) {
        if (prod instanceof gast_public_1.NonTerminal) {
          return genNonTerminal(prod, n);
        } else if (prod instanceof gast_public_1.Option) {
          return genDSLRule("OPTION", prod, n);
        } else if (prod instanceof gast_public_1.RepetitionMandatory) {
          return genDSLRule("AT_LEAST_ONE", prod, n);
        } else if (prod instanceof gast_public_1.RepetitionMandatoryWithSeparator) {
          return genDSLRule("AT_LEAST_ONE_SEP", prod, n);
        } else if (prod instanceof gast_public_1.RepetitionWithSeparator) {
          return genDSLRule("MANY_SEP", prod, n);
        } else if (prod instanceof gast_public_1.Repetition) {
          return genDSLRule("MANY", prod, n);
        } else if (prod instanceof gast_public_1.Alternation) {
          return genAlternation(prod, n);
        } else if (prod instanceof gast_public_1.Terminal) {
          return genTerminal(prod, n);
        } else if (prod instanceof gast_public_1.Alternative) {
          return genDefinition(prod.definition, n);
        } else {
          throw Error("non exhaustive match");
        }
      }
      function genDSLRule(dslName, prod, n) {
        var result = indent(n, "$." + (dslName + prod.idx) + "(");
        if (prod.separator) {
          result += "{" + NL;
          result += indent(n + 1, "SEP: this.tokensMap." + prod.separator.name) + "," + NL;
          result += "DEF: " + genDefFunction(prod.definition, n + 2) + NL;
          result += indent(n, "}") + NL;
        } else {
          result += genDefFunction(prod.definition, n + 1);
        }
        result += indent(n, ")") + NL;
        return result;
      }
      function genDefFunction(definition, n) {
        var def = "function() {" + NL;
        def += genDefinition(definition, n);
        def += indent(n, "}") + NL;
        return def;
      }
      function genDefinition(def, n) {
        var result = "";
        utils_1.forEach(def, function(prod) {
          result += genProd(prod, n + 1);
        });
        return result;
      }
      function indent(howMuch, text) {
        var spaces = Array(howMuch * 4 + 1).join(" ");
        return spaces + text;
      }
    }
  });

  // node_modules/chevrotain/lib/src/generate/generate_public.js
  var require_generate_public = __commonJS({
    "node_modules/chevrotain/lib/src/generate/generate_public.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.generateParserModule = exports2.generateParserFactory = void 0;
      var generate_1 = require_generate();
      function generateParserFactory(options) {
        var wrapperText = generate_1.genWrapperFunction({
          name: options.name,
          rules: options.rules
        });
        var constructorWrapper = new Function("tokenVocabulary", "config", "chevrotain", wrapperText);
        return function(config) {
          return constructorWrapper(
            options.tokenVocabulary,
            config,
            // TODO: check how the require is transpiled/webpacked
            require_api()
          );
        };
      }
      exports2.generateParserFactory = generateParserFactory;
      function generateParserModule(options) {
        return generate_1.genUmdModule({ name: options.name, rules: options.rules });
      }
      exports2.generateParserModule = generateParserModule;
    }
  });

  // node_modules/chevrotain/lib/src/api.js
  var require_api = __commonJS({
    "node_modules/chevrotain/lib/src/api.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Parser = exports2.generateParserModule = exports2.generateParserFactory = exports2.createSyntaxDiagramsCode = exports2.clearCache = exports2.validateGrammar = exports2.resolveGrammar = exports2.assignOccurrenceIndices = exports2.GAstVisitor = exports2.serializeProduction = exports2.serializeGrammar = exports2.Terminal = exports2.Rule = exports2.RepetitionWithSeparator = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Repetition = exports2.Option = exports2.NonTerminal = exports2.Alternative = exports2.Alternation = exports2.defaultLexerErrorProvider = exports2.NoViableAltException = exports2.NotAllInputParsedException = exports2.MismatchedTokenException = exports2.isRecognitionException = exports2.EarlyExitException = exports2.defaultParserErrorProvider = exports2.defaultGrammarValidatorErrorProvider = exports2.defaultGrammarResolverErrorProvider = exports2.tokenName = exports2.tokenMatcher = exports2.tokenLabel = exports2.EOF = exports2.createTokenInstance = exports2.createToken = exports2.LexerDefinitionErrorType = exports2.Lexer = exports2.EMPTY_ALT = exports2.ParserDefinitionErrorType = exports2.EmbeddedActionsParser = exports2.CstParser = exports2.VERSION = void 0;
      var version_1 = require_version();
      Object.defineProperty(exports2, "VERSION", { enumerable: true, get: function() {
        return version_1.VERSION;
      } });
      var parser_1 = require_parser();
      Object.defineProperty(exports2, "CstParser", { enumerable: true, get: function() {
        return parser_1.CstParser;
      } });
      Object.defineProperty(exports2, "EmbeddedActionsParser", { enumerable: true, get: function() {
        return parser_1.EmbeddedActionsParser;
      } });
      Object.defineProperty(exports2, "ParserDefinitionErrorType", { enumerable: true, get: function() {
        return parser_1.ParserDefinitionErrorType;
      } });
      Object.defineProperty(exports2, "EMPTY_ALT", { enumerable: true, get: function() {
        return parser_1.EMPTY_ALT;
      } });
      var lexer_public_1 = require_lexer_public();
      Object.defineProperty(exports2, "Lexer", { enumerable: true, get: function() {
        return lexer_public_1.Lexer;
      } });
      Object.defineProperty(exports2, "LexerDefinitionErrorType", { enumerable: true, get: function() {
        return lexer_public_1.LexerDefinitionErrorType;
      } });
      var tokens_public_1 = require_tokens_public();
      Object.defineProperty(exports2, "createToken", { enumerable: true, get: function() {
        return tokens_public_1.createToken;
      } });
      Object.defineProperty(exports2, "createTokenInstance", { enumerable: true, get: function() {
        return tokens_public_1.createTokenInstance;
      } });
      Object.defineProperty(exports2, "EOF", { enumerable: true, get: function() {
        return tokens_public_1.EOF;
      } });
      Object.defineProperty(exports2, "tokenLabel", { enumerable: true, get: function() {
        return tokens_public_1.tokenLabel;
      } });
      Object.defineProperty(exports2, "tokenMatcher", { enumerable: true, get: function() {
        return tokens_public_1.tokenMatcher;
      } });
      Object.defineProperty(exports2, "tokenName", { enumerable: true, get: function() {
        return tokens_public_1.tokenName;
      } });
      var errors_public_1 = require_errors_public();
      Object.defineProperty(exports2, "defaultGrammarResolverErrorProvider", { enumerable: true, get: function() {
        return errors_public_1.defaultGrammarResolverErrorProvider;
      } });
      Object.defineProperty(exports2, "defaultGrammarValidatorErrorProvider", { enumerable: true, get: function() {
        return errors_public_1.defaultGrammarValidatorErrorProvider;
      } });
      Object.defineProperty(exports2, "defaultParserErrorProvider", { enumerable: true, get: function() {
        return errors_public_1.defaultParserErrorProvider;
      } });
      var exceptions_public_1 = require_exceptions_public();
      Object.defineProperty(exports2, "EarlyExitException", { enumerable: true, get: function() {
        return exceptions_public_1.EarlyExitException;
      } });
      Object.defineProperty(exports2, "isRecognitionException", { enumerable: true, get: function() {
        return exceptions_public_1.isRecognitionException;
      } });
      Object.defineProperty(exports2, "MismatchedTokenException", { enumerable: true, get: function() {
        return exceptions_public_1.MismatchedTokenException;
      } });
      Object.defineProperty(exports2, "NotAllInputParsedException", { enumerable: true, get: function() {
        return exceptions_public_1.NotAllInputParsedException;
      } });
      Object.defineProperty(exports2, "NoViableAltException", { enumerable: true, get: function() {
        return exceptions_public_1.NoViableAltException;
      } });
      var lexer_errors_public_1 = require_lexer_errors_public();
      Object.defineProperty(exports2, "defaultLexerErrorProvider", { enumerable: true, get: function() {
        return lexer_errors_public_1.defaultLexerErrorProvider;
      } });
      var gast_public_1 = require_gast_public();
      Object.defineProperty(exports2, "Alternation", { enumerable: true, get: function() {
        return gast_public_1.Alternation;
      } });
      Object.defineProperty(exports2, "Alternative", { enumerable: true, get: function() {
        return gast_public_1.Alternative;
      } });
      Object.defineProperty(exports2, "NonTerminal", { enumerable: true, get: function() {
        return gast_public_1.NonTerminal;
      } });
      Object.defineProperty(exports2, "Option", { enumerable: true, get: function() {
        return gast_public_1.Option;
      } });
      Object.defineProperty(exports2, "Repetition", { enumerable: true, get: function() {
        return gast_public_1.Repetition;
      } });
      Object.defineProperty(exports2, "RepetitionMandatory", { enumerable: true, get: function() {
        return gast_public_1.RepetitionMandatory;
      } });
      Object.defineProperty(exports2, "RepetitionMandatoryWithSeparator", { enumerable: true, get: function() {
        return gast_public_1.RepetitionMandatoryWithSeparator;
      } });
      Object.defineProperty(exports2, "RepetitionWithSeparator", { enumerable: true, get: function() {
        return gast_public_1.RepetitionWithSeparator;
      } });
      Object.defineProperty(exports2, "Rule", { enumerable: true, get: function() {
        return gast_public_1.Rule;
      } });
      Object.defineProperty(exports2, "Terminal", { enumerable: true, get: function() {
        return gast_public_1.Terminal;
      } });
      var gast_public_2 = require_gast_public();
      Object.defineProperty(exports2, "serializeGrammar", { enumerable: true, get: function() {
        return gast_public_2.serializeGrammar;
      } });
      Object.defineProperty(exports2, "serializeProduction", { enumerable: true, get: function() {
        return gast_public_2.serializeProduction;
      } });
      var gast_visitor_public_1 = require_gast_visitor_public();
      Object.defineProperty(exports2, "GAstVisitor", { enumerable: true, get: function() {
        return gast_visitor_public_1.GAstVisitor;
      } });
      var gast_resolver_public_1 = require_gast_resolver_public();
      Object.defineProperty(exports2, "assignOccurrenceIndices", { enumerable: true, get: function() {
        return gast_resolver_public_1.assignOccurrenceIndices;
      } });
      Object.defineProperty(exports2, "resolveGrammar", { enumerable: true, get: function() {
        return gast_resolver_public_1.resolveGrammar;
      } });
      Object.defineProperty(exports2, "validateGrammar", { enumerable: true, get: function() {
        return gast_resolver_public_1.validateGrammar;
      } });
      function clearCache() {
        console.warn("The clearCache function was 'soft' removed from the Chevrotain API.\n	 It performs no action other than printing this message.\n	 Please avoid using it as it will be completely removed in the future");
      }
      exports2.clearCache = clearCache;
      var render_public_1 = require_render_public();
      Object.defineProperty(exports2, "createSyntaxDiagramsCode", { enumerable: true, get: function() {
        return render_public_1.createSyntaxDiagramsCode;
      } });
      var generate_public_1 = require_generate_public();
      Object.defineProperty(exports2, "generateParserFactory", { enumerable: true, get: function() {
        return generate_public_1.generateParserFactory;
      } });
      Object.defineProperty(exports2, "generateParserModule", { enumerable: true, get: function() {
        return generate_public_1.generateParserModule;
      } });
      var Parser = (
        /** @class */
        /* @__PURE__ */ (function() {
          function Parser2() {
            throw new Error("The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.	\nSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0");
          }
          return Parser2;
        })()
      );
      exports2.Parser = Parser;
    }
  });

  // node_modules/fast-formula-parser/grammar/lexing.js
  var require_lexing = __commonJS({
    "node_modules/fast-formula-parser/grammar/lexing.js"(exports2, module2) {
      var { createToken, Lexer } = require_api();
      var FormulaError2 = require_error();
      var tokenVocabulary = {};
      var WhiteSpace = createToken({
        name: "WhiteSpace",
        pattern: /\s+/,
        group: Lexer.SKIPPED
      });
      var String2 = createToken({
        name: "String",
        pattern: /"(""|[^"])*"/
      });
      var SingleQuotedString = createToken({
        name: "SingleQuotedString",
        pattern: /'(''|[^'])*'/
      });
      var SheetQuoted = createToken({
        name: "SheetQuoted",
        pattern: /'((?![\\\/\[\]*?:]).)+?'!/
      });
      var Function2 = createToken({
        name: "Function",
        pattern: /[A-Za-z_]+[A-Za-z_0-9.]*\(/
      });
      var FormulaErrorT = createToken({
        name: "FormulaErrorT",
        pattern: /#NULL!|#DIV\/0!|#VALUE!|#NAME\?|#NUM!|#N\/A/
      });
      var RefError = createToken({
        name: "RefError",
        pattern: /#REF!/
      });
      var Name = createToken({
        name: "Name",
        pattern: /[a-zA-Z_][a-zA-Z0-9_.?]*/
        // longer_alt: RangeColumn // e.g. A:AA
      });
      var Sheet = createToken({
        name: "Sheet",
        pattern: /[A-Za-z_.\d\u007F-\uFFFF]+!/
      });
      var Cell2 = createToken({
        name: "Cell",
        pattern: /[$]?[A-Za-z]{1,3}[$]?[1-9][0-9]*/,
        longer_alt: Name
      });
      var Number2 = createToken({
        name: "Number",
        pattern: /[0-9]+[.]?[0-9]*([eE][+\-][0-9]+)?/
      });
      var Boolean2 = createToken({
        name: "Boolean",
        pattern: /TRUE|FALSE/i
      });
      var Column = createToken({
        name: "Column",
        pattern: /[$]?[A-Za-z]{1,3}/,
        longer_alt: Name
      });
      var At = createToken({
        name: "At",
        pattern: /@/
      });
      var Comma = createToken({
        name: "Comma",
        pattern: /,/
      });
      var Colon = createToken({
        name: "Colon",
        pattern: /:/
      });
      var Semicolon = createToken({
        name: "Semicolon",
        pattern: /;/
      });
      var OpenParen = createToken({
        name: "OpenParen",
        pattern: /\(/
      });
      var CloseParen = createToken({
        name: "CloseParen",
        pattern: /\)/
      });
      var OpenSquareParen = createToken({
        name: "OpenSquareParen",
        pattern: /\[/
      });
      var CloseSquareParen = createToken({
        name: "CloseSquareParen",
        pattern: /]/
      });
      var ExclamationMark = createToken({
        name: "exclamationMark",
        pattern: /!/
      });
      var OpenCurlyParen = createToken({
        name: "OpenCurlyParen",
        pattern: /{/
      });
      var CloseCurlyParen = createToken({
        name: "CloseCurlyParen",
        pattern: /}/
      });
      var QuoteS = createToken({
        name: "QuoteS",
        pattern: /'/
      });
      var MulOp = createToken({
        name: "MulOp",
        pattern: /\*/
      });
      var PlusOp = createToken({
        name: "PlusOp",
        pattern: /\+/
      });
      var DivOp = createToken({
        name: "DivOp",
        pattern: /\//
      });
      var MinOp = createToken({
        name: "MinOp",
        pattern: /-/
      });
      var ConcatOp = createToken({
        name: "ConcatOp",
        pattern: /&/
      });
      var ExOp = createToken({
        name: "ExOp",
        pattern: /\^/
      });
      var PercentOp = createToken({
        name: "PercentOp",
        pattern: /%/
      });
      var GtOp = createToken({
        name: "GtOp",
        pattern: />/
      });
      var EqOp = createToken({
        name: "EqOp",
        pattern: /=/
      });
      var LtOp = createToken({
        name: "LtOp",
        pattern: /</
      });
      var NeqOp = createToken({
        name: "NeqOp",
        pattern: /<>/
      });
      var GteOp = createToken({
        name: "GteOp",
        pattern: />=/
      });
      var LteOp = createToken({
        name: "LteOp",
        pattern: /<=/
      });
      var allTokens = [
        WhiteSpace,
        String2,
        SheetQuoted,
        SingleQuotedString,
        Function2,
        FormulaErrorT,
        RefError,
        Sheet,
        Cell2,
        Boolean2,
        Column,
        Name,
        Number2,
        At,
        Comma,
        Colon,
        Semicolon,
        OpenParen,
        CloseParen,
        OpenSquareParen,
        CloseSquareParen,
        // ExclamationMark,
        OpenCurlyParen,
        CloseCurlyParen,
        QuoteS,
        MulOp,
        PlusOp,
        DivOp,
        MinOp,
        ConcatOp,
        ExOp,
        MulOp,
        PercentOp,
        NeqOp,
        GteOp,
        LteOp,
        GtOp,
        EqOp,
        LtOp
      ];
      var SelectLexer = new Lexer(allTokens, { ensureOptimizations: true });
      allTokens.forEach((tokenType) => {
        tokenVocabulary[tokenType.name] = tokenType;
      });
      module2.exports = {
        tokenVocabulary,
        lex: function(inputText) {
          const lexingResult = SelectLexer.tokenize(inputText);
          if (lexingResult.errors.length > 0) {
            const error = lexingResult.errors[0];
            const line = error.line, column = error.column;
            let msg = "\n" + inputText.split("\n")[line - 1] + "\n";
            msg += Array(column - 1).fill(" ").join("") + "^\n";
            error.message = msg + `Error at position ${line}:${column}
` + error.message;
            error.errorLocation = { line, column };
            throw FormulaError2.ERROR(error.message, error);
          }
          return lexingResult;
        }
      };
    }
  });

  // node_modules/fast-formula-parser/grammar/parsing.js
  var require_parsing = __commonJS({
    "node_modules/fast-formula-parser/grammar/parsing.js"(exports2, module2) {
      var lexer = require_lexing();
      var { EmbeddedActionsParser } = require_api();
      var tokenVocabulary = lexer.tokenVocabulary;
      var {
        String: String2,
        SheetQuoted,
        ExcelRefFunction,
        ExcelConditionalRefFunction,
        Function: Function2,
        FormulaErrorT,
        RefError,
        Cell: Cell2,
        Sheet,
        Name,
        Number: Number2,
        Boolean: Boolean2,
        Column,
        // At,
        Comma,
        Colon,
        Semicolon,
        OpenParen,
        CloseParen,
        // OpenSquareParen,
        // CloseSquareParen,
        // ExclamationMark,
        OpenCurlyParen,
        CloseCurlyParen,
        MulOp,
        PlusOp,
        DivOp,
        MinOp,
        ConcatOp,
        ExOp,
        PercentOp,
        NeqOp,
        GteOp,
        LteOp,
        GtOp,
        EqOp,
        LtOp
      } = lexer.tokenVocabulary;
      var Parsing = class extends EmbeddedActionsParser {
        /**
         *
         * @param {FormulaParser|DepParser} context
         * @param {Utils} utils
         */
        constructor(context2, utils) {
          super(tokenVocabulary, {
            outputCst: false,
            maxLookahead: 1,
            skipValidations: true
            // traceInitPerf: true,
          });
          this.utils = utils;
          this.binaryOperatorsPrecedence = [
            ["^"],
            ["*", "/"],
            ["+", "-"],
            ["&"],
            ["<", ">", "=", "<>", "<=", ">="]
          ];
          const $ = this;
          $.RULE("formulaWithBinaryOp", () => {
            const infixes = [];
            const values2 = [$.SUBRULE($.formulaWithPercentOp)];
            $.MANY(() => {
              infixes.push($.OR($.c1 || ($.c1 = [
                { ALT: () => $.CONSUME(GtOp).image },
                { ALT: () => $.CONSUME(EqOp).image },
                { ALT: () => $.CONSUME(LtOp).image },
                { ALT: () => $.CONSUME(NeqOp).image },
                { ALT: () => $.CONSUME(GteOp).image },
                { ALT: () => $.CONSUME(LteOp).image },
                { ALT: () => $.CONSUME(ConcatOp).image },
                { ALT: () => $.CONSUME(PlusOp).image },
                { ALT: () => $.CONSUME(MinOp).image },
                { ALT: () => $.CONSUME(MulOp).image },
                { ALT: () => $.CONSUME(DivOp).image },
                { ALT: () => $.CONSUME(ExOp).image }
              ])));
              values2.push($.SUBRULE2($.formulaWithPercentOp));
            });
            $.ACTION(() => {
              for (const ops of this.binaryOperatorsPrecedence) {
                for (let index = 0, length = infixes.length; index < length; index++) {
                  const infix = infixes[index];
                  if (!ops.includes(infix)) continue;
                  infixes.splice(index, 1);
                  values2.splice(index, 2, this.utils.applyInfix(values2[index], infix, values2[index + 1]));
                  index--;
                  length--;
                }
              }
            });
            return values2[0];
          });
          $.RULE("plusMinusOp", () => $.OR([
            { ALT: () => $.CONSUME(PlusOp).image },
            { ALT: () => $.CONSUME(MinOp).image }
          ]));
          $.RULE("formulaWithPercentOp", () => {
            let value = $.SUBRULE($.formulaWithUnaryOp);
            $.OPTION(() => {
              const postfix = $.CONSUME(PercentOp).image;
              value = $.ACTION(() => this.utils.applyPostfix(value, postfix));
            });
            return value;
          });
          $.RULE("formulaWithUnaryOp", () => {
            const prefixes = [];
            $.MANY(() => {
              const op = $.OR([
                { ALT: () => $.CONSUME(PlusOp).image },
                { ALT: () => $.CONSUME(MinOp).image }
              ]);
              prefixes.push(op);
            });
            const formula = $.SUBRULE($.formulaWithIntersect);
            if (prefixes.length > 0) return $.ACTION(() => this.utils.applyPrefix(prefixes, formula));
            return formula;
          });
          $.RULE("formulaWithIntersect", () => {
            let ref1 = $.SUBRULE($.formulaWithRange);
            const refs = [ref1];
            $.MANY({
              GATE: () => {
                const prevToken = $.LA(0);
                const nextToken = $.LA(1);
                return nextToken.startOffset > prevToken.endOffset + 1;
              },
              DEF: () => {
                refs.push($.SUBRULE3($.formulaWithRange));
              }
            });
            if (refs.length > 1) {
              return $.ACTION(() => $.ACTION(() => this.utils.applyIntersect(refs)));
            }
            return ref1;
          });
          $.RULE("formulaWithRange", () => {
            const ref1 = $.SUBRULE($.formula);
            const refs = [ref1];
            $.MANY(() => {
              $.CONSUME(Colon);
              refs.push($.SUBRULE2($.formula));
            });
            if (refs.length > 1)
              return $.ACTION(() => $.ACTION(() => this.utils.applyRange(refs)));
            return ref1;
          });
          $.RULE("formula", () => $.OR9([
            { ALT: () => $.SUBRULE($.referenceWithoutInfix) },
            { ALT: () => $.SUBRULE($.paren) },
            { ALT: () => $.SUBRULE($.constant) },
            { ALT: () => $.SUBRULE($.functionCall) },
            { ALT: () => $.SUBRULE($.constantArray) }
          ]));
          $.RULE("paren", () => {
            $.CONSUME(OpenParen);
            let result;
            const refs = [];
            refs.push($.SUBRULE($.formulaWithBinaryOp));
            $.MANY(() => {
              $.CONSUME(Comma);
              refs.push($.SUBRULE2($.formulaWithBinaryOp));
            });
            if (refs.length > 1)
              result = $.ACTION(() => this.utils.applyUnion(refs));
            else
              result = refs[0];
            $.CONSUME(CloseParen);
            return result;
          });
          $.RULE("constantArray", () => {
            const arr = [[]];
            let currentRow = 0;
            $.CONSUME(OpenCurlyParen);
            arr[currentRow].push($.SUBRULE($.constantForArray));
            $.MANY(() => {
              const sep = $.OR([
                { ALT: () => $.CONSUME(Comma).image },
                { ALT: () => $.CONSUME(Semicolon).image }
              ]);
              const constant = $.SUBRULE2($.constantForArray);
              if (sep === ",") {
                arr[currentRow].push(constant);
              } else {
                currentRow++;
                arr[currentRow] = [];
                arr[currentRow].push(constant);
              }
            });
            $.CONSUME(CloseCurlyParen);
            return $.ACTION(() => this.utils.toArray(arr));
          });
          $.RULE("constantForArray", () => $.OR([
            {
              ALT: () => {
                const prefix = $.OPTION(() => $.SUBRULE($.plusMinusOp));
                const image = $.CONSUME(Number2).image;
                const number = $.ACTION(() => this.utils.toNumber(image));
                if (prefix)
                  return $.ACTION(() => this.utils.applyPrefix([prefix], number));
                return number;
              }
            },
            {
              ALT: () => {
                const str = $.CONSUME(String2).image;
                return $.ACTION(() => this.utils.toString(str));
              }
            },
            {
              ALT: () => {
                const bool = $.CONSUME(Boolean2).image;
                return $.ACTION(() => this.utils.toBoolean(bool));
              }
            },
            {
              ALT: () => {
                const err = $.CONSUME(FormulaErrorT).image;
                return $.ACTION(() => this.utils.toError(err));
              }
            },
            {
              ALT: () => {
                const err = $.CONSUME(RefError).image;
                return $.ACTION(() => this.utils.toError(err));
              }
            }
          ]));
          $.RULE("constant", () => $.OR([
            {
              ALT: () => {
                const number = $.CONSUME(Number2).image;
                return $.ACTION(() => this.utils.toNumber(number));
              }
            },
            {
              ALT: () => {
                const str = $.CONSUME(String2).image;
                return $.ACTION(() => this.utils.toString(str));
              }
            },
            {
              ALT: () => {
                const bool = $.CONSUME(Boolean2).image;
                return $.ACTION(() => this.utils.toBoolean(bool));
              }
            },
            {
              ALT: () => {
                const err = $.CONSUME(FormulaErrorT).image;
                return $.ACTION(() => this.utils.toError(err));
              }
            }
          ]));
          $.RULE("functionCall", () => {
            const functionName = $.CONSUME(Function2).image.slice(0, -1);
            const args = $.SUBRULE($.arguments);
            $.CONSUME(CloseParen);
            return $.ACTION(() => context2.callFunction(functionName, args));
          });
          $.RULE("arguments", () => {
            $.MANY2(() => {
              $.CONSUME2(Comma);
            });
            const args = [];
            $.OPTION(() => {
              args.push($.SUBRULE($.formulaWithBinaryOp));
              $.MANY(() => {
                $.CONSUME1(Comma);
                args.push(null);
                $.OPTION3(() => {
                  args.pop();
                  args.push($.SUBRULE2($.formulaWithBinaryOp));
                });
              });
            });
            return args;
          });
          $.RULE("referenceWithoutInfix", () => $.OR([
            { ALT: () => $.SUBRULE($.referenceItem) },
            {
              // sheet name prefix
              ALT: () => {
                const sheetName = $.SUBRULE($.prefixName);
                const referenceItem = $.SUBRULE2($.formulaWithRange);
                $.ACTION(() => {
                  if (this.utils.isFormulaError(referenceItem))
                    return referenceItem;
                  referenceItem.ref.sheet = sheetName;
                });
                return referenceItem;
              }
            }
            // {ALT: () => $.SUBRULE('dynamicDataExchange')},
          ]));
          $.RULE("referenceItem", () => $.OR([
            {
              ALT: () => {
                const address = $.CONSUME(Cell2).image;
                return $.ACTION(() => this.utils.parseCellAddress(address));
              }
            },
            {
              ALT: () => {
                const name = $.CONSUME(Name).image;
                return $.ACTION(() => context2.getVariable(name));
              }
            },
            {
              ALT: () => {
                const column = $.CONSUME(Column).image;
                return $.ACTION(() => this.utils.parseCol(column));
              }
            },
            // A row check should be here, but the token is same with Number,
            // In other to resolve ambiguities, I leave this empty, and
            // parse the number to row number when needed.
            {
              ALT: () => {
                const err = $.CONSUME(RefError).image;
                return $.ACTION(() => this.utils.toError(err));
              }
            }
            // {ALT: () => $.SUBRULE($.udfFunctionCall)},
            // {ALT: () => $.SUBRULE($.structuredReference)},
          ]));
          $.RULE("prefixName", () => $.OR([
            { ALT: () => $.CONSUME(Sheet).image.slice(0, -1) },
            { ALT: () => $.CONSUME(SheetQuoted).image.slice(1, -2).replace(/''/g, "'") }
          ]));
          this.performSelfAnalysis();
        }
      };
      module2.exports = {
        Parser: Parsing
      };
    }
  });

  // node_modules/fast-formula-parser/grammar/utils.js
  var require_utils2 = __commonJS({
    "node_modules/fast-formula-parser/grammar/utils.js"(exports2, module2) {
      var FormulaError2 = require_error();
      var { Address } = require_helpers();
      var { Prefix, Postfix, Infix, Operators } = require_operators();
      var Collection = require_collection();
      var MAX_ROW = 1048576;
      var MAX_COLUMN = 16384;
      var { NotAllInputParsedException } = require_api();
      var Utils = class {
        constructor(context2) {
          this.context = context2;
        }
        columnNameToNumber(columnName) {
          return Address.columnNameToNumber(columnName);
        }
        /**
         * Parse the cell address only.
         * @param {string} cellAddress
         * @return {{ref: {col: number, address: string, row: number}}}
         */
        parseCellAddress(cellAddress) {
          const res = cellAddress.match(/([$]?)([A-Za-z]{1,3})([$]?)([1-9][0-9]*)/);
          return {
            ref: {
              address: res[0],
              col: this.columnNameToNumber(res[2]),
              row: +res[4]
            }
          };
        }
        parseRow(row) {
          const rowNum = +row;
          if (!Number.isInteger(rowNum))
            throw Error("Row number must be integer.");
          return {
            ref: {
              col: void 0,
              row: +row
            }
          };
        }
        parseCol(col) {
          return {
            ref: {
              col: this.columnNameToNumber(col),
              row: void 0
            }
          };
        }
        parseColRange(col1, col2) {
          col1 = this.columnNameToNumber(col1);
          col2 = this.columnNameToNumber(col2);
          return {
            ref: {
              from: {
                col: Math.min(col1, col2),
                row: null
              },
              to: {
                col: Math.max(col1, col2),
                row: null
              }
            }
          };
        }
        parseRowRange(row1, row2) {
          return {
            ref: {
              from: {
                col: null,
                row: Math.min(row1, row2)
              },
              to: {
                col: null,
                row: Math.max(row1, row2)
              }
            }
          };
        }
        _applyPrefix(prefixes, val, isArray2) {
          if (this.isFormulaError(val))
            return val;
          return Prefix.unaryOp(prefixes, val, isArray2);
        }
        async applyPrefixAsync(prefixes, value) {
          const { val, isArray: isArray2 } = this.extractRefValue(await value);
          return this._applyPrefix(prefixes, val, isArray2);
        }
        /**
         * Apply + or - unary prefix.
         * @param {Array.<string>} prefixes
         * @param {*} value
         * @return {*}
         */
        applyPrefix(prefixes, value) {
          if (this.context.async) {
            return this.applyPrefixAsync(prefixes, value);
          } else {
            const { val, isArray: isArray2 } = this.extractRefValue(value);
            return this._applyPrefix(prefixes, val, isArray2);
          }
        }
        _applyPostfix(val, isArray2, postfix) {
          if (this.isFormulaError(val))
            return val;
          return Postfix.percentOp(val, postfix, isArray2);
        }
        async applyPostfixAsync(value, postfix) {
          const { val, isArray: isArray2 } = this.extractRefValue(await value);
          return this._applyPostfix(val, isArray2, postfix);
        }
        applyPostfix(value, postfix) {
          if (this.context.async) {
            return this.applyPostfixAsync(value, postfix);
          } else {
            const { val, isArray: isArray2 } = this.extractRefValue(value);
            return this._applyPostfix(val, isArray2, postfix);
          }
        }
        _applyInfix(res1, infix, res2) {
          const val1 = res1.val, isArray1 = res1.isArray;
          const val2 = res2.val, isArray2 = res2.isArray;
          if (this.isFormulaError(val1))
            return val1;
          if (this.isFormulaError(val2))
            return val2;
          if (Operators.compareOp.includes(infix))
            return Infix.compareOp(val1, infix, val2, isArray1, isArray2);
          else if (Operators.concatOp.includes(infix))
            return Infix.concatOp(val1, infix, val2, isArray1, isArray2);
          else if (Operators.mathOp.includes(infix))
            return Infix.mathOp(val1, infix, val2, isArray1, isArray2);
          else
            throw new Error(`Unrecognized infix: ${infix}`);
        }
        async applyInfixAsync(value1, infix, value2) {
          const res1 = this.extractRefValue(await value1);
          const res2 = this.extractRefValue(await value2);
          return this._applyInfix(res1, infix, res2);
        }
        applyInfix(value1, infix, value2) {
          if (this.context.async) {
            return this.applyInfixAsync(value1, infix, value2);
          } else {
            const res1 = this.extractRefValue(value1);
            const res2 = this.extractRefValue(value2);
            return this._applyInfix(res1, infix, res2);
          }
        }
        applyIntersect(refs) {
          if (this.isFormulaError(refs[0]))
            return refs[0];
          if (!refs[0].ref)
            throw Error(`Expecting a reference, but got ${refs[0]}.`);
          let maxRow, maxCol, minRow, minCol, sheet, res;
          const ref = refs.shift().ref;
          sheet = ref.sheet;
          if (!ref.from) {
            if (ref.row === void 0 || ref.col === void 0) {
              throw Error("Cannot intersect the whole row or column.");
            }
            maxRow = minRow = ref.row;
            maxCol = minCol = ref.col;
          } else {
            maxRow = Math.max(ref.from.row, ref.to.row);
            minRow = Math.min(ref.from.row, ref.to.row);
            maxCol = Math.max(ref.from.col, ref.to.col);
            minCol = Math.min(ref.from.col, ref.to.col);
          }
          let err;
          refs.forEach((ref2) => {
            if (this.isFormulaError(ref2))
              return ref2;
            ref2 = ref2.ref;
            if (!ref2) throw Error(`Expecting a reference, but got ${ref2}.`);
            if (!ref2.from) {
              if (ref2.row === void 0 || ref2.col === void 0) {
                throw Error("Cannot intersect the whole row or column.");
              }
              if (ref2.row > maxRow || ref2.row < minRow || ref2.col > maxCol || ref2.col < minCol || sheet !== ref2.sheet) {
                err = FormulaError2.NULL;
              }
              maxRow = minRow = ref2.row;
              maxCol = minCol = ref2.col;
            } else {
              const refMaxRow = Math.max(ref2.from.row, ref2.to.row);
              const refMinRow = Math.min(ref2.from.row, ref2.to.row);
              const refMaxCol = Math.max(ref2.from.col, ref2.to.col);
              const refMinCol = Math.min(ref2.from.col, ref2.to.col);
              if (refMinRow > maxRow || refMaxRow < minRow || refMinCol > maxCol || refMaxCol < minCol || sheet !== ref2.sheet) {
                err = FormulaError2.NULL;
              }
              maxRow = Math.min(maxRow, refMaxRow);
              minRow = Math.max(minRow, refMinRow);
              maxCol = Math.min(maxCol, refMaxCol);
              minCol = Math.max(minCol, refMinCol);
            }
          });
          if (err) return err;
          if (maxRow === minRow && maxCol === minCol) {
            res = {
              ref: {
                sheet,
                row: maxRow,
                col: maxCol
              }
            };
          } else {
            res = {
              ref: {
                sheet,
                from: { row: minRow, col: minCol },
                to: { row: maxRow, col: maxCol }
              }
            };
          }
          if (!res.ref.sheet)
            delete res.ref.sheet;
          return res;
        }
        applyUnion(refs) {
          const collection = new Collection();
          for (let i = 0; i < refs.length; i++) {
            if (this.isFormulaError(refs[i]))
              return refs[i];
            collection.add(this.extractRefValue(refs[i]).val, refs[i]);
          }
          return collection;
        }
        /**
         * Apply multiple references, e.g. A1:B3:C8:A:1:.....
         * @param refs
         // * @return {{ref: {from: {col: number, row: number}, to: {col: number, row: number}}}}
         */
        applyRange(refs) {
          let res, maxRow = -1, maxCol = -1, minRow = MAX_ROW + 1, minCol = MAX_COLUMN + 1;
          refs.forEach((ref) => {
            if (this.isFormulaError(ref))
              return ref;
            if (typeof ref === "number") {
              ref = this.parseRow(ref);
            }
            ref = ref.ref;
            if (ref.row === void 0) {
              minRow = 1;
              maxRow = MAX_ROW;
            }
            if (ref.col === void 0) {
              minCol = 1;
              maxCol = MAX_COLUMN;
            }
            if (ref.row > maxRow)
              maxRow = ref.row;
            if (ref.row < minRow)
              minRow = ref.row;
            if (ref.col > maxCol)
              maxCol = ref.col;
            if (ref.col < minCol)
              minCol = ref.col;
          });
          if (maxRow === minRow && maxCol === minCol) {
            res = {
              ref: {
                row: maxRow,
                col: maxCol
              }
            };
          } else {
            res = {
              ref: {
                from: { row: minRow, col: minCol },
                to: { row: maxRow, col: maxCol }
              }
            };
          }
          return res;
        }
        /**
         * Throw away the refs, and retrieve the value.
         * @return {{val: *, isArray: boolean}}
         */
        extractRefValue(obj) {
          let res = obj, isArray2 = false;
          if (Array.isArray(res))
            isArray2 = true;
          if (obj.ref) {
            return { val: this.context.retrieveRef(obj), isArray: isArray2 };
          }
          return { val: res, isArray: isArray2 };
        }
        /**
         *
         * @param array
         * @return {Array}
         */
        toArray(array) {
          return array;
        }
        /**
         * @param {string} number
         * @return {number}
         */
        toNumber(number) {
          return Number(number);
        }
        /**
         * @param {string} string
         * @return {string}
         */
        toString(string) {
          return string.substring(1, string.length - 1).replace(/""/g, '"');
        }
        /**
         * @param {string} bool
         * @return {boolean}
         */
        toBoolean(bool) {
          return bool === "TRUE";
        }
        /**
         * Parse an error.
         * @param {string} error
         * @return {string}
         */
        toError(error) {
          return new FormulaError2(error.toUpperCase());
        }
        isFormulaError(obj) {
          return obj instanceof FormulaError2;
        }
        static formatChevrotainError(error, inputText) {
          let line, column, msg = "";
          if (error instanceof NotAllInputParsedException) {
            line = error.token.startLine;
            column = error.token.startColumn;
          } else {
            line = error.previousToken.startLine;
            column = error.previousToken.startColumn + 1;
          }
          msg += "\n" + inputText.split("\n")[line - 1] + "\n";
          msg += Array(column - 1).fill(" ").join("") + "^\n";
          msg += `Error at position ${line}:${column}
` + error.message;
          error.errorLocation = { line, column };
          return FormulaError2.ERROR(msg, error);
        }
      };
      module2.exports = Utils;
    }
  });

  // node_modules/fast-formula-parser/grammar/hooks.js
  var require_hooks = __commonJS({
    "node_modules/fast-formula-parser/grammar/hooks.js"(exports2, module2) {
      var TextFunctions = require_text();
      var MathFunctions = require_math();
      var TrigFunctions = require_trigonometry();
      var LogicalFunctions = require_logical();
      var EngFunctions = require_engineering();
      var ReferenceFunctions = require_reference();
      var InformationFunctions = require_information();
      var StatisticalFunctions = require_statistical();
      var DateFunctions = require_date();
      var WebFunctions = require_web();
      var FormulaError2 = require_error();
      var { FormulaHelpers } = require_helpers();
      var { Parser, allTokens } = require_parsing();
      var lexer = require_lexing();
      var Utils = require_utils2();
      var FormulaParser2 = class {
        /**
         * @param {{functions: {}, functionsNeedContext: {}, onVariable: function, onCell: function, onRange: function}} [config]
         * @param isTest - is in testing environment
         */
        constructor(config, isTest = false) {
          this.logs = [];
          this.isTest = isTest;
          this.utils = new Utils(this);
          config = Object.assign({
            functions: {},
            functionsNeedContext: {},
            onVariable: () => null,
            onCell: () => 0,
            onRange: () => [[0]]
          }, config);
          this.onVariable = config.onVariable;
          this.functions = Object.assign(
            {},
            DateFunctions,
            StatisticalFunctions,
            InformationFunctions,
            ReferenceFunctions,
            EngFunctions,
            LogicalFunctions,
            TextFunctions,
            MathFunctions,
            TrigFunctions,
            WebFunctions,
            config.functions,
            config.functionsNeedContext
          );
          this.onRange = config.onRange;
          this.onCell = config.onCell;
          this.funsNullAs0 = Object.keys(MathFunctions).concat(Object.keys(TrigFunctions)).concat(Object.keys(LogicalFunctions)).concat(Object.keys(EngFunctions)).concat(Object.keys(ReferenceFunctions)).concat(Object.keys(StatisticalFunctions)).concat(Object.keys(DateFunctions));
          this.funsNeedContextAndNoDataRetrieve = ["ROW", "ROWS", "COLUMN", "COLUMNS", "SUMIF", "INDEX", "AVERAGEIF", "IF"];
          this.funsNeedContext = [
            ...Object.keys(config.functionsNeedContext),
            ...this.funsNeedContextAndNoDataRetrieve,
            "INDEX",
            "OFFSET",
            "INDIRECT",
            "IF",
            "CHOOSE",
            "WEBSERVICE"
          ];
          this.funsPreserveRef = Object.keys(InformationFunctions);
          this.parser = new Parser(this, this.utils);
        }
        /**
         * Get all lexing token names. Webpack needs this.
         * @return {Array.<string>} - All token names that should not be minimized.
         */
        static get allTokens() {
          return allTokens;
        }
        /**
         * Get value from the cell reference
         * @param ref
         * @return {*}
         */
        getCell(ref) {
          if (ref.sheet == null)
            ref.sheet = this.position ? this.position.sheet : void 0;
          return this.onCell(ref);
        }
        /**
         * Get values from the range reference.
         * @param ref
         * @return {*}
         */
        getRange(ref) {
          if (ref.sheet == null)
            ref.sheet = this.position ? this.position.sheet : void 0;
          return this.onRange(ref);
        }
        /**
         * TODO:
         * Get references or values from a user defined variable.
         * @param name
         * @return {*}
         */
        getVariable(name) {
          const res = { ref: this.onVariable(name, this.position.sheet, this.position) };
          if (res.ref == null)
            return FormulaError2.NAME;
          return res;
        }
        /**
         * Retrieve values from the given reference.
         * @param valueOrRef
         * @return {*}
         */
        retrieveRef(valueOrRef) {
          if (FormulaHelpers.isRangeRef(valueOrRef)) {
            return this.getRange(valueOrRef.ref);
          }
          if (FormulaHelpers.isCellRef(valueOrRef)) {
            return this.getCell(valueOrRef.ref);
          }
          return valueOrRef;
        }
        /**
         * Call an excel function.
         * @param name - Function name.
         * @param args - Arguments that pass to the function.
         * @return {*}
         */
        _callFunction(name, args) {
          if (name.indexOf("_xlfn.") === 0)
            name = name.slice(6);
          name = name.toUpperCase();
          const nullValue = this.funsNullAs0.includes(name) ? 0 : "";
          if (!this.funsNeedContextAndNoDataRetrieve.includes(name)) {
            args = args.map((arg) => {
              if (arg === null)
                return { value: nullValue, isArray: false, omitted: true };
              const res = this.utils.extractRefValue(arg);
              if (this.funsPreserveRef.includes(name)) {
                return { value: res.val, isArray: res.isArray, ref: arg.ref };
              }
              return {
                value: res.val,
                isArray: res.isArray,
                isRangeRef: !!FormulaHelpers.isRangeRef(arg),
                isCellRef: !!FormulaHelpers.isCellRef(arg)
              };
            });
          }
          if (this.functions[name]) {
            let res;
            try {
              if (!this.funsNeedContextAndNoDataRetrieve.includes(name) && !this.funsNeedContext.includes(name))
                res = this.functions[name](...args);
              else
                res = this.functions[name](this, ...args);
            } catch (e) {
              if (e instanceof FormulaError2) {
                return e;
              } else {
                throw e;
              }
            }
            if (res === void 0) {
              if (this.isTest) {
                if (!this.logs.includes(name)) this.logs.push(name);
                return { value: 0, ref: {} };
              }
              throw FormulaError2.NOT_IMPLEMENTED(name);
            }
            return res;
          } else {
            if (this.isTest) {
              if (!this.logs.includes(name)) this.logs.push(name);
              return { value: 0, ref: {} };
            }
            throw FormulaError2.NOT_IMPLEMENTED(name);
          }
        }
        async callFunctionAsync(name, args) {
          const awaitedArgs = [];
          for (const arg of args) {
            awaitedArgs.push(await arg);
          }
          const res = await this._callFunction(name, awaitedArgs);
          return FormulaHelpers.checkFunctionResult(res);
        }
        callFunction(name, args) {
          if (this.async) {
            return this.callFunctionAsync(name, args);
          } else {
            const res = this._callFunction(name, args);
            return FormulaHelpers.checkFunctionResult(res);
          }
        }
        /**
         * Return currently supported functions.
         * @return {this}
         */
        supportedFunctions() {
          const supported = [];
          const functions = Object.keys(this.functions);
          functions.forEach((fun) => {
            try {
              const res = this.functions[fun](0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
              if (res === void 0) return;
              supported.push(fun);
            } catch (e) {
              if (e instanceof Error)
                supported.push(fun);
            }
          });
          return supported.sort();
        }
        /**
         * Check and return the appropriate formula result.
         * @param result
         * @param {boolean} [allowReturnArray] - If the formula can return an array
         * @return {*}
         */
        checkFormulaResult(result, allowReturnArray = false) {
          const type = typeof result;
          if (type === "number") {
            if (isNaN(result)) {
              return FormulaError2.VALUE;
            } else if (!isFinite(result)) {
              return FormulaError2.NUM;
            }
            result += 0;
          } else if (type === "object") {
            if (result instanceof FormulaError2)
              return result;
            if (allowReturnArray) {
              if (result.ref) {
                result = this.retrieveRef(result);
              }
              if (typeof result === "object" && !Array.isArray(result) && result != null) {
                return FormulaError2.VALUE;
              }
            } else {
              if (result.ref && result.ref.row && !result.ref.from) {
                result = this.retrieveRef(result);
              } else if (result.ref && result.ref.from && result.ref.from.col === result.ref.to.col) {
                result = this.retrieveRef({
                  ref: {
                    row: result.ref.from.row,
                    col: result.ref.from.col
                  }
                });
              } else if (Array.isArray(result)) {
                result = result[0][0];
              } else {
                return FormulaError2.VALUE;
              }
            }
          }
          return result;
        }
        /**
         * Parse an excel formula.
         * @param {string} inputText
         * @param {{row: number, col: number}} [position] - The position of the parsed formula
         *              e.g. {row: 1, col: 1}
         * @param {boolean} [allowReturnArray] - If the formula can return an array. Useful when parsing array formulas,
         *                                      or data validation formulas.
         * @returns {*}
         */
        parse(inputText, position, allowReturnArray = false) {
          if (inputText.length === 0) throw Error("Input must not be empty.");
          this.position = position;
          this.async = false;
          const lexResult = lexer.lex(inputText);
          this.parser.input = lexResult.tokens;
          let res;
          try {
            res = this.parser.formulaWithBinaryOp();
            res = this.checkFormulaResult(res, allowReturnArray);
            if (res instanceof FormulaError2) {
              return res;
            }
          } catch (e) {
            throw FormulaError2.ERROR(e.message, e);
          }
          if (this.parser.errors.length > 0) {
            const error = this.parser.errors[0];
            throw Utils.formatChevrotainError(error, inputText);
          }
          return res;
        }
        /**
         * Parse an excel formula asynchronously.
         * Use when providing custom async functions.
         * @param {string} inputText
         * @param {{row: number, col: number}} [position] - The position of the parsed formula
         *              e.g. {row: 1, col: 1}
         * @param {boolean} [allowReturnArray] - If the formula can return an array. Useful when parsing array formulas,
         *                                      or data validation formulas.
         * @returns {*}
         */
        async parseAsync(inputText, position, allowReturnArray = false) {
          if (inputText.length === 0) throw Error("Input must not be empty.");
          this.position = position;
          this.async = true;
          const lexResult = lexer.lex(inputText);
          this.parser.input = lexResult.tokens;
          let res;
          try {
            res = await this.parser.formulaWithBinaryOp();
            res = this.checkFormulaResult(res, allowReturnArray);
            if (res instanceof FormulaError2) {
              return res;
            }
          } catch (e) {
            throw FormulaError2.ERROR(e.message, e);
          }
          if (this.parser.errors.length > 0) {
            const error = this.parser.errors[0];
            throw Utils.formatChevrotainError(error, inputText);
          }
          return res;
        }
      };
      module2.exports = {
        FormulaParser: FormulaParser2,
        FormulaHelpers
      };
    }
  });

  // node_modules/fast-formula-parser/grammar/dependency/utils.js
  var require_utils3 = __commonJS({
    "node_modules/fast-formula-parser/grammar/dependency/utils.js"(exports2, module2) {
      var FormulaError2 = require_error();
      var { FormulaHelpers, Types, Address } = require_helpers();
      var { Prefix, Postfix, Infix, Operators } = require_operators();
      var Collection = require_collection();
      var MAX_ROW = 1048576;
      var MAX_COLUMN = 16384;
      var Utils = class {
        constructor(context2) {
          this.context = context2;
        }
        columnNameToNumber(columnName) {
          return Address.columnNameToNumber(columnName);
        }
        /**
         * Parse the cell address only.
         * @param {string} cellAddress
         * @return {{ref: {col: number, address: string, row: number}}}
         */
        parseCellAddress(cellAddress) {
          const res = cellAddress.match(/([$]?)([A-Za-z]{1,3})([$]?)([1-9][0-9]*)/);
          return {
            ref: {
              col: this.columnNameToNumber(res[2]),
              row: +res[4]
            }
          };
        }
        parseRow(row) {
          const rowNum = +row;
          if (!Number.isInteger(rowNum))
            throw Error("Row number must be integer.");
          return {
            ref: {
              col: void 0,
              row: +row
            }
          };
        }
        parseCol(col) {
          return {
            ref: {
              col: this.columnNameToNumber(col),
              row: void 0
            }
          };
        }
        /**
         * Apply + or - unary prefix.
         * @param {Array.<string>} prefixes
         * @param {*} value
         * @return {*}
         */
        applyPrefix(prefixes, value) {
          this.extractRefValue(value);
          return 0;
        }
        applyPostfix(value, postfix) {
          this.extractRefValue(value);
          return 0;
        }
        applyInfix(value1, infix, value2) {
          this.extractRefValue(value1);
          this.extractRefValue(value2);
          return 0;
        }
        applyIntersect(refs) {
          if (this.isFormulaError(refs[0]))
            return refs[0];
          if (!refs[0].ref)
            throw Error(`Expecting a reference, but got ${refs[0]}.`);
          let maxRow, maxCol, minRow, minCol, sheet, res;
          const ref = refs.shift().ref;
          sheet = ref.sheet;
          if (!ref.from) {
            if (ref.row === void 0 || ref.col === void 0) {
              throw Error("Cannot intersect the whole row or column.");
            }
            maxRow = minRow = ref.row;
            maxCol = minCol = ref.col;
          } else {
            maxRow = Math.max(ref.from.row, ref.to.row);
            minRow = Math.min(ref.from.row, ref.to.row);
            maxCol = Math.max(ref.from.col, ref.to.col);
            minCol = Math.min(ref.from.col, ref.to.col);
          }
          let err;
          refs.forEach((ref2) => {
            if (this.isFormulaError(ref2))
              return ref2;
            ref2 = ref2.ref;
            if (!ref2) throw Error(`Expecting a reference, but got ${ref2}.`);
            if (!ref2.from) {
              if (ref2.row === void 0 || ref2.col === void 0) {
                throw Error("Cannot intersect the whole row or column.");
              }
              if (ref2.row > maxRow || ref2.row < minRow || ref2.col > maxCol || ref2.col < minCol || sheet !== ref2.sheet) {
                err = FormulaError2.NULL;
              }
              maxRow = minRow = ref2.row;
              maxCol = minCol = ref2.col;
            } else {
              const refMaxRow = Math.max(ref2.from.row, ref2.to.row);
              const refMinRow = Math.min(ref2.from.row, ref2.to.row);
              const refMaxCol = Math.max(ref2.from.col, ref2.to.col);
              const refMinCol = Math.min(ref2.from.col, ref2.to.col);
              if (refMinRow > maxRow || refMaxRow < minRow || refMinCol > maxCol || refMaxCol < minCol || sheet !== ref2.sheet) {
                err = FormulaError2.NULL;
              }
              maxRow = Math.min(maxRow, refMaxRow);
              minRow = Math.max(minRow, refMinRow);
              maxCol = Math.min(maxCol, refMaxCol);
              minCol = Math.max(minCol, refMinCol);
            }
          });
          if (err) return err;
          if (maxRow === minRow && maxCol === minCol) {
            res = {
              ref: {
                sheet,
                row: maxRow,
                col: maxCol
              }
            };
          } else {
            res = {
              ref: {
                sheet,
                from: { row: minRow, col: minCol },
                to: { row: maxRow, col: maxCol }
              }
            };
          }
          if (!res.ref.sheet)
            delete res.ref.sheet;
          return res;
        }
        applyUnion(refs) {
          const collection = new Collection();
          for (let i = 0; i < refs.length; i++) {
            if (this.isFormulaError(refs[i]))
              return refs[i];
            collection.add(this.extractRefValue(refs[i]).val, refs[i]);
          }
          return collection;
        }
        /**
         * Apply multiple references, e.g. A1:B3:C8:A:1:.....
         * @param refs
         // * @return {{ref: {from: {col: number, row: number}, to: {col: number, row: number}}}}
         */
        applyRange(refs) {
          let res, maxRow = -1, maxCol = -1, minRow = MAX_ROW + 1, minCol = MAX_COLUMN + 1;
          refs.forEach((ref) => {
            if (this.isFormulaError(ref))
              return ref;
            if (typeof ref === "number") {
              ref = this.parseRow(ref);
            }
            ref = ref.ref;
            if (ref.row === void 0) {
              minRow = 1;
              maxRow = MAX_ROW;
            }
            if (ref.col === void 0) {
              minCol = 1;
              maxCol = MAX_COLUMN;
            }
            if (ref.row > maxRow)
              maxRow = ref.row;
            if (ref.row < minRow)
              minRow = ref.row;
            if (ref.col > maxCol)
              maxCol = ref.col;
            if (ref.col < minCol)
              minCol = ref.col;
          });
          if (maxRow === minRow && maxCol === minCol) {
            res = {
              ref: {
                row: maxRow,
                col: maxCol
              }
            };
          } else {
            res = {
              ref: {
                from: { row: minRow, col: minCol },
                to: { row: maxRow, col: maxCol }
              }
            };
          }
          return res;
        }
        /**
         * Throw away the refs, and retrieve the value.
         * @return {{val: *, isArray: boolean}}
         */
        extractRefValue(obj) {
          const isArray2 = Array.isArray(obj);
          if (obj.ref) {
            return { val: this.context.retrieveRef(obj), isArray: isArray2 };
          }
          return { val: obj, isArray: isArray2 };
        }
        /**
         *
         * @param array
         * @return {Array}
         */
        toArray(array) {
          return array;
        }
        /**
         * @param {string} number
         * @return {number}
         */
        toNumber(number) {
          return Number(number);
        }
        /**
         * @param {string} string
         * @return {string}
         */
        toString(string) {
          return string.substring(1, string.length - 1).replace(/""/g, '"');
        }
        /**
         * @param {string} bool
         * @return {boolean}
         */
        toBoolean(bool) {
          return bool === "TRUE";
        }
        /**
         * Parse an error.
         * @param {string} error
         * @return {FormulaError}
         */
        toError(error) {
          return new FormulaError2(error.toUpperCase());
        }
        isFormulaError(obj) {
          return obj instanceof FormulaError2;
        }
      };
      module2.exports = Utils;
    }
  });

  // node_modules/fast-formula-parser/grammar/dependency/hooks.js
  var require_hooks2 = __commonJS({
    "node_modules/fast-formula-parser/grammar/dependency/hooks.js"(exports2, module2) {
      var FormulaError2 = require_error();
      var { FormulaHelpers } = require_helpers();
      var { Parser } = require_parsing();
      var lexer = require_lexing();
      var Utils = require_utils3();
      var { formatChevrotainError } = require_utils2();
      var DepParser2 = class {
        /**
         *
         * @param {{onVariable: Function}} [config]
         */
        constructor(config) {
          this.data = [];
          this.utils = new Utils(this);
          config = Object.assign({
            onVariable: () => null
          }, config);
          this.utils = new Utils(this);
          this.onVariable = config.onVariable;
          this.functions = {};
          this.parser = new Parser(this, this.utils);
        }
        /**
         * Get value from the cell reference
         * @param ref
         * @return {*}
         */
        getCell(ref) {
          if (ref.row != null) {
            if (ref.sheet == null)
              ref.sheet = this.position ? this.position.sheet : void 0;
            const idx = this.data.findIndex((element) => {
              return element.from && element.from.row <= ref.row && element.to.row >= ref.row && element.from.col <= ref.col && element.to.col >= ref.col || element.row === ref.row && element.col === ref.col && element.sheet === ref.sheet;
            });
            if (idx === -1)
              this.data.push(ref);
          }
          return 0;
        }
        /**
         * Get values from the range reference.
         * @param ref
         * @return {*}
         */
        getRange(ref) {
          if (ref.from.row != null) {
            if (ref.sheet == null)
              ref.sheet = this.position ? this.position.sheet : void 0;
            const idx = this.data.findIndex((element) => {
              return element.from && element.from.row === ref.from.row && element.from.col === ref.from.col && element.to.row === ref.to.row && element.to.col === ref.to.col;
            });
            if (idx === -1)
              this.data.push(ref);
          }
          return [[0]];
        }
        /**
         * TODO:
         * Get references or values from a user defined variable.
         * @param name
         * @return {*}
         */
        getVariable(name) {
          const res = { ref: this.onVariable(name, this.position.sheet) };
          if (res.ref == null)
            return FormulaError2.NAME;
          if (FormulaHelpers.isCellRef(res))
            this.getCell(res.ref);
          else {
            this.getRange(res.ref);
          }
          return 0;
        }
        /**
         * Retrieve values from the given reference.
         * @param valueOrRef
         * @return {*}
         */
        retrieveRef(valueOrRef) {
          if (FormulaHelpers.isRangeRef(valueOrRef)) {
            return this.getRange(valueOrRef.ref);
          }
          if (FormulaHelpers.isCellRef(valueOrRef)) {
            return this.getCell(valueOrRef.ref);
          }
          return valueOrRef;
        }
        /**
         * Call an excel function.
         * @param name - Function name.
         * @param args - Arguments that pass to the function.
         * @return {*}
         */
        callFunction(name, args) {
          args.forEach((arg) => {
            if (arg == null)
              return;
            this.retrieveRef(arg);
          });
          return { value: 0, ref: {} };
        }
        /**
         * Check and return the appropriate formula result.
         * @param result
         * @return {*}
         */
        checkFormulaResult(result) {
          this.retrieveRef(result);
        }
        /**
         * Parse an excel formula and return the dependencies
         * @param {string} inputText
         * @param {{row: number, col: number, sheet: string}} position
         * @param {boolean} [ignoreError=false] if true, throw FormulaError when error occurred.
         *                                      if false, the parser will return partial dependencies.
         * @returns {Array.<{}>}
         */
        parse(inputText, position, ignoreError = false) {
          if (inputText.length === 0) throw Error("Input must not be empty.");
          this.data = [];
          this.position = position;
          const lexResult = lexer.lex(inputText);
          this.parser.input = lexResult.tokens;
          try {
            const res = this.parser.formulaWithBinaryOp();
            this.checkFormulaResult(res);
          } catch (e) {
            if (!ignoreError) {
              throw FormulaError2.ERROR(e.message, e);
            }
          }
          if (this.parser.errors.length > 0 && !ignoreError) {
            const error = this.parser.errors[0];
            throw formatChevrotainError(error, inputText);
          }
          return this.data;
        }
      };
      module2.exports = {
        DepParser: DepParser2
      };
    }
  });

  // node_modules/fast-formula-parser/index.js
  var require_fast_formula_parser = __commonJS({
    "node_modules/fast-formula-parser/index.js"(exports2, module2) {
      var { FormulaParser: FormulaParser2 } = require_hooks();
      var { DepParser: DepParser2 } = require_hooks2();
      var SSF = require_ssf();
      var FormulaError2 = require_error();
      Object.assign(FormulaParser2, __spreadValues({
        MAX_ROW: 1048576,
        MAX_COLUMN: 16384,
        SSF,
        DepParser: DepParser2,
        FormulaError: FormulaError2
      }, require_helpers()));
      module2.exports = FormulaParser2;
    }
  });

  // node_modules/scheduler/cjs/scheduler.development.js
  var require_scheduler_development = __commonJS({
    "node_modules/scheduler/cjs/scheduler.development.js"(exports2) {
      "use strict";
      (function() {
        function performWorkUntilDeadline() {
          needsPaint = false;
          if (isMessageLoopRunning) {
            var currentTime = exports2.unstable_now();
            startTime = currentTime;
            var hasMoreWork = true;
            try {
              a: {
                isHostCallbackScheduled = false;
                isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
                isPerformingWork = true;
                var previousPriorityLevel = currentPriorityLevel;
                try {
                  b: {
                    advanceTimers(currentTime);
                    for (currentTask = peek2(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                      var callback = currentTask.callback;
                      if ("function" === typeof callback) {
                        currentTask.callback = null;
                        currentPriorityLevel = currentTask.priorityLevel;
                        var continuationCallback = callback(
                          currentTask.expirationTime <= currentTime
                        );
                        currentTime = exports2.unstable_now();
                        if ("function" === typeof continuationCallback) {
                          currentTask.callback = continuationCallback;
                          advanceTimers(currentTime);
                          hasMoreWork = true;
                          break b;
                        }
                        currentTask === peek2(taskQueue) && pop(taskQueue);
                        advanceTimers(currentTime);
                      } else pop(taskQueue);
                      currentTask = peek2(taskQueue);
                    }
                    if (null !== currentTask) hasMoreWork = true;
                    else {
                      var firstTimer = peek2(timerQueue);
                      null !== firstTimer && requestHostTimeout(
                        handleTimeout,
                        firstTimer.startTime - currentTime
                      );
                      hasMoreWork = false;
                    }
                  }
                  break a;
                } finally {
                  currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
                }
                hasMoreWork = void 0;
              }
            } finally {
              hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
            }
          }
        }
        function push(heap, node) {
          var index = heap.length;
          heap.push(node);
          a: for (; 0 < index; ) {
            var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
            if (0 < compare(parent, node))
              heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
            else break a;
          }
        }
        function peek2(heap) {
          return 0 === heap.length ? null : heap[0];
        }
        function pop(heap) {
          if (0 === heap.length) return null;
          var first2 = heap[0], last2 = heap.pop();
          if (last2 !== first2) {
            heap[0] = last2;
            a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
              var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
              if (0 > compare(left, last2))
                rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last2, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last2, index = leftIndex);
              else if (rightIndex < length && 0 > compare(right, last2))
                heap[index] = right, heap[rightIndex] = last2, index = rightIndex;
              else break a;
            }
          }
          return first2;
        }
        function compare(a, b) {
          var diff = a.sortIndex - b.sortIndex;
          return 0 !== diff ? diff : a.id - b.id;
        }
        function advanceTimers(currentTime) {
          for (var timer2 = peek2(timerQueue); null !== timer2; ) {
            if (null === timer2.callback) pop(timerQueue);
            else if (timer2.startTime <= currentTime)
              pop(timerQueue), timer2.sortIndex = timer2.expirationTime, push(taskQueue, timer2);
            else break;
            timer2 = peek2(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled)
            if (null !== peek2(taskQueue))
              isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
            else {
              var firstTimer = peek2(timerQueue);
              null !== firstTimer && requestHostTimeout(
                handleTimeout,
                firstTimer.startTime - currentTime
              );
            }
        }
        function shouldYieldToHost() {
          return needsPaint ? true : exports2.unstable_now() - startTime < frameInterval ? false : true;
        }
        function requestHostTimeout(callback, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports2.unstable_now());
          }, ms);
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        exports2.unstable_now = void 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          exports2.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date, initialTime = localDate.now();
          exports2.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null, isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
        if ("function" === typeof localSetImmediate)
          var schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        else if ("undefined" !== typeof MessageChannel) {
          var channel = new MessageChannel(), port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        exports2.unstable_IdlePriority = 5;
        exports2.unstable_ImmediatePriority = 1;
        exports2.unstable_LowPriority = 4;
        exports2.unstable_NormalPriority = 3;
        exports2.unstable_Profiling = null;
        exports2.unstable_UserBlockingPriority = 2;
        exports2.unstable_cancelCallback = function(task) {
          task.callback = null;
        };
        exports2.unstable_forceFrameRate = function(fps) {
          0 > fps || 125 < fps ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
        };
        exports2.unstable_getCurrentPriorityLevel = function() {
          return currentPriorityLevel;
        };
        exports2.unstable_next = function(eventHandler) {
          switch (currentPriorityLevel) {
            case 1:
            case 2:
            case 3:
              var priorityLevel = 3;
              break;
            default:
              priorityLevel = currentPriorityLevel;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports2.unstable_requestPaint = function() {
          needsPaint = true;
        };
        exports2.unstable_runWithPriority = function(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              priorityLevel = 3;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports2.unstable_scheduleCallback = function(priorityLevel, callback, options) {
          var currentTime = exports2.unstable_now();
          "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
          switch (priorityLevel) {
            case 1:
              var timeout = -1;
              break;
            case 2:
              timeout = 250;
              break;
            case 5:
              timeout = 1073741823;
              break;
            case 4:
              timeout = 1e4;
              break;
            default:
              timeout = 5e3;
          }
          timeout = options + timeout;
          priorityLevel = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: options,
            expirationTime: timeout,
            sortIndex: -1
          };
          options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek2(taskQueue) && priorityLevel === peek2(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
          return priorityLevel;
        };
        exports2.unstable_shouldYield = shouldYieldToHost;
        exports2.unstable_wrapCallback = function(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        };
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports2, module2) {
      "use strict";
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_scheduler_development();
      }
    }
  });

  // node_modules/use-context-selector/dist/index.js
  function createContext(defaultValue) {
    const context2 = (0, import_react.createContext)({
      [CONTEXT_VALUE]: {
        /* "v"alue     */
        v: { current: defaultValue },
        /* versio"n"   */
        n: { current: -1 },
        /* "l"isteners */
        l: /* @__PURE__ */ new Set(),
        /* "u"pdate    */
        u: (f) => f()
      }
    });
    context2[ORIGINAL_PROVIDER] = context2.Provider;
    context2.Provider = createProvider(context2.Provider);
    delete context2.Consumer;
    return context2;
  }
  function useContextSelector(context2, selector) {
    const contextValue = (0, import_react.useContext)(context2)[CONTEXT_VALUE];
    if (typeof process === "object" && true) {
      if (!contextValue) {
        throw new Error("useContextSelector requires special context");
      }
    }
    const {
      /* "v"alue     */
      v: { current: value },
      /* versio"n"   */
      n: { current: version },
      /* "l"isteners */
      l: listeners
    } = contextValue;
    const selected = selector(value);
    const [state, dispatch] = (0, import_react.useReducer)((prev, action) => {
      if (!action) {
        return [value, selected];
      }
      if ("p" in action) {
        throw action.p;
      }
      if (action.n === version) {
        if (Object.is(prev[1], selected)) {
          return prev;
        }
        return [value, selected];
      }
      try {
        if ("v" in action) {
          if (Object.is(prev[0], action.v)) {
            return prev;
          }
          const nextSelected = selector(action.v);
          if (Object.is(prev[1], nextSelected)) {
            return prev;
          }
          return [action.v, nextSelected];
        }
      } catch (_e) {
      }
      return [...prev];
    }, [value, selected]);
    if (!Object.is(state[1], selected)) {
      dispatch();
    }
    useIsomorphicLayoutEffect(() => {
      listeners.add(dispatch);
      return () => {
        listeners.delete(dispatch);
      };
    }, [listeners]);
    return state[1];
  }
  var import_react, import_scheduler, CONTEXT_VALUE, ORIGINAL_PROVIDER, isSSR, useIsomorphicLayoutEffect, runWithNormalPriority, createProvider;
  var init_dist = __esm({
    "node_modules/use-context-selector/dist/index.js"() {
      import_react = __toESM(require_react(), 1);
      import_scheduler = __toESM(require_scheduler(), 1);
      CONTEXT_VALUE = Symbol();
      ORIGINAL_PROVIDER = Symbol();
      isSSR = typeof window === "undefined" || /ServerSideRendering/.test(window.navigator && window.navigator.userAgent);
      useIsomorphicLayoutEffect = isSSR ? import_react.useEffect : import_react.useLayoutEffect;
      runWithNormalPriority = import_scheduler.unstable_runWithPriority ? (fn) => {
        try {
          (0, import_scheduler.unstable_runWithPriority)(import_scheduler.unstable_NormalPriority, fn);
        } catch (e) {
          if (e.message === "Not implemented.") {
            fn();
          } else {
            throw e;
          }
        }
      } : (fn) => fn();
      createProvider = (ProviderOrig) => {
        const ContextProvider = ({ value, children }) => {
          const valueRef = (0, import_react.useRef)(value);
          const versionRef = (0, import_react.useRef)(0);
          const [resolve, setResolve] = (0, import_react.useState)(null);
          if (resolve) {
            resolve(value);
            setResolve(null);
          }
          const contextValue = (0, import_react.useRef)();
          if (!contextValue.current) {
            const listeners = /* @__PURE__ */ new Set();
            const update = (fn, options) => {
              versionRef.current += 1;
              const action = {
                n: versionRef.current
              };
              if (options === null || options === void 0 ? void 0 : options.suspense) {
                action.n *= -1;
                action.p = new Promise((r) => {
                  setResolve(() => (v) => {
                    action.v = v;
                    delete action.p;
                    r(v);
                  });
                });
              }
              listeners.forEach((listener) => listener(action));
              fn();
            };
            contextValue.current = {
              [CONTEXT_VALUE]: {
                /* "v"alue     */
                v: valueRef,
                /* versio"n"   */
                n: versionRef,
                /* "l"isteners */
                l: listeners,
                /* "u"pdate    */
                u: update
              }
            };
          }
          useIsomorphicLayoutEffect(() => {
            valueRef.current = value;
            versionRef.current += 1;
            runWithNormalPriority(() => {
              contextValue.current[CONTEXT_VALUE].l.forEach((listener) => {
                listener({ n: versionRef.current, v: value });
              });
            });
          }, [value]);
          return (0, import_react.createElement)(ProviderOrig, { value: contextValue.current }, children);
        };
        return ContextProvider;
      };
    }
  });

  // node_modules/react-spreadsheet/dist/es/index.js
  function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  }
  function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  }
  function setData(data) {
    return {
      type: SET_DATA,
      payload: { data }
    };
  }
  function setCreateFormulaParser(createFormulaParser2) {
    return {
      type: SET_CREATE_FORMULA_PARSER,
      payload: { createFormulaParser: createFormulaParser2 }
    };
  }
  function selectEntireRow(row, extend) {
    return {
      type: SELECT_ENTIRE_ROW,
      payload: { row, extend }
    };
  }
  function selectEntireColumn(column, extend) {
    return {
      type: SELECT_ENTIRE_COLUMN,
      payload: { column, extend }
    };
  }
  function selectEntireWorksheet() {
    return { type: SELECT_ENTIRE_WORKSHEET };
  }
  function setSelection(selection) {
    return { type: SET_SELECTION, payload: { selection } };
  }
  function select(point) {
    return {
      type: SELECT,
      payload: { point }
    };
  }
  function activate(point) {
    return {
      type: ACTIVATE,
      payload: { point }
    };
  }
  function setCellData(active, data) {
    return {
      type: SET_CELL_DATA,
      payload: { active, data }
    };
  }
  function setCellDimensions(point, dimensions) {
    return {
      type: SET_CELL_DIMENSIONS,
      payload: { point, dimensions }
    };
  }
  function paste(data) {
    return {
      type: PASTE,
      payload: { data }
    };
  }
  function keyPress(event) {
    return {
      type: KEY_PRESS,
      payload: { event }
    };
  }
  function keyDown(event) {
    return {
      type: KEY_DOWN,
      payload: { event }
    };
  }
  function dragStart() {
    return { type: DRAG_START };
  }
  function dragEnd() {
    return { type: DRAG_END };
  }
  function commit$1(changes) {
    return {
      type: COMMIT,
      payload: { changes }
    };
  }
  function copy() {
    return { type: COPY };
  }
  function cut() {
    return { type: CUT };
  }
  function edit$1() {
    return { type: EDIT };
  }
  function view$1() {
    return { type: VIEW };
  }
  function blur$1() {
    return { type: BLUR };
  }
  function get(point, matrix) {
    var columns = matrix[point.row];
    if (columns === void 0) {
      return void 0;
    }
    return columns[point.column];
  }
  function slice(startPoint, endPoint, matrix) {
    var sliced = [];
    var columns = endPoint.column - startPoint.column;
    for (var row = startPoint.row; row <= endPoint.row; row++) {
      var slicedRow = row - startPoint.row;
      sliced[slicedRow] = sliced[slicedRow] || Array(columns);
      for (var column = startPoint.column; column <= endPoint.column; column++) {
        sliced[slicedRow][column - startPoint.column] = get({ row, column }, matrix);
      }
    }
    return sliced;
  }
  function set(point, value, matrix) {
    var nextMatrix = __spreadArray([], __read(matrix), false);
    var firstRow = matrix[0];
    var nextFirstRow = firstRow ? __spreadArray([], __read(firstRow), false) : [];
    if (nextFirstRow.length - 1 < point.column) {
      nextFirstRow[point.column] = void 0;
      nextMatrix[0] = nextFirstRow;
    }
    var nextRow = matrix[point.row] ? __spreadArray([], __read(matrix[point.row]), false) : [];
    nextRow[point.column] = value;
    nextMatrix[point.row] = nextRow;
    return nextMatrix;
  }
  function mutableSet(point, value, matrix) {
    var firstRow = matrix[0];
    if (!firstRow) {
      firstRow = [];
      matrix[0] = firstRow;
    }
    if (!(point.row in matrix)) {
      matrix[point.row] = [];
    }
    if (!(point.column in firstRow)) {
      firstRow[point.column] = void 0;
    }
    matrix[point.row][point.column] = value;
  }
  function unset(point, matrix) {
    if (!has2(point, matrix)) {
      return matrix;
    }
    var nextMatrix = __spreadArray([], __read(matrix), false);
    var nextRow = __spreadArray([], __read(matrix[point.row]), false);
    nextRow[point.column] = void 0;
    nextMatrix[point.row] = nextRow;
    return nextMatrix;
  }
  function map2(func, matrix) {
    var e_1, _a;
    var newMatrix = [];
    try {
      for (var _b = __values(entries(matrix)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var _d = __read(_c.value, 2), point = _d[0], value = _d[1];
        mutableSet(point, func(value, point), newMatrix);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    return newMatrix;
  }
  function entries(matrix) {
    var _a, _b, _c, row, values2, _d, _e, _f, column, value, point, e_2_1, e_3_1;
    var e_3, _g, e_2, _h;
    return __generator(this, function(_j) {
      switch (_j.label) {
        case 0:
          _j.trys.push([0, 11, 12, 13]);
          _a = __values(matrix.entries()), _b = _a.next();
          _j.label = 1;
        case 1:
          if (!!_b.done) return [3, 10];
          _c = __read(_b.value, 2), row = _c[0], values2 = _c[1];
          _j.label = 2;
        case 2:
          _j.trys.push([2, 7, 8, 9]);
          _d = (e_2 = void 0, __values(values2.entries())), _e = _d.next();
          _j.label = 3;
        case 3:
          if (!!_e.done) return [3, 6];
          _f = __read(_e.value, 2), column = _f[0], value = _f[1];
          point = { row, column };
          return [4, [point, value]];
        case 4:
          _j.sent();
          _j.label = 5;
        case 5:
          _e = _d.next();
          return [3, 3];
        case 6:
          return [3, 9];
        case 7:
          e_2_1 = _j.sent();
          e_2 = { error: e_2_1 };
          return [3, 9];
        case 8:
          try {
            if (_e && !_e.done && (_h = _d.return)) _h.call(_d);
          } finally {
            if (e_2) throw e_2.error;
          }
          return [
            7
            /*endfinally*/
          ];
        case 9:
          _b = _a.next();
          return [3, 1];
        case 10:
          return [3, 13];
        case 11:
          e_3_1 = _j.sent();
          e_3 = { error: e_3_1 };
          return [3, 13];
        case 12:
          try {
            if (_b && !_b.done && (_g = _a.return)) _g.call(_a);
          } finally {
            if (e_3) throw e_3.error;
          }
          return [
            7
            /*endfinally*/
          ];
        case 13:
          return [
            2
            /*return*/
          ];
      }
    });
  }
  function join(matrix, horizontalSeparator, verticalSeparator) {
    if (horizontalSeparator === void 0) {
      horizontalSeparator = "	";
    }
    if (verticalSeparator === void 0) {
      verticalSeparator = "\n";
    }
    var joined = "";
    var _a = getSize(matrix), rows = _a.rows, columns = _a.columns;
    for (var row = 0; row < rows; row++) {
      if (row) {
        joined += verticalSeparator;
      }
      for (var column = 0; column < columns; column++) {
        if (column) {
          joined += horizontalSeparator;
        }
        if (matrix[row] && column in matrix[row]) {
          joined += String(matrix[row][column]);
        }
      }
    }
    return joined;
  }
  function split(csv, transform, horizontalSeparator, verticalSeparator) {
    if (horizontalSeparator === void 0) {
      horizontalSeparator = "	";
    }
    if (verticalSeparator === void 0) {
      verticalSeparator = /\r\n|\n|\r/;
    }
    var replaced = csv.replace(/"([^"]*?)"/g, function(match, p1) {
      return p1.replace(/\n/g, "\\n");
    });
    return replaced.split(verticalSeparator).map(function(row) {
      return row.split(horizontalSeparator).map(function(line) {
        return line.replace(/\\n/g, "\n");
      }).map(transform);
    });
  }
  function has2(point, matrix) {
    var firstRow = matrix[0];
    return firstRow && // validation
    point.row >= 0 && point.column >= 0 && Number.isInteger(point.row) && Number.isInteger(point.column) && // first row length is in sync with other rows
    point.column < firstRow.length && point.row < matrix.length;
  }
  function getSize(matrix) {
    return {
      columns: getColumnsCount(matrix),
      rows: getRowsCount(matrix)
    };
  }
  function getRowsCount(matrix) {
    return matrix.length;
  }
  function getColumnsCount(matrix) {
    var firstRow = matrix[0];
    return firstRow ? firstRow.length : 0;
  }
  function pad(matrix, size) {
    var _a = getSize(matrix), rows = _a.rows, columns = _a.columns;
    if (rows >= size.rows && columns >= size.columns) {
      return matrix;
    }
    var resultSize = {
      rows: size.rows > rows ? size.rows : rows,
      columns: size.columns > columns ? size.columns : columns
    };
    var padded = __spreadArray([], __read(matrix), false);
    if (resultSize.columns > columns) {
      var padColumns_1 = resultSize.columns - columns;
      padded = padded.map(function(row) {
        return __spreadArray(__spreadArray([], __read(row), false), __read(Array(padColumns_1).fill(void 0)), false);
      });
    }
    if (resultSize.rows > rows) {
      var padRows_1 = resultSize.rows - rows;
      var emptyRow = Array(resultSize.columns).fill(void 0);
      padded = __spreadArray(__spreadArray([], __read(padded), false), __read(Array(padRows_1).fill(emptyRow)), false);
    }
    return padded;
  }
  function toArray(matrix, transform) {
    var array = [];
    for (var row = 0; row < matrix.length; row++) {
      for (var column = 0; column < matrix[row].length; column++) {
        var value = matrix[row][column];
        array.push(transform ? transform(value, { row, column }) : value);
      }
    }
    return array;
  }
  function maxPoint(matrix) {
    var size = getSize(matrix);
    return { row: size.rows - 1, column: size.columns - 1 };
  }
  function isEqual(source, target) {
    return source.column === target.column && source.row === target.row;
  }
  function getMatrixRange(data) {
    var maxPoint$1 = maxPoint(data);
    return new PointRange(ORIGIN, maxPoint$1);
  }
  function isIndex(value) {
    return Number.isInteger(value) && value >= 0;
  }
  function moveCursorToEnd(el) {
    el.selectionStart = el.selectionEnd = el.value.length;
  }
  function range(end, start, step) {
    if (start === void 0) {
      start = 0;
    }
    if (step === void 0) {
      step = 1;
    }
    var array = [];
    if (Math.sign(end - start) === -1) {
      for (var element = start; element > end; element -= step) {
        array.push(element);
      }
      return array;
    }
    for (var element = start; element < end; element += step) {
      array.push(element);
    }
    return array;
  }
  function isActive(active, point) {
    return Boolean(active && isEqual(point, active));
  }
  function getOffsetRect(element) {
    return {
      width: element.offsetWidth,
      height: element.offsetHeight,
      left: element.offsetLeft,
      top: element.offsetTop
    };
  }
  function writeTextToClipboard(event, data) {
    var _a;
    (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.setData(PLAIN_TEXT_MIME, data);
  }
  function readTextFromClipboard(event) {
    if (window.clipboardData && window.clipboardData.getData) {
      return window.clipboardData.getData("Text");
    }
    if (event.clipboardData && event.clipboardData.getData) {
      return event.clipboardData.getData(PLAIN_TEXT_MIME);
    }
    return "";
  }
  function getCellDimensions(point, rowDimensions, columnDimensions) {
    var cellRowDimensions = rowDimensions && rowDimensions[point.row];
    var cellColumnDimensions = columnDimensions && columnDimensions[point.column];
    return cellRowDimensions && cellColumnDimensions && __assign(__assign({}, cellRowDimensions), cellColumnDimensions);
  }
  function getRangeDimensions(rowDimensions, columnDimensions, range2) {
    var startDimensions = getCellDimensions(range2.start, rowDimensions, columnDimensions);
    var endDimensions = getCellDimensions(range2.end, rowDimensions, columnDimensions);
    return startDimensions && endDimensions && {
      width: endDimensions.left + endDimensions.width - startDimensions.left,
      height: endDimensions.top + endDimensions.height - startDimensions.top,
      top: startDimensions.top,
      left: startDimensions.left
    };
  }
  function getSelectedDimensions(rowDimensions, columnDimensions, data, selected) {
    var range2 = selected.toRange(data);
    return range2 ? getRangeDimensions(rowDimensions, columnDimensions, range2) : void 0;
  }
  function getCSV(data) {
    var valueMatrix = map2(function(cell) {
      return (cell === null || cell === void 0 ? void 0 : cell.value) || "";
    }, data);
    return join(valueMatrix);
  }
  function calculateSpreadsheetSize(data, rowLabels, columnLabels) {
    var _a = getSize(data), columns = _a.columns, rows = _a.rows;
    return {
      rows: rowLabels ? Math.max(rows, rowLabels.length) : rows,
      columns: columnLabels ? Math.max(columns, columnLabels.length) : columns
    };
  }
  function shouldHandleClipboardEvent(root, mode) {
    return root !== null && mode === "view" && isFocusedWithin(root);
  }
  function isFocusedWithin(element) {
    return element.matches(FOCUS_WITHIN_SELECTOR);
  }
  function hasLineBreaker(value) {
    return typeof value === "string" && value.includes("\n");
  }
  function toString(point) {
    return "".concat(point.row, ",").concat(point.column);
  }
  function fromString(point) {
    var _a = __read(point.split(","), 2), row = _a[0], column = _a[1];
    return { row: Number(row), column: Number(column) };
  }
  function isFormulaValue(value) {
    return typeof value === "string" && value.startsWith(FORMULA_VALUE_PREFIX) && value.length > 1;
  }
  function extractFormula(value) {
    return value.slice(1);
  }
  function createFormulaParser(data, config) {
    return new import_fast_formula_parser.default(__assign(__assign({}, config), { onCell: function(ref) {
      var point = {
        row: ref.row - 1,
        column: ref.col - 1
      };
      var cell = get(point, data);
      if (!isNaN(cell === null || cell === void 0 ? void 0 : cell.value))
        return Number(cell === null || cell === void 0 ? void 0 : cell.value);
      return cell === null || cell === void 0 ? void 0 : cell.value;
    }, onRange: function(ref) {
      var size = getSize(data);
      var start = {
        row: ref.from.row - 1,
        column: ref.from.col - 1
      };
      var end = {
        row: Math.min(ref.to.row - 1, size.rows - 1),
        column: Math.min(ref.to.col - 1, size.columns - 1)
      };
      var dataSlice = slice(start, end, data);
      return toArray(dataSlice, function(cell) {
        if (!isNaN(cell === null || cell === void 0 ? void 0 : cell.value))
          return Number(cell === null || cell === void 0 ? void 0 : cell.value);
        return cell === null || cell === void 0 ? void 0 : cell.value;
      });
    } }));
  }
  function getReferences(formula, point, data) {
    var _a = getSize(data), rows = _a.rows, columns = _a.columns;
    try {
      var dependencies = depParser.parse(formula, convertPointToCellRef(point));
      var references = PointSet.from(dependencies.flatMap(function(reference) {
        var isRange = "from" in reference;
        if (isRange) {
          var from = reference.from, to = reference.to;
          var normalizedFrom = {
            row: from.row - 1,
            column: from.col - 1
          };
          var normalizedTo = {
            row: Math.min(to.row - 1, rows - 1),
            column: Math.min(to.col - 1, columns - 1)
          };
          var range2 = new PointRange(normalizedFrom, normalizedTo);
          return Array.from(range2);
        }
        return { row: reference.row - 1, column: reference.col - 1 };
      }));
      return references;
    } catch (error) {
      if (error instanceof import_fast_formula_parser.FormulaError) {
        return PointSet.from([]);
      } else {
        throw error;
      }
    }
  }
  function evaluate(formula, point, formulaParser) {
    try {
      var position = convertPointToCellRef(point);
      var returned = formulaParser.parse(formula, position);
      return returned instanceof import_fast_formula_parser.FormulaError ? returned.toString() : returned;
    } catch (error) {
      if (error instanceof import_fast_formula_parser.FormulaError) {
        return error.toString();
      }
      throw error;
    }
  }
  function convertPointToCellRef(point) {
    return {
      row: point.row + 1,
      col: point.column + 1,
      // TODO: fill once we support multiple sheets
      sheet: "Sheet1"
    };
  }
  function updateCellValue(model, point, cell) {
    var nextData = set(point, cell, model.data);
    var nextReferenceGraph = isFormulaValue(cell.value) ? updateReferenceGraph(model.referenceGraph, point, cell, nextData) : model.referenceGraph;
    var formulaParser = model.createFormulaParser(nextData);
    var nextEvaluatedData = evaluateCell(model.evaluatedData, nextData, nextReferenceGraph, point, cell, formulaParser);
    return new Model(model.createFormulaParser, nextData, nextReferenceGraph, nextEvaluatedData);
  }
  function updateReferenceGraph(referenceGraph, point, cell, data) {
    var references = getReferences(extractFormula(cell.value), point, data);
    var nextReferenceGraph = referenceGraph.set(point, references);
    return nextReferenceGraph;
  }
  function evaluateCell(prevEvaluatedData, data, referenceGraph, point, cell, formulaParser) {
    var e_1, _a, e_2, _b;
    if (referenceGraph.hasCircularDependency(point)) {
      var visited = PointSet.from([point]);
      var nextEvaluatedData_1 = set(point, __assign(__assign({}, cell), { value: import_fast_formula_parser.FormulaError.REF }), prevEvaluatedData);
      try {
        for (var _c = __values(referenceGraph.getBackwardsRecursive(point)), _d = _c.next(); !_d.done; _d = _c.next()) {
          var referrer = _d.value;
          if (visited.has(referrer)) {
            break;
          }
          visited = visited.add(referrer);
          var referrerCell = get(referrer, data);
          if (!referrerCell) {
            continue;
          }
          nextEvaluatedData_1 = set(referrer, __assign(__assign({}, referrerCell), { value: import_fast_formula_parser.FormulaError.REF }), nextEvaluatedData_1);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      return nextEvaluatedData_1;
    }
    var nextEvaluatedData = prevEvaluatedData;
    var evaluatedValue = isFormulaValue(cell.value) ? getFormulaComputedValue(cell.value, point, formulaParser) : cell.value;
    var evaluatedCell = __assign(__assign({}, cell), { value: evaluatedValue });
    nextEvaluatedData = set(point, evaluatedCell, nextEvaluatedData);
    try {
      for (var _e = __values(referenceGraph.getBackwardsRecursive(point)), _f = _e.next(); !_f.done; _f = _e.next()) {
        var referrer = _f.value;
        var referrerCell = get(referrer, data);
        if (!referrerCell) {
          continue;
        }
        var evaluatedValue_1 = isFormulaValue(referrerCell.value) ? getFormulaComputedValue(referrerCell.value, point, formulaParser) : referrerCell.value;
        var evaluatedCell_1 = __assign(__assign({}, referrerCell), { value: evaluatedValue_1 });
        nextEvaluatedData = set(referrer, evaluatedCell_1, nextEvaluatedData);
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
      } finally {
        if (e_2) throw e_2.error;
      }
    }
    return nextEvaluatedData;
  }
  function createReferenceGraph(data) {
    var e_3, _a;
    var entries$1 = [];
    try {
      for (var _b = __values(entries(data)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var _d = __read(_c.value, 2), point = _d[0], cell = _d[1];
        if (cell && isFormulaValue(cell.value)) {
          var references = getReferences(extractFormula(cell.value), point, data);
          entries$1.push([point, references]);
        }
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_3) throw e_3.error;
      }
    }
    return PointGraph.from(entries$1);
  }
  function createEvaluatedData(data, referenceGraph, createFormulaParser2) {
    var e_4, _a;
    var evaluatedData = data;
    var formulaParser = createFormulaParser2(evaluatedData);
    try {
      for (var _b = __values(referenceGraph.traverseBFSBackwards()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var point = _c.value;
        var cell = get(point, data);
        if (!cell) {
          continue;
        }
        if (isFormulaValue(cell.value)) {
          var evaluatedValue = getFormulaComputedValue(cell.value, point, formulaParser);
          evaluatedData = set(point, __assign(__assign({}, cell), { value: evaluatedValue }), evaluatedData);
          formulaParser = createFormulaParser2(evaluatedData);
        }
      }
    } catch (e_4_1) {
      e_4 = { error: e_4_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_4) throw e_4.error;
      }
    }
    return evaluatedData;
  }
  function getFormulaComputedValue(value, point, formulaParser) {
    var formula = extractFormula(value);
    try {
      return evaluate(formula, point, formulaParser);
    } catch (e) {
      return import_fast_formula_parser.FormulaError.REF;
    }
  }
  function reducer(state, action) {
    var _a, _b, e_1, _c, e_2, _d;
    switch (action.type) {
      case SET_DATA: {
        var data = action.payload.data;
        var nextActive = state.active && has2(state.active, data) ? state.active : null;
        var nextSelected = state.selected.normalizeTo(data);
        return __assign(__assign({}, state), { model: new Model(state.model.createFormulaParser, data), active: nextActive, selected: nextSelected });
      }
      case SET_CREATE_FORMULA_PARSER: {
        var createFormulaParser_1 = action.payload.createFormulaParser;
        return __assign(__assign({}, state), { model: new Model(createFormulaParser_1, state.model.data) });
      }
      case SELECT_ENTIRE_ROW: {
        var _e = action.payload, row = _e.row, extend = _e.extend;
        var active = state.active;
        return __assign(__assign({}, state), { selected: extend && active ? new EntireRowsSelection(active.row, row) : new EntireRowsSelection(row, row), active: extend && active ? active : __assign(__assign({}, ORIGIN), { row }), mode: "view" });
      }
      case SELECT_ENTIRE_COLUMN: {
        var _f = action.payload, column = _f.column, extend = _f.extend;
        var active = state.active;
        return __assign(__assign({}, state), { selected: extend && active ? new EntireColumnsSelection(active.column, column) : new EntireColumnsSelection(column, column), active: extend && active ? active : __assign(__assign({}, ORIGIN), { column }), mode: "view" });
      }
      case SELECT_ENTIRE_WORKSHEET: {
        return __assign(__assign({}, state), { selected: new EntireWorksheetSelection(), active: ORIGIN, mode: "view" });
      }
      case SET_SELECTION: {
        var selection = action.payload.selection;
        var range2 = selection.toRange(state.model.data);
        var active = state.active && selection.has(state.model.data, state.active) ? state.active : range2 === null || range2 === void 0 ? void 0 : range2.start;
        return __assign(__assign({}, state), { selected: selection, active: active || null, mode: "view" });
      }
      case SELECT: {
        var point = action.payload.point;
        if (state.active && !isActive(state.active, point)) {
          return __assign(__assign({}, state), { selected: new RangeSelection(new PointRange(point, state.active)), mode: "view" });
        }
        return state;
      }
      case ACTIVATE: {
        var point = action.payload.point;
        return __assign(__assign({}, state), { selected: new RangeSelection(new PointRange(point, point)), active: point, mode: isActive(state.active, point) ? "edit" : "view" });
      }
      case SET_CELL_DATA: {
        var _g = action.payload, active = _g.active, cellData = _g.data;
        if (isActiveReadOnly(state)) {
          return state;
        }
        return __assign(__assign({}, state), { model: updateCellValue(state.model, active, cellData), lastChanged: active });
      }
      case SET_CELL_DIMENSIONS: {
        var _h = action.payload, point = _h.point, dimensions = _h.dimensions;
        var prevRowDimensions = state.rowDimensions[point.row];
        var prevColumnDimensions = state.columnDimensions[point.column];
        if (prevRowDimensions && prevColumnDimensions && prevRowDimensions.top === dimensions.top && prevRowDimensions.height === dimensions.height && prevColumnDimensions.left === dimensions.left && prevColumnDimensions.width === dimensions.width) {
          return state;
        }
        return __assign(__assign({}, state), { rowDimensions: __assign(__assign({}, state.rowDimensions), (_a = {}, _a[point.row] = { top: dimensions.top, height: dimensions.height }, _a)), columnDimensions: __assign(__assign({}, state.columnDimensions), (_b = {}, _b[point.column] = { left: dimensions.left, width: dimensions.width }, _b)) });
      }
      case COPY:
      case CUT: {
        var selectedRange = state.selected.toRange(state.model.data);
        return __assign(__assign({}, state), { copied: selectedRange, cut: action.type === CUT, hasPasted: false });
      }
      case PASTE: {
        var text = action.payload.data;
        var active = state.active;
        if (!active) {
          return state;
        }
        var copied = split(text, function(value) {
          return { value };
        });
        var copiedSize = getSize(copied);
        var selectedRange = state.selected.toRange(state.model.data);
        if (selectedRange && copiedSize.rows === 1 && copiedSize.columns === 1) {
          var cell = get({ row: 0, column: 0 }, copied);
          var newData = state.cut && state.copied ? unset(state.copied.start, state.model.data) : state.model.data;
          var commit_1 = [];
          try {
            for (var _j = __values(selectedRange || []), _k = _j.next(); !_k.done; _k = _j.next()) {
              var point = _k.value;
              var currentCell = get(point, state.model.data);
              commit_1.push({
                prevCell: currentCell || null,
                nextCell: cell || null
              });
              newData = set(point, cell, newData);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return __assign(__assign({}, state), { model: new Model(createFormulaParser, newData), copied: null, cut: false, hasPasted: true, mode: "view", lastCommit: commit_1 });
        }
        var requiredSize = {
          rows: active.row + copiedSize.rows,
          columns: active.column + copiedSize.columns
        };
        var paddedData = pad(state.model.data, requiredSize);
        var acc = { data: paddedData, commit: [] };
        try {
          for (var _l = __values(entries(copied)), _m = _l.next(); !_m.done; _m = _l.next()) {
            var _o = __read(_m.value, 2), point = _o[0], cell = _o[1];
            var commit_2 = acc.commit || [];
            var nextPoint = {
              row: point.row + active.row,
              column: point.column + active.column
            };
            var nextData = acc.data;
            if (state.cut) {
              if (state.copied) {
                var prevPoint = {
                  row: point.row + state.copied.start.row,
                  column: point.column + state.copied.start.column
                };
                nextData = unset(prevPoint, acc.data);
              }
              commit_2 = __spreadArray(__spreadArray([], __read(commit_2), false), [{ prevCell: cell || null, nextCell: null }], false);
            }
            if (!has2(nextPoint, paddedData)) {
              acc = { data: nextData, commit: commit_2 };
            }
            var currentCell = get(nextPoint, nextData) || null;
            commit_2 = __spreadArray(__spreadArray([], __read(commit_2), false), [
              {
                prevCell: currentCell,
                nextCell: cell || null
              }
            ], false);
            acc.data = set(nextPoint, __assign(__assign({ value: void 0 }, currentCell), cell), nextData);
            acc.commit = commit_2;
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
        return __assign(__assign({}, state), { model: new Model(createFormulaParser, acc.data), selected: new RangeSelection(new PointRange(active, {
          row: active.row + copiedSize.rows - 1,
          column: active.column + copiedSize.columns - 1
        })), copied: null, cut: false, hasPasted: true, mode: "view", lastCommit: acc.commit });
      }
      case EDIT: {
        return edit(state);
      }
      case VIEW: {
        return view(state);
      }
      case CLEAR: {
        return clear(state);
      }
      case BLUR: {
        return blur(state);
      }
      case KEY_PRESS: {
        var event_1 = action.payload.event;
        if (isActiveReadOnly(state) || event_1.metaKey) {
          return state;
        }
        if (state.mode === "view" && state.active) {
          var selectedRange = state.selected.toRange(state.model.data);
          if ((selectedRange === null || selectedRange === void 0 ? void 0 : selectedRange.size()) === 1) {
            return edit(clear(state));
          }
          return edit(state);
        }
        return state;
      }
      case KEY_DOWN: {
        var event_2 = action.payload.event;
        var handler = getKeyDownHandler(state, event_2);
        if (handler) {
          return __assign(__assign({}, state), handler(state, event_2));
        }
        return state;
      }
      case DRAG_START: {
        return __assign(__assign({}, state), { dragging: true });
      }
      case DRAG_END: {
        return __assign(__assign({}, state), { dragging: false });
      }
      case COMMIT: {
        var changes = action.payload.changes;
        return __assign(__assign({}, state), commit(changes));
      }
      default:
        throw new Error("Unknown action");
    }
  }
  function edit(state) {
    if (isActiveReadOnly(state)) {
      return state;
    }
    return __assign(__assign({}, state), { mode: "edit" });
  }
  function clear(state) {
    var e_3, _a;
    if (!state.active) {
      return state;
    }
    var canClearCell = function(cell2) {
      return cell2 && !cell2.readOnly;
    };
    var clearCell = function(cell2) {
      if (!canClearCell(cell2)) {
        return cell2;
      }
      return Object.assign({}, cell2, { value: void 0 });
    };
    var selectedRange = state.selected.toRange(state.model.data);
    var changes = [];
    var newData = state.model.data;
    try {
      for (var _b = __values(selectedRange || []), _c = _b.next(); !_c.done; _c = _b.next()) {
        var point = _c.value;
        var cell = get(point, state.model.data);
        var clearedCell = clearCell(cell);
        changes.push({
          prevCell: cell || null,
          nextCell: clearedCell || null
        });
        newData = set(point, clearedCell, newData);
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_3) throw e_3.error;
      }
    }
    return __assign(__assign(__assign({}, state), { model: new Model(createFormulaParser, newData) }), commit(changes));
  }
  function blur(state) {
    return __assign(__assign({}, state), { active: null, selected: new EmptySelection() });
  }
  function view(state) {
    return __assign(__assign({}, state), { mode: "view" });
  }
  function commit(changes) {
    return { lastCommit: changes };
  }
  function getKeyDownHandler(state, event) {
    var key = event.key;
    var handlers;
    if (state.mode === "edit") {
      if (event.shiftKey) {
        handlers = editShiftKeyDownHandlers;
      } else {
        handlers = editKeyDownHandlers;
      }
    } else if (event.shiftKey && event.metaKey) {
      handlers = shiftMetaKeyDownHandlers;
    } else if (event.shiftKey) {
      handlers = shiftKeyDownHandlers;
    } else if (event.metaKey) {
      handlers = metaKeyDownHandlers;
    } else {
      handlers = keyDownHandlers;
    }
    return handlers[key];
  }
  function hasKeyDownHandler(state, event) {
    return getKeyDownHandler(state, event) !== void 0;
  }
  function isActiveReadOnly(state) {
    var activeCell = getActive(state);
    return Boolean(activeCell === null || activeCell === void 0 ? void 0 : activeCell.readOnly);
  }
  function getActive(state) {
    var activeCell = state.active && get(state.active, state.model.data);
    return activeCell || null;
  }
  function modifyEdge(selection, active, data, direction) {
    if (!active) {
      return selection;
    }
    if (selection instanceof RangeSelection) {
      var nextSelection = modifyRangeSelectionEdge(selection, active, data, direction);
      return nextSelection;
    }
    if (selection instanceof EntireColumnsSelection) {
      return modifyEntireColumnsSelection(selection, active, data, direction);
    }
    if (selection instanceof EntireRowsSelection) {
      return modifyEntireRowsSelection(selection, active, data, direction);
    }
    return selection;
  }
  function modifyRangeSelectionEdge(rangeSelection, active, data, edge) {
    var _a;
    var field = edge === Direction.Left || edge === Direction.Right ? "column" : "row";
    var key = edge === Direction.Left || edge === Direction.Top ? "start" : "end";
    var delta = key === "start" ? -1 : 1;
    var edgeOffsets = rangeSelection.range.has(__assign(__assign({}, active), (_a = {}, _a[field] = active[field] + delta * -1, _a)));
    var keyToModify = edgeOffsets ? key === "start" ? "end" : "start" : key;
    var nextRange = new PointRange(rangeSelection.range.start, rangeSelection.range.end);
    nextRange[keyToModify][field] += delta;
    var nextSelection = new RangeSelection(nextRange).normalizeTo(data);
    return nextSelection;
  }
  function modifyEntireRowsSelection(selection, active, data, edge) {
    if (edge === Direction.Left || edge === Direction.Right) {
      return selection;
    }
    var delta = edge === Direction.Top ? -1 : 1;
    var property = edge === Direction.Top ? "start" : "end";
    var oppositeProperty = property === "start" ? "end" : "start";
    var newSelectionData = __assign({}, selection);
    if (edge === Direction.Top ? selection.end > active.row : selection.start < active.row) {
      newSelectionData[oppositeProperty] = selection[oppositeProperty] + delta;
    } else {
      newSelectionData[property] = selection[property] + delta;
    }
    var nextSelection = new EntireRowsSelection(Math.max(newSelectionData.start, 0), Math.max(newSelectionData.end, 0));
    return nextSelection.normalizeTo(data);
  }
  function modifyEntireColumnsSelection(selection, active, data, edge) {
    if (edge === Direction.Top || edge === Direction.Bottom) {
      return selection;
    }
    var delta = edge === Direction.Left ? -1 : 1;
    var property = edge === Direction.Left ? "start" : "end";
    var oppositeProperty = property === "start" ? "end" : "start";
    var newSelectionData = __assign({}, selection);
    if (edge === Direction.Left ? selection.end > active.row : selection.start < active.row) {
      newSelectionData[oppositeProperty] = selection[oppositeProperty] + delta;
    } else {
      newSelectionData[property] = selection[property] + delta;
    }
    var nextSelection = new EntireColumnsSelection(Math.max(newSelectionData.start, 0), Math.max(newSelectionData.end, 0));
    return nextSelection.normalizeTo(data);
  }
  function useDispatch() {
    return useContextSelector(context, function(_a) {
      var _b = __read(_a, 2);
      _b[0];
      var dispatch = _b[1];
      return dispatch;
    });
  }
  function useSelector(selector) {
    return useContextSelector(context, function(_a) {
      var _b = __read(_a, 1), state = _b[0];
      return selector(state);
    });
  }
  function columnIndexToLabel(column) {
    var label = "";
    var index = column;
    while (index >= 0) {
      label = String.fromCharCode(65 + index % 26) + label;
      index = Math.floor(index / 26) - 1;
    }
    return label;
  }
  function getValue(cell, evaluatedCell) {
    var _a;
    var baseValue = (_a = evaluatedCell === null || evaluatedCell === void 0 ? void 0 : evaluatedCell.value) !== null && _a !== void 0 ? _a : cell === null || cell === void 0 ? void 0 : cell.value;
    if (baseValue && typeof baseValue === "object") {
      return baseValue.toString();
    }
    return baseValue;
  }
  function convertBooleanToText(value) {
    return value ? TRUE_TEXT : FALSE_TEXT;
  }
  function styleInject(css, ref) {
    if (ref === void 0) ref = {};
    var insertAt = ref.insertAt;
    if (!css || typeof document === "undefined") {
      return;
    }
    var head = document.head || document.getElementsByTagName("head")[0];
    var style2 = document.createElement("style");
    style2.type = "text/css";
    if (insertAt === "top") {
      if (head.firstChild) {
        head.insertBefore(style2, head.firstChild);
      } else {
        head.appendChild(style2);
      }
    } else {
      head.appendChild(style2);
    }
    if (style2.styleSheet) {
      style2.styleSheet.cssText = css;
    } else {
      style2.appendChild(document.createTextNode(css));
    }
  }
  var React, import_classnames, import_fast_formula_parser, extendStatics, __assign, SET_DATA, SET_CREATE_FORMULA_PARSER, SELECT_ENTIRE_ROW, SELECT_ENTIRE_COLUMN, SELECT_ENTIRE_WORKSHEET, SET_SELECTION, SELECT, ACTIVATE, SET_CELL_DATA, SET_CELL_DIMENSIONS, COPY, CUT, PASTE, EDIT, VIEW, CLEAR, BLUR, KEY_PRESS, KEY_DOWN, DRAG_START, DRAG_END, COMMIT, PointRange, ORIGIN, Selection, EmptySelection, RangeSelection, EntireSelection, EntireWorksheetSelection, EntireAxisSelection, EntireRowsSelection, EntireColumnsSelection, InvalidIndexError, PLAIN_TEXT_MIME, FOCUS_WITHIN_SELECTOR, PointSet, FORMULA_VALUE_PREFIX, depParser, PointGraph, Model, INITIAL_STATE, go, keyDownHandlers, editKeyDownHandlers, editShiftKeyDownHandlers, Direction, shiftKeyDownHandlers, shiftMetaKeyDownHandlers, metaKeyDownHandlers, context, Table, Row, HeaderRow, CornerIndicator, enhance$3, ColumnIndicator, enhance$2, RowIndicator, enhance$1, Cell, enhance, TRUE_TEXT, FALSE_TEXT, DataViewer, DataEditor, ActiveCell, FloatingRect, Selected, Copied, css_248z, Spreadsheet, Spreadsheet$1;
  var init_es = __esm({
    "node_modules/react-spreadsheet/dist/es/index.js"() {
      React = __toESM(require_react());
      import_classnames = __toESM(require_classnames());
      import_fast_formula_parser = __toESM(require_fast_formula_parser());
      init_dist();
      extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      __assign = function() {
        __assign = Object.assign || function __assign2(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      SET_DATA = "SET_DATA";
      SET_CREATE_FORMULA_PARSER = "SET_CREATE_FORMULA_PARSER";
      SELECT_ENTIRE_ROW = "SELECT_ENTIRE_ROW";
      SELECT_ENTIRE_COLUMN = "SELECT_ENTIRE_COLUMN";
      SELECT_ENTIRE_WORKSHEET = "SELECT_ENTIRE_WORKSHEET";
      SET_SELECTION = "SET_SELECTION";
      SELECT = "SELECT";
      ACTIVATE = "ACTIVATE";
      SET_CELL_DATA = "SET_CELL_DATA";
      SET_CELL_DIMENSIONS = "SET_CELL_DIMENSIONS";
      COPY = "COPY";
      CUT = "CUT";
      PASTE = "PASTE";
      EDIT = "EDIT";
      VIEW = "VIEW";
      CLEAR = "CLEAR";
      BLUR = "BLUR";
      KEY_PRESS = "KEY_PRESS";
      KEY_DOWN = "KEY_DOWN";
      DRAG_START = "DRAG_START";
      DRAG_END = "DRAG_END";
      COMMIT = "COMMIT";
      PointRange = /** @class */
      (function() {
        function PointRange2(source, target) {
          this.start = {
            row: Math.min(source.row, target.row),
            column: Math.min(source.column, target.column)
          };
          this.end = {
            row: Math.max(source.row, target.row),
            column: Math.max(source.column, target.column)
          };
        }
        PointRange2.prototype[Symbol.iterator] = function() {
          var row, column;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                row = this.start.row;
                _a.label = 1;
              case 1:
                if (!(row <= this.end.row)) return [3, 6];
                column = this.start.column;
                _a.label = 2;
              case 2:
                if (!(column <= this.end.column)) return [3, 5];
                return [4, { row, column }];
              case 3:
                _a.sent();
                _a.label = 4;
              case 4:
                column++;
                return [3, 2];
              case 5:
                row++;
                return [3, 1];
              case 6:
                return [
                  2
                  /*return*/
                ];
            }
          });
        };
        PointRange2.prototype.size = function() {
          var rows = this.end.row + 1 - this.start.row;
          var columns = this.end.column + 1 - this.start.column;
          return rows * columns;
        };
        PointRange2.prototype.has = function(point) {
          return point.row >= this.start.row && point.column >= this.start.column && point.row <= this.end.row && point.column <= this.end.column;
        };
        PointRange2.prototype.mask = function(mask) {
          return new PointRange2({
            row: mask.start.row > this.start.row ? mask.start.row : this.start.row,
            column: mask.start.column > this.start.column ? mask.start.column : this.start.column
          }, {
            row: mask.end.row < this.end.row ? mask.end.row : this.end.row,
            column: mask.end.column < this.end.column ? mask.end.column : this.end.column
          });
        };
        PointRange2.prototype.equals = function(range2) {
          return this.start.row === range2.start.row && this.start.column === range2.start.column && this.end.row === range2.end.row && this.end.column === range2.end.column;
        };
        return PointRange2;
      })();
      ORIGIN = { row: 0, column: 0 };
      Selection = /** @class */
      /* @__PURE__ */ (function() {
        function Selection2() {
        }
        return Selection2;
      })();
      EmptySelection = /** @class */
      (function(_super) {
        __extends(EmptySelection2, _super);
        function EmptySelection2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        EmptySelection2.prototype.toRange = function(data) {
          return null;
        };
        EmptySelection2.prototype.normalizeTo = function(data) {
          return this;
        };
        EmptySelection2.prototype.hasEntireRow = function(row) {
          return false;
        };
        EmptySelection2.prototype.hasEntireColumn = function(column) {
          return false;
        };
        EmptySelection2.prototype.size = function() {
          return 0;
        };
        EmptySelection2.prototype.has = function() {
          return false;
        };
        EmptySelection2.prototype.equals = function(selection) {
          return selection instanceof EmptySelection2;
        };
        return EmptySelection2;
      })(Selection);
      RangeSelection = /** @class */
      (function(_super) {
        __extends(RangeSelection2, _super);
        function RangeSelection2(range2) {
          var _this = _super.call(this) || this;
          _this.range = range2;
          return _this;
        }
        RangeSelection2.prototype.toRange = function(data) {
          return this.range;
        };
        RangeSelection2.prototype.normalizeTo = function(data) {
          var dataRange = getMatrixRange(data);
          var nextSelection = new RangeSelection2(this.range.mask(dataRange));
          return nextSelection;
        };
        RangeSelection2.prototype.hasEntireRow = function(row) {
          return false;
        };
        RangeSelection2.prototype.hasEntireColumn = function(column) {
          return false;
        };
        RangeSelection2.prototype.size = function(data) {
          var range2 = this.toRange(data);
          return range2 ? range2.size() : 0;
        };
        RangeSelection2.prototype.has = function(data, point) {
          var range2 = this.toRange(data);
          return range2 !== null && range2.has(point);
        };
        RangeSelection2.prototype.equals = function(selection) {
          return selection instanceof RangeSelection2 && this.range.equals(selection.range);
        };
        return RangeSelection2;
      })(Selection);
      EntireSelection = /** @class */
      (function(_super) {
        __extends(EntireSelection2, _super);
        function EntireSelection2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return EntireSelection2;
      })(Selection);
      EntireWorksheetSelection = /** @class */
      (function(_super) {
        __extends(EntireWorksheetSelection2, _super);
        function EntireWorksheetSelection2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        EntireWorksheetSelection2.prototype.toRange = function(data) {
          return getMatrixRange(data);
        };
        EntireWorksheetSelection2.prototype.normalizeTo = function(data) {
          return this;
        };
        EntireWorksheetSelection2.prototype.hasEntireColumn = function(column) {
          return true;
        };
        EntireWorksheetSelection2.prototype.hasEntireRow = function(row) {
          return true;
        };
        EntireWorksheetSelection2.prototype.size = function(data) {
          return getColumnsCount(data) * getRowsCount(data);
        };
        EntireWorksheetSelection2.prototype.has = function(data, point) {
          return true;
        };
        EntireWorksheetSelection2.prototype.equals = function(selection) {
          return selection instanceof EntireWorksheetSelection2;
        };
        return EntireWorksheetSelection2;
      })(EntireSelection);
      EntireAxisSelection = /** @class */
      (function(_super) {
        __extends(EntireAxisSelection2, _super);
        function EntireAxisSelection2(start, end) {
          var _this = this;
          if (!isIndex(start)) {
            throw new InvalidIndexError("start");
          }
          if (!isIndex(end)) {
            throw new InvalidIndexError("end");
          }
          _this = _super.call(this) || this;
          _this.start = Math.min(start, end);
          _this.end = Math.max(start, end);
          return _this;
        }
        EntireAxisSelection2.prototype.equals = function(selection) {
          return selection instanceof EntireAxisSelection2 && this.constructor === selection.constructor && this.start === selection.start && this.end === selection.end;
        };
        return EntireAxisSelection2;
      })(EntireSelection);
      EntireRowsSelection = /** @class */
      (function(_super) {
        __extends(EntireRowsSelection2, _super);
        function EntireRowsSelection2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        EntireRowsSelection2.prototype.toRange = function(data) {
          var max = maxPoint(data);
          return new PointRange({ row: this.start, column: 0 }, { row: this.end, column: max.column });
        };
        EntireRowsSelection2.prototype.normalizeTo = function(data) {
          var count = getRowsCount(data);
          var nextSelection = new EntireRowsSelection2(Math.max(this.start, 0), Math.min(this.end, count - 1));
          return nextSelection;
        };
        EntireRowsSelection2.prototype.hasEntireRow = function(row) {
          return row >= this.start && row <= this.end;
        };
        EntireRowsSelection2.prototype.hasEntireColumn = function(column) {
          return false;
        };
        EntireRowsSelection2.prototype.size = function(data) {
          var rows = this.end - this.start + 1;
          return rows * getColumnsCount(data);
        };
        EntireRowsSelection2.prototype.has = function(data, point) {
          return point.row >= this.start && point.row <= this.end;
        };
        return EntireRowsSelection2;
      })(EntireAxisSelection);
      EntireColumnsSelection = /** @class */
      (function(_super) {
        __extends(EntireColumnsSelection2, _super);
        function EntireColumnsSelection2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        EntireColumnsSelection2.prototype.toRange = function(data) {
          var max = maxPoint(data);
          return new PointRange({ row: 0, column: this.start }, { row: max.row, column: this.end });
        };
        EntireColumnsSelection2.prototype.normalizeTo = function(data) {
          var count = getColumnsCount(data);
          var nextSelection = new EntireColumnsSelection2(Math.max(this.start, 0), Math.min(this.end, count - 1));
          return nextSelection;
        };
        EntireColumnsSelection2.prototype.hasEntireRow = function(row) {
          return false;
        };
        EntireColumnsSelection2.prototype.hasEntireColumn = function(column) {
          return column >= this.start && column <= this.end;
        };
        EntireColumnsSelection2.prototype.size = function(data) {
          var columns = this.end - this.start + 1;
          return columns * getRowsCount(data);
        };
        EntireColumnsSelection2.prototype.has = function(data, point) {
          return point.column >= this.start && point.column <= this.end;
        };
        return EntireColumnsSelection2;
      })(EntireAxisSelection);
      InvalidIndexError = /** @class */
      (function(_super) {
        __extends(InvalidIndexError2, _super);
        function InvalidIndexError2(name) {
          return _super.call(this, "".concat(name, " is not a valid index. It must be 0 or a positive integer")) || this;
        }
        return InvalidIndexError2;
      })(Error);
      PLAIN_TEXT_MIME = "text/plain";
      FOCUS_WITHIN_SELECTOR = ":focus-within";
      PointSet = /** @class */
      (function() {
        function PointSet2(set2) {
          this.set = set2;
        }
        PointSet2.from = function(points) {
          var e_1, _a;
          var set2 = /* @__PURE__ */ new Set();
          try {
            for (var points_1 = __values(points), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
              var point = points_1_1.value;
              set2.add(toString(point));
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (points_1_1 && !points_1_1.done && (_a = points_1.return)) _a.call(points_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return new PointSet2(set2);
        };
        PointSet2.prototype.has = function(point) {
          return this.set.has(toString(point));
        };
        Object.defineProperty(PointSet2.prototype, "size", {
          /** Returns the number of points in a PointSet object */
          get: function() {
            return this.set.size;
          },
          enumerable: false,
          configurable: true
        });
        PointSet2.prototype.add = function(point) {
          var newSet = new Set(this.set);
          newSet.add(toString(point));
          return new PointSet2(newSet);
        };
        PointSet2.prototype.delete = function(point) {
          var newSet = new Set(this.set);
          if (!newSet.delete(toString(point))) {
            return this;
          }
          return new PointSet2(newSet);
        };
        PointSet2.prototype.difference = function(other) {
          var e_2, _a;
          var newSet = this;
          try {
            for (var other_1 = __values(other), other_1_1 = other_1.next(); !other_1_1.done; other_1_1 = other_1.next()) {
              var point = other_1_1.value;
              newSet = newSet.delete(point);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (other_1_1 && !other_1_1.done && (_a = other_1.return)) _a.call(other_1);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
          return newSet;
        };
        PointSet2.prototype.union = function(other) {
          var e_3, _a;
          var newSet = this;
          try {
            for (var other_2 = __values(other), other_2_1 = other_2.next(); !other_2_1.done; other_2_1 = other_2.next()) {
              var point = other_2_1.value;
              newSet = newSet.add(point);
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (other_2_1 && !other_2_1.done && (_a = other_2.return)) _a.call(other_2);
            } finally {
              if (e_3) throw e_3.error;
            }
          }
          return newSet;
        };
        PointSet2.prototype[Symbol.iterator] = function() {
          var _a, _b, value, e_4_1;
          var e_4, _c;
          return __generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                _d.trys.push([0, 5, 6, 7]);
                _a = __values(this.set), _b = _a.next();
                _d.label = 1;
              case 1:
                if (!!_b.done) return [3, 4];
                value = _b.value;
                return [4, fromString(value)];
              case 2:
                _d.sent();
                _d.label = 3;
              case 3:
                _b = _a.next();
                return [3, 1];
              case 4:
                return [3, 7];
              case 5:
                e_4_1 = _d.sent();
                e_4 = { error: e_4_1 };
                return [3, 7];
              case 6:
                try {
                  if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                } finally {
                  if (e_4) throw e_4.error;
                }
                return [
                  7
                  /*endfinally*/
                ];
              case 7:
                return [
                  2
                  /*return*/
                ];
            }
          });
        };
        return PointSet2;
      })();
      FORMULA_VALUE_PREFIX = "=";
      depParser = new import_fast_formula_parser.DepParser();
      PointGraph = /** @class */
      (function() {
        function PointGraph2(forwards) {
          if (forwards === void 0) {
            forwards = /* @__PURE__ */ new Map();
          }
          this.forwards = forwards;
        }
        PointGraph2.from = function(pairs) {
          var e_1, _a;
          var forwards = /* @__PURE__ */ new Map();
          try {
            for (var pairs_1 = __values(pairs), pairs_1_1 = pairs_1.next(); !pairs_1_1.done; pairs_1_1 = pairs_1.next()) {
              var _b = __read(pairs_1_1.value, 2), node = _b[0], edges = _b[1];
              forwards.set(toString(node), edges);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (pairs_1_1 && !pairs_1_1.done && (_a = pairs_1.return)) _a.call(pairs_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return new PointGraph2(forwards);
        };
        PointGraph2.prototype.set = function(node, edges) {
          var newGraph = new PointGraph2(new Map(this.forwards));
          if (edges.size === 0) {
            newGraph.forwards.delete(toString(node));
            return newGraph;
          }
          newGraph.forwards.set(toString(node), edges);
          return newGraph;
        };
        PointGraph2.prototype.get = function(node) {
          return this.forwards.get(toString(node)) || PointSet.from([]);
        };
        PointGraph2.prototype.getBackwards = function(node) {
          var e_2, _a;
          var result = PointSet.from([]);
          try {
            for (var _b = __values(this.forwards), _c = _b.next(); !_c.done; _c = _b.next()) {
              var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
              if (value.has(node)) {
                result = result.add(fromString(key));
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
          return result;
        };
        PointGraph2.prototype.getBackwardsRecursive = function(node, visited) {
          var e_3, _a;
          if (visited === void 0) {
            visited = PointSet.from([]);
          }
          var result = this.getBackwards(node);
          var newVisited = visited;
          try {
            for (var result_1 = __values(result), result_1_1 = result_1.next(); !result_1_1.done; result_1_1 = result_1.next()) {
              var point = result_1_1.value;
              if (newVisited.has(point)) {
                continue;
              }
              newVisited = newVisited.add(point);
              result = result.union(this.getBackwardsRecursive(point, newVisited));
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (result_1_1 && !result_1_1.done && (_a = result_1.return)) _a.call(result_1);
            } finally {
              if (e_3) throw e_3.error;
            }
          }
          return result;
        };
        PointGraph2.prototype.hasCircularDependency = function(startPoint) {
          var e_4, _a;
          var visited = PointSet.from([]);
          var stack = [startPoint];
          while (stack.length > 0) {
            var current = stack.pop();
            if (!current) {
              continue;
            }
            if (visited.has(current)) {
              return true;
            }
            visited = visited.add(current);
            var dependents = this.get(current);
            if (!dependents) {
              continue;
            }
            try {
              for (var dependents_1 = (e_4 = void 0, __values(dependents)), dependents_1_1 = dependents_1.next(); !dependents_1_1.done; dependents_1_1 = dependents_1.next()) {
                var dependent = dependents_1_1.value;
                stack.push(dependent);
              }
            } catch (e_4_1) {
              e_4 = { error: e_4_1 };
            } finally {
              try {
                if (dependents_1_1 && !dependents_1_1.done && (_a = dependents_1.return)) _a.call(dependents_1);
              } finally {
                if (e_4) throw e_4.error;
              }
            }
          }
          return false;
        };
        PointGraph2.prototype[Symbol.iterator] = function() {
          var visitedHashes, _a, _b, _c, key, values2, point, values_1, values_1_1, value, hash, e_5_1, e_6_1;
          var e_6, _d, e_5, _e;
          return __generator(this, function(_f) {
            switch (_f.label) {
              case 0:
                visitedHashes = /* @__PURE__ */ new Set();
                _f.label = 1;
              case 1:
                _f.trys.push([1, 13, 14, 15]);
                _a = __values(this.forwards), _b = _a.next();
                _f.label = 2;
              case 2:
                if (!!_b.done) return [3, 12];
                _c = __read(_b.value, 2), key = _c[0], values2 = _c[1];
                point = fromString(key);
                visitedHashes.add(key);
                return [4, [point, values2]];
              case 3:
                _f.sent();
                _f.label = 4;
              case 4:
                _f.trys.push([4, 9, 10, 11]);
                values_1 = (e_5 = void 0, __values(values2)), values_1_1 = values_1.next();
                _f.label = 5;
              case 5:
                if (!!values_1_1.done) return [3, 8];
                value = values_1_1.value;
                hash = toString(value);
                if (!(!visitedHashes.has(hash) && !this.forwards.has(hash))) return [3, 7];
                visitedHashes.add(hash);
                return [4, [value, PointSet.from([])]];
              case 6:
                _f.sent();
                _f.label = 7;
              case 7:
                values_1_1 = values_1.next();
                return [3, 5];
              case 8:
                return [3, 11];
              case 9:
                e_5_1 = _f.sent();
                e_5 = { error: e_5_1 };
                return [3, 11];
              case 10:
                try {
                  if (values_1_1 && !values_1_1.done && (_e = values_1.return)) _e.call(values_1);
                } finally {
                  if (e_5) throw e_5.error;
                }
                return [
                  7
                  /*endfinally*/
                ];
              case 11:
                _b = _a.next();
                return [3, 2];
              case 12:
                return [3, 15];
              case 13:
                e_6_1 = _f.sent();
                e_6 = { error: e_6_1 };
                return [3, 15];
              case 14:
                try {
                  if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                } finally {
                  if (e_6) throw e_6.error;
                }
                return [
                  7
                  /*endfinally*/
                ];
              case 15:
                return [
                  2
                  /*return*/
                ];
            }
          });
        };
        PointGraph2.prototype.traverseBFSBackwards = function() {
          var visited, queue, _a, _b, _c, point, values2, point, dependents, dependents_2, dependents_2_1, dependent;
          var e_7, _d, e_8, _e;
          return __generator(this, function(_f) {
            switch (_f.label) {
              case 0:
                visited = PointSet.from([]);
                queue = [];
                try {
                  for (_a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                    _c = __read(_b.value, 2), point = _c[0], values2 = _c[1];
                    if (values2.size === 0) {
                      visited = visited.add(point);
                      queue.push(point);
                    }
                  }
                } catch (e_7_1) {
                  e_7 = { error: e_7_1 };
                } finally {
                  try {
                    if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                  } finally {
                    if (e_7) throw e_7.error;
                  }
                }
                _f.label = 1;
              case 1:
                if (!(queue.length > 0)) return [3, 3];
                point = queue.shift();
                if (!point) {
                  return [3, 1];
                }
                return [4, point];
              case 2:
                _f.sent();
                dependents = this.getBackwards(point);
                if (dependents.size === 0) {
                  return [3, 1];
                }
                try {
                  for (dependents_2 = (e_8 = void 0, __values(dependents)), dependents_2_1 = dependents_2.next(); !dependents_2_1.done; dependents_2_1 = dependents_2.next()) {
                    dependent = dependents_2_1.value;
                    if (!visited.has(dependent) && this.get(dependent).difference(visited).size === 0) {
                      queue.push(dependent);
                      visited = visited.add(dependent);
                    }
                  }
                } catch (e_8_1) {
                  e_8 = { error: e_8_1 };
                } finally {
                  try {
                    if (dependents_2_1 && !dependents_2_1.done && (_e = dependents_2.return)) _e.call(dependents_2);
                  } finally {
                    if (e_8) throw e_8.error;
                  }
                }
                return [3, 1];
              case 3:
                return [
                  2
                  /*return*/
                ];
            }
          });
        };
        return PointGraph2;
      })();
      Model = /** @class */
      /* @__PURE__ */ (function() {
        function Model2(createFormulaParser2, data, referenceGraph, evaluatedData) {
          this.createFormulaParser = createFormulaParser2;
          this.data = data;
          this.referenceGraph = referenceGraph || createReferenceGraph(data);
          this.evaluatedData = evaluatedData || createEvaluatedData(data, this.referenceGraph, this.createFormulaParser);
        }
        return Model2;
      })();
      INITIAL_STATE = {
        active: null,
        mode: "view",
        rowDimensions: {},
        columnDimensions: {},
        lastChanged: null,
        hasPasted: false,
        cut: false,
        dragging: false,
        model: new Model(createFormulaParser, []),
        selected: new EmptySelection(),
        copied: null,
        lastCommit: null
      };
      go = function(rowDelta, columnDelta) {
        return function(state) {
          if (!state.active) {
            return;
          }
          var size = getSize(state.model.data);
          var newColumn = state.active.column + columnDelta;
          var shouldWrap = newColumn >= size.columns;
          var nextActive = {
            row: state.active.row + rowDelta + (shouldWrap ? 1 : 0),
            column: (state.active.column + columnDelta) % size.columns
          };
          if (!has2(nextActive, state.model.data)) {
            return __assign(__assign({}, state), { mode: "view" });
          }
          return __assign(__assign({}, state), { active: nextActive, selected: new RangeSelection(new PointRange(nextActive, nextActive)), mode: "view" });
        };
      };
      keyDownHandlers = {
        ArrowUp: go(-1, 0),
        ArrowDown: go(1, 0),
        ArrowLeft: go(0, -1),
        ArrowRight: go(0, 1),
        Tab: go(0, 1),
        Enter: edit,
        Backspace: clear,
        Delete: clear,
        Escape: blur
      };
      editKeyDownHandlers = {
        Escape: view,
        Tab: keyDownHandlers.Tab,
        Enter: keyDownHandlers.ArrowDown
      };
      editShiftKeyDownHandlers = {
        Tab: go(0, -1)
      };
      (function(Direction2) {
        Direction2["Left"] = "Left";
        Direction2["Right"] = "Right";
        Direction2["Top"] = "Top";
        Direction2["Bottom"] = "Bottom";
      })(Direction || (Direction = {}));
      shiftKeyDownHandlers = {
        ArrowUp: function(state) {
          return __assign(__assign({}, state), { selected: modifyEdge(state.selected, state.active, state.model.data, Direction.Top) });
        },
        ArrowDown: function(state) {
          return __assign(__assign({}, state), { selected: modifyEdge(state.selected, state.active, state.model.data, Direction.Bottom) });
        },
        ArrowLeft: function(state) {
          return __assign(__assign({}, state), { selected: modifyEdge(state.selected, state.active, state.model.data, Direction.Left) });
        },
        ArrowRight: function(state) {
          return __assign(__assign({}, state), { selected: modifyEdge(state.selected, state.active, state.model.data, Direction.Right) });
        },
        Tab: go(0, -1)
      };
      shiftMetaKeyDownHandlers = {};
      metaKeyDownHandlers = {};
      context = createContext([INITIAL_STATE, function() {
      }]);
      Table = function(_a) {
        var children = _a.children, columns = _a.columns, hideColumnIndicators = _a.hideColumnIndicators;
        var columnCount = columns + (hideColumnIndicators ? 0 : 1);
        var columnNodes = range(columnCount).map(function(i) {
          return React.createElement("col", { key: i });
        });
        return React.createElement(
          "table",
          { className: "Spreadsheet__table" },
          React.createElement("colgroup", null, columnNodes),
          React.createElement("tbody", null, children)
        );
      };
      Row = function(props) {
        return React.createElement("tr", __assign({}, props));
      };
      HeaderRow = function(props) {
        return React.createElement("tr", __assign({}, props));
      };
      CornerIndicator = function(_a) {
        var selected = _a.selected, onSelect = _a.onSelect;
        var handleClick = React.useCallback(function() {
          onSelect();
        }, [onSelect]);
        return React.createElement("th", { className: (0, import_classnames.default)("Spreadsheet__header", {
          "Spreadsheet__header--selected": selected
        }), onClick: handleClick, tabIndex: 0 });
      };
      enhance$3 = function(CornerIndicatorComponent) {
        return function CornerIndicatorWrapper(props) {
          var dispatch = useDispatch();
          var selectEntireWorksheet$1 = React.useCallback(function() {
            return dispatch(selectEntireWorksheet());
          }, [dispatch]);
          var selected = useSelector(function(state) {
            return state.selected instanceof EntireWorksheetSelection;
          });
          return React.createElement(CornerIndicatorComponent, __assign({}, props, { selected, onSelect: selectEntireWorksheet$1 }));
        };
      };
      ColumnIndicator = function(_a) {
        var column = _a.column, label = _a.label, selected = _a.selected, onSelect = _a.onSelect;
        var handleClick = React.useCallback(function(event) {
          onSelect(column, event.shiftKey);
        }, [onSelect, column]);
        return React.createElement("th", { className: (0, import_classnames.default)("Spreadsheet__header", {
          "Spreadsheet__header--selected": selected
        }), onClick: handleClick, tabIndex: 0 }, label !== void 0 ? label : columnIndexToLabel(column));
      };
      enhance$2 = function(ColumnIndicatorComponent) {
        return function ColumnIndicatorWrapper(props) {
          var dispatch = useDispatch();
          var selectEntireColumn$1 = React.useCallback(function(column, extend) {
            return dispatch(selectEntireColumn(column, extend));
          }, [dispatch]);
          var selected = useSelector(function(state) {
            return state.selected.hasEntireColumn(props.column);
          });
          return React.createElement(ColumnIndicatorComponent, __assign({}, props, { selected, onSelect: selectEntireColumn$1 }));
        };
      };
      RowIndicator = function(_a) {
        var row = _a.row, label = _a.label, selected = _a.selected, onSelect = _a.onSelect;
        var handleClick = React.useCallback(function(event) {
          onSelect(row, event.shiftKey);
        }, [onSelect, row]);
        return React.createElement("th", { className: (0, import_classnames.default)("Spreadsheet__header", {
          "Spreadsheet__header--selected": selected
        }), onClick: handleClick, tabIndex: 0 }, label !== void 0 ? label : row + 1);
      };
      enhance$1 = function(RowIndicatorComponent) {
        return function RowIndicatorWrapper(props) {
          var dispatch = useDispatch();
          var selected = useSelector(function(state) {
            return state.selected.hasEntireRow(props.row);
          });
          var selectEntireRow$1 = React.useCallback(function(row, extend) {
            return dispatch(selectEntireRow(row, extend));
          }, [dispatch]);
          return React.createElement(RowIndicatorComponent, __assign({}, props, { selected, onSelect: selectEntireRow$1 }));
        };
      };
      Cell = function(_a) {
        var row = _a.row, column = _a.column, DataViewer2 = _a.DataViewer, selected = _a.selected, active = _a.active, dragging = _a.dragging, mode = _a.mode, data = _a.data, evaluatedData = _a.evaluatedData, select2 = _a.select, activate2 = _a.activate, setCellDimensions2 = _a.setCellDimensions, setCellData2 = _a.setCellData;
        var rootRef = React.useRef(null);
        var point = React.useMemo(function() {
          return {
            row,
            column
          };
        }, [row, column]);
        var handleMouseDown = React.useCallback(function(event) {
          if (mode === "view") {
            setCellDimensions2(point, getOffsetRect(event.currentTarget));
            if (event.shiftKey) {
              select2(point);
            } else {
              activate2(point);
            }
          }
        }, [mode, setCellDimensions2, point, select2, activate2]);
        var handleMouseOver = React.useCallback(function(event) {
          if (dragging) {
            setCellDimensions2(point, getOffsetRect(event.currentTarget));
            select2(point);
          }
        }, [setCellDimensions2, select2, dragging, point]);
        React.useEffect(function() {
          var root = rootRef.current;
          if (selected && root) {
            setCellDimensions2(point, getOffsetRect(root));
          }
          if (root && active && mode === "view") {
            root.focus();
          }
        }, [setCellDimensions2, selected, active, mode, point, data]);
        if (data && data.DataViewer) {
          DataViewer2 = data.DataViewer;
        }
        return React.createElement(
          "td",
          { ref: rootRef, className: (0, import_classnames.default)("Spreadsheet__cell", data === null || data === void 0 ? void 0 : data.className, {
            "Spreadsheet__cell--readonly": data === null || data === void 0 ? void 0 : data.readOnly
          }), onMouseOver: handleMouseOver, onMouseDown: handleMouseDown, tabIndex: 0 },
          React.createElement(DataViewer2, { row, column, cell: data, evaluatedCell: evaluatedData, setCellData: setCellData2 })
        );
      };
      enhance = function(CellComponent) {
        return function CellWrapper(props) {
          var row = props.row, column = props.column;
          var dispatch = useDispatch();
          var point = React.useMemo(function() {
            return {
              row,
              column
            };
          }, [row, column]);
          var setCellData$1 = React.useCallback(function(data2) {
            return dispatch(setCellData(point, data2));
          }, [dispatch, point]);
          var select$1 = React.useCallback(function(point2) {
            return dispatch(select(point2));
          }, [dispatch]);
          var activate$1 = React.useCallback(function(point2) {
            return dispatch(activate(point2));
          }, [dispatch]);
          var setCellDimensions$1 = React.useCallback(function(point2, dimensions) {
            return dispatch(setCellDimensions(point2, dimensions));
          }, [dispatch]);
          var active = useSelector(function(state) {
            return isActive(state.active, point);
          });
          var mode = useSelector(function(state) {
            return active ? state.mode : "view";
          });
          var data = useSelector(function(state) {
            return get(point, state.model.data);
          });
          var evaluatedData = useSelector(function(state) {
            return get(point, state.model.evaluatedData);
          });
          var selected = useSelector(function(state) {
            return state.selected.has(state.model.data, point);
          });
          var dragging = useSelector(function(state) {
            return state.dragging;
          });
          var copied = useSelector(function(state) {
            var _a;
            return ((_a = state.copied) === null || _a === void 0 ? void 0 : _a.has(point)) || false;
          });
          return React.createElement(CellComponent, __assign({}, props, { selected, active, copied, dragging, mode, evaluatedData, data, select: select$1, activate: activate$1, setCellDimensions: setCellDimensions$1, setCellData: setCellData$1 }));
        };
      };
      TRUE_TEXT = "TRUE";
      FALSE_TEXT = "FALSE";
      DataViewer = function(_a) {
        var cell = _a.cell, evaluatedCell = _a.evaluatedCell;
        var value = getValue(cell, evaluatedCell);
        return typeof value === "boolean" ? React.createElement("span", { className: "Spreadsheet__data-viewer Spreadsheet__data-viewer--boolean" }, convertBooleanToText(value)) : React.createElement("span", { className: (0, import_classnames.default)("Spreadsheet__data-viewer", {
          "Spreadsheet__data-viewer--preserve-breaks": hasLineBreaker(value)
        }) }, value);
      };
      DataEditor = function(_a) {
        var _b;
        var onChange = _a.onChange, cell = _a.cell;
        var inputRef = React.useRef(null);
        var handleChange = React.useCallback(function(event) {
          onChange(__assign(__assign({}, cell), { value: event.target.value }));
        }, [onChange, cell]);
        React.useEffect(function() {
          if (inputRef.current) {
            moveCursorToEnd(inputRef.current);
          }
        }, [inputRef]);
        var value = (_b = cell === null || cell === void 0 ? void 0 : cell.value) !== null && _b !== void 0 ? _b : "";
        return React.createElement(
          "div",
          { className: "Spreadsheet__data-editor" },
          React.createElement("input", { ref: inputRef, type: "text", onChange: handleChange, value, autoFocus: true })
        );
      };
      ActiveCell = function(props) {
        var rootRef = React.useRef(null);
        var dispatch = useDispatch();
        var setCellData$1 = React.useCallback(function(active2, data) {
          return dispatch(setCellData(active2, data));
        }, [dispatch]);
        var edit2 = React.useCallback(function() {
          return dispatch(edit$1());
        }, [dispatch]);
        var commit2 = React.useCallback(function(changes) {
          return dispatch(commit$1(changes));
        }, [dispatch]);
        var view2 = React.useCallback(function() {
          dispatch(view$1());
        }, [dispatch]);
        var active = useSelector(function(state) {
          return state.active;
        });
        var mode = useSelector(function(state) {
          return state.mode;
        });
        var cell = useSelector(function(state) {
          return state.active ? get(state.active, state.model.data) : void 0;
        });
        var dimensions = useSelector(function(state) {
          return active ? getCellDimensions(active, state.rowDimensions, state.columnDimensions) : void 0;
        });
        var hidden = React.useMemo(function() {
          return !active || !dimensions;
        }, [active, dimensions]);
        var initialCellRef = React.useRef(void 0);
        var prevActiveRef = React.useRef(null);
        var prevCellRef = React.useRef(void 0);
        var handleChange = React.useCallback(function(cell2) {
          if (!active) {
            return;
          }
          setCellData$1(active, cell2);
        }, [setCellData$1, active]);
        React.useEffect(function() {
          var root = rootRef.current;
          if (!hidden && root) {
            root.focus();
          }
        }, [rootRef, hidden]);
        React.useEffect(function() {
          var prevActive = prevActiveRef.current;
          var prevCell = prevCellRef.current;
          prevActiveRef.current = active;
          prevCellRef.current = cell;
          if (!prevActive || !prevCell) {
            return;
          }
          var coordsChanged = (active === null || active === void 0 ? void 0 : active.row) !== prevActive.row || (active === null || active === void 0 ? void 0 : active.column) !== prevActive.column;
          var exitedEditMode = mode !== "edit";
          if (coordsChanged || exitedEditMode) {
            var initialCell = initialCellRef.current;
            if (prevCell !== initialCell) {
              commit2([
                {
                  prevCell: initialCell || null,
                  nextCell: prevCell
                }
              ]);
            } else if (!coordsChanged && cell !== prevCell) {
              commit2([
                {
                  prevCell,
                  nextCell: cell || null
                }
              ]);
            }
            initialCellRef.current = cell;
          }
        });
        var DataEditor2 = cell && cell.DataEditor || props.DataEditor;
        var readOnly = cell && cell.readOnly;
        return hidden ? null : React.createElement("div", { ref: rootRef, className: (0, import_classnames.default)("Spreadsheet__active-cell", "Spreadsheet__active-cell--".concat(mode)), style: dimensions, onClick: mode === "view" && !readOnly ? edit2 : void 0, tabIndex: 0 }, mode === "edit" && active && React.createElement(DataEditor2, {
          row: active.row,
          column: active.column,
          cell,
          // @ts-ignore
          onChange: handleChange,
          exitEditMode: view2
        }));
      };
      FloatingRect = function(_a) {
        var _b;
        var dimensions = _a.dimensions, dragging = _a.dragging, hidden = _a.hidden, variant = _a.variant;
        var _c = dimensions || {}, width = _c.width, height = _c.height, top = _c.top, left = _c.left;
        return React.createElement("div", { className: (0, import_classnames.default)("Spreadsheet__floating-rect", (_b = {}, _b["Spreadsheet__floating-rect--".concat(variant)] = variant, _b["Spreadsheet__floating-rect--dragging"] = dragging, _b["Spreadsheet__floating-rect--hidden"] = hidden, _b)), style: { width, height, top, left } });
      };
      Selected = function() {
        var selected = useSelector(function(state) {
          return state.selected;
        });
        var dimensions = useSelector(function(state) {
          return selected && getSelectedDimensions(state.rowDimensions, state.columnDimensions, state.model.data, state.selected);
        });
        var dragging = useSelector(function(state) {
          return state.dragging;
        });
        var hidden = useSelector(function(state) {
          return state.selected.size(state.model.data) < 2;
        });
        return React.createElement(FloatingRect, { variant: "selected", dimensions, dragging, hidden });
      };
      Copied = function() {
        var range2 = useSelector(function(state) {
          return state.copied;
        });
        var dimensions = useSelector(function(state) {
          return range2 && getRangeDimensions(state.rowDimensions, state.columnDimensions, range2);
        });
        var hidden = range2 === null;
        return React.createElement(FloatingRect, { variant: "copied", dimensions, hidden, dragging: false });
      };
      css_248z = ".Spreadsheet {\n  --background-color: white;\n  --text-color: black;\n  --readonly-text-color: rgb(0 0 0 / 40%);\n  --outline-color: #4285f4;\n  --outline-background-color: rgb(160 195 255 / 20%);\n  --border-color: hsl(2deg 0% 91%);\n  --header-background-color: rgb(0 0 0 / 4%);\n  --elevation: 0 2px 5px rgb(0 0 0 / 40%);\n\n  position: relative;\n  overflow: visible;\n  background: var(--background-color);\n  color: var(--text-color);\n  display: inline-block;\n}\n\n.Spreadsheet--dark-mode {\n  --background-color: black;\n  --text-color: white;\n  --readonly-text-color: rgb(255 255 255 / 40%);\n  --header-background-color: rgb(255 255 255 / 4%);\n  --border-color: hsl(2deg 0% 19%);\n}\n\n.Spreadsheet__active-cell {\n  position: absolute;\n  border: 2px solid var(--outline-color);\n  box-sizing: border-box;\n}\n\n.Spreadsheet__active-cell--edit {\n  background: var(--background-color);\n  box-shadow: var(--elevation);\n}\n\n.Spreadsheet__table {\n  border-collapse: collapse;\n  table-layout: fixed;\n}\n\n.Spreadsheet__cell,\n.Spreadsheet__active-cell {\n  cursor: cell;\n}\n\n.Spreadsheet__cell {\n  outline: none;\n}\n\n.Spreadsheet__cell--readonly {\n  color: var(--readonly-text-color);\n}\n\n.Spreadsheet__cell,\n.Spreadsheet__header {\n  min-width: 6em;\n  min-height: 1.9em;\n  height: 1.9em;\n  max-height: 1.9em;\n  border: 1px solid var(--border-color);\n  overflow: hidden;\n  word-break: keep-all;\n  white-space: nowrap;\n  text-align: left;\n  box-sizing: border-box;\n  user-select: none;\n}\n\n.Spreadsheet__header {\n  background: var(--header-background-color);\n  color: var(--readonly-text-color);\n  text-align: center;\n  font: inherit;\n}\n\n.Spreadsheet__header--selected {\n  background: #5f6268;\n  color: #fff;\n}\n\n.Spreadsheet__header,\n.Spreadsheet__data-viewer,\n.Spreadsheet__data-editor input {\n  padding: 4px;\n  box-sizing: border-box;\n}\n\n.Spreadsheet__data-viewer--preserve-breaks {\n  white-space: pre-wrap;\n}\n\n.Spreadsheet__data-editor,\n.Spreadsheet__data-editor input {\n  width: 100%;\n  height: 100%;\n}\n\n.Spreadsheet__data-editor input {\n  font: inherit;\n  color: inherit;\n  background: none;\n  border: none;\n  outline: none;\n  margin: 0;\n}\n\n.Spreadsheet__data-viewer--boolean {\n  text-align: center;\n}\n\n.Spreadsheet__floating-rect {\n  position: absolute;\n  pointer-events: none;\n  box-sizing: border-box;\n}\n\n.Spreadsheet__floating-rect--hidden {\n  display: none;\n}\n\n.Spreadsheet__floating-rect--selected {\n  background: var(--outline-background-color);\n  border: 2px var(--outline-color) solid;\n}\n\n.Spreadsheet__floating-rect--dragging {\n  border: none;\n}\n\n.Spreadsheet__floating-rect--copied {\n  border: 2px var(--outline-color) dashed;\n}\n";
      styleInject(css_248z);
      Spreadsheet = function(props, ref) {
        var _a;
        var className = props.className, darkMode = props.darkMode, columnLabels = props.columnLabels, rowLabels = props.rowLabels, hideColumnIndicators = props.hideColumnIndicators, hideRowIndicators = props.hideRowIndicators, onKeyDown = props.onKeyDown, _b = props.Table, Table$1 = _b === void 0 ? Table : _b, _c = props.Row, Row$1 = _c === void 0 ? Row : _c, _d = props.HeaderRow, HeaderRow$1 = _d === void 0 ? HeaderRow : _d, _e = props.DataEditor, DataEditor$1 = _e === void 0 ? DataEditor : _e, _f = props.DataViewer, DataViewer$1 = _f === void 0 ? DataViewer : _f, _g = props.onChange, onChange = _g === void 0 ? function() {
        } : _g, _h = props.onModeChange, onModeChange = _h === void 0 ? function() {
        } : _h, _j = props.onSelect, onSelect = _j === void 0 ? function() {
        } : _j, _k = props.onActivate, onActivate = _k === void 0 ? function() {
        } : _k, _l = props.onBlur, onBlur = _l === void 0 ? function() {
        } : _l, _m = props.onCellCommit, onCellCommit = _m === void 0 ? function() {
        } : _m, _o = props.onEvaluatedDataChange, onEvaluatedDataChange = _o === void 0 ? function() {
        } : _o;
        var initialState = React.useMemo(function() {
          var createParser = props.createFormulaParser || createFormulaParser;
          var model = new Model(createParser, props.data);
          return __assign(__assign({}, INITIAL_STATE), { model, selected: props.selected || INITIAL_STATE.selected });
        }, [props.createFormulaParser, props.data, props.selected]);
        var reducerElements = React.useReducer(reducer, initialState);
        var _p = __read(reducerElements, 2), state = _p[0], dispatch = _p[1];
        var size = React.useMemo(function() {
          return calculateSpreadsheetSize(state.model.data, rowLabels, columnLabels);
        }, [state.model.data, rowLabels, columnLabels]);
        var mode = state.mode;
        var rootRef = React.useRef(null);
        var useAction = function(action) {
          return React.useCallback(function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return dispatch(action.apply(void 0, __spreadArray([], __read(args), false)));
          }, [action]);
        };
        var cut$1 = useAction(cut);
        var copy$1 = useAction(copy);
        var paste$1 = useAction(paste);
        var onKeyDownAction = useAction(keyDown);
        var onKeyPress = useAction(keyPress);
        var onDragStart = useAction(dragStart);
        var onDragEnd = useAction(dragEnd);
        var setData$1 = useAction(setData);
        var setCreateFormulaParser$1 = useAction(setCreateFormulaParser);
        var blur2 = useAction(blur$1);
        var setSelection$1 = useAction(setSelection);
        var activate$1 = useAction(activate);
        var methods = React.useMemo(function() {
          return {
            activate: function(point) {
              activate$1(point);
            }
          };
        }, []);
        React.useImperativeHandle(ref, function() {
          return methods;
        });
        var prevActiveRef = React.useRef(state.active);
        React.useEffect(function() {
          if (state.active !== prevActiveRef.current) {
            if (state.active) {
              onActivate(state.active);
            } else {
              var root = rootRef.current;
              if (root && isFocusedWithin(root) && document.activeElement) {
                document.activeElement.blur();
              }
              onBlur();
            }
          }
          prevActiveRef.current = state.active;
        }, [onActivate, onBlur, state.active]);
        var prevDataRef = React.useRef(state.model.data);
        React.useEffect(function() {
          if (state.model.data !== prevDataRef.current) {
            if (state.model.data !== props.data) {
              onChange(state.model.data);
            }
          }
          prevDataRef.current = state.model.data;
        }, [state.model.data, onChange, props.data]);
        var prevEvaluatedDataRef = React.useRef(state.model.evaluatedData);
        React.useEffect(function() {
          var _a2, _b2;
          if (((_a2 = state === null || state === void 0 ? void 0 : state.model) === null || _a2 === void 0 ? void 0 : _a2.evaluatedData) !== (prevEvaluatedDataRef === null || prevEvaluatedDataRef === void 0 ? void 0 : prevEvaluatedDataRef.current)) {
            onEvaluatedDataChange((_b2 = state === null || state === void 0 ? void 0 : state.model) === null || _b2 === void 0 ? void 0 : _b2.evaluatedData);
          }
          prevEvaluatedDataRef.current = state.model.evaluatedData;
        }, [(_a = state === null || state === void 0 ? void 0 : state.model) === null || _a === void 0 ? void 0 : _a.evaluatedData, onEvaluatedDataChange]);
        var prevSelectedRef = React.useRef(state.selected);
        React.useEffect(function() {
          if (!state.selected.equals(prevSelectedRef.current)) {
            if (!props.selected || !state.selected.equals(props.selected)) {
              onSelect(state.selected);
            }
          }
          prevSelectedRef.current = state.selected;
        }, [state.selected, onSelect, props.selected]);
        var prevModeRef = React.useRef(state.mode);
        React.useEffect(function() {
          if (state.mode !== prevModeRef.current) {
            onModeChange(state.mode);
          }
          prevModeRef.current = state.mode;
        }, [state.mode, onModeChange]);
        var prevLastCommitRef = React.useRef(state.lastCommit);
        React.useEffect(function() {
          var e_1, _a2;
          if (state.lastCommit && state.lastCommit !== prevLastCommitRef.current) {
            try {
              for (var _b2 = __values(state.lastCommit), _c2 = _b2.next(); !_c2.done; _c2 = _b2.next()) {
                var change = _c2.value;
                onCellCommit(change.prevCell, change.nextCell, state.lastChanged);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_c2 && !_c2.done && (_a2 = _b2.return)) _a2.call(_b2);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          }
        }, [onCellCommit, state.lastChanged, state.lastCommit]);
        var prevSelectedPropRef = React.useRef(props.selected);
        React.useEffect(function() {
          if (props.selected && prevSelectedPropRef.current && !props.selected.equals(prevSelectedPropRef.current)) {
            setSelection$1(props.selected);
          }
          prevSelectedPropRef.current = props.selected;
        }, [props.selected, setSelection$1]);
        var prevDataPropRef = React.useRef(props.data);
        React.useEffect(function() {
          if (props.data !== prevDataPropRef.current) {
            setData$1(props.data);
          }
          prevDataPropRef.current = props.data;
        }, [props.data, setData$1]);
        var prevCreateFormulaParserPropRef = React.useRef(props.createFormulaParser);
        React.useEffect(function() {
          if (props.createFormulaParser !== prevCreateFormulaParserPropRef.current && props.createFormulaParser)
            setCreateFormulaParser$1(props.createFormulaParser);
          prevCreateFormulaParserPropRef.current = props.createFormulaParser;
        }, [props.createFormulaParser, setCreateFormulaParser$1]);
        var writeDataToClipboard = React.useCallback(function(event) {
          var model = state.model, selected = state.selected;
          var data = model.data;
          var range2 = selected.toRange(data);
          if (range2) {
            var selectedData = slice(range2.start, range2.end, data);
            var csv = getCSV(selectedData);
            writeTextToClipboard(event, csv);
          }
        }, [state]);
        var handleCut = React.useCallback(function(event) {
          if (shouldHandleClipboardEvent(rootRef.current, mode)) {
            event.preventDefault();
            event.stopPropagation();
            writeDataToClipboard(event);
            cut$1();
          }
        }, [mode, writeDataToClipboard, cut$1]);
        var handleCopy = React.useCallback(function(event) {
          if (shouldHandleClipboardEvent(rootRef.current, mode)) {
            event.preventDefault();
            event.stopPropagation();
            writeDataToClipboard(event);
            copy$1();
          }
        }, [mode, writeDataToClipboard, copy$1]);
        var handlePaste = React.useCallback(function(event) {
          if (shouldHandleClipboardEvent(rootRef.current, mode)) {
            event.preventDefault();
            event.stopPropagation();
            if (event.clipboardData) {
              var text = readTextFromClipboard(event);
              paste$1(text);
            }
          }
        }, [mode, paste$1]);
        var handleKeyDown = React.useCallback(function(event) {
          event.persist();
          if (onKeyDown) {
            onKeyDown(event);
          }
          if (!event.defaultPrevented) {
            if (hasKeyDownHandler(state, event)) {
              event.nativeEvent.preventDefault();
            }
            onKeyDownAction(event);
          }
        }, [state, onKeyDown, onKeyDownAction]);
        var handleMouseUp = React.useCallback(function() {
          onDragEnd();
          document.removeEventListener("mouseup", handleMouseUp);
        }, [onDragEnd]);
        var handleMouseMove = React.useCallback(function(event) {
          if (!state.dragging && event.buttons === 1) {
            onDragStart();
            document.addEventListener("mouseup", handleMouseUp);
          }
        }, [state, onDragStart, handleMouseUp]);
        var handleBlur = React.useCallback(function(event) {
          if (!event.currentTarget.contains(event.relatedTarget)) {
            blur2();
          }
        }, [blur2]);
        var Cell$1 = React.useMemo(function() {
          return enhance(props.Cell || Cell);
        }, [props.Cell]);
        var CornerIndicator$1 = React.useMemo(function() {
          return enhance$3(props.CornerIndicator || CornerIndicator);
        }, [props.CornerIndicator]);
        var RowIndicator$1 = React.useMemo(function() {
          return enhance$1(props.RowIndicator || RowIndicator);
        }, [props.RowIndicator]);
        var ColumnIndicator$1 = React.useMemo(function() {
          return enhance$2(props.ColumnIndicator || ColumnIndicator);
        }, [props.ColumnIndicator]);
        React.useEffect(function() {
          document.addEventListener("cut", handleCut);
          document.addEventListener("copy", handleCopy);
          document.addEventListener("paste", handlePaste);
          return function() {
            document.removeEventListener("cut", handleCut);
            document.removeEventListener("copy", handleCopy);
            document.removeEventListener("paste", handlePaste);
          };
        }, [handleCut, handleCopy, handlePaste]);
        var tableNode = React.useMemo(function() {
          return React.createElement(
            Table$1,
            { columns: size.columns, hideColumnIndicators },
            React.createElement(
              HeaderRow$1,
              null,
              !hideRowIndicators && !hideColumnIndicators && React.createElement(CornerIndicator$1, null),
              !hideColumnIndicators && range(size.columns).map(function(columnNumber) {
                return columnLabels ? React.createElement(ColumnIndicator$1, { key: columnNumber, column: columnNumber, label: columnNumber in columnLabels ? columnLabels[columnNumber] : null }) : React.createElement(ColumnIndicator$1, { key: columnNumber, column: columnNumber });
              })
            ),
            range(size.rows).map(function(rowNumber) {
              return React.createElement(
                Row$1,
                { key: rowNumber, row: rowNumber },
                !hideRowIndicators && (rowLabels ? React.createElement(RowIndicator$1, { key: rowNumber, row: rowNumber, label: rowNumber in rowLabels ? rowLabels[rowNumber] : null }) : React.createElement(RowIndicator$1, { key: rowNumber, row: rowNumber })),
                range(size.columns).map(function(columnNumber) {
                  return React.createElement(Cell$1, {
                    key: columnNumber,
                    row: rowNumber,
                    column: columnNumber,
                    // @ts-ignore
                    DataViewer: DataViewer$1
                  });
                })
              );
            })
          );
        }, [
          Table$1,
          size.rows,
          size.columns,
          hideColumnIndicators,
          Row$1,
          HeaderRow$1,
          hideRowIndicators,
          CornerIndicator$1,
          columnLabels,
          ColumnIndicator$1,
          rowLabels,
          RowIndicator$1,
          Cell$1,
          DataViewer$1
        ]);
        var activeCellNode = React.useMemo(function() {
          return React.createElement(
            ActiveCell,
            {
              // @ts-ignore
              DataEditor: DataEditor$1
            }
          );
        }, [DataEditor$1]);
        var rootNode = React.useMemo(function() {
          return React.createElement(
            "div",
            { ref: rootRef, className: (0, import_classnames.default)("Spreadsheet", className, {
              "Spreadsheet--dark-mode": darkMode
            }), onKeyPress, onKeyDown: handleKeyDown, onMouseMove: handleMouseMove, onBlur: handleBlur },
            tableNode,
            activeCellNode,
            React.createElement(Selected, null),
            React.createElement(Copied, null)
          );
        }, [
          className,
          darkMode,
          onKeyPress,
          handleKeyDown,
          handleMouseMove,
          handleBlur,
          tableNode,
          activeCellNode
        ]);
        return React.createElement(context.Provider, { value: reducerElements }, rootNode);
      };
      Spreadsheet$1 = React.forwardRef(Spreadsheet);
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/error_utils.js
  function spawnErrorWithOriginOmittedFromStackTrace(errorMessageFormat, errorMessageArgs, errorOriginFn) {
    const safeMessage = errorMessageFormat;
    let argIndex = 0;
    const formattedMessage = errorMessageFormat.replace(/%s/g, () => {
      const arg = errorMessageArgs ? errorMessageArgs[argIndex] : void 0;
      argIndex++;
      return String(arg);
    });
    const err = new Error(formattedMessage);
    if (Error.captureStackTrace && errorOriginFn) {
      Error.captureStackTrace(err, errorOriginFn);
    }
    Object.defineProperty(err, "__safeMessage", {
      configurable: false,
      enumerable: false,
      value: safeMessage,
      writable: false
    });
    return err;
  }
  function spawnError(errorMessageFormat) {
    for (var _len = arguments.length, errorMessageArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      errorMessageArgs[_key - 1] = arguments[_key];
    }
    return spawnErrorWithOriginOmittedFromStackTrace(errorMessageFormat, errorMessageArgs, spawnError);
  }
  function invariant(condition, errorMessageFormat) {
    if (!condition) {
      for (var _len2 = arguments.length, errorMessageArgs = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        errorMessageArgs[_key2 - 2] = arguments[_key2];
      }
      throw spawnErrorWithOriginOmittedFromStackTrace(errorMessageFormat, errorMessageArgs, invariant);
    }
  }
  var init_error_utils = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/error_utils.js"() {
    }
  });

  // node_modules/@airtable/blocks/dist/esm/injected/airtable_interface.js
  function getAirtableInterface() {
    const getAirtableInterfaceAtVersion = window.__getAirtableInterfaceAtVersion;
    if (!airtableInterface) {
      if (!getAirtableInterfaceAtVersion) {
        throw spawnError(missingAirtableInterfaceErrorMessage);
      }
      airtableInterface = getAirtableInterfaceAtVersion(AIRTABLE_INTERFACE_VERSION);
    }
    return airtableInterface;
  }
  var AIRTABLE_INTERFACE_VERSION, airtableInterface, missingAirtableInterfaceErrorMessage;
  var init_airtable_interface = __esm({
    "node_modules/@airtable/blocks/dist/esm/injected/airtable_interface.js"() {
      init_error_utils();
      AIRTABLE_INTERFACE_VERSION = 0;
      airtableInterface = null;
      missingAirtableInterfaceErrorMessage = ["Error: Extension environment misconfigured", "\n\n", "Airtable Extensions can only run in the presence of an Airtable Base. If you ", "are trying to run your Extension with a Base hosted on airtable.com, then be ", "sure you are using the Airtable CLI to serve your code and accessing it ", "through a Custom Extension installed inside a Base on airtable.com.", "\n\n", "If you are trying to run automated tests for your Extension, then make sure ", "you have loaded the `@airtable/testing-library` module *before* the ", "`@airtable/blocks` module."].join("");
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/types/airtable_interface.js
  var BlockRunContextType;
  var init_airtable_interface2 = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/types/airtable_interface.js"() {
      BlockRunContextType = /* @__PURE__ */ (function(BlockRunContextType3) {
        BlockRunContextType3["PAGE_ELEMENT_IN_QUERY_CONTAINER"] = "pageElementInQueryContainer";
        return BlockRunContextType3;
      })({});
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/assert_run_context.js
  var init_assert_run_context = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/assert_run_context.js"() {
      init_airtable_interface();
      init_error_utils();
      init_airtable_interface2();
      if (window.__getAirtableInterfaceAtVersion) {
        const runContextType = getAirtableInterface().sdkInitData.runContext.type;
        if (runContextType !== BlockRunContextType.PAGE_ELEMENT_IN_QUERY_CONTAINER) {
          throw spawnError("Unexpected import when running block in base");
        }
      }
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/warning.js
  function __injectSdkIntoWarning(_sdk) {
    sdk = _sdk;
  }
  var sdk;
  var init_warning = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/warning.js"() {
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/private_utils.js
  function cloneDeep(obj) {
    const jsonString = JSON.stringify(obj);
    if (jsonString === void 0) {
      return obj;
    }
    return JSON.parse(jsonString);
  }
  function isDeepEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (a && b && typeof a === "object" && typeof b === "object") {
      if (a.constructor !== b.constructor) {
        return false;
      }
      if (Array.isArray(a)) {
        const length2 = a.length;
        if (length2 !== b.length) {
          return false;
        }
        for (let i = length2 - 1; i >= 0; i--) {
          if (!isDeepEqual(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
      const keys3 = Object.keys(a);
      const length = keys3.length;
      if (length !== Object.keys(b).length) {
        return false;
      }
      for (let i = length - 1; i >= 0; i--) {
        if (!Object.prototype.hasOwnProperty.call(b, keys3[i])) {
          return false;
        }
      }
      for (let i = length - 1; i >= 0; i--) {
        const key = keys3[i];
        if (!isDeepEqual(a[key], b[key])) {
          return false;
        }
      }
      return true;
    }
    return a !== a && b !== b;
  }
  function keys2(obj) {
    return Object.keys(obj);
  }
  function entries2(obj) {
    return Object.entries(obj);
  }
  function has3(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  function getInvertedEnumMemoized(enumObj) {
    const existingInvertedEnum = invertedEnumCache.get(enumObj);
    if (existingInvertedEnum) {
      return existingInvertedEnum;
    }
    const invertedEnum = {};
    for (const enumKey of keys2(enumObj)) {
      const enumValue = enumObj[enumKey];
      invertedEnum[enumValue] = enumKey;
    }
    invertedEnumCache.set(enumObj, invertedEnum);
    return invertedEnum;
  }
  function getEnumValueIfExists(enumObj, valueToCheck) {
    const invertedEnum = getInvertedEnumMemoized(enumObj);
    if (has3(invertedEnum, valueToCheck) && invertedEnum[valueToCheck]) {
      const enumKey = invertedEnum[valueToCheck];
      return enumObj[enumKey];
    }
    return null;
  }
  function isEnumValue(enumObj, valueToCheck) {
    return getEnumValueIfExists(enumObj, valueToCheck) !== null;
  }
  function isObjectEmpty(obj) {
    for (const key in obj) {
      if (has3(obj, key)) {
        return false;
      }
    }
    return true;
  }
  function getLocallyUniqueId() {
    let prefix = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return `${prefix}.${idCount++}`;
  }
  function getValueAtOwnPath(value, path) {
    let currentValue = value;
    for (const part of path) {
      if (currentValue === void 0) {
        return void 0;
      }
      if (typeof currentValue !== "object" || currentValue === null) {
        throw spawnError("Cannot get '%s' in primitive value", part);
      }
      if (Array.isArray(currentValue)) {
        throw spawnError("Cannot get '%s' in array", part);
      }
      const prototype = Object.getPrototypeOf(currentValue);
      if (prototype !== null && prototype !== plainObjectPrototype) {
        throw spawnError("Cannot get '%s' in non-plain object", part);
      }
      currentValue = has3(currentValue, part) ? currentValue[part] : void 0;
    }
    return currentValue;
  }
  var invertedEnumCache, idCount, plainObjectPrototype;
  var init_private_utils = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/private_utils.js"() {
      init_airtable_interface();
      init_error_utils();
      invertedEnumCache = /* @__PURE__ */ new WeakMap();
      idCount = 0;
      plainObjectPrototype = Object.getPrototypeOf({});
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/watchable.js
  var Watchable, watchable_default;
  var init_watchable = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/watchable.js"() {
      init_private_utils();
      init_error_utils();
      Watchable = class {
        /** @internal */
        static _className = "Watchable";
        /** @internal */
        static _isWatchableKey(_key) {
          return false;
        }
        /** @internal */
        _changeCount = 0;
        /** @internal */
        _watchableId = getLocallyUniqueId();
        /** @internal */
        /**
         * @internal
         */
        constructor() {
          this._changeWatchersByKey = {};
        }
        // React integrations (e.g. useSubscription) rely on referential equality (===) to determine
        // when things have changed. This doesn't work with our mutable models, since the identity
        // of the model doesn't change, but the data inside it might. Rather than never returning two equal values
        // those integrations can use __getWatchableKey, a string key that is guaranteed to be unique
        // to each watchable and will change whenever the watch keys are fired.
        /**
         * @internal
         */
        __getWatchableKey() {
          return `${this._watchableId} ${this._changeCount}`;
        }
        /**
         * Helper method to get only the valid watchable keys - or throw if a key is invalid
         *
         * @param keys
         * @internal
         */
        _getWatchableValidKeysOrThrow(keys3, errorMethodName, shouldWarnInsteadOfThrow) {
          const arrayKeys = Array.isArray(keys3) ? keys3 : [keys3];
          const validKeys = [];
          for (const key of arrayKeys) {
            if (this.constructor._isWatchableKey(key)) {
              validKeys.push(key);
            } else {
              const className = this.constructor._className;
              const errorString = `Invalid key to ${errorMethodName} for ${className}: ${key}`;
              if (shouldWarnInsteadOfThrow) {
                console.warn(errorString);
              } else {
                throw spawnError(errorString);
              }
            }
          }
          return validKeys;
        }
        /**
         * Get notified of changes to the model.
         *
         * Every call to `.watch` should have a matching call to `.unwatch`.
         *
         * Returns the array of keys that were watched.
         *
         * @param keys the keys to watch
         * @param callback a function to call when those keys change
         * @param context an optional context for `this` in `callback`.
         */
        watch(keys3, callback, context2) {
          const validKeys = this._getWatchableValidKeysOrThrow(keys3, "watch");
          for (const key of validKeys) {
            if (!this._changeWatchersByKey[key]) {
              this._changeWatchersByKey[key] = [];
            }
            this._changeWatchersByKey[key] = [...this._changeWatchersByKey[key], {
              callback,
              context: context2
            }];
          }
          return validKeys;
        }
        /**
         * Unwatch keys watched with `.watch`.
         *
         * Should be called with the same arguments given to `.watch`.
         *
         * Returns the array of keys that were unwatched.
         *
         * @param keys the keys to unwatch
         * @param callback the function passed to `.watch` for these keys
         * @param context the context that was passed to `.watch` for this `callback`
         */
        unwatch(keys3, callback, context2) {
          const validKeys = this._getWatchableValidKeysOrThrow(keys3, "unwatch", true);
          for (const key of validKeys) {
            const watchers = this._changeWatchersByKey[key];
            if (watchers) {
              const filteredWatchers = watchers.filter((watcher) => {
                return watcher.callback !== callback || watcher.context !== context2;
              });
              if (filteredWatchers.length > 0) {
                this._changeWatchersByKey[key] = filteredWatchers;
              } else {
                delete this._changeWatchersByKey[key];
              }
            }
          }
          return validKeys;
        }
        /**
         * @internal
         */
        _onChange(key) {
          this._changeCount += 1;
          const watchers = this._changeWatchersByKey[key];
          if (watchers) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            for (const watcher of watchers) {
              watcher.callback.call(watcher.context, this, key, ...args);
            }
          }
        }
      };
      watchable_default = Watchable;
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/types/mutations_core.js
  var MutationTypesCore;
  var init_mutations_core = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/types/mutations_core.js"() {
      MutationTypesCore = Object.freeze({
        SET_MULTIPLE_GLOBAL_CONFIG_PATHS: "setMultipleGlobalConfigPaths",
        SET_MULTIPLE_RECORDS_CELL_VALUES: "setMultipleRecordsCellValues",
        DELETE_MULTIPLE_RECORDS: "deleteMultipleRecords",
        CREATE_MULTIPLE_RECORDS: "createMultipleRecords"
      });
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/global_config.js
  var GlobalConfig, global_config_default;
  var init_global_config = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/global_config.js"() {
      init_watchable();
      init_error_utils();
      init_mutations_core();
      init_private_utils();
      GlobalConfig = class extends watchable_default {
        /** @internal */
        static _className = "GlobalConfig";
        /** @internal */
        static _isWatchableKey(key) {
          return true;
        }
        /** @internal */
        /** @internal */
        /** @internal */
        /**
         * @internal
         */
        constructor(initialKvValuesByKey, sdk3) {
          super();
          this._kvStore = initialKvValuesByKey;
          this._sdk = sdk3;
          this._airtableInterface = sdk3.__airtableInterface;
        }
        /**
         * @internal
         */
        __getTopLevelKey(key) {
          if (Array.isArray(key)) {
            return key[0];
          }
          return key;
        }
        /**
         * @internal
         */
        _formatKeyAsPath(key) {
          if (!Array.isArray(key)) {
            return [key];
          }
          return key;
        }
        /**
         * @internal
         */
        _validatePath(path, store) {
          const validation = this._airtableInterface.globalConfigHelpers.validatePath(path, store);
          if (!validation.isValid) {
            return validation;
          }
          if (path[0] === "*") {
            return {
              isValid: false,
              reason: "cannot use '*' as a top-level key"
            };
          }
          return {
            isValid: true
          };
        }
        /**
         * Get the value at a path. Throws an error if the path is invalid.
         *
         * Returns undefined if no value exists at that path.
         *
         * @param key A string for the top-level key, or an array of strings describing the path to the value.
         * @example
         * ```js
         * import {useGlobalConfig} from '@airtable/blocks/[placeholder-path]/ui';
         *
         * function MyApp() {
         *     const globalConfig = useGlobalConfig();
         *     const topLevelValue = globalConfig.get('topLevelKey');
         *     const nestedValue = globalConfig.get(['topLevelKey', 'nested', 'deeply']);
         * }
         * ```
         */
        get(key) {
          const path = this._formatKeyAsPath(key);
          const pathValidationResult = this._validatePath(path, this._kvStore);
          if (!pathValidationResult.isValid) {
            throw spawnError("Invalid globalConfig path: %s", pathValidationResult.reason);
          }
          const value = getValueAtOwnPath(this._kvStore, path);
          return value;
        }
        /**
         * Checks whether the current user has permission to set the given global config key.
         *
         * Accepts partial input, in the same format as {@link setAsync}.
         * The more information provided, the more accurate the permissions check will be.
         *
         * Returns `{hasPermission: true}` if the current user can set the specified key,
         * `{hasPermission: false, reasonDisplayString: string}` otherwise.  `reasonDisplayString` may
         * be used to display an error message to the user.
         *
         * @param key A string for the top-level key, or an array of strings describing the path to set.
         * @param value The value to set at the specified path. Use `undefined` to delete the value at the given path.
         *
         * @example
         * ```js
         * // Check if user can update a specific key and value.
         * const setCheckResult =
         *     globalConfig.checkPermissionsForSet('favoriteColor', 'purple');
         * if (!setCheckResult.hasPermission) {
         *     alert(setCheckResult.reasonDisplayString);
         * }
         *
         * // Check if user can update a specific key without knowing the value
         * const setKeyCheckResult =
         *     globalConfig.checkPermissionsForSet('favoriteColor');
         *
         * // Check if user can update globalConfig without knowing key or value
         * const setUnknownKeyCheckResult = globalConfig.checkPermissionsForSet();
         * ```
         */
        checkPermissionsForSet(key, value) {
          return this.checkPermissionsForSetPaths([{
            path: key ? this._formatKeyAsPath(key) : void 0,
            value
          }]);
        }
        /**
         * An alias for `globalConfig.checkPermissionsForSet(key, value).hasPermission`.
         *
         * Checks whether the current user has permission to set the given global config key.
         *
         * Accepts partial input, in the same format as {@link setAsync}.
         * The more information provided, the more accurate the permissions check will be.
         *
         * @param key A string for the top-level key, or an array of strings describing the path to set.
         * @param value The value to set at the specified path. Use `undefined` to delete the value at the given path.
         *
         * @example
         * ```js
         * // Check if user can update a specific key and value.
         * const canSetFavoriteColorToPurple =
         *     globalConfig.hasPermissionToSet('favoriteColor', 'purple');
         * if (!canSetFavoriteColorToPurple) {
         *     alert('Not allowed!');
         * }
         *
         * // Check if user can update a specific key without knowing the value
         * const canSetFavoriteColor = globalConfig.hasPermissionToSet('favoriteColor');
         *
         * // Check if user can update globalConfig without knowing key or value
         * const canSetGlobalConfig = globalConfig.hasPermissionToSet();
         * ```
         */
        hasPermissionToSet(key, value) {
          return this.checkPermissionsForSet(key, value).hasPermission;
        }
        /**
         * Sets a value at a path. Throws an error if the path or value is invalid.
         *
         * This action is asynchronous: `await` the returned promise if you wish to wait for the
         * update to be persisted to Airtable servers.
         *
         * Updates are applied optimistically locally, so your change will be reflected in
         * {@link GlobalConfig} before the promise resolves.
         *
         * @param key A string for the top-level key, or an array of strings describing the path to set.
         * @param value The value to set at the specified path. Use `undefined` to delete the value at the given path.
         * @example
         * ```js
         * import {useGlobalConfig} from '@airtable/blocks/[placeholder-path]/ui';
         *
         * function MyApp() {
         *     const globalConfig = useGlobalConfig();
         *     const updateFavoriteColorIfPossible = (color) => {
         *         if (globalConfig.hasPermissionToSet('favoriteColor', color)) {
         *             globalConfig.setAsync('favoriteColor', color);
         *         }
         *         // The update is now applied within your extension (eg will be
         *         // reflected in globalConfig) but are still being saved to
         *         // Airtable servers (e.g. may not be updated for other users yet)
         *     }
         *
         *     const updateFavoriteColorIfPossibleAsync = async (color) => {
         *         if (globalConfig.hasPermissionToSet('favoriteColor', color)) {
         *             await globalConfig.setAsync('favoriteColor', color);
         *         }
         *         // globalConfig updates have been saved to Airtable servers.
         *         alert('favoriteColor has been updated');
         *     }
         * }
         * ```
         */
        async setAsync(key, value) {
          const path = this._formatKeyAsPath(key);
          await this.setPathsAsync([{
            path,
            value
          }]);
        }
        /**
         * Checks whether the current user has permission to perform the specified updates to global config.
         *
         * Accepts partial input, in the same format as {@link setPathsAsync}.
         * The more information provided, the more accurate the permissions check will be.
         *
         * Returns `{hasPermission: true}` if the current user can set the specified key,
         * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
         * used to display an error message to the user.
         *
         * @param updates The paths and values to set.
         * @example
         * ```js
         * // Check if user can update a specific keys and values.
         * const setPathsCheckResult = globalConfig.checkPermissionsForSet([
         *     {path: ['topLevelKey1', 'nestedKey1'], value: 'foo'},
         *     {path: ['topLevelKey2', 'nestedKey2'], value: 'bar'},
         * ]);
         * if (!setPathsCheckResult.hasPermission) {
         *     alert(setPathsCheckResult.reasonDisplayString);
         * }
         *
         * // Check if user could potentially set globalConfig values.
         * // Equivalent to globalConfig.checkPermissionsForSet()
         * const setUnknownPathsCheckResult =
         *     globalConfig.checkPermissionsForSetPaths();
         * ```
         */
        checkPermissionsForSetPaths(updates) {
          return this._sdk.__mutations.checkPermissionsForMutation({
            type: MutationTypesCore.SET_MULTIPLE_GLOBAL_CONFIG_PATHS,
            updates: updates ? updates.map((_ref) => {
              let {
                path,
                value
              } = _ref;
              return {
                path: path || void 0,
                value
              };
            }) : void 0
          });
        }
        /**
         * An alias for `globalConfig.checkPermissionsForSetPaths(updates).hasPermission`.
         *
         * Checks whether the current user has permission to perform the specified updates to global
         * config.
         *
         * Accepts partial input, in the same format as {@link setPathsAsync}.
         * The more information provided, the more accurate the permissions check will be.
         *
         * @param updates The paths and values to set.
         *
         * @example
         * ```js
         * // Check if user can update a specific keys and values.
         * const canSetPaths = globalConfig.hasPermissionToSetPaths([
         *     {path: ['topLevelKey1', 'nestedKey1'], value: 'foo'},
         *     {path: ['topLevelKey2', 'nestedKey2'], value: 'bar'},
         * ]);
         * if (!canSetPaths) {
         *     alert('not allowed!');
         * }
         *
         * // Check if user could potentially set globalConfig values.
         * // Equivalent to globalConfig.hasPermissionToSet()
         * const canSetAnyPaths = globalConfig.hasPermissionToSetPaths();
         * ```
         */
        hasPermissionToSetPaths(updates) {
          return this.checkPermissionsForSetPaths(updates).hasPermission;
        }
        /**
         * Sets multiple values. Throws if any path or value is invalid.
         *
         * This action is asynchronous: `await` the returned promise if you wish to wait for the
         * updates to be persisted to Airtable servers.
         * Updates are applied optimistically locally, so your changes will be reflected in
         * {@link GlobalConfig} before the promise resolves.
         *
         * @param updates The paths and values to set.
         * @example
         * ```js
         * import {useGlobalConfig} from '@airtable/blocks/[placeholder-path]/ui';
         *
         * function MyApp() {
         *     const globalConfig = useGlobalConfig();
         *     const updates = [
         *         {path: ['topLevelKey1', 'nestedKey1'], value: 'foo'},
         *         {path: ['topLevelKey2', 'nestedKey2'], value: 'bar'},
         *     ];
         *
         *     const applyUpdatesIfPossible = () => {
         *         if (globalConfig.hasPermissionToSetPaths(updates)) {
         *             globalConfig.setPathsAsync(updates);
         *         }
         *         // The updates are now applied within your extension (eg will be reflected in
         *         // globalConfig) but are still being saved to Airtable servers (e.g. they
         *         // may not be updated for other users yet)
         *     }
         *
         *     const applyUpdatesIfPossibleAsync = async () => {
         *         if (globalConfig.hasPermissionToSetPaths(updates)) {
         *             await globalConfig.setPathsAsync(updates);
         *         }
         *         // globalConfig updates have been saved to Airtable servers.
         *         alert('globalConfig has been updated');
         *     }
         * }
         * ```
         */
        async setPathsAsync(updates) {
          if (!this.hasPermissionToSetPaths(updates)) {
            throw spawnError("Your permission level does not allow setting globalConfig values");
          }
          for (const update of updates) {
            const pathValidation = this._validatePath(update.path, this._kvStore);
            if (!pathValidation.isValid) {
              throw spawnError("Invalid globalConfig path: %s", pathValidation.reason);
            }
          }
          await this._sdk.__mutations.applyMutationAsync({
            type: MutationTypesCore.SET_MULTIPLE_GLOBAL_CONFIG_PATHS,
            updates
          });
        }
        /**
         * @internal
         * this shouldn't be called directly - instead, use this._sdk.__applyGlobalConfigUpdates()
         */
        __setMultipleKvPaths(updates) {
          const {
            newKvStore,
            changedTopLevelKeys
          } = this._airtableInterface.globalConfigHelpers.validateAndApplyUpdates(updates, this._kvStore);
          this._kvStore = newKvStore;
          for (const key of changedTopLevelKeys) {
            this._onChange(key);
          }
          if (changedTopLevelKeys.length) {
            this._onChange("*");
          }
        }
      };
      global_config_default = GlobalConfig;
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/sdk_core.js
  var BlockSdkCore;
  var init_sdk_core = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/sdk_core.js"() {
      init_global_config();
      BlockSdkCore = class _BlockSdkCore {
        /**
         * This value is used by the blocks-testing library to verify
         * compatibility.
         *
         * @hidden
         */
        // @ts-ignore
        static VERSION = "0.0.0-experimental-28533a19d-20251016";
        /** Storage for this block installation's configuration. */
        /** Contains information about the current session. */
        /** Represents the current Airtable {@link Base}. */
        /**
         * Returns the ID for the current block installation.
         *
         * @example
         * ```js
         * import {installationId} from '@airtable/blocks/base';
         * console.log(installationId);
         * // => 'blifDutUr92OKwnUn'
         * ```
         */
        /** @hidden */
        /** @internal */
        /** @internal */
        /** @hidden */
        constructor(airtableInterface2) {
          this.__airtableInterface = airtableInterface2;
          airtableInterface2.assertAllowedSdkPackageVersion("@airtable/blocks", _BlockSdkCore.VERSION);
          const sdkInitData = airtableInterface2.sdkInitData;
          this.globalConfig = new global_config_default(sdkInitData.initialKvValuesByKey, this);
          this.installationId = sdkInitData.blockInstallationId;
          this.runInfo = Object.freeze({
            isFirstRun: sdkInitData.isFirstRun,
            isDevelopmentMode: sdkInitData.isDevelopmentMode,
            intentData: sdkInitData.intentData
          });
          this.session = this._constructSession();
          this.base = this._constructBase();
          this.__mutations = this._constructMutations();
          this.reload = this.reload.bind(this);
        }
        /** @internal */
        /** @internal */
        /** @internal */
        /**
         * Call this function to reload your block.
         *
         * @example
         * ```js
         * import React from 'react';
         * import {reload} from '@airtable/blocks/base';
         * import {Button, initializeBlock} from '@airtable/blocks/base/ui';
         * function MyBlock() {
         *     return <Button onClick={() => reload()}>Reload</Button>;
         * }
         * initializeBlock(() => <MyBlock />);
         * ```
         */
        reload() {
          this.__airtableInterface.reloadFrame();
        }
        /**
         * @internal
         */
        get __appInterface() {
          return this.base._baseData.appInterface;
        }
      };
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/models/abstract_model.js
  var AbstractModel, abstract_model_default;
  var init_abstract_model = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/models/abstract_model.js"() {
      init_error_utils();
      init_watchable();
      AbstractModel = class extends watchable_default {
        /** @internal */
        static _className = "AbstractModel";
        /**
         * This method is essentially abstract, but as of this writing, TypeScript
         * does not support abstract static methods. This necessitates a concrete
         * implementation which must be explicitly ignored by the test coverage
         * tooling.
         *
         * @internal
         */
        // istanbul ignore next
        static _isWatchableKey(key) {
          return false;
        }
        /** @internal */
        /** @internal */
        /** @internal */
        /**
         * @internal
         */
        constructor(sdk3, modelId) {
          super();
          invariant(typeof modelId === "string", "%s id should be a string", this.constructor._className);
          this._sdk = sdk3;
          this._baseData = sdk3.__airtableInterface.sdkInitData.baseData;
          this._id = modelId;
        }
        /**
         * The ID for this model.
         */
        get id() {
          return this._id;
        }
        /**
         * @internal
         */
        /**
         * @internal
         */
        get _data() {
          const data = this._dataOrNullIfDeleted;
          if (data === null) {
            throw this._spawnErrorForDeletion();
          }
          return data;
        }
        /**
         * `true` if the model has been deleted, and `false` otherwise.
         *
         * In general, it's best to avoid keeping a reference to an object past the
         * current event loop, since it may be deleted and trying to access any data
         * of a deleted object (other than its ID) will throw. But if you keep a
         * reference, you can use `isDeleted` to check that it's safe to access the
         * model's data.
         */
        get isDeleted() {
          return this._dataOrNullIfDeleted === null;
        }
        /**
         * @internal
         */
        _spawnErrorForDeletion() {
          return spawnError("%s has been deleted", this.constructor._className);
        }
        /**
         * A string representation of the model for use in debugging.
         */
        toString() {
          return `[${this.constructor._className} ${this.id}]`;
        }
      };
      abstract_model_default = AbstractModel;
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/models/session_core.js
  var WatchableSessionKeys, SessionCore;
  var init_session_core = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/models/session_core.js"() {
      init_error_utils();
      init_private_utils();
      init_abstract_model();
      WatchableSessionKeys = Object.freeze({
        permissionLevel: "permissionLevel",
        // NOTE: the current user's identity will never change, but their name/email/profile pic/etc. can.
        currentUser: "currentUser"
      });
      SessionCore = class extends abstract_model_default {
        /** @internal */
        static _className = "SessionCore";
        /** @internal */
        static _isWatchableKey(key) {
          return isEnumValue(WatchableSessionKeys, key);
        }
        /** @internal */
        /** @internal */
        /**
         * @internal
         */
        constructor(sdk3) {
          super(sdk3, "session");
          this._airtableInterface = sdk3.__airtableInterface;
          const {
            permissionLevel,
            currentUserId,
            enabledFeatureNames
          } = this._airtableInterface.sdkInitData.baseData;
          this._sessionData = {
            permissionLevel,
            currentUserId,
            enabledFeatureNames
          };
          Object.seal(this);
        }
        /**
         * @internal
         */
        get _dataOrNullIfDeleted() {
          return this._sessionData;
        }
        /**
         * The current user, or `null` if the extension is running in a publicly shared base.
         *
         * @example
         * ```js
         * import {useSession} from '@airtable/blocks/[placeholder-path]/ui';
         *
         * function CurrentUser() {
         *     const session = useSession();
         *
         *     if (!session.currentUser) {
         *         return <div>This extension is being used in a public share.</div>;
         *     }
         *
         *     return <ul>
         *         <li>ID: {session.currentUser.id}</li>
         *         <li>E-mail: {session.currentUser.email}</li>
         *         <li>Name: {session.currentUser.name}</li>
         *     </ul>;
         * }
         * ```
         */
        get currentUser() {
          const userId = this._sessionData.currentUserId;
          if (!userId) {
            return null;
          } else {
            const {
              base
            } = this._sdk;
            return base.getCollaboratorByIdIfExists(userId);
          }
        }
        /**
         * Returns true if `featureName` is enabled and automatically tracks an exposure.
         *
         * @internal
         */
        __isFeatureEnabled(featureName) {
          this._airtableInterface.trackExposure(featureName);
          return this.__peekIfFeatureIsEnabled(featureName);
        }
        /**
         * Returns true if `featureName` is enabled; does not track an exposure.
         *
         * @internal
         */
        __peekIfFeatureIsEnabled(featureName) {
          return this._sessionData.enabledFeatureNames.includes(featureName);
        }
        /**
         * @internal
         */
        __applyChangesWithoutTriggeringEvents(changes) {
          const changedKeys = {
            [WatchableSessionKeys.permissionLevel]: false,
            [WatchableSessionKeys.currentUser]: false
          };
          for (const {
            path,
            value
          } of changes) {
            if (path[0] === "permissionLevel") {
              invariant(path.length === 1, "cannot set within permissionLevel");
              invariant(typeof value === "string", "permissionLevel must be a string");
              this._sessionData.permissionLevel = value;
              changedKeys[WatchableSessionKeys.permissionLevel] = true;
            }
            if (path[0] === "collaboratorsById") {
              changedKeys[WatchableSessionKeys.currentUser] = true;
            }
          }
          return changedKeys;
        }
        /**
         * @internal
         */
        __triggerOnChangeForChangedKeys(changedKeys) {
          for (const [key, didChange] of entries2(changedKeys)) {
            if (didChange) {
              this._onChange(key);
            }
          }
        }
      };
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/models/session.js
  var Session;
  var init_session = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/models/session.js"() {
      init_session_core();
      Session = class extends SessionCore {
      };
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/models/mutations_core.js
  var MUTATIONS_MAX_BATCH_SIZE, MUTATIONS_MAX_BODY_SIZE, MUTATION_HOLD_FOR_MS, MutationsCore;
  var init_mutations_core2 = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/models/mutations_core.js"() {
      init_mutations_core();
      init_error_utils();
      init_private_utils();
      MUTATIONS_MAX_BATCH_SIZE = 50;
      MUTATIONS_MAX_BODY_SIZE = 1.9 * 1024 * 1024;
      MUTATION_HOLD_FOR_MS = 100;
      MutationsCore = class {
        /** @internal */
        /** @internal */
        /** @internal */
        /** @internal */
        /** @internal */
        /** @internal */
        /** @hidden */
        constructor(sdk3, session, base, applyModelChanges, applyGlobalConfigUpdates) {
          this._airtableInterface = sdk3.__airtableInterface;
          this._session = session;
          this._sdk = sdk3;
          this._base = base;
          this._applyModelChanges = applyModelChanges;
          this._applyGlobalConfigUpdates = applyGlobalConfigUpdates;
        }
        /** @hidden */
        async applyMutationAsync(mutation) {
          this._assertMutationIsValid(mutation);
          this._assertMutationUnderLimits(mutation);
          const permissionCheck = this.checkPermissionsForMutation(mutation);
          if (!permissionCheck.hasPermission) {
            throw spawnError("Cannot apply %s mutation: %s", mutation.type, permissionCheck.reasonDisplayString);
          }
          const didApplyOptimisticUpdates = this._applyOptimisticUpdatesForMutation(mutation);
          try {
            await this._getAirtableInterfaceAsAirtableInterfaceCore().applyMutationAsync(mutation, {
              holdForMs: MUTATION_HOLD_FOR_MS
            });
          } catch (err) {
            if (didApplyOptimisticUpdates) {
              setTimeout(() => {
                throw err;
              }, 0);
              await new Promise(() => {
              });
            } else {
              throw err;
            }
          }
        }
        /** @hidden */
        checkPermissionsForMutation(mutation) {
          return this._getAirtableInterfaceAsAirtableInterfaceCore().checkPermissionsForMutation(mutation, this._base.__getBaseData());
        }
        // Not really sure why this is necessary. It seems like all callsites could just use
        // this._airtableInterface directly, but TS complains.
        /** @hidden */
        _getAirtableInterfaceAsAirtableInterfaceCore() {
          return this._airtableInterface;
        }
        /** @internal */
        _assertMutationUnderLimits(mutation) {
          if (encodeURIComponent(JSON.stringify(mutation)).length > MUTATIONS_MAX_BODY_SIZE) {
            throw spawnError("Request exceeds maximum size limit of %s bytes", MUTATIONS_MAX_BODY_SIZE);
          }
          if (this._doesMutationExceedBatchSizeLimit(mutation)) {
            throw spawnError("Request exceeds maximum batch size limit of %s items", MUTATIONS_MAX_BATCH_SIZE);
          }
        }
        /** @internal */
        _applyOptimisticUpdatesForMutation(mutation) {
          if (mutation.type === MutationTypesCore.SET_MULTIPLE_GLOBAL_CONFIG_PATHS) {
            const _mutation = mutation;
            this._applyGlobalConfigUpdates(_mutation.updates);
            return true;
          }
          const modelChanges = this._getOptimisticModelChangesForMutation(mutation);
          if (modelChanges.length > 0) {
            this._applyModelChanges(modelChanges);
            return true;
          }
          return false;
        }
        /** @internal */
        _doesMutationExceedBatchSizeLimit(mutation) {
          switch (mutation.type) {
            case MutationTypesCore.SET_MULTIPLE_RECORDS_CELL_VALUES:
            case MutationTypesCore.CREATE_MULTIPLE_RECORDS:
              return mutation.records.length > MUTATIONS_MAX_BATCH_SIZE;
            case MutationTypesCore.DELETE_MULTIPLE_RECORDS:
              return mutation.recordIds.length > MUTATIONS_MAX_BATCH_SIZE;
            case MutationTypesCore.SET_MULTIPLE_GLOBAL_CONFIG_PATHS:
              return mutation.updates.length > MUTATIONS_MAX_BATCH_SIZE;
            // The "default" case cannot be reached because this method is only
            // invoked after the mutation type has been validated.
            // istanbul ignore next
            default:
              return false;
          }
        }
        /** @internal */
        _assertFieldIsValidForMutation(field) {
          if (field.isComputed) {
            throw spawnError("Can't set cell values: Field '%s' is computed and cannot be set", field.name);
          }
        }
        /** @internal */
        _assertMutationIsValid(mutation) {
          const appInterface = this._sdk.__appInterface;
          switch (mutation.type) {
            case MutationTypesCore.SET_MULTIPLE_RECORDS_CELL_VALUES: {
              const {
                tableId,
                records
              } = mutation;
              const table = this._base.getTableByIdIfExists(tableId);
              if (!table) {
                throw spawnError("Can't set cell values: No table with id %s exists", tableId);
              }
              const recordStore = this._base.__getRecordStore(tableId);
              const checkedFieldIds = /* @__PURE__ */ new Set();
              for (const record of records) {
                let existingRecord = null;
                if (this._isRecordStoreReadyForMutations(recordStore)) {
                  existingRecord = recordStore.getRecordByIdIfExists(record.id);
                  if (!existingRecord) {
                    throw spawnError("Can't set cell values: No record with id %s exists", record.id);
                  }
                }
                for (const fieldId of Object.keys(record.cellValuesByFieldId)) {
                  const field = table.getFieldByIdIfExists(fieldId);
                  if (!field) {
                    throw spawnError("Can't set cell values: No field with id %s exists in table '%s'", fieldId, table.name);
                  }
                  if (!checkedFieldIds.has(fieldId)) {
                    this._assertFieldIsValidForMutation(field);
                    checkedFieldIds.add(fieldId);
                  }
                  if (existingRecord && this._isFieldAvailableForMutation(recordStore, field.id)) {
                    const validationResult = this._airtableInterface.fieldTypeProvider.validateCellValueForUpdate(appInterface, record.cellValuesByFieldId[fieldId], existingRecord._getRawCellValue(field), field._data);
                    if (!validationResult.isValid) {
                      throw spawnError("Can't set cell values: invalid cell value for field '%s'.\n%s", field.name, validationResult.reason);
                    }
                  }
                }
              }
              return;
            }
            case MutationTypesCore.DELETE_MULTIPLE_RECORDS: {
              const {
                tableId,
                recordIds
              } = mutation;
              const table = this._base.getTableByIdIfExists(tableId);
              if (!table) {
                throw spawnError("Can't delete records: No table with id %s exists", tableId);
              }
              const recordStore = this._base.__getRecordStore(tableId);
              if (this._isRecordStoreReadyForMutations(recordStore)) {
                for (const recordId of recordIds) {
                  const record = recordStore.getRecordByIdIfExists(recordId);
                  if (!record) {
                    throw spawnError("Can't delete records: No record with id %s exists in table '%s'", recordId, table.name);
                  }
                }
              }
              return;
            }
            case MutationTypesCore.CREATE_MULTIPLE_RECORDS: {
              const {
                tableId,
                records
              } = mutation;
              const checkedFieldIds = /* @__PURE__ */ new Set();
              const table = this._base.getTableByIdIfExists(tableId);
              if (!table) {
                throw spawnError("Can't create records: No table with id %s exists", tableId);
              }
              for (const record of records) {
                for (const fieldId of Object.keys(record.cellValuesByFieldId)) {
                  const field = table.getFieldByIdIfExists(fieldId);
                  if (!field) {
                    throw spawnError("Can't create records: No field with id %s exists in table '%s'", fieldId, table.name);
                  }
                  if (!checkedFieldIds.has(fieldId)) {
                    this._assertFieldIsValidForMutation(field);
                    checkedFieldIds.add(fieldId);
                  }
                  const validationResult = this._airtableInterface.fieldTypeProvider.validateCellValueForUpdate(appInterface, record.cellValuesByFieldId[fieldId], null, field._data);
                  if (!validationResult.isValid) {
                    throw spawnError("Can't create records: invalid cell value for field '%s'.\n%s", field.name, validationResult.reason);
                  }
                }
              }
              return;
            }
            case MutationTypesCore.SET_MULTIPLE_GLOBAL_CONFIG_PATHS: {
              return;
            }
            default:
              throw spawnError("unhandled mutation type: %s", mutation.type);
          }
        }
        /** @internal */
        _getOptimisticModelChangesForMutation(mutation) {
          switch (mutation.type) {
            case MutationTypesCore.SET_MULTIPLE_RECORDS_CELL_VALUES: {
              const {
                tableId,
                records
              } = mutation;
              const recordStore = this._base.__getRecordStore(tableId);
              return records.flatMap((record) => Object.keys(record.cellValuesByFieldId).filter((fieldId) => this._isFieldAvailableForMutation(recordStore, fieldId)).map((fieldId) => ({
                path: ["tablesById", tableId, "recordsById", record.id, "cellValuesByFieldId", fieldId],
                value: record.cellValuesByFieldId[fieldId]
              })));
            }
            case MutationTypesCore.DELETE_MULTIPLE_RECORDS: {
              const {
                tableId,
                recordIds
              } = mutation;
              return recordIds.map((recordId) => ({
                path: ["tablesById", tableId, "recordsById", recordId],
                value: void 0
              }));
            }
            case MutationTypesCore.CREATE_MULTIPLE_RECORDS: {
              const {
                tableId,
                records
              } = mutation;
              const recordStore = this._base.__getRecordStore(tableId);
              return records.map((record) => {
                const filteredCellValuesByFieldId = {};
                for (const [fieldId, cellValue] of entries2(record.cellValuesByFieldId)) {
                  if (this._isFieldAvailableForMutation(recordStore, fieldId)) {
                    filteredCellValuesByFieldId[fieldId] = cellValue;
                  }
                }
                return {
                  path: ["tablesById", tableId, "recordsById", record.id],
                  value: __spreadProps(__spreadValues({}, this._getDefaultRecordProperties()), {
                    id: record.id,
                    cellValuesByFieldId: filteredCellValuesByFieldId
                  })
                };
              });
            }
            // The following branch is unreachable because this method's only
            // call site is preceded by an explicit guard for this condition.
            // istanbul ignore next
            case MutationTypesCore.SET_MULTIPLE_GLOBAL_CONFIG_PATHS: {
              throw spawnError("attempting to generate model updates for SET_MULTIPLE_GLOBAL_CONFIG_PATH");
            }
            // The following branch is unreachable because this method's only
            // call site is preceded by an explicit guard for this condition.
            // istanbul ignore next
            default:
              throw spawnError("unhandled mutation type: %s", mutation.type);
          }
        }
        /** @internal */
        /** @internal */
        /** @internal */
      };
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/types/mutations.js
  var MutationTypes;
  var init_mutations = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/types/mutations.js"() {
      init_mutations_core();
      MutationTypes = Object.freeze(__spreadValues({}, MutationTypesCore));
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/models/mutations.js
  var Mutations;
  var init_mutations2 = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/models/mutations.js"() {
      init_mutations_core2();
      init_mutations();
      Mutations = class extends MutationsCore {
        /** @internal */
        _isRecordStoreReadyForMutations() {
          return true;
        }
        /** @internal */
        _isFieldAvailableForMutation() {
          return true;
        }
        /** @internal */
        _getDefaultRecordProperties() {
          return {
            createdTime: (/* @__PURE__ */ new Date()).toJSON()
          };
        }
        /** @internal */
        _getOptimisticModelChangesForMutation(mutation) {
          switch (mutation.type) {
            case MutationTypes.CREATE_MULTIPLE_RECORDS: {
              return super._getOptimisticModelChangesForMutation(mutation);
            }
            case MutationTypes.DELETE_MULTIPLE_RECORDS: {
              const {
                tableId,
                recordIds: deletedRecordIds
              } = mutation;
              const recordStore = this._base.__getRecordStore(tableId);
              const deletedRecordIdsSet = new Set(deletedRecordIds);
              return [{
                path: ["tablesById", tableId, "recordOrder"],
                value: recordStore.recordIds.filter((recordId) => !deletedRecordIdsSet.has(recordId))
              }, ...super._getOptimisticModelChangesForMutation(mutation)];
            }
            default: {
              return super._getOptimisticModelChangesForMutation(mutation);
            }
          }
        }
      };
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/models/base_core.js
  var WatchableBaseKeys, BaseCore;
  var init_base_core = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/models/base_core.js"() {
      init_private_utils();
      init_error_utils();
      init_abstract_model();
      WatchableBaseKeys = Object.freeze({
        name: "name",
        tables: "tables",
        collaborators: "collaborators",
        schema: "schema",
        color: "color"
      });
      BaseCore = class extends abstract_model_default {
        /** @internal */
        static _className = "BaseCore";
        /** @internal */
        static _isWatchableKey(key) {
          return isEnumValue(WatchableBaseKeys, key);
        }
        /** @internal */
        /** @internal */
        _tableRecordStoresByTableId = {};
        /** @internal */
        /** @internal */
        _collaboratorIdsByNameAndEmail = null;
        /**
         * @internal
         */
        constructor(sdk3) {
          super(sdk3, sdk3.__airtableInterface.sdkInitData.baseData.id);
          this._tableModelsById = {};
          this.__billingPlanGrouping = sdk3.__airtableInterface.sdkInitData.baseData.billingPlanGrouping;
        }
        /**
         * Aliased to communicate stability for internal use by Sdk code.
         *
         * @internal
         */
        get __sdk() {
          return this._sdk;
        }
        /**
         * @internal
         */
        get _dataOrNullIfDeleted() {
          return this._baseData;
        }
        /**
         * The name of the base.
         *
         * @example
         * ```js
         * import {useBase} from '@airtable/blocks/[placeholder-path]/ui';
         *
         * function MyApp() {
         *     const base = useBase();
         *     console.log('The name of your base is', base.name);
         * }
         * ```
         */
        get name() {
          return this._data.name;
        }
        /**
         * The workspace id of the base.
         *
         * @example
         * ```js
         * import {useBase} from '@airtable/blocks/[placeholder-path]/ui';
         *
         * function MyApp() {
         *     const base = useBase();
         *     console.log('The workspace id of your base is', base.workspaceId);
         * }
         * ```
         */
        get workspaceId() {
          return this._data.workspaceId;
        }
        /**
         * The color of the base.
         *
         * @example
         * ```js
         * import {colorUtils, useBase} from '@airtable/blocks/[placeholder-path]/ui';
         *
         * function MyApp() {
         *     const base = useBase();
         *     return (
         *         <div style={{backgroundColor: colorUtils.getHexForColor(base.color)}}>
         *             This div's background is the same color as the base background
         *         </div>
         *     );
         * }
         * ```
         */
        get color() {
          return this._data.color;
        }
        /**
         * The tables in this base. Can be watched to know when tables are created, deleted, or reordered in the base.
         *
         * @example
         * ```js
         * import {useBase} from '@airtable/blocks/[placeholder-path]/ui';
         *
         * function MyApp() {
         *     const base = useBase();
         *     console.log(`You have ${base.tables.length} tables`);
         * }
         * ```
         */
        get tables() {
          const tables = [];
          for (const tableId of this._data.tableOrder) {
            const table = this.getTableByIdIfExists(tableId);
            if (table) {
              tables.push(table);
            }
          }
          return tables;
        }
        /** @internal */
        /** @internal */
        /**
         * The users who have access to this base.
         *
         * @example
         * ```js
         * import {useBase} from '@airtable/blocks/[placeholder-path]/ui';
         *
         * function MyApp() {
         *     const base = useBase();
         *     console.log(base.activeCollaborators[0].email);
         * }
         * ```
         */
        get activeCollaborators() {
          return this._data.activeCollaboratorIds.map((collaboratorId) => this.getCollaboratorById(collaboratorId));
        }
        /**
         * The user matching the given ID, or `null` if that user does not exist or does not have access
         * to this base.
         *
         * @param collaboratorId The ID of the user.
         */
        getCollaboratorByIdIfExists(collaboratorId) {
          const collaboratorsById = this._data.collaboratorsById;
          return has3(collaboratorsById, collaboratorId) ? collaboratorsById[collaboratorId] : null;
        }
        /**
         * The user matching the given ID. Throws if that user does not exist
         * or does not have access to this base. Use {@link getCollaboratorByIdIfExists}
         * instead if you are unsure whether a collaborator with the given ID exists
         * and has access to this base.
         *
         * @param collaboratorId The ID of the user.
         */
        getCollaboratorById(collaboratorId) {
          const collaborator = this.getCollaboratorByIdIfExists(collaboratorId);
          if (!collaborator) {
            throw spawnError("No collaborator with ID %s has access to base '%s'", collaboratorId, this.name);
          }
          return collaborator;
        }
        /**
         * The user matching the given ID, name, or email address. Returns null if that user does not
         * exist or does not have access to this base.
         *
         * This method is convenient when building an extension for a specific base, but for more generic
         * extensions the best practice is to use the {@link getCollaboratorByIdIfExists} method instead.
         *
         * @param collaboratorIdOrNameOrEmail The ID of the user.
         */
        getCollaboratorIfExists(idOrNameOrEmail) {
          const collaboratorById = this.getCollaboratorByIdIfExists(idOrNameOrEmail);
          if (collaboratorById) {
            return collaboratorById;
          }
          if (!this._collaboratorIdsByNameAndEmail) {
            this._collaboratorIdsByNameAndEmail = /* @__PURE__ */ new Map();
            for (const [id, {
              email,
              name
            }] of entries2(this._data.collaboratorsById)) {
              this._collaboratorIdsByNameAndEmail.set(email, id);
              if (name && !this._collaboratorIdsByNameAndEmail.has(name)) {
                this._collaboratorIdsByNameAndEmail.set(name, id);
              }
            }
          }
          const idForNameOrEmail = this._collaboratorIdsByNameAndEmail.get(idOrNameOrEmail);
          if (idForNameOrEmail !== void 0) {
            return this.getCollaboratorById(idForNameOrEmail);
          }
          return null;
        }
        /**
         * The user matching the given ID, name, or email address. Throws if that user does not exist
         * or does not have access to this base. Use {@link getCollaboratorIfExists} instead if you are
         * unsure whether a collaborator with the given ID exists and has access to this base.
         *
         * This method is convenient when building an extension for a specific base, but for more generic
         * extensions the best practice is to use the {@link getCollaboratorById} method instead.
         *
         * @param collaboratorIdOrNameOrEmail The ID of the user.
         */
        getCollaborator(idOrNameOrEmail) {
          const collaborator = this.getCollaboratorIfExists(idOrNameOrEmail);
          if (!collaborator) {
            throw spawnError("No collaborator with ID, name, or email of '%s' is in base '%s'", idOrNameOrEmail, this.name);
          }
          return collaborator;
        }
        /**
         * @internal
         */
        __getBaseData() {
          return this._data;
        }
        /**
         * The table matching the given ID, or `null` if that table does not exist in this base.
         *
         * @param tableId The ID of the table.
         */
        getTableByIdIfExists(tableId) {
          if (!this._data.tablesById[tableId]) {
            return null;
          } else {
            if (!this._tableModelsById[tableId]) {
              this._tableModelsById[tableId] = this._constructTable(tableId);
            }
            return this._tableModelsById[tableId];
          }
        }
        /**
         * The table matching the given ID. Throws if that table does not exist in this base. Use
         * {@link getTableByIdIfExists} instead if you are unsure whether a table exists with the given
         * ID.
         *
         * @param tableId The ID of the table.
         */
        getTableById(tableId) {
          const table = this.getTableByIdIfExists(tableId);
          if (!table) {
            throw spawnError("No table with ID %s in base '%s'", tableId, this.name);
          }
          return table;
        }
        /**
         * The table matching the given name, or `null` if no table exists with that name in this base.
         *
         * @param tableName The name of the table you're looking for.
         */
        getTableByNameIfExists(tableName) {
          for (const [tableId, tableData] of entries2(this._data.tablesById)) {
            if (tableData.name === tableName) {
              return this.getTableByIdIfExists(tableId);
            }
          }
          return null;
        }
        /**
         * The table matching the given name. Throws if no table exists with that name in this base. Use
         * {@link getTableByNameIfExists} instead if you are unsure whether a table exists with the
         * given name.
         *
         * @param tableName The name of the table you're looking for.
         */
        getTableByName(tableName) {
          const table = this.getTableByNameIfExists(tableName);
          if (!table) {
            throw spawnError("No table named '%s' in base '%s'", tableName, this.name);
          }
          return table;
        }
        /**
         * The table matching the given ID or name. Returns `null` if no matching table exists within
         * this base.
         *
         * This method is convenient when building an extension for a specific base, but for more generic
         * extensions the best practice is to use the {@link getTableByIdIfExists} or
         * {@link getTableByNameIfExists} methods instead.
         *
         * @param tableIdOrName The ID or name of the table you're looking for.
         */
        getTableIfExists(tableIdOrName) {
          return this.getTableByIdIfExists(tableIdOrName) ?? this.getTableByNameIfExists(tableIdOrName);
        }
        /**
         * The table matching the given ID or name. Throws if no matching table exists within this base.
         * Use {@link getTableIfExists} instead if you are unsure whether a table exists with the given
         * name/ID.
         *
         * This method is convenient when building an extension for a specific base, but for more generic
         * extensions the best practice is to use the {@link getTableById} or {@link getTableByName} methods
         * instead.
         *
         * @param tableIdOrName The ID or name of the table you're looking for.
         */
        getTable(tableIdOrName) {
          const table = this.getTableIfExists(tableIdOrName);
          if (!table) {
            throw spawnError("No table with ID or name '%s' in base '%s'", tableIdOrName, this.name);
          }
          return table;
        }
        /**
         * Returns the maximum number of records allowed in each table of this base.
         */
        getMaxRecordsPerTable() {
          return this._data.maxRowsPerTable ?? 1e5;
        }
        /**
         * @internal
         */
        __getRecordStore(tableId) {
          if (has3(this._tableRecordStoresByTableId, tableId)) {
            return this._tableRecordStoresByTableId[tableId];
          }
          invariant(this._data.tablesById[tableId], "table must exist");
          const newRecordStore = this._constructRecordStore(this._sdk, tableId);
          this._tableRecordStoresByTableId[tableId] = newRecordStore;
          return newRecordStore;
        }
        /**
         * @internal
         */
        __triggerOnChangeForChangedPaths(changedPaths) {
          let didSchemaChange = false;
          if (changedPaths.name) {
            this._onChange(WatchableBaseKeys.name);
            didSchemaChange = true;
          }
          if (changedPaths.color) {
            this._onChange(WatchableBaseKeys.color);
            didSchemaChange = true;
          }
          if (changedPaths.tableOrder) {
            this._onChange(WatchableBaseKeys.tables);
            didSchemaChange = true;
            for (const [tableId, tableModel] of entries2(this._tableModelsById)) {
              if (tableModel.isDeleted) {
                delete this._tableModelsById[tableId];
              }
            }
            for (const [tableId, recordStore] of entries2(this._tableRecordStoresByTableId)) {
              if (recordStore && recordStore.isDeleted) {
                recordStore.__onDataDeletion();
                delete this._tableRecordStoresByTableId[tableId];
              }
            }
          }
          const {
            tablesById
          } = changedPaths;
          if (tablesById) {
            if (isDeepEqual(tablesById, {
              _isDirty: true
            })) {
              didSchemaChange = true;
            } else {
              for (const [tableId, dirtyTablePaths] of entries2(tablesById)) {
                const table = this.getTableByIdIfExists(tableId);
                if (table && dirtyTablePaths) {
                  const didTableSchemaChange = table.__triggerOnChangeForDirtyPaths(dirtyTablePaths);
                  if (didTableSchemaChange) {
                    didSchemaChange = true;
                  }
                }
              }
            }
          }
          if (changedPaths.collaboratorsById || changedPaths.activeCollaboratorIds) {
            this._onChange(WatchableBaseKeys.collaborators);
          }
          if (changedPaths.appInterface) {
            didSchemaChange = true;
          }
          if (didSchemaChange) {
            this._onChange(WatchableBaseKeys.schema);
          }
        }
        /**
         * @internal
         */
        __applyChangesWithoutTriggeringEvents(changes) {
          const changedPaths = {};
          for (const change of changes) {
            this._applyChange(change.path, change.value, changedPaths);
          }
          return changedPaths;
        }
        /**
         * @internal
         */
        _applyChange(path, value, changedPathsByRef) {
          let dataSubtree = this._data;
          let dirtySubtree = changedPathsByRef;
          for (let i = 0; i < path.length - 1; i++) {
            const part = path[i];
            if (!dataSubtree[part]) {
              dataSubtree[part] = {};
            }
            dataSubtree = dataSubtree[part];
            if (!dirtySubtree[part]) {
              dirtySubtree[part] = {};
            }
            invariant(dirtySubtree[part], "dirtySubtree");
            dirtySubtree = dirtySubtree[part];
          }
          const lastPathPart = path[path.length - 1];
          const didChange = !isDeepEqual(dataSubtree[lastPathPart], value);
          if (value === void 0) {
            delete dataSubtree[lastPathPart];
          } else {
            dataSubtree[lastPathPart] = value;
          }
          if (didChange) {
            if (!dirtySubtree[lastPathPart]) {
              dirtySubtree[lastPathPart] = {};
            }
            invariant(dirtySubtree[lastPathPart], "dirtySubtree");
            dirtySubtree[lastPathPart]._isDirty = true;
          }
        }
      };
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/types/field_core.js
  var FieldType;
  var init_field_core = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/types/field_core.js"() {
      FieldType = /* @__PURE__ */ (function(FieldType2) {
        FieldType2["SINGLE_LINE_TEXT"] = "singleLineText";
        FieldType2["EMAIL"] = "email";
        FieldType2["URL"] = "url";
        FieldType2["MULTILINE_TEXT"] = "multilineText";
        FieldType2["NUMBER"] = "number";
        FieldType2["PERCENT"] = "percent";
        FieldType2["CURRENCY"] = "currency";
        FieldType2["SINGLE_SELECT"] = "singleSelect";
        FieldType2["MULTIPLE_SELECTS"] = "multipleSelects";
        FieldType2["SINGLE_COLLABORATOR"] = "singleCollaborator";
        FieldType2["MULTIPLE_COLLABORATORS"] = "multipleCollaborators";
        FieldType2["MULTIPLE_RECORD_LINKS"] = "multipleRecordLinks";
        FieldType2["DATE"] = "date";
        FieldType2["DATE_TIME"] = "dateTime";
        FieldType2["PHONE_NUMBER"] = "phoneNumber";
        FieldType2["MULTIPLE_ATTACHMENTS"] = "multipleAttachments";
        FieldType2["CHECKBOX"] = "checkbox";
        FieldType2["FORMULA"] = "formula";
        FieldType2["CREATED_TIME"] = "createdTime";
        FieldType2["ROLLUP"] = "rollup";
        FieldType2["COUNT"] = "count";
        FieldType2["MULTIPLE_LOOKUP_VALUES"] = "multipleLookupValues";
        FieldType2["AUTO_NUMBER"] = "autoNumber";
        FieldType2["BARCODE"] = "barcode";
        FieldType2["RATING"] = "rating";
        FieldType2["RICH_TEXT"] = "richText";
        FieldType2["DURATION"] = "duration";
        FieldType2["LAST_MODIFIED_TIME"] = "lastModifiedTime";
        FieldType2["CREATED_BY"] = "createdBy";
        FieldType2["LAST_MODIFIED_BY"] = "lastModifiedBy";
        FieldType2["BUTTON"] = "button";
        FieldType2["EXTERNAL_SYNC_SOURCE"] = "externalSyncSource";
        FieldType2["AI_TEXT"] = "aiText";
        return FieldType2;
      })({});
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/models/field_core.js
  var WatchableFieldKeys, FieldCore;
  var init_field_core2 = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/models/field_core.js"() {
      init_field_core();
      init_private_utils();
      init_abstract_model();
      WatchableFieldKeys = Object.freeze({
        name: "name",
        type: "type",
        options: "options",
        isComputed: "isComputed",
        description: "description",
        isFieldSynced: "isFieldSynced"
      });
      FieldCore = class extends abstract_model_default {
        /** @internal */
        static _className = "FieldCore";
        /** @internal */
        static _isWatchableKey(key) {
          return isEnumValue(WatchableFieldKeys, key);
        }
        /** @internal */
        /** @internal */
        /**
         * @internal
         */
        constructor(sdk3, parentTable, fieldId) {
          super(sdk3, fieldId);
          this._parentTable = parentTable;
          this._cachedFieldTypeConfigOrNull = null;
        }
        /**
         * @internal
         */
        get _dataOrNullIfDeleted() {
          const tableData = this._baseData.tablesById[this.parentTable.id];
          return tableData?.fieldsById[this._id] ?? null;
        }
        /**
         * The table that this field belongs to. Should never change because fields aren't moved between tables.
         *
         * @internal (since we may not be able to return parent model instances in the immutable models world)
         * @example
         * ```js
         * const field = myTable.getFieldByName('Name');
         * console.log(field.parentTable.id === myTable.id);
         * // => true
         * ```
         */
        get parentTable() {
          return this._parentTable;
        }
        /**
         * The name of the field. Can be watched.
         *
         * @example
         * ```js
         * console.log(myField.name);
         * // => 'Name'
         * ```
         */
        get name() {
          return this._data.name;
        }
        /**
         * The type of the field. Can be watched.
         *
         * @example
         * ```js
         * console.log(myField.type);
         * // => 'singleLineText'
         * ```
         */
        get type() {
          const {
            type
          } = this._getCachedConfigFromFieldTypeProvider();
          if (type === "lookup") {
            return FieldType.MULTIPLE_LOOKUP_VALUES;
          } else {
            return type;
          }
        }
        /**
         * The configuration options of the field. The structure of the field's
         * options depend on the field's type. `null` if the field has no options.
         * See {@link FieldType} for more information on the options for each field
         * type. Can be watched.
         *
         * @see {@link FieldType}
         * @example
         * ```js
         * import {FieldType} from '@airtable/blocks/[placeholder-path]/models';
         *
         * if (myField.type === FieldType.CURRENCY) {
         *     console.log(myField.options.symbol);
         *     // => '$'
         * }
         * ```
         */
        get options() {
          const {
            options
          } = this._getCachedConfigFromFieldTypeProvider();
          return options ? cloneDeep(options) : null;
        }
        // We use a cached response from FieldTypeProvider because getting the config can
        // be an expensive operation. In particular when fieldConfigs are extremely large
        // (eg: Select fields with lots of select options)
        _getCachedConfigFromFieldTypeProvider() {
          if (this._cachedFieldTypeConfigOrNull !== null) {
            return this._cachedFieldTypeConfigOrNull;
          }
          const airtableInterface2 = this._sdk.__airtableInterface;
          const appInterface = this._sdk.__appInterface;
          this._cachedFieldTypeConfigOrNull = airtableInterface2.fieldTypeProvider.getConfig(appInterface, this._data, this.parentTable.__getFieldNamesById());
          return this._cachedFieldTypeConfigOrNull;
        }
        _clearCachedConfig() {
          this._cachedFieldTypeConfigOrNull = null;
        }
        /**
         * The type and options of the field to make type narrowing `FieldOptions` easier.
         * See {@link FieldType} for more information on the options for each field type.
         *
         * @see {@link FieldConfig}
         * @example
         * const fieldConfig = field.config;
         * if (fieldConfig.type === FieldType.SINGLE_SELECT) {
         *     return fieldConfig.options.choices;
         * } else if (fieldConfig.type === FieldType.MULTIPLE_LOOKUP_VALUES && fieldConfig.options.isValid) {
         *     if (fieldConfig.options.result.type === FieldType.SINGLE_SELECT) {
         *         return fieldConfig.options.result.options.choices;
         *     }
         * }
         * return DEFAULT_CHOICES;
         */
        get config() {
          return {
            type: this.type,
            options: this.options
          };
        }
        /**
         * `true` if this field is synced, `false` otherwise. A field is
         * "synced" if it's source is from another airtable base or external data source
         * like Google Calendar, Jira, etc..
         *
         * @hidden
         */
        get isFieldSynced() {
          return this._data.isSynced ?? false;
        }
        /**
         * `true` if this field is computed, `false` otherwise. A field is
         * "computed" if it's value is not set by user input (e.g. autoNumber, formula,
         * etc.). Can be watched
         *
         * @example
         * ```js
         * console.log(mySingleLineTextField.isComputed);
         * // => false
         * console.log(myAutoNumberField.isComputed);
         * // => true
         * ```
         */
        get isComputed() {
          const airtableInterface2 = this._sdk.__airtableInterface;
          return airtableInterface2.fieldTypeProvider.isComputed(this._data);
        }
        /**
         * `true` if this field is its parent table's primary field, `false` otherwise.
         * Should never change because the primary field of a table cannot change.
         */
        get isPrimaryField() {
          return this.id === this.parentTable.primaryField.id;
        }
        /**
         * The description of the field, if it has one. Can be watched.
         *
         * @example
         * ```js
         * console.log(myField.description);
         * // => 'This is my field'
         * ```
         */
        get description() {
          return this._data.description;
        }
        /**
         * Attempt to parse a given string and return a valid cell value for the field's current config.
         * Returns `null` if unable to parse the given string.
         *
         * @param string The string to parse.
         * @example
         * ```js
         * const inputString = '42';
         * const cellValue = myNumberField.convertStringToCellValue(inputString);
         * console.log(cellValue === 42);
         * // => true
         * ```
         */
        convertStringToCellValue(string) {
          const airtableInterface2 = this._sdk.__airtableInterface;
          const appInterface = this._sdk.__appInterface;
          const cellValue = airtableInterface2.fieldTypeProvider.convertStringToCellValue(
            appInterface,
            string,
            this._data,
            // The opt parseDateCellValueInColumnTimeZone is used here to ensure date string
            // inputs are interpreted correctly according to the `timeZone` of the dateTime field.
            {
              parseDateCellValueInColumnTimeZone: this.type === FieldType.DATE_TIME
            }
          );
          if (this.isComputed) {
            return cellValue;
          }
          const validationResult = airtableInterface2.fieldTypeProvider.validateCellValueForUpdate(appInterface, cellValue, null, this._data);
          if (validationResult.isValid) {
            return cellValue;
          } else {
            return null;
          }
        }
        /**
         * @internal
         */
        __triggerOnChangeForDirtyPaths(dirtyPaths) {
          this._clearCachedConfig();
          if (dirtyPaths.name) {
            this._onChange(WatchableFieldKeys.name);
          }
          if (dirtyPaths.type) {
            this._onChange(WatchableFieldKeys.type);
            this._onChange(WatchableFieldKeys.isComputed);
          }
          if (dirtyPaths.typeOptions) {
            this._onChange(WatchableFieldKeys.options);
          }
          if (dirtyPaths.description) {
            this._onChange(WatchableFieldKeys.description);
          }
          if (dirtyPaths.isSynced) {
            this._onChange(WatchableFieldKeys.isFieldSynced);
          }
        }
      };
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/models/table_core.js
  var WatchableTableKeysCore, TableCore;
  var init_table_core = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/models/table_core.js"() {
      init_private_utils();
      init_error_utils();
      init_mutations_core();
      init_abstract_model();
      init_field_core2();
      WatchableTableKeysCore = Object.freeze({
        name: "name",
        description: "description",
        fields: "fields"
      });
      TableCore = class extends abstract_model_default {
        /** @internal */
        static _className = "TableCore";
        /** @internal */
        static _isWatchableKey(key) {
          return isEnumValue(WatchableTableKeysCore, key);
        }
        /** @internal */
        /** @internal */
        /** @internal */
        /** @internal */
        /**
         * @internal
         */
        constructor(parentBase, recordStore, tableId, sdk3) {
          super(sdk3, tableId);
          this._parentBase = parentBase;
          this._recordStore = recordStore;
          this._fieldModelsById = {};
          this._cachedFieldNamesById = null;
        }
        /**
         * @internal
         */
        get _dataOrNullIfDeleted() {
          return this._baseData.tablesById[this._id] ?? null;
        }
        /**
         * The base that this table belongs to.
         *
         * @internal (since we may not be able to return parent model instances in the immutable models world)
         * @example
         * ```js
         * import {base} from '@airtable/blocks/base';
         * const table = base.getTableByName('Table 1');
         * console.log(table.parentBase.id === base.id);
         * // => true
         * ```
         */
        get parentBase() {
          return this._parentBase;
        }
        /**
         * The name of the table. Can be watched.
         *
         * @example
         * ```js
         * console.log(myTable.name);
         * // => 'Table 1'
         * ```
         */
        get name() {
          return this._data.name;
        }
        /**
         * The description of the table, if it has one. Can be watched.
         *
         * @example
         * ```js
         * console.log(myTable.description);
         * // => 'This is my table'
         * ```
         */
        get description() {
          return this._data.description;
        }
        /**
         * The table's primary field. Every table has exactly one primary
         * field. The primary field of a table will not change.
         *
         * @example
         * ```js
         * console.log(myTable.primaryField.name);
         * // => 'Name'
         * ```
         */
        get primaryField() {
          const primaryField = this.getFieldById(this._data.primaryFieldId);
          return primaryField;
        }
        /**
         * The fields in this table. The order is arbitrary, since fields are
         * only ordered in the context of a specific view.
         *
         * Can be watched to know when fields are created or deleted.
         *
         * @example
         * ```js
         * console.log(`This table has ${myTable.fields.length} fields`);
         * ```
         */
        get fields() {
          const fields = [];
          for (const fieldId of Object.keys(this._data.fieldsById)) {
            const field = this.getFieldById(fieldId);
            fields.push(field);
          }
          return fields;
        }
        /**
         * Gets the field matching the given ID, or `null` if that field does not exist in this table.
          * @param fieldId The ID of the field.
         * @example
         * ```js
         * const fieldId = 'fldxxxxxxxxxxxxxx';
         * const field = myTable.getFieldByIdIfExists(fieldId);
         * if (field !== null) {
         *     console.log(field.name);
         * } else {
         *     console.log('No field exists with that ID');
         * }
         * ```
         */
        getFieldByIdIfExists(fieldId) {
          if (!this._data.fieldsById[fieldId]) {
            return null;
          } else {
            if (!this._fieldModelsById[fieldId]) {
              this._fieldModelsById[fieldId] = this._constructField(fieldId);
            }
            return this._fieldModelsById[fieldId];
          }
        }
        /** @internal */
        /**
         * Gets the field matching the given ID. Throws if that field does not exist in this table. Use
         * {@link getFieldByIdIfExists} instead if you are unsure whether a field exists with the given
         * ID.
         *
         * @param fieldId The ID of the field.
         * @example
         * ```js
         * const fieldId = 'fldxxxxxxxxxxxxxx';
         * const field = myTable.getFieldById(fieldId);
         * console.log(field.name);
         * // => 'Name'
         * ```
         */
        getFieldById(fieldId) {
          const field = this.getFieldByIdIfExists(fieldId);
          if (!field) {
            throw spawnError("No field with ID %s in table '%s'", fieldId, this.name);
          }
          return field;
        }
        /**
         * Gets the field matching the given name, or `null` if no field exists with that name in this
         * table.
         *
         * @param fieldName The name of the field you're looking for.
         * @example
         * ```js
         * const field = myTable.getFieldByNameIfExists('Name');
         * if (field !== null) {
         *     console.log(field.id);
         * } else {
         *     console.log('No field exists with that name');
         * }
         * ```
         */
        getFieldByNameIfExists(fieldName) {
          for (const [fieldId, fieldData] of entries2(this._data.fieldsById)) {
            if (fieldData.name === fieldName) {
              return this.getFieldByIdIfExists(fieldId);
            }
          }
          return null;
        }
        /**
         * Gets the field matching the given name. Throws if no field exists with that name in this
         * table. Use {@link getFieldByNameIfExists} instead if you are unsure whether a field exists
         * with the given name.
         *
         * @param fieldName The name of the field you're looking for.
         * @example
         * ```js
         * const field = myTable.getFieldByName('Name');
         * console.log(field.id);
         * // => 'fldxxxxxxxxxxxxxx'
         * ```
         */
        getFieldByName(fieldName) {
          const field = this.getFieldByNameIfExists(fieldName);
          if (!field) {
            throw spawnError("No field named '%s' in table '%s'", fieldName, this.name);
          }
          return field;
        }
        /**
         * The field matching the given ID or name. Returns `null` if no matching field exists within
         * this table.
         *
         * This method is convenient when building an extension for a specific base, but for more generic
         * extensions the best practice is to use the {@link getFieldByIdIfExists} or
         * {@link getFieldByNameIfExists} methods instead.
         *
         * @param fieldIdOrName The ID or name of the field you're looking for.
         */
        getFieldIfExists(fieldIdOrName) {
          return this.getFieldByIdIfExists(fieldIdOrName) ?? this.getFieldByNameIfExists(fieldIdOrName);
        }
        /**
         * The field matching the given ID or name. Throws if no matching field exists within this table.
         * Use {@link getFieldIfExists} instead if you are unsure whether a field exists with the given
         * name/ID.
         *
         * This method is convenient when building an extension for a specific base, but for more generic
         * extensions the best practice is to use the {@link getFieldById} or {@link getFieldByName} methods
         * instead.
         *
         * @param fieldIdOrName The ID or name of the field you're looking for.
         */
        getField(fieldIdOrName) {
          const field = this.getFieldIfExists(fieldIdOrName);
          if (!field) {
            throw spawnError("No field with ID or name '%s' in table '%s'", fieldIdOrName, this.name);
          }
          return field;
        }
        /** @internal */
        _cellValuesByFieldIdOrNameToCellValuesByFieldId(cellValuesByFieldIdOrName, onGenerateIdForNewForeignRecord) {
          return Object.fromEntries(entries2(cellValuesByFieldIdOrName).map((_ref) => {
            let [fieldIdOrName, cellValue] = _ref;
            const field = this.__getFieldMatching(fieldIdOrName);
            return [field.id, this._adjustCellValueForFieldIfNecessary(field, cellValue, onGenerateIdForNewForeignRecord)];
          }));
        }
        // This can be overridden by subclasses. See sdk/src/interface/models/table.ts.
        /** @internal */
        _adjustCellValueForFieldIfNecessary(field, cellValue, onGenerateIdForNewForeignRecord) {
          return cellValue;
        }
        /**
         * @internal
         */
        __getFieldMatching(fieldOrFieldIdOrFieldName) {
          let field;
          if (fieldOrFieldIdOrFieldName instanceof FieldCore) {
            if (fieldOrFieldIdOrFieldName.parentTable.id !== this.id) {
              throw spawnError("Field '%s' is from a different table than table '%s'", fieldOrFieldIdOrFieldName.name, this.name);
            }
            field = fieldOrFieldIdOrFieldName;
          } else {
            field = this.getFieldByIdIfExists(fieldOrFieldIdOrFieldName) || this.getFieldByNameIfExists(fieldOrFieldIdOrFieldName);
            if (field === null) {
              throw spawnError("Field '%s' does not exist in table '%s'", fieldOrFieldIdOrFieldName, this.name);
            }
          }
          if (field.isDeleted) {
            throw spawnError("Field '%s' was deleted from table '%s'", field.name, this.name);
          }
          return field;
        }
        /**
         * Updates cell values for a record.
         *
         * Throws an error if the user does not have permission to update the given cell values in
         * the record, or if invalid input is provided (eg. invalid cell values).
         *
         * Refer to {@link FieldType} for cell value write formats.
         *
         * This action is asynchronous: `await` the returned promise if you wish to wait for the updated
         * cell values to be persisted to Airtable servers.
         * Updates are applied optimistically locally, so your changes will be reflected in your extension
         * before the promise resolves.
         *
         * @param recordOrRecordId the record to update
         * @param fields cell values to update in that record, specified as object mapping `FieldId` or field name to value for that field.
         * @example
         * ```js
         * function updateRecord(record, recordFields) {
         *     if (table.hasPermissionToUpdateRecord(record, recordFields)) {
         *         table.updateRecordAsync(record, recordFields);
         *     }
         *     // The updated values will now show in your extension (eg in
         *     // `table.selectRecords()` result) but are still being saved to Airtable
         *     // servers (e.g. other users may not be able to see them yet).
         * }
         *
         * async function updateRecordAsync(record, recordFields) {
         *     if (table.hasPermissionToUpdateRecord(record, recordFields)) {
         *         await table.updateRecordAsync(record, recordFields);
         *     }
         *     // New record has been saved to Airtable servers.
         *     alert(`record with ID ${record.id} has been updated`);
         * }
         *
         * // Fields can be specified by name or ID
         * updateRecord(record1, {
         *     'Post Title': 'How to make: orange-mango pound cake',
         *     'Publication Date': '2020-01-01',
         * });
         * updateRecord(record2, {
         *     [postTitleField.id]: 'Cake decorating tips & tricks',
         *     [publicationDateField.id]: '2020-02-02',
         * });
         *
         * // Cell values should generally have format matching the output of
         * // record.getCellValue() for the field being updated
         * updateRecord(record1, {
         *     'Category (single select)': {name: 'Recipe'},
         *     'Tags (multiple select)': [{name: 'Desserts'}, {id: 'someChoiceId'}],
         *     'Images (attachment)': [{url: 'http://mywebsite.com/cake.png'}],
         *     'Related posts (linked records)': [{id: 'someRecordId'}],
         * });
         * ```
         */
        async updateRecordAsync(recordOrRecordId, fields) {
          const recordId = typeof recordOrRecordId === "string" ? recordOrRecordId : recordOrRecordId.id;
          await this.updateRecordsAsync([{
            id: recordId,
            fields
          }]);
        }
        /**
         * Checks whether the current user has permission to perform the given record update.
         *
         * Accepts partial input, in the same format as {@link updateRecordAsync}.
         * The more information provided, the more accurate the permissions check will be.
         *
         * Returns `{hasPermission: true}` if the current user can update the specified record,
         * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
         * used to display an error message to the user.
         *
         * @param recordOrRecordId the record to update
         * @param fields cell values to update in that record, specified as object mapping `FieldId` or field name to value for that field.
         * @example
         * ```js
         * // Check if user can update specific fields for a specific record.
         * const updateRecordCheckResult =
         *     table.checkPermissionsForUpdateRecord(record, {
         *         'Post Title': 'How to make: orange-mango pound cake',
         *         'Publication Date': '2020-01-01',
         *     });
         * if (!updateRecordCheckResult.hasPermission) {
         *     alert(updateRecordCheckResult.reasonDisplayString);
         * }
         *
         * // Like updateRecordAsync, you can use either field names or field IDs.
         * const updateRecordCheckResultWithFieldIds =
         *     table.checkPermissionsForUpdateRecord(record, {
         *         [postTitleField.id]: 'Cake decorating tips & tricks',
         *         [publicationDateField.id]: '2020-02-02',
         *     });
         *
         * // Check if user could update a given record, when you don't know the
         * // specific fields that will be updated yet (e.g. to check whether you should
         * // allow a user to select a certain record to update).
         * const updateUnknownFieldsCheckResult =
         *     table.checkPermissionsForUpdateRecord(record);
         *
         * // Check if user could update specific fields, when you don't know the
         * // specific record that will be updated yet. (for example, if the field is
         * // selected by the user and you want to check if your extension can write to it).
         * const updateUnknownRecordCheckResult =
         *     table.checkPermissionsForUpdateRecord(undefined, {
         *         'My field name': 'updated value',
         *         // You can use undefined if you know you're going to update a field,
         *         // but don't know the new cell value yet.
         *         'Another field name': undefined,
         *     });
         *
         * // Check if user could perform updates within the table, without knowing the
         * // specific record or fields that will be updated yet (e.g., to render your
         * // extension in "read only" mode).
         * const updateUnknownRecordAndFieldsCheckResult =
         *     table.checkPermissionsForUpdateRecord();
         * ```
         */
        checkPermissionsForUpdateRecord(recordOrRecordId, fields) {
          const recordId = typeof recordOrRecordId === "object" && recordOrRecordId !== null ? recordOrRecordId.id : recordOrRecordId;
          return this.checkPermissionsForUpdateRecords([{
            id: recordId,
            fields
          }]);
        }
        /**
         * An alias for `checkPermissionsForUpdateRecord(recordOrRecordId, fields).hasPermission`.
         *
         * Checks whether the current user has permission to perform the given record update.
         *
         * Accepts partial input, in the same format as {@link updateRecordAsync}.
         * The more information provided, the more accurate the permissions check will be.
         *
         * @param recordOrRecordId the record to update
         * @param fields cell values to update in that record, specified as object mapping `FieldId` or field name to value for that field.
         * @example
         * ```js
         * // Check if user can update specific fields for a specific record.
         * const canUpdateRecord = table.hasPermissionToUpdateRecord(record, {
         *     'Post Title': 'How to make: orange-mango pound cake',
         *     'Publication Date': '2020-01-01',
         * });
         * if (!canUpdateRecord) {
         *     alert('not allowed!');
         * }
         *
         * // Like updateRecordAsync, you can use either field names or field IDs.
         * const canUpdateRecordWithFieldIds =
         *     table.hasPermissionToUpdateRecord(record, {
         *         [postTitleField.id]: 'Cake decorating tips & tricks',
         *         [publicationDateField.id]: '2020-02-02',
         *     });
         *
         * // Check if user could update a given record, when you don't know the
         * // specific fields that will be updated yet (e.g. to check whether you should
         * // allow a user to select a certain record to update).
         * const canUpdateUnknownFields = table.hasPermissionToUpdateRecord(record);
         *
         * // Check if user could update specific fields, when you don't know the
         * // specific record that will be updated yet (e.g. if the field is selected
         * // by the user and you want to check if your extension can write to it).
         * const canUpdateUnknownRecord =
         *     table.hasPermissionToUpdateRecord(undefined, {
         *         'My field name': 'updated value',
         *         // You can use undefined if you know you're going to update a field,
         *         // but don't know the new cell value yet.
         *         'Another field name': undefined,
         *     });
         *
         * // Check if user could perform updates within the table, without knowing the
         * // specific record or fields that will be updated yet. (for example, to
         * // render your extension in "read only" mode)
         * const canUpdateUnknownRecordAndFields = table.hasPermissionToUpdateRecord();
         * ```
         */
        hasPermissionToUpdateRecord(recordOrRecordId, fields) {
          return this.checkPermissionsForUpdateRecord(recordOrRecordId, fields).hasPermission;
        }
        /**
         * Updates cell values for records.
         *
         * Throws an error if the user does not have permission to update the given cell values in
         * the records, or if invalid input is provided (eg. invalid cell values).
         *
         * Refer to {@link FieldType} for cell value write formats.
         *
         * You may only update up to 50 records in one call to `updateRecordsAsync`.
         * See [Write back to Airtable](/guides/write-back-to-airtable) for more information
         * about write limits.
         *
         * This action is asynchronous: `await` the returned promise if you wish to wait for the
         * updates to be persisted to Airtable servers.
         * Updates are applied optimistically locally, so your changes will be reflected in your extension
         * before the promise resolves.
         *
         * @param records Array of objects containing recordId and fields/cellValues to update for that record (specified as an object mapping `FieldId` or field name to cell value)
         * @example
         * ```js
         * const recordsToUpdate = [
         *     // Fields can be specified by name or ID
         *     {
         *         id: record1.id,
         *         fields: {
         *             'Post Title': 'How to make: orange-mango pound cake',
         *             'Publication Date': '2020-01-01',
         *         },
         *     },
         *     {
         *         id: record2.id,
         *         fields: {
         *             // Sets the cell values to be empty.
         *             'Post Title': '',
         *             'Publication Date': '',
         *         },
         *     },
         *     {
         *         id: record3.id,
         *         fields: {
         *             [postTitleField.id]: 'Cake decorating tips & tricks',
         *             [publicationDateField.id]: '2020-02-02',
         *         },
         *     },
         *     // Cell values should generally have format matching the output of
         *     // record.getCellValue() for the field being updated
         *     {
         *         id: record4.id,
         *         fields: {
         *             'Category (single select)': {name: 'Recipe'},
         *             'Tags (multiple select)': [{name: 'Desserts'}, {id: 'choiceId'}],
         *             'Images (attachment)': [{url: 'http://mywebsite.com/cake.png'}],
         *             'Related posts (linked records)': [{id: 'someRecordId'}],
         *         },
         *     },
         * ];
         *
         * function updateRecords() {
         *     if (table.hasPermissionToUpdateRecords(recordsToUpdate)) {
         *         table.updateRecordsAsync(recordsToUpdate);
         *     }
         *     // The records are now updated within your extension (eg will be reflected in
         *     // `table.selectRecords()`) but are still being saved to Airtable servers
         *     // (e.g. they may not be updated for other users yet).
         * }
         *
         * async function updateRecordsAsync() {
         *     if (table.hasPermissionToUpdateRecords(recordsToUpdate)) {
         *         await table.updateRecordsAsync(recordsToUpdate);
         *     }
         *     // Record updates have been saved to Airtable servers.
         *     alert('records have been updated');
         * }
         * ```
         */
        async updateRecordsAsync(records) {
          let includesForeignRowsThatShouldBeCreated = false;
          const recordsWithCellValuesByFieldId = records.map((record) => ({
            id: record.id,
            cellValuesByFieldId: this._cellValuesByFieldIdOrNameToCellValuesByFieldId(record.fields, () => {
              includesForeignRowsThatShouldBeCreated = true;
            })
          }));
          await this._sdk.__mutations.applyMutationAsync({
            type: MutationTypesCore.SET_MULTIPLE_RECORDS_CELL_VALUES,
            tableId: this.id,
            records: recordsWithCellValuesByFieldId,
            opts: {
              parseDateCellValueInColumnTimeZone: true,
              includesForeignRowsThatShouldBeCreated
            }
          });
        }
        /**
         * Checks whether the current user has permission to perform the given record updates.
         *
         * Accepts partial input, in the same format as {@link updateRecordsAsync}.
         * The more information provided, the more accurate the permissions check will be.
         *
         * Returns `{hasPermission: true}` if the current user can update the specified records,
         * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
         * used to display an error message to the user.
         *
         * @param records Array of objects containing recordId and fields/cellValues to update for that record (specified as an object mapping `FieldId` or field name to cell value)
         * @example
         * ```js
         * const recordsToUpdate = [
         *     {
         *         // Validating a complete record update
         *         id: record1.id,
         *         fields: {
         *             'Post Title': 'How to make: orange-mango pound cake',
         *             'Publication Date': '2020-01-01',
         *         },
         *     },
         *     {
         *         // Like updateRecordsAsync, fields can be specified by name or ID
         *         id: record2.id,
         *         fields: {
         *             [postTitleField.id]: 'Cake decorating tips & tricks',
         *             [publicationDateField.id]: '2020-02-02',
         *         },
         *     },
         *     {
         *         // Validating an update to a specific record, not knowing what
         *         // fields will be updated
         *         id: record3.id,
         *     },
         *     {
         *         // Validating an update to specific cell values, not knowing what
         *         // record will be updated
         *         fields: {
         *             'My field name': 'updated value for unknown record',
         *             // You can use undefined if you know you're going to update a
         *             // field, but don't know the new cell value yet.
         *             'Another field name': undefined,
         *         },
         *     },
         * ];
         *
         * const updateRecordsCheckResult =
         *     table.checkPermissionsForUpdateRecords(recordsToUpdate);
         * if (!updateRecordsCheckResult.hasPermission) {
         *     alert(updateRecordsCheckResult.reasonDisplayString);
         * }
         *
         * // Check if user could potentially update records.
         * // Equivalent to table.checkPermissionsForUpdateRecord()
         * const updateUnknownRecordAndFieldsCheckResult =
         *     table.checkPermissionsForUpdateRecords();
         * ```
         */
        checkPermissionsForUpdateRecords(records) {
          let includesForeignRowsThatShouldBeCreated = false;
          const recordsWithCellValuesByFieldId = records ? records.map((record) => ({
            id: record.id || void 0,
            cellValuesByFieldId: record.fields ? this._cellValuesByFieldIdOrNameToCellValuesByFieldId(record.fields, () => {
              includesForeignRowsThatShouldBeCreated = true;
            }) : void 0
          })) : void 0;
          return this._sdk.__mutations.checkPermissionsForMutation({
            type: MutationTypesCore.SET_MULTIPLE_RECORDS_CELL_VALUES,
            tableId: this.id,
            records: recordsWithCellValuesByFieldId,
            opts: {
              parseDateCellValueInColumnTimeZone: true,
              includesForeignRowsThatShouldBeCreated
            }
          });
        }
        /**
         * An alias for `checkPermissionsForUpdateRecords(records).hasPermission`.
         *
         * Checks whether the current user has permission to perform the given record updates.
         *
         * Accepts partial input, in the same format as {@link updateRecordsAsync}.
         * The more information provided, the more accurate the permissions check will be.
         *
         * @param records Array of objects containing recordId and fields/cellValues to update for that record (specified as an object mapping `FieldId` or field name to cell value)
         * @example
         * ```js
         * const recordsToUpdate = [
         *     {
         *         // Validating a complete record update
         *         id: record1.id,
         *         fields: {
         *             'Post Title': 'How to make: orange-mango pound cake',
         *             'Publication Date': '2020-01-01',
         *         },
         *     },
         *     {
         *         // Like updateRecordsAsync, fields can be specified by name or ID
         *         id: record2.id,
         *         fields: {
         *             [postTitleField.id]: 'Cake decorating tips & tricks',
         *             [publicationDateField.id]: '2020-02-02',
         *         },
         *     },
         *     {
         *         // Validating an update to a specific record, not knowing what
         *         // fields will be updated
         *         id: record3.id,
         *     },
         *     {
         *         // Validating an update to specific cell values, not knowing what
         *         // record will be updated
         *         fields: {
         *             'My field name': 'updated value for unknown record',
         *             // You can use undefined if you know you're going to update a
         *             // field, but don't know the new cell value yet.
         *             'Another field name': undefined,
         *         },
         *     },
         * ];
         *
         * const canUpdateRecords = table.hasPermissionToUpdateRecords(recordsToUpdate);
         * if (!canUpdateRecords) {
         *     alert('not allowed');
         * }
         *
         * // Check if user could potentially update records.
         * // Equivalent to table.hasPermissionToUpdateRecord()
         * const canUpdateUnknownRecordsAndFields =
         *     table.hasPermissionToUpdateRecords();
         * ```
         */
        hasPermissionToUpdateRecords(records) {
          return this.checkPermissionsForUpdateRecords(records).hasPermission;
        }
        /**
         * Delete the given record.
         *
         * Throws an error if the user does not have permission to delete the given record.
         *
         * This action is asynchronous: `await` the returned promise if you wish to wait for the
         * delete to be persisted to Airtable servers.
         * Updates are applied optimistically locally, so your changes will be reflected in your extension
         * before the promise resolves.
         *
         * @param recordOrRecordId the record to be deleted
         * @example
         * ```js
         * function deleteRecord(record) {
         *     if (table.hasPermissionToDeleteRecord(record)) {
         *         table.deleteRecordAsync(record);
         *     }
         *     // The record is now deleted within your extension (eg will not be returned
         *     // in `table.selectRecords`) but it is still being saved to Airtable
         *     // servers (e.g. it may not look deleted to other users yet).
         * }
         *
         * async function deleteRecordAsync(record) {
         *     if (table.hasPermissionToDeleteRecord(record)) {
         *         await table.deleteRecordAsync(record);
         *     }
         *     // Record deletion has been saved to Airtable servers.
         *     alert('record has been deleted');
         * }
         * ```
         */
        async deleteRecordAsync(recordOrRecordId) {
          await this.deleteRecordsAsync([recordOrRecordId]);
        }
        /**
         * Checks whether the current user has permission to delete the specified record.
         *
         * Accepts optional input, in the same format as {@link deleteRecordAsync}.
         * The more information provided, the more accurate the permissions check will be.
         *
         * Returns `{hasPermission: true}` if the current user can delete the specified record,
         * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
         * used to display an error message to the user.
         *
         * @param recordOrRecordId the record to be deleted
         * @example
         * ```js
         * // Check if user can delete a specific record
         * const deleteRecordCheckResult =
         *     table.checkPermissionsForDeleteRecord(record);
         * if (!deleteRecordCheckResult.hasPermission) {
         *     alert(deleteRecordCheckResult.reasonDisplayString);
         * }
         *
         * // Check if user could potentially delete a record.
         * // Use when you don't know the specific record you want to delete yet (for
         * // example, to show/hide UI controls that let you select a record to delete).
         * const deleteUnknownRecordCheckResult =
         *     table.checkPermissionsForDeleteRecord();
         * ```
         */
        checkPermissionsForDeleteRecord(recordOrRecordId) {
          return this.checkPermissionsForDeleteRecords(recordOrRecordId ? [recordOrRecordId] : void 0);
        }
        /**
         * An alias for `checkPermissionsForDeleteRecord(recordOrRecordId).hasPermission`.
         *
         * Checks whether the current user has permission to delete the specified record.
         *
         * Accepts optional input, in the same format as {@link deleteRecordAsync}.
         * The more information provided, the more accurate the permissions check will be.
         *
         * @param recordOrRecordId the record to be deleted
         * @example
         * ```js
         * // Check if user can delete a specific record
         * const canDeleteRecord = table.hasPermissionToDeleteRecord(record);
         * if (!canDeleteRecord) {
         *     alert('not allowed');
         * }
         *
         * // Check if user could potentially delete a record.
         * // Use when you don't know the specific record you want to delete yet (for
         * // example, to show/hide UI controls that let you select a record to delete).
         * const canDeleteUnknownRecord = table.hasPermissionToDeleteRecord();
         * ```
         */
        hasPermissionToDeleteRecord(recordOrRecordId) {
          return this.checkPermissionsForDeleteRecord(recordOrRecordId).hasPermission;
        }
        /**
         * Delete the given records.
         *
         * Throws an error if the user does not have permission to delete the given records.
         *
         * You may only delete up to 50 records in one call to `deleteRecordsAsync`.
         * See [Write back to Airtable](/guides/write-back-to-airtable#size-limits-rate-limits) for
         * more information about write limits.
         *
         * This action is asynchronous: `await` the returned promise if you wish to wait for the
         * delete to be persisted to Airtable servers.
         * Updates are applied optimistically locally, so your changes will be reflected in your extension
         * before the promise resolves.
         *
         * @param recordsOrRecordIds Array of Records and RecordIds
         * @example
         * ```js
         *
         * function deleteRecords(records) {
         *     if (table.hasPermissionToDeleteRecords(records)) {
         *         table.deleteRecordsAsync(records);
         *     }
         *     // The records are now deleted within your extension (eg will not be
         *     // returned in `table.selectRecords()`) but are still being saved to
         *     // Airtable servers (e.g. they may not look deleted to other users yet).
         * }
         *
         * async function deleteRecordsAsync(records) {
         *     if (table.hasPermissionToDeleteRecords(records)) {
         *         await table.deleteRecordsAsync(records);
         *     }
         *     // Record deletions have been saved to Airtable servers.
         *     alert('records have been deleted');
         * }
         * ```
         */
        async deleteRecordsAsync(recordsOrRecordIds) {
          const recordIds = recordsOrRecordIds.map((recordOrRecordId) => typeof recordOrRecordId === "string" ? recordOrRecordId : recordOrRecordId.id);
          await this._sdk.__mutations.applyMutationAsync({
            type: MutationTypesCore.DELETE_MULTIPLE_RECORDS,
            tableId: this.id,
            recordIds
          });
        }
        /**
         * Checks whether the current user has permission to delete the specified records.
         *
         * Accepts optional input, in the same format as {@link deleteRecordsAsync}.
         * The more information provided, the more accurate the permissions check will be.
         *
         * Returns `{hasPermission: true}` if the current user can delete the specified records,
         * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
         * used to display an error message to the user.
         *
         * @param recordsOrRecordIds the records to be deleted
         * @example
         * ```js
         * // Check if user can delete specific records
         * const deleteRecordsCheckResult =
         *     table.checkPermissionsForDeleteRecords([record1, record2]);
         * if (!deleteRecordsCheckResult.hasPermission) {
         *     alert(deleteRecordsCheckResult.reasonDisplayString);
         * }
         *
         * // Check if user could potentially delete records.
         * // Use when you don't know the specific records you want to delete yet (for
         * // example, to show/hide UI controls that let you select records to delete).
         * // Equivalent to table.hasPermissionToDeleteRecord()
         * const deleteUnknownRecordsCheckResult =
         *     table.checkPermissionsForDeleteRecords();
         * ```
         */
        checkPermissionsForDeleteRecords(recordsOrRecordIds) {
          return this._sdk.__mutations.checkPermissionsForMutation({
            type: MutationTypesCore.DELETE_MULTIPLE_RECORDS,
            tableId: this.id,
            recordIds: recordsOrRecordIds ? recordsOrRecordIds.map((recordOrRecordId) => typeof recordOrRecordId === "string" ? recordOrRecordId : recordOrRecordId.id) : void 0
          });
        }
        /**
         * An alias for `checkPermissionsForDeleteRecords(recordsOrRecordIds).hasPermission`.
         *
         * Checks whether the current user has permission to delete the specified records.
         *
         * Accepts optional input, in the same format as {@link deleteRecordsAsync}.
         * The more information provided, the more accurate the permissions check will be.
         *
         * @param recordsOrRecordIds the records to be deleted
         * @example
         * ```js
         * // Check if user can delete specific records
         * const canDeleteRecords =
         *     table.hasPermissionToDeleteRecords([record1, record2]);
         * if (!canDeleteRecords) {
         *     alert('not allowed!');
         * }
         *
         * // Check if user could potentially delete records.
         * // Use when you don't know the specific records you want to delete yet (for
         * // example, to show/hide UI controls that let you select records to delete).
         * // Equivalent to table.hasPermissionToDeleteRecord()
         * const canDeleteUnknownRecords = table.hasPermissionToDeleteRecords();
         * ```
         */
        hasPermissionToDeleteRecords(recordsOrRecordIds) {
          return this.checkPermissionsForDeleteRecords(recordsOrRecordIds).hasPermission;
        }
        /**
         * Creates a new record with the specified cell values.
         *
         * Throws an error if the user does not have permission to create the given records, or
         * if invalid input is provided (eg. invalid cell values).
         *
         * Refer to {@link FieldType} for cell value write formats.
         *
         * This action is asynchronous: `await` the returned promise if you wish to wait for the new
         * record to be persisted to Airtable servers.
         * Updates are applied optimistically locally, so your changes will be reflected in your extension
         * before the promise resolves.
         *
         * The returned promise will resolve to the RecordId of the new record once it is persisted.
         *
         * @param fields object mapping `FieldId` or field name to value for that field.
         * @example
         * ```js
         * function createNewRecord(recordFields) {
         *     if (table.hasPermissionToCreateRecord(recordFields)) {
         *         table.createRecordAsync(recordFields);
         *     }
         *     // You can now access the new record in your extension (eg
         *     // `table.selectRecords()`) but it is still being saved to Airtable
         *     // servers (e.g. other users may not be able to see it yet).
         * }
         *
         * async function createNewRecordAsync(recordFields) {
         *     if (table.hasPermissionToCreateRecord(recordFields)) {
         *         const newRecordId = await table.createRecordAsync(recordFields);
         *     }
         *     // New record has been saved to Airtable servers.
         *     alert(`new record with ID ${newRecordId} has been created`);
         * }
         *
         * // Fields can be specified by name or ID
         * createNewRecord({
         *     'Project Name': 'Advertising campaign',
         *     'Budget': 100,
         * });
         * createNewRecord({
         *     [projectNameField.id]: 'Cat video',
         *     [budgetField.id]: 200,
         * });
         *
         * // Cell values should generally have format matching the output of
         * // record.getCellValue() for the field being updated
         * createNewRecord({
         *     'Project Name': 'Cat video 2'
         *     'Category (single select)': {name: 'Video'},
         *     'Tags (multiple select)': [{name: 'Cats'}, {id: 'someChoiceId'}],
         *     'Assets (attachment)': [{url: 'http://mywebsite.com/cats.mp4'}],
         *     'Related projects (linked records)': [{id: 'someRecordId'}],
         * });
         * ```
         */
        async createRecordAsync() {
          let fields = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          const recordIds = await this.createRecordsAsync([{
            fields
          }]);
          return recordIds[0];
        }
        /**
         * Checks whether the current user has permission to create the specified record.
         *
         * Accepts partial input, in the same format as {@link createRecordAsync}.
         * The more information provided, the more accurate the permissions check will be.
         *
         * Returns `{hasPermission: true}` if the current user can create the specified record,
         * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
         * used to display an error message to the user.
         *
         * @param fields object mapping `FieldId` or field name to value for that field.
         * @example
         * ```js
         * // Check if user can create a specific record, when you already know what
         * // fields/cell values will be set for the record.
         * const createRecordCheckResult = table.checkPermissionsForCreateRecord({
         *     'Project Name': 'Advertising campaign',
         *     'Budget': 100,
         * });
         * if (!createRecordCheckResult.hasPermission) {
         *     alert(createRecordCheckResult.reasonDisplayString);
         * }
         *
         * // Like createRecordAsync, you can use either field names or field IDs.
         * const checkResultWithFieldIds = table.checkPermissionsForCreateRecord({
         *     [projectNameField.id]: 'Cat video',
         *     [budgetField.id]: 200,
         * });
         *
         * // Check if user could potentially create a record.
         * // Use when you don't know the specific fields/cell values yet (for example,
         * // to show or hide UI controls that let you start creating a record.)
         * const createUnknownRecordCheckResult =
         *     table.checkPermissionsForCreateRecord();
         * ```
         */
        checkPermissionsForCreateRecord(fields) {
          return this.checkPermissionsForCreateRecords([{
            fields: fields || void 0
          }]);
        }
        /**
         * An alias for `checkPermissionsForCreateRecord(fields).hasPermission`.
         *
         * Checks whether the current user has permission to create the specified record.
         *
         * Accepts partial input, in the same format as {@link createRecordAsync}.
         * The more information provided, the more accurate the permissions check will be.
         *
         * @param fields object mapping `FieldId` or field name to value for that field.
         * @example
         * ```js
         * // Check if user can create a specific record, when you already know what
         * // fields/cell values will be set for the record.
         * const canCreateRecord = table.hasPermissionToCreateRecord({
         *     'Project Name': 'Advertising campaign',
         *     'Budget': 100,
         * });
         * if (!canCreateRecord) {
         *     alert('not allowed!');
         * }
         *
         * // Like createRecordAsync, you can use either field names or field IDs.
         * const canCreateRecordWithFieldIds = table.hasPermissionToCreateRecord({
         *     [projectNameField.id]: 'Cat video',
         *     [budgetField.id]: 200,
         * });
         *
         * // Check if user could potentially create a record.
         * // Use when you don't know the specific fields/cell values yet (for example,
         * // to show or hide UI controls that let you start creating a record.)
         * const canCreateUnknownRecord = table.hasPermissionToCreateRecord();
         * ```
         */
        hasPermissionToCreateRecord(fields) {
          return this.checkPermissionsForCreateRecord(fields).hasPermission;
        }
        /**
         * Creates new records with the specified cell values.
         *
         * Throws an error if the user does not have permission to create the given records, or
         * if invalid input is provided (eg. invalid cell values).
         *
         * Refer to {@link FieldType} for cell value write formats.
         *
         * You may only create up to 50 records in one call to `createRecordsAsync`.
         * See [Write back to Airtable](/guides/write-back-to-airtable#size-limits-rate-limits) for
         * more information about write limits.
         *
         * This action is asynchronous: `await` the returned promise if you wish to wait for the new
         * record to be persisted to Airtable servers.
         * Updates are applied optimistically locally, so your changes will be reflected in your extension
         * before the promise resolves.
         *
         * The returned promise will resolve to an array of RecordIds of the new records once the new
         * records are persisted.
         *
         * @param records Array of objects with a `fields` key mapping `FieldId` or field name to value for that field.
         * @example
         * ```js
         * const recordDefs = [
         *     // Fields can be specified by name or ID
         *     {
         *          fields: {
         *              'Project Name': 'Advertising campaign',
         *              'Budget': 100,
         *          },
         *     },
         *     {
         *          fields: {
         *              [projectNameField.id]: 'Cat video',
         *              [budgetField.id]: 200,
         *          },
         *     },
         *     // Specifying no fields will create a new record with no cell values set
         *     {
         *          fields: {},
         *     },
         *     // Cell values should generally have format matching the output of
         *     // record.getCellValue() for the field being updated
         *     {
         *          fields: {
         *              'Project Name': 'Cat video 2'
         *              'Category (single select)': {name: 'Video'},
         *              'Tags (multiple select)': [{name: 'Cats'}, {id: 'choiceId'}],
         *              'Assets (attachment)': [{url: 'http://mywebsite.com/cats.mp4'}],
         *              'Related projects (linked records)': [{id: 'someRecordId'}],
         *          },
         *     },
         * ];
         *
         * function createNewRecords() {
         *     if (table.hasPermissionToCreateRecords(recordDefs)) {
         *         table.createRecordsAsync(recordDefs);
         *     }
         *     // You can now access the new records in your extension (e.g.
         *     // `table.selectRecords()`) but they are still being saved to Airtable
         *     // servers (e.g. other users may not be able to see them yet.)
         * }
         *
         * async function createNewRecordsAsync() {
         *     if (table.hasPermissionToCreateRecords(recordDefs)) {
         *         const newRecordIds = await table.createRecordsAsync(recordDefs);
         *     }
         *     // New records have been saved to Airtable servers.
         *     alert(`new records with IDs ${newRecordIds} have been created`);
         * }
         * ```
         */
        async createRecordsAsync(records) {
          let includesForeignRowsThatShouldBeCreated = false;
          const recordsToCreate = records.map((recordDef) => {
            const recordDefKeys = keys2(recordDef);
            let fields;
            if (recordDefKeys.length === 1 && recordDefKeys[0] === "fields") {
              fields = recordDef.fields;
            } else {
              throw spawnError("Invalid record format. Please define field mappings using a `fields` key for each record definition object");
            }
            return {
              id: this._sdk.__airtableInterface.idGenerator.generateRecordId(),
              cellValuesByFieldId: this._cellValuesByFieldIdOrNameToCellValuesByFieldId(fields, () => {
                includesForeignRowsThatShouldBeCreated = true;
              })
            };
          });
          await this._sdk.__mutations.applyMutationAsync({
            type: MutationTypesCore.CREATE_MULTIPLE_RECORDS,
            tableId: this.id,
            records: recordsToCreate,
            opts: {
              parseDateCellValueInColumnTimeZone: true,
              includesForeignRowsThatShouldBeCreated
            }
          });
          return recordsToCreate.map((record) => record.id);
        }
        /**
         * Checks whether the current user has permission to create the specified records.
         *
         * Accepts partial input, in the same format as {@link createRecordsAsync}.
         * The more information provided, the more accurate the permissions check will be.
         *
         * Returns `{hasPermission: true}` if the current user can create the specified records,
         * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
         * used to display an error message to the user.
         *
         * @param records Array of objects mapping `FieldId` or field name to value for that field.
         * @example
         * ```js
         * // Check if user can create specific records, when you already know what
         * // fields/cell values will be set for the records.
         * const createRecordsCheckResult = table.checkPermissionsForCreateRecords([
         *     // Like createRecordsAsync, fields can be specified by name or ID
         *     {
         *          fields: {
         *              'Project Name': 'Advertising campaign',
         *              'Budget': 100,
         *          },
         *     },
         *     {
         *          fields: {
         *              [projectNameField.id]: 'Cat video',
         *              [budgetField.id]: 200,
         *          },
         *     },
         *     {},
         * ]);
         * if (!createRecordsCheckResult.hasPermission) {
         *     alert(createRecordsCheckResult.reasonDisplayString);
         * }
         *
         * // Check if user could potentially create records.
         * // Use when you don't know the specific fields/cell values yet (for example,
         * // to show or hide UI controls that let you start creating records.)
         * // Equivalent to table.checkPermissionsForCreateRecord()
         * const createUnknownRecordCheckResult =
         *     table.checkPermissionsForCreateRecords();
         * ```
         */
        checkPermissionsForCreateRecords(records) {
          let includesForeignRowsThatShouldBeCreated = false;
          const recordsWithCellValuesByFieldId = records ? records.map((record) => ({
            id: void 0,
            cellValuesByFieldId: record.fields ? this._cellValuesByFieldIdOrNameToCellValuesByFieldId(record.fields, () => {
              includesForeignRowsThatShouldBeCreated = true;
            }) : void 0
          })) : void 0;
          return this._sdk.__mutations.checkPermissionsForMutation({
            type: MutationTypesCore.CREATE_MULTIPLE_RECORDS,
            tableId: this.id,
            records: recordsWithCellValuesByFieldId,
            opts: {
              parseDateCellValueInColumnTimeZone: true,
              includesForeignRowsThatShouldBeCreated
            }
          });
        }
        /**
         * An alias for `checkPermissionsForCreateRecords(records).hasPermission`.
         *
         * Checks whether the current user has permission to create the specified records.
         *
         * Accepts partial input, in the same format as {@link createRecordsAsync}.
         * The more information provided, the more accurate the permissions check will be.
         *
         * @param records Array of objects mapping `FieldId` or field name to value for that field.
         * @example
         * ```js
         * // Check if user can create specific records, when you already know what fields/cell values
         * // will be set for the records.
         * const canCreateRecords = table.hasPermissionToCreateRecords([
         *     // Like createRecordsAsync, fields can be specified by name or ID
         *     {
         *          fields: {
         *              'Project Name': 'Advertising campaign',
         *              'Budget': 100,
         *          }
         *     },
         *     {
         *          fields: {
         *              [projectNameField.id]: 'Cat video',
         *              [budgetField.id]: 200,
         *          }
         *     },
         *     {},
         * ]);
         * if (!canCreateRecords) {
         *     alert('not allowed');
         * }
         *
         * // Check if user could potentially create records.
         * // Use when you don't know the specific fields/cell values yet (for example,
         * // to show or hide UI controls that let you start creating records).
         * // Equivalent to table.hasPermissionToCreateRecord()
         * const canCreateUnknownRecords = table.hasPermissionToCreateRecords();
         * ```
         */
        hasPermissionToCreateRecords(records) {
          return this.checkPermissionsForCreateRecords(records).hasPermission;
        }
        /**
         * @internal
         */
        __triggerOnChangeForDirtyPaths(dirtyPaths) {
          let didTableSchemaChange = false;
          if (dirtyPaths.name) {
            this._onChange(WatchableTableKeysCore.name);
            didTableSchemaChange = true;
          }
          if (dirtyPaths.lock) {
            didTableSchemaChange = true;
          }
          if (dirtyPaths.externalSyncById) {
            didTableSchemaChange = true;
          }
          if (dirtyPaths.description) {
            this._onChange(WatchableTableKeysCore.description);
            didTableSchemaChange = true;
          }
          if (dirtyPaths.fieldsById) {
            didTableSchemaChange = true;
            const addedFieldIds = [];
            const removedFieldIds = [];
            for (const [fieldId, dirtyFieldPaths] of entries2(dirtyPaths.fieldsById)) {
              if (dirtyFieldPaths && dirtyFieldPaths._isDirty) {
                if (has3(this._data.fieldsById, fieldId)) {
                  addedFieldIds.push(fieldId);
                } else {
                  removedFieldIds.push(fieldId);
                  const fieldModel = this._fieldModelsById[fieldId];
                  if (fieldModel) {
                    delete this._fieldModelsById[fieldId];
                  }
                }
              } else {
                const field = this._fieldModelsById[fieldId];
                if (field) {
                  field.__triggerOnChangeForDirtyPaths(dirtyFieldPaths);
                }
              }
            }
            if (addedFieldIds.length > 0 || removedFieldIds.length > 0) {
              this._onChange(WatchableTableKeysCore.fields, {
                addedFieldIds,
                removedFieldIds
              });
            }
            this._cachedFieldNamesById = null;
          }
          this._recordStore.triggerOnChangeForDirtyPaths(dirtyPaths);
          return didTableSchemaChange;
        }
        /**
         * @internal
         */
        __getFieldNamesById() {
          if (!this._cachedFieldNamesById) {
            const fieldNamesById = {};
            for (const [fieldId, fieldData] of entries2(this._data.fieldsById)) {
              fieldNamesById[fieldId] = fieldData.name;
            }
            this._cachedFieldNamesById = fieldNamesById;
          }
          return this._cachedFieldNamesById;
        }
      };
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/models/field.js
  var Field;
  var init_field = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/models/field.js"() {
      init_field_core2();
      Field = class extends FieldCore {
        /** @internal */
        static _className = "Field";
      };
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/models/table.js
  var Table2;
  var init_table = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/models/table.js"() {
      init_table_core();
      init_field_core();
      init_field();
      Table2 = class extends TableCore {
        /** @internal */
        _constructField(fieldId) {
          return new Field(this.parentBase.__sdk, this, fieldId);
        }
        /**
         * Checks whether records in this table can be expanded.
         *
         * Returns `{hasPermission: true}` if records can be expanded,
         * `{hasPermission: false, reasonDisplayString: string}` otherwise.
         *
         * @example
         * ```js
         * const expandRecordsCheckResult = table.checkPermissionToExpandRecords();
         * if (!expandRecordsCheckResult.hasPermission) {
         *     alert(expandRecordsCheckResult.reasonDisplayString);
         * }
         * ```
         */
        checkPermissionToExpandRecords() {
          const canExpand = this._baseData.tablesById[this.id].isRecordExpansionEnabled;
          return canExpand ? {
            hasPermission: true
          } : {
            hasPermission: false,
            reasonDisplayString: "Record expansion is not enabled for this table"
          };
        }
        /**
         * An alias for `checkPermissionsForExpandRecords().hasPermission`.
         *
         * Whether records in this table can be expanded.
         *
         * @example
         * ```js
         * const isRecordExpansionEnabled = table.hasPermissionToExpandRecords();
         * if (isRecordExpansionEnabled) {
         *     expandRecord(record);
         * }
         * ```
         */
        hasPermissionToExpandRecords() {
          return this.checkPermissionToExpandRecords().hasPermission;
        }
        /** @internal */
        _adjustCellValueForFieldIfNecessary(field, cellValue, onGenerateIdForNewForeignRecord) {
          if (field.type !== FieldType.MULTIPLE_RECORD_LINKS || !Array.isArray(cellValue)) {
            return cellValue;
          }
          return cellValue.map((item) => {
            if (typeof item !== "object" || item === null) {
              return item;
            }
            if (!item.id) {
              const newForeignRecordId = this.parentBase.__sdk.__airtableInterface.idGenerator.generateRecordId();
              onGenerateIdForNewForeignRecord(newForeignRecordId);
              return __spreadProps(__spreadValues({}, item), {
                id: newForeignRecordId
              });
            }
            return item;
          });
        }
      };
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/models/record_store_core.js
  var WatchableRecordStoreKeysCore, WatchableCellValuesInFieldKeyPrefix, RecordStoreCore, record_store_core_default;
  var init_record_store_core = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/models/record_store_core.js"() {
      init_private_utils();
      init_error_utils();
      init_abstract_model();
      WatchableRecordStoreKeysCore = Object.freeze({
        records: "records",
        recordIds: "recordIds",
        cellValues: "cellValues"
      });
      WatchableCellValuesInFieldKeyPrefix = "cellValuesInField:";
      RecordStoreCore = class extends abstract_model_default {
        static _className = "RecordStoreCore";
        static _isWatchableKey(key) {
          return isEnumValue(WatchableRecordStoreKeysCore, key) || key.startsWith(WatchableCellValuesInFieldKeyPrefix);
        }
        _recordModelsById = {};
        constructor(sdk3, tableId) {
          super(sdk3, `${tableId}-RecordStore`);
          this.tableId = tableId;
        }
        get _dataOrNullIfDeleted() {
          return this._baseData.tablesById[this.tableId] ?? null;
        }
        watch(keys3, callback, context2) {
          const validKeys = super.watch(keys3, callback, context2);
          return validKeys;
        }
        unwatch(keys3, callback, context2) {
          const validKeys = super.unwatch(keys3, callback, context2);
          return validKeys;
        }
        /**
         * The records in this table.
         */
        get records() {
          const recordsById = this._data.recordsById;
          invariant(recordsById, "Record metadata is not loaded");
          const records = this.recordIds.map((recordId) => {
            const record = this.getRecordByIdIfExists(recordId);
            invariant(record, "record");
            return record;
          });
          return records;
        }
        /**
         * The record IDs in this table.
         */
        getRecordByIdIfExists(recordId) {
          const recordsById = this._data.recordsById;
          invariant(recordsById, "Record metadata is not loaded");
          invariant(typeof recordId === "string", "getRecordById expects a string");
          if (!recordsById[recordId]) {
            return null;
          } else {
            if (this._recordModelsById[recordId]) {
              return this._recordModelsById[recordId];
            }
            const newRecord = this._constructRecord(recordId, this._sdk.base.getTableById(this.tableId));
            this._recordModelsById[recordId] = newRecord;
            return newRecord;
          }
        }
        triggerOnChangeForDirtyPaths(dirtyPaths) {
          if (dirtyPaths.recordsById) {
            const dirtyFieldIdsSet = {};
            const addedRecordIds = [];
            const removedRecordIds = [];
            for (const [recordId, dirtyRecordPaths] of entries2(dirtyPaths.recordsById)) {
              if (dirtyRecordPaths && dirtyRecordPaths._isDirty) {
                invariant(this._data.recordsById, "No recordsById");
                if (has3(this._data.recordsById, recordId)) {
                  addedRecordIds.push(recordId);
                } else {
                  removedRecordIds.push(recordId);
                  const recordModel = this._recordModelsById[recordId];
                  if (recordModel) {
                    delete this._recordModelsById[recordId];
                  }
                }
              } else {
                const recordModel = this._recordModelsById[recordId];
                if (recordModel) {
                  recordModel.__triggerOnChangeForDirtyPaths(dirtyRecordPaths);
                }
              }
              const {
                cellValuesByFieldId
              } = dirtyRecordPaths;
              if (cellValuesByFieldId) {
                for (const fieldId of Object.keys(cellValuesByFieldId)) {
                  dirtyFieldIdsSet[fieldId] = true;
                }
              }
            }
            if (addedRecordIds.length > 0 || removedRecordIds.length > 0) {
              this._onChange(WatchableRecordStoreKeysCore.records, {
                addedRecordIds,
                removedRecordIds
              });
              this._onChange(WatchableRecordStoreKeysCore.recordIds, {
                addedRecordIds,
                removedRecordIds
              });
            }
            const fieldIds = Object.freeze(Object.keys(dirtyFieldIdsSet));
            const recordIds = Object.freeze(Object.keys(dirtyPaths.recordsById));
            if (fieldIds.length > 0 && recordIds.length > 0) {
              this._onChange(WatchableRecordStoreKeysCore.cellValues, {
                recordIds,
                fieldIds
              });
            }
            for (const fieldId of fieldIds) {
              this._onChange(WatchableCellValuesInFieldKeyPrefix + fieldId, recordIds, fieldId);
            }
          }
        }
      };
      record_store_core_default = RecordStoreCore;
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/models/record_core.js
  var WatchableRecordKeysCore, RecordCore;
  var init_record_core = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/models/record_core.js"() {
      init_private_utils();
      init_error_utils();
      init_field_core();
      init_abstract_model();
      init_field_core2();
      WatchableRecordKeysCore = Object.freeze({
        name: "name",
        // TODO(kasra): these keys don't have matching getters (not that they should
        // it's just inconsistent...)
        cellValues: "cellValues"
      });
      RecordCore = class extends abstract_model_default {
        /** @internal */
        static _className = "RecordCore";
        /** @internal */
        static _isWatchableKey(key) {
          return isEnumValue(WatchableRecordKeysCore, key);
        }
        /** @internal */
        /** @internal */
        /**
         * @internal
         */
        constructor(sdk3, parentRecordStore, parentTable, recordId) {
          super(sdk3, recordId);
          this._parentRecordStore = parentRecordStore;
          this._parentTable = parentTable;
        }
        /**
         * @internal
         */
        get _dataOrNullIfDeleted() {
          const tableData = this._baseData.tablesById[this.parentTable.id];
          if (!tableData) {
            return null;
          }
          const recordsById = tableData.recordsById;
          invariant(recordsById, "Record data is not loaded");
          return recordsById[this._id] ?? null;
        }
        /**
         * The table that this record belongs to. Should never change because records aren't moved between tables.
         *
         * @internal (since we may not be able to return parent model instances in the immutable models world)
         * @example
         * ```js
         * import {useRecords} from '@airtable/blocks/base/ui';
         * const records = useRecords(myTable);
         * console.log(records[0].parentTable.id === myTable.id);
         * // => true
         * ```
         */
        get parentTable() {
          return this._parentTable;
        }
        /**
         * @internal
         */
        _getFieldMatching(fieldOrFieldIdOrFieldName) {
          if (fieldOrFieldIdOrFieldName instanceof FieldCore) {
            return this._parentTable.__getFieldMatching(fieldOrFieldIdOrFieldName.id);
          }
          return this.parentTable.__getFieldMatching(fieldOrFieldIdOrFieldName);
        }
        /**
         * @internal
         *
         * For use when we need the raw public API cell value. Specifically makes a difference
         * for lookup fields, where we translate the format to a blocks-specific format in getCellValue.
         * That format is incompatible with fieldTypeProvider methods, which expect the public API
         * format - use _getRawCellValue instead.
         */
        _getRawCellValue(field) {
          const {
            cellValuesByFieldId
          } = this._data;
          if (!cellValuesByFieldId) {
            return null;
          }
          const cellValue = cellValuesByFieldId[field.id] !== void 0 ? cellValuesByFieldId[field.id] : null;
          if (typeof cellValue === "object" && cellValue !== null) {
            return cloneDeep(cellValue);
          } else {
            return cellValue;
          }
        }
        /**
         * Gets the cell value of the given field for this record.
         *
         * @param fieldOrFieldIdOrFieldName The field (or field ID or field name) whose cell value you'd like to get.
         * @example
         * ```js
         * const cellValue = myRecord.getCellValue(mySingleLineTextField);
         * console.log(cellValue);
         * // => 'cell value'
         * ```
         */
        getCellValue(fieldOrFieldIdOrFieldName) {
          const field = this._getFieldMatching(fieldOrFieldIdOrFieldName);
          const cellValue = this._getRawCellValue(field);
          if (typeof cellValue === "object" && cellValue !== null && field.type === FieldType.MULTIPLE_LOOKUP_VALUES && !this._sdk.__airtableInterface.sdkInitData.isUsingNewLookupCellValueFormat) {
            const cellValueForMigration = [];
            invariant(Array.isArray(cellValue.linkedRecordIds), "linkedRecordIds");
            for (const linkedRecordId of cellValue.linkedRecordIds) {
              invariant(typeof linkedRecordId === "string", "linkedRecordId");
              const {
                valuesByLinkedRecordId
              } = cellValue;
              invariant(valuesByLinkedRecordId && typeof valuesByLinkedRecordId === "object", "valuesByLinkedRecordId");
              const value = valuesByLinkedRecordId[linkedRecordId];
              if (Array.isArray(value)) {
                for (const v of value) {
                  cellValueForMigration.push({
                    linkedRecordId,
                    value: v
                  });
                }
              } else {
                cellValueForMigration.push({
                  linkedRecordId,
                  value
                });
              }
            }
            return cellValueForMigration;
          }
          return cellValue;
        }
        /**
         * Gets the cell value of the given field for this record, formatted as a `string`.
         *
         * @param fieldOrFieldIdOrFieldName The field (or field ID or field name) whose cell value you'd like to get.
         * @example
         * ```js
         * const stringValue = myRecord.getCellValueAsString(myNumberField);
         * console.log(stringValue);
         * // => '42'
         * ```
         */
        getCellValueAsString(fieldOrFieldIdOrFieldName) {
          const field = this._getFieldMatching(fieldOrFieldIdOrFieldName);
          const cellValue = this._getRawCellValue(field);
          if (cellValue === null || cellValue === void 0) {
            return "";
          } else {
            const airtableInterface2 = this._sdk.__airtableInterface;
            const appInterface = this._sdk.__appInterface;
            return airtableInterface2.fieldTypeProvider.convertCellValueToString(appInterface, cellValue, field._data);
          }
        }
        /**
         * The primary cell value in this record, formatted as a `string`.
         *
         * @example
         * ```js
         * console.log(myRecord.name);
         * // => '42'
         * ```
         */
        get name() {
          return this.getCellValueAsString(this.parentTable.primaryField);
        }
        /**
         * The created time of this record.
         *
         * @example
         * ```js
         * console.log(`
         *     This record was created at ${myRecord.createdTime.toISOString()}
         * `);
         * ```
         */
        get createdTime() {
          return new Date(this._data.createdTime);
        }
        /**
         * @internal
         */
        __triggerOnChangeForDirtyPaths(dirtyPaths) {
          const {
            cellValuesByFieldId
          } = dirtyPaths;
          if (cellValuesByFieldId && !isObjectEmpty(cellValuesByFieldId)) {
            this._onChange(WatchableRecordKeysCore.cellValues, Object.keys(cellValuesByFieldId));
            if (cellValuesByFieldId[this.parentTable.primaryField.id]) {
              this._onChange(WatchableRecordKeysCore.name);
            }
          }
        }
      };
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/models/record.js
  var WatchableRecordKeys, Record;
  var init_record = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/models/record.js"() {
      init_error_utils();
      init_record_core();
      init_field_core();
      WatchableRecordKeys = Object.freeze(__spreadValues({}, WatchableRecordKeysCore));
      Record = class extends RecordCore {
        /** @internal */
        static _className = "Record";
        /**
         * Fetch foreign records for a field. Subsequent calls to this method will
         * override previous calls that are still pending. The previous call(s)
         * will immediately resolve with an empty `records` array.
         *
         * @param fieldId - The ID of the field to fetch foreign records for.
         * @param filterString - The filter string to use to filter the records.
         * @returns A promise that resolves to the foreign records.
         */
        fetchForeignRecordsAsync(field, filterString) {
          const parentTable = this.parentTable;
          if (field.parentTable !== parentTable) {
            throw spawnError("Field %s is not in the same table as the record", field.name);
          }
          if (field.type !== FieldType.MULTIPLE_RECORD_LINKS) {
            throw spawnError("Field %s is not a multiple record links field", field.name);
          }
          const airtableInterface2 = this.parentTable.parentBase.__sdk.__airtableInterface;
          return airtableInterface2.fetchForeignRecordsAsync(parentTable.id, this.id, field.id, filterString);
        }
      };
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/models/record_store.js
  var WatchableRecordStoreKeys, RecordStore;
  var init_record_store = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/models/record_store.js"() {
      init_record_store_core();
      init_private_utils();
      init_record();
      WatchableRecordStoreKeys = Object.freeze(__spreadProps(__spreadValues({}, WatchableRecordStoreKeysCore), {
        recordOrder: "recordOrder"
      }));
      RecordStore = class extends record_store_core_default {
        static _className = "RecordStore";
        static _isWatchableKey(key) {
          return isEnumValue(WatchableRecordStoreKeys, key) || key.startsWith(WatchableCellValuesInFieldKeyPrefix);
        }
        _constructRecord(recordId, parentTable) {
          return new Record(this._sdk, this, parentTable, recordId);
        }
        /**
         * The record Ids in this table.
         */
        get recordIds() {
          return this._data.recordOrder;
        }
        __onDataDeletion() {
        }
        triggerOnChangeForDirtyPaths(dirtyPaths) {
          super.triggerOnChangeForDirtyPaths(dirtyPaths);
          if (dirtyPaths.recordOrder) {
            this._onChange(WatchableRecordStoreKeys.recordOrder);
          }
        }
      };
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/models/base.js
  var Base;
  var init_base = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/models/base.js"() {
      init_base_core();
      init_table();
      init_record_store();
      Base = class extends BaseCore {
        /** @internal */
        _constructTable(tableId) {
          const recordStore = this.__getRecordStore(tableId);
          return new Table2(this, recordStore, tableId, this._sdk);
        }
        /** @internal */
        _constructRecordStore(sdk3, tableId) {
          return new RecordStore(sdk3, tableId);
        }
        /** @internal */
        _getAllTableDataForEditModeConfiguration() {
          return this._data.allTableDataForEditModeConfiguration;
        }
        /** @internal */
        __triggerOnChangeForChangedPaths(changedPaths) {
          super.__triggerOnChangeForChangedPaths(changedPaths);
          if (changedPaths.allTableDataForEditModeConfiguration) {
            this._onChange(WatchableBaseKeys.schema);
          }
        }
      };
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/sdk.js
  var InterfaceBlockSdk;
  var init_sdk = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/sdk.js"() {
      init_sdk_core();
      init_session();
      init_mutations2();
      init_base();
      InterfaceBlockSdk = class extends BlockSdkCore {
        constructor(airtableInterface2) {
          super(airtableInterface2);
          this._registerHandlers();
        }
        /** @internal */
        _constructSession() {
          return new Session(this);
        }
        /** @internal */
        _constructBase() {
          return new Base(this);
        }
        /** @internal */
        _constructMutations() {
          return new Mutations(this, this.session, this.base, (changes) => this.__applyModelChanges(changes), (updates) => this.__applyGlobalConfigUpdates(updates));
        }
        /** @internal */
        _registerHandlers() {
          this.__airtableInterface.subscribeToModelUpdates((_ref) => {
            let {
              changes
            } = _ref;
            this.__applyModelChanges(changes);
          });
          this.__airtableInterface.subscribeToGlobalConfigUpdates((_ref2) => {
            let {
              updates
            } = _ref2;
            this.__applyGlobalConfigUpdates(updates);
          });
        }
        /** @internal */
        __applyModelChanges(changes) {
          const changedBasePaths = this.base.__applyChangesWithoutTriggeringEvents(changes);
          const changedSessionKeys = this.session.__applyChangesWithoutTriggeringEvents(changes);
          this.base.__triggerOnChangeForChangedPaths(changedBasePaths);
          this.session.__triggerOnChangeForChangedKeys(changedSessionKeys);
        }
        /** @internal */
        __applyGlobalConfigUpdates(updates) {
          this.globalConfig.__setMultipleKvPaths(updates);
        }
        /**
         * @internal
         */
        get __appInterface() {
          return this.base._baseData.appInterface;
        }
        /** @hidden */
        getBlockRunContext() {
          return this.__airtableInterface.sdkInitData.runContext;
        }
        /**
         * @internal
         */
        setCustomPropertiesAsync(properties) {
          return this.__airtableInterface.setCustomPropertiesAsync(properties);
        }
      };
    }
  });

  // node_modules/react-dom/cjs/react-dom-client.development.js
  var require_react_dom_client_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom-client.development.js"(exports2) {
      "use strict";
      (function() {
        function findHook(fiber, id) {
          for (fiber = fiber.memoizedState; null !== fiber && 0 < id; )
            fiber = fiber.next, id--;
          return fiber;
        }
        function copyWithSetImpl(obj, path, index, value) {
          if (index >= path.length) return value;
          var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign2({}, obj);
          updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
          return updated;
        }
        function copyWithRename(obj, oldPath, newPath) {
          if (oldPath.length !== newPath.length)
            console.warn("copyWithRename() expects paths of the same length");
          else {
            for (var i = 0; i < newPath.length - 1; i++)
              if (oldPath[i] !== newPath[i]) {
                console.warn(
                  "copyWithRename() expects paths to be the same except for the deepest key"
                );
                return;
              }
            return copyWithRenameImpl(obj, oldPath, newPath, 0);
          }
        }
        function copyWithRenameImpl(obj, oldPath, newPath, index) {
          var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign2({}, obj);
          index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(
            obj[oldKey],
            oldPath,
            newPath,
            index + 1
          );
          return updated;
        }
        function copyWithDeleteImpl(obj, path, index) {
          var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign2({}, obj);
          if (index + 1 === path.length)
            return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;
          updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
          return updated;
        }
        function shouldSuspendImpl() {
          return false;
        }
        function shouldErrorImpl() {
          return null;
        }
        function warnInvalidHookAccess() {
          console.error(
            "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
          );
        }
        function warnInvalidContextAccess() {
          console.error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
        }
        function noop() {
        }
        function warnForMissingKey() {
        }
        function setToSortedString(set2) {
          var array = [];
          set2.forEach(function(value) {
            array.push(value);
          });
          return array.sort().join(", ");
        }
        function createFiber(tag, pendingProps, key, mode) {
          return new FiberNode(tag, pendingProps, key, mode);
        }
        function scheduleRoot(root2, element) {
          root2.context === emptyContextObject && (updateContainerImpl(root2.current, 2, element, root2, null, null), flushSyncWork$1());
        }
        function scheduleRefresh(root2, update) {
          if (null !== resolveFamily) {
            var staleFamilies = update.staleFamilies;
            update = update.updatedFamilies;
            flushPendingEffects();
            scheduleFibersWithFamiliesRecursively(
              root2.current,
              update,
              staleFamilies
            );
            flushSyncWork$1();
          }
        }
        function setRefreshHandler(handler) {
          resolveFamily = handler;
        }
        function isValidContainer(node) {
          return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
        }
        function getNearestMountedFiber(fiber) {
          var node = fiber, nearestMounted = fiber;
          if (fiber.alternate) for (; node.return; ) node = node.return;
          else {
            fiber = node;
            do
              node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
            while (fiber);
          }
          return 3 === node.tag ? nearestMounted : null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
          if (13 === fiber.tag) {
            var suspenseState = fiber.memoizedState;
            null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
            if (null !== suspenseState) return suspenseState.dehydrated;
          }
          return null;
        }
        function getActivityInstanceFromFiber(fiber) {
          if (31 === fiber.tag) {
            var activityState = fiber.memoizedState;
            null === activityState && (fiber = fiber.alternate, null !== fiber && (activityState = fiber.memoizedState));
            if (null !== activityState) return activityState.dehydrated;
          }
          return null;
        }
        function assertIsMounted(fiber) {
          if (getNearestMountedFiber(fiber) !== fiber)
            throw Error("Unable to find node on an unmounted component.");
        }
        function findCurrentFiberUsingSlowPath(fiber) {
          var alternate = fiber.alternate;
          if (!alternate) {
            alternate = getNearestMountedFiber(fiber);
            if (null === alternate)
              throw Error("Unable to find node on an unmounted component.");
            return alternate !== fiber ? null : fiber;
          }
          for (var a = fiber, b = alternate; ; ) {
            var parentA = a.return;
            if (null === parentA) break;
            var parentB = parentA.alternate;
            if (null === parentB) {
              b = parentA.return;
              if (null !== b) {
                a = b;
                continue;
              }
              break;
            }
            if (parentA.child === parentB.child) {
              for (parentB = parentA.child; parentB; ) {
                if (parentB === a) return assertIsMounted(parentA), fiber;
                if (parentB === b) return assertIsMounted(parentA), alternate;
                parentB = parentB.sibling;
              }
              throw Error("Unable to find node on an unmounted component.");
            }
            if (a.return !== b.return) a = parentA, b = parentB;
            else {
              for (var didFindChild = false, _child = parentA.child; _child; ) {
                if (_child === a) {
                  didFindChild = true;
                  a = parentA;
                  b = parentB;
                  break;
                }
                if (_child === b) {
                  didFindChild = true;
                  b = parentA;
                  a = parentB;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                for (_child = parentB.child; _child; ) {
                  if (_child === a) {
                    didFindChild = true;
                    a = parentB;
                    b = parentA;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentB;
                    a = parentA;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild)
                  throw Error(
                    "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
                  );
              }
            }
            if (a.alternate !== b)
              throw Error(
                "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
              );
          }
          if (3 !== a.tag)
            throw Error("Unable to find node on an unmounted component.");
          return a.stateNode.current === a ? fiber : alternate;
        }
        function findCurrentHostFiberImpl(node) {
          var tag = node.tag;
          if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
          for (node = node.child; null !== node; ) {
            tag = findCurrentHostFiberImpl(node);
            if (null !== tag) return tag;
            node = node.sibling;
          }
          return null;
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x) {
                }
            }
          return null;
        }
        function getComponentNameFromOwner(owner) {
          return "number" === typeof owner.tag ? getComponentNameFromFiber(owner) : "string" === typeof owner.name ? owner.name : null;
        }
        function getComponentNameFromFiber(fiber) {
          var type = fiber.type;
          switch (fiber.tag) {
            case 31:
              return "Activity";
            case 24:
              return "Cache";
            case 9:
              return (type._context.displayName || "Context") + ".Consumer";
            case 10:
              return type.displayName || "Context";
            case 18:
              return "DehydratedFragment";
            case 11:
              return fiber = type.render, fiber = fiber.displayName || fiber.name || "", type.displayName || ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef");
            case 7:
              return "Fragment";
            case 26:
            case 27:
            case 5:
              return type;
            case 4:
              return "Portal";
            case 3:
              return "Root";
            case 6:
              return "Text";
            case 16:
              return getComponentNameFromType(type);
            case 8:
              return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
            case 22:
              return "Offscreen";
            case 12:
              return "Profiler";
            case 21:
              return "Scope";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 25:
              return "TracingMarker";
            case 1:
            case 0:
            case 14:
            case 15:
              if ("function" === typeof type)
                return type.displayName || type.name || null;
              if ("string" === typeof type) return type;
              break;
            case 29:
              type = fiber._debugInfo;
              if (null != type) {
                for (var i = type.length - 1; 0 <= i; i--)
                  if ("string" === typeof type[i].name) return type[i].name;
              }
              if (null !== fiber.return)
                return getComponentNameFromFiber(fiber.return);
          }
          return null;
        }
        function createCursor(defaultValue) {
          return { current: defaultValue };
        }
        function pop(cursor, fiber) {
          0 > index$jscomp$0 ? console.error("Unexpected pop.") : (fiber !== fiberStack[index$jscomp$0] && console.error("Unexpected Fiber popped."), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);
        }
        function push(cursor, value, fiber) {
          index$jscomp$0++;
          valueStack[index$jscomp$0] = cursor.current;
          fiberStack[index$jscomp$0] = fiber;
          cursor.current = value;
        }
        function requiredContext(c) {
          null === c && console.error(
            "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
          );
          return c;
        }
        function pushHostContainer(fiber, nextRootInstance) {
          push(rootInstanceStackCursor, nextRootInstance, fiber);
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor, null, fiber);
          var nextRootContext = nextRootInstance.nodeType;
          switch (nextRootContext) {
            case 9:
            case 11:
              nextRootContext = 9 === nextRootContext ? "#document" : "#fragment";
              nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? (nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : HostContextNamespaceNone : HostContextNamespaceNone;
              break;
            default:
              if (nextRootContext = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
                nextRootInstance = getOwnHostContext(nextRootInstance), nextRootInstance = getChildHostContextProd(
                  nextRootInstance,
                  nextRootContext
                );
              else
                switch (nextRootContext) {
                  case "svg":
                    nextRootInstance = HostContextNamespaceSvg;
                    break;
                  case "math":
                    nextRootInstance = HostContextNamespaceMath;
                    break;
                  default:
                    nextRootInstance = HostContextNamespaceNone;
                }
          }
          nextRootContext = nextRootContext.toLowerCase();
          nextRootContext = updatedAncestorInfoDev(null, nextRootContext);
          nextRootContext = {
            context: nextRootInstance,
            ancestorInfo: nextRootContext
          };
          pop(contextStackCursor, fiber);
          push(contextStackCursor, nextRootContext, fiber);
        }
        function popHostContainer(fiber) {
          pop(contextStackCursor, fiber);
          pop(contextFiberStackCursor, fiber);
          pop(rootInstanceStackCursor, fiber);
        }
        function getHostContext() {
          return requiredContext(contextStackCursor.current);
        }
        function pushHostContext(fiber) {
          null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);
          var context2 = requiredContext(contextStackCursor.current);
          var type = fiber.type;
          var nextContext = getChildHostContextProd(context2.context, type);
          type = updatedAncestorInfoDev(context2.ancestorInfo, type);
          nextContext = { context: nextContext, ancestorInfo: type };
          context2 !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));
        }
        function popHostContext(fiber) {
          contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
          hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), HostTransitionContext._currentValue = NotPendingTransition);
        }
        function disabledLog() {
        }
        function disableLogs() {
          if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
        function reenableLogs() {
          disabledDepth--;
          if (0 === disabledDepth) {
            var props = { configurable: true, enumerable: true, writable: true };
            Object.defineProperties(console, {
              log: assign2({}, props, { value: prevLog }),
              info: assign2({}, props, { value: prevInfo }),
              warn: assign2({}, props, { value: prevWarn }),
              error: assign2({}, props, { value: prevError }),
              group: assign2({}, props, { value: prevGroup }),
              groupCollapsed: assign2({}, props, { value: prevGroupCollapsed }),
              groupEnd: assign2({}, props, { value: prevGroupEnd })
            });
          }
          0 > disabledDepth && console.error(
            "disabledDepth fell below zero. This is a bug in React. Please file an issue."
          );
        }
        function formatOwnerStack(error) {
          var prevPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          error = error.stack;
          Error.prepareStackTrace = prevPrepareStackTrace;
          error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
          prevPrepareStackTrace = error.indexOf("\n");
          -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
          prevPrepareStackTrace = error.indexOf("react_stack_bottom_frame");
          -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf(
            "\n",
            prevPrepareStackTrace
          ));
          if (-1 !== prevPrepareStackTrace)
            error = error.slice(0, prevPrepareStackTrace);
          else return "";
          return error;
        }
        function describeBuiltInComponentFrame(name) {
          if (void 0 === prefix)
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
              suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
            }
          return "\n" + prefix + name + suffix;
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) return "";
          var frame = componentFrameCache.get(fn);
          if (void 0 !== frame) return frame;
          reentry = true;
          frame = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher2 = null;
          previousDispatcher2 = ReactSharedInternals.H;
          ReactSharedInternals.H = null;
          disableLogs();
          try {
            var RunInRootFrame = {
              DetermineComponentFrameRoot: function() {
                try {
                  if (construct) {
                    var Fake = function() {
                      throw Error();
                    };
                    Object.defineProperty(Fake.prototype, "props", {
                      set: function() {
                        throw Error();
                      }
                    });
                    if ("object" === typeof Reflect && Reflect.construct) {
                      try {
                        Reflect.construct(Fake, []);
                      } catch (x) {
                        var control = x;
                      }
                      Reflect.construct(fn, [], Fake);
                    } else {
                      try {
                        Fake.call();
                      } catch (x$0) {
                        control = x$0;
                      }
                      fn.call(Fake.prototype);
                    }
                  } else {
                    try {
                      throw Error();
                    } catch (x$1) {
                      control = x$1;
                    }
                    (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                    });
                  }
                } catch (sample) {
                  if (sample && control && "string" === typeof sample.stack)
                    return [sample.stack, control.stack];
                }
                return [null, null];
              }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name"
            );
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name",
              { value: "DetermineComponentFrameRoot" }
            );
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
              var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
              for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
                "DetermineComponentFrameRoot"
              ); )
                namePropDescriptor++;
              for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
                "DetermineComponentFrameRoot"
              ); )
                _RunInRootFrame$Deter++;
              if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
                for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                  _RunInRootFrame$Deter--;
              for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
                if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                  if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                    do
                      if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                        var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                          " at new ",
                          " at "
                        );
                        fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                        "function" === typeof fn && componentFrameCache.set(fn, _frame);
                        return _frame;
                      }
                    while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                  }
                  break;
                }
            }
          } finally {
            reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
          }
          sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
          "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
          return sampleLines;
        }
        function describeFiber(fiber, childFiber) {
          switch (fiber.tag) {
            case 26:
            case 27:
            case 5:
              return describeBuiltInComponentFrame(fiber.type);
            case 16:
              return describeBuiltInComponentFrame("Lazy");
            case 13:
              return fiber.child !== childFiber && null !== childFiber ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
            case 19:
              return describeBuiltInComponentFrame("SuspenseList");
            case 0:
            case 15:
              return describeNativeComponentFrame(fiber.type, false);
            case 11:
              return describeNativeComponentFrame(fiber.type.render, false);
            case 1:
              return describeNativeComponentFrame(fiber.type, true);
            case 31:
              return describeBuiltInComponentFrame("Activity");
            default:
              return "";
          }
        }
        function getStackByFiberInDevAndProd(workInProgress2) {
          try {
            var info = "", previous = null;
            do {
              info += describeFiber(workInProgress2, previous);
              var debugInfo = workInProgress2._debugInfo;
              if (debugInfo)
                for (var i = debugInfo.length - 1; 0 <= i; i--) {
                  var entry = debugInfo[i];
                  if ("string" === typeof entry.name) {
                    var JSCompiler_temp_const = info;
                    a: {
                      var name = entry.name, env = entry.env, location = entry.debugLocation;
                      if (null != location) {
                        var childStack = formatOwnerStack(location), idx = childStack.lastIndexOf("\n"), lastLine = -1 === idx ? childStack : childStack.slice(idx + 1);
                        if (-1 !== lastLine.indexOf(name)) {
                          var JSCompiler_inline_result = "\n" + lastLine;
                          break a;
                        }
                      }
                      JSCompiler_inline_result = describeBuiltInComponentFrame(
                        name + (env ? " [" + env + "]" : "")
                      );
                    }
                    info = JSCompiler_temp_const + JSCompiler_inline_result;
                  }
                }
              previous = workInProgress2;
              workInProgress2 = workInProgress2.return;
            } while (workInProgress2);
            return info;
          } catch (x) {
            return "\nError generating stack: " + x.message + "\n" + x.stack;
          }
        }
        function describeFunctionComponentFrameWithoutLineNumber(fn) {
          return (fn = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(fn) : "";
        }
        function getCurrentFiberOwnerNameInDevOrNull() {
          if (null === current) return null;
          var owner = current._debugOwner;
          return null != owner ? getComponentNameFromOwner(owner) : null;
        }
        function getCurrentFiberStackInDev() {
          if (null === current) return "";
          var workInProgress2 = current;
          try {
            var info = "";
            6 === workInProgress2.tag && (workInProgress2 = workInProgress2.return);
            switch (workInProgress2.tag) {
              case 26:
              case 27:
              case 5:
                info += describeBuiltInComponentFrame(workInProgress2.type);
                break;
              case 13:
                info += describeBuiltInComponentFrame("Suspense");
                break;
              case 19:
                info += describeBuiltInComponentFrame("SuspenseList");
                break;
              case 31:
                info += describeBuiltInComponentFrame("Activity");
                break;
              case 30:
              case 0:
              case 15:
              case 1:
                workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                  workInProgress2.type
                ));
                break;
              case 11:
                workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                  workInProgress2.type.render
                ));
            }
            for (; workInProgress2; )
              if ("number" === typeof workInProgress2.tag) {
                var fiber = workInProgress2;
                workInProgress2 = fiber._debugOwner;
                var debugStack = fiber._debugStack;
                if (workInProgress2 && debugStack) {
                  var formattedStack = formatOwnerStack(debugStack);
                  "" !== formattedStack && (info += "\n" + formattedStack);
                }
              } else if (null != workInProgress2.debugStack) {
                var ownerStack = workInProgress2.debugStack;
                (workInProgress2 = workInProgress2.owner) && ownerStack && (info += "\n" + formatOwnerStack(ownerStack));
              } else break;
            var JSCompiler_inline_result = info;
          } catch (x) {
            JSCompiler_inline_result = "\nError generating stack: " + x.message + "\n" + x.stack;
          }
          return JSCompiler_inline_result;
        }
        function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
          var previousFiber = current;
          setCurrentFiber(fiber);
          try {
            return null !== fiber && fiber._debugTask ? fiber._debugTask.run(
              callback.bind(null, arg0, arg1, arg2, arg3, arg4)
            ) : callback(arg0, arg1, arg2, arg3, arg4);
          } finally {
            setCurrentFiber(previousFiber);
          }
          throw Error(
            "runWithFiberInDEV should never be called in production. This is a bug in React."
          );
        }
        function setCurrentFiber(fiber) {
          ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;
          isRendering = false;
          current = fiber;
        }
        function typeName(value) {
          return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        }
        function willCoercionThrow(value) {
          try {
            return testStringCoercion(value), false;
          } catch (e) {
            return true;
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
              attributeName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
              propName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkFormFieldValueStringCoercion(value) {
          if (willCoercionThrow(value))
            return console.error(
              "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
              typeName(value)
            ), testStringCoercion(value);
        }
        function injectInternals(internals) {
          if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return false;
          var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook.isDisabled) return true;
          if (!hook.supportsFiber)
            return console.error(
              "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
            ), true;
          try {
            rendererID = hook.inject(internals), injectedHook = hook;
          } catch (err) {
            console.error("React instrumentation encountered an error: %o.", err);
          }
          return hook.checkDCE ? true : false;
        }
        function setIsStrictModeForDevtools(newIsStrictMode) {
          "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
          if (injectedHook && "function" === typeof injectedHook.setStrictMode)
            try {
              injectedHook.setStrictMode(rendererID, newIsStrictMode);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %o",
                err
              ));
            }
        }
        function clz32Fallback(x) {
          x >>>= 0;
          return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
        }
        function getHighestPriorityLanes(lanes) {
          var pendingSyncLanes = lanes & 42;
          if (0 !== pendingSyncLanes) return pendingSyncLanes;
          switch (lanes & -lanes) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
              return 64;
            case 128:
              return 128;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
              return lanes & 261888;
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return lanes & 3932160;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return lanes & 62914560;
            case 67108864:
              return 67108864;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 0;
            default:
              return console.error(
                "Should have found matching lanes. This is a bug in React."
              ), lanes;
          }
        }
        function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
          var pendingLanes = root2.pendingLanes;
          if (0 === pendingLanes) return 0;
          var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
          root2 = root2.warmLanes;
          var nonIdlePendingLanes = pendingLanes & 134217727;
          0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
          return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
        }
        function checkIfRootIsPrerendering(root2, renderLanes2) {
          return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
        }
        function computeExpirationTime(lane, currentTime) {
          switch (lane) {
            case 1:
            case 2:
            case 4:
            case 8:
            case 64:
              return currentTime + 250;
            case 16:
            case 32:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return currentTime + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return -1;
            case 67108864:
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
              return -1;
            default:
              return console.error(
                "Should have found matching lanes. This is a bug in React."
              ), -1;
          }
        }
        function claimNextRetryLane() {
          var lane = nextRetryLane;
          nextRetryLane <<= 1;
          0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
          return lane;
        }
        function createLaneMap(initial) {
          for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
          return laneMap;
        }
        function markRootUpdated$1(root2, updateLane) {
          root2.pendingLanes |= updateLane;
          268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
        }
        function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
          var previouslyPendingLanes = root2.pendingLanes;
          root2.pendingLanes = remainingLanes;
          root2.suspendedLanes = 0;
          root2.pingedLanes = 0;
          root2.warmLanes = 0;
          root2.expiredLanes &= remainingLanes;
          root2.entangledLanes &= remainingLanes;
          root2.errorRecoveryDisabledLanes &= remainingLanes;
          root2.shellSuspendCounter = 0;
          var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
          for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
            var index = 31 - clz32(remainingLanes), lane = 1 << index;
            entanglements[index] = 0;
            expirationTimes[index] = -1;
            var hiddenUpdatesForLane = hiddenUpdates[index];
            if (null !== hiddenUpdatesForLane)
              for (hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++) {
                var update = hiddenUpdatesForLane[index];
                null !== update && (update.lane &= -536870913);
              }
            remainingLanes &= ~lane;
          }
          0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
          0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
        }
        function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
          root2.pendingLanes |= spawnedLane;
          root2.suspendedLanes &= ~spawnedLane;
          var spawnedLaneIndex = 31 - clz32(spawnedLane);
          root2.entangledLanes |= spawnedLane;
          root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
        }
        function markRootEntangled(root2, entangledLanes) {
          var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
          for (root2 = root2.entanglements; rootEntangledLanes; ) {
            var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;
            lane & entangledLanes | root2[index] & entangledLanes && (root2[index] |= entangledLanes);
            rootEntangledLanes &= ~lane;
          }
        }
        function getBumpedLaneForHydration(root2, renderLanes2) {
          var renderLane = renderLanes2 & -renderLanes2;
          renderLane = 0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
          return 0 !== (renderLane & (root2.suspendedLanes | renderLanes2)) ? 0 : renderLane;
        }
        function getBumpedLaneForHydrationByLane(lane) {
          switch (lane) {
            case 2:
              lane = 1;
              break;
            case 8:
              lane = 4;
              break;
            case 32:
              lane = 16;
              break;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              lane = 128;
              break;
            case 268435456:
              lane = 134217728;
              break;
            default:
              lane = 0;
          }
          return lane;
        }
        function addFiberToLanesMap(root2, fiber, lanes) {
          if (isDevToolsPresent)
            for (root2 = root2.pendingUpdatersLaneMap; 0 < lanes; ) {
              var index = 31 - clz32(lanes), lane = 1 << index;
              root2[index].add(fiber);
              lanes &= ~lane;
            }
        }
        function movePendingFibersToMemoized(root2, lanes) {
          if (isDevToolsPresent)
            for (var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap, memoizedUpdaters = root2.memoizedUpdaters; 0 < lanes; ) {
              var index = 31 - clz32(lanes);
              root2 = 1 << index;
              index = pendingUpdatersLaneMap[index];
              0 < index.size && (index.forEach(function(fiber) {
                var alternate = fiber.alternate;
                null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);
              }), index.clear());
              lanes &= ~root2;
            }
        }
        function lanesToEventPriority(lanes) {
          lanes &= -lanes;
          return 0 !== DiscreteEventPriority && DiscreteEventPriority < lanes ? 0 !== ContinuousEventPriority && ContinuousEventPriority < lanes ? 0 !== (lanes & 134217727) ? DefaultEventPriority : IdleEventPriority : ContinuousEventPriority : DiscreteEventPriority;
        }
        function resolveUpdatePriority() {
          var updatePriority = ReactDOMSharedInternals.p;
          if (0 !== updatePriority) return updatePriority;
          updatePriority = window.event;
          return void 0 === updatePriority ? DefaultEventPriority : getEventPriority(updatePriority.type);
        }
        function runWithPriority2(priority, fn) {
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            return ReactDOMSharedInternals.p = priority, fn();
          } finally {
            ReactDOMSharedInternals.p = previousPriority;
          }
        }
        function detachDeletedInstance(node) {
          delete node[internalInstanceKey];
          delete node[internalPropsKey];
          delete node[internalEventHandlersKey];
          delete node[internalEventHandlerListenersKey];
          delete node[internalEventHandlesSetKey];
        }
        function getClosestInstanceFromNode(targetNode) {
          var targetInst = targetNode[internalInstanceKey];
          if (targetInst) return targetInst;
          for (var parentNode = targetNode.parentNode; parentNode; ) {
            if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
              parentNode = targetInst.alternate;
              if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
                for (targetNode = getParentHydrationBoundary(targetNode); null !== targetNode; ) {
                  if (parentNode = targetNode[internalInstanceKey])
                    return parentNode;
                  targetNode = getParentHydrationBoundary(targetNode);
                }
              return targetInst;
            }
            targetNode = parentNode;
            parentNode = targetNode.parentNode;
          }
          return null;
        }
        function getInstanceFromNode(node) {
          if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
            var tag = node.tag;
            if (5 === tag || 6 === tag || 13 === tag || 31 === tag || 26 === tag || 27 === tag || 3 === tag)
              return node;
          }
          return null;
        }
        function getNodeFromInstance(inst) {
          var tag = inst.tag;
          if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
            return inst.stateNode;
          throw Error("getNodeFromInstance: Invalid argument.");
        }
        function getResourcesFromRoot(root2) {
          var resources = root2[internalRootNodeResourcesKey];
          resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
          return resources;
        }
        function markNodeAsHoistable(node) {
          node[internalHoistableMarker] = true;
        }
        function registerTwoPhaseEvent(registrationName, dependencies) {
          registerDirectEvent(registrationName, dependencies);
          registerDirectEvent(registrationName + "Capture", dependencies);
        }
        function registerDirectEvent(registrationName, dependencies) {
          registrationNameDependencies[registrationName] && console.error(
            "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
            registrationName
          );
          registrationNameDependencies[registrationName] = dependencies;
          var lowerCasedName = registrationName.toLowerCase();
          possibleRegistrationNames[lowerCasedName] = registrationName;
          "onDoubleClick" === registrationName && (possibleRegistrationNames.ondblclick = registrationName);
          for (registrationName = 0; registrationName < dependencies.length; registrationName++)
            allNativeEvents.add(dependencies[registrationName]);
        }
        function checkControlledValueProps(tagName, props) {
          hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
          ) : console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
          ));
          props.onChange || props.readOnly || props.disabled || null == props.checked || console.error(
            "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
          );
        }
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
            return true;
          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
            return false;
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
            return validatedAttributeNameCache[attributeName] = true;
          illegalAttributeNameCache[attributeName] = true;
          console.error("Invalid attribute name: `%s`", attributeName);
          return false;
        }
        function getValueForAttributeOnCustomComponent(node, name, expected) {
          if (isAttributeNameSafe(name)) {
            if (!node.hasAttribute(name)) {
              switch (typeof expected) {
                case "symbol":
                case "object":
                  return expected;
                case "function":
                  return expected;
                case "boolean":
                  if (false === expected) return expected;
              }
              return void 0 === expected ? void 0 : null;
            }
            node = node.getAttribute(name);
            if ("" === node && true === expected) return true;
            checkAttributeStringCoercion(expected, name);
            return node === "" + expected ? expected : node;
          }
        }
        function setValueForAttribute(node, name, value) {
          if (isAttributeNameSafe(name))
            if (null === value) node.removeAttribute(name);
            else {
              switch (typeof value) {
                case "undefined":
                case "function":
                case "symbol":
                  node.removeAttribute(name);
                  return;
                case "boolean":
                  var prefix2 = name.toLowerCase().slice(0, 5);
                  if ("data-" !== prefix2 && "aria-" !== prefix2) {
                    node.removeAttribute(name);
                    return;
                  }
              }
              checkAttributeStringCoercion(value, name);
              node.setAttribute(name, "" + value);
            }
        }
        function setValueForKnownAttribute(node, name, value) {
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                node.removeAttribute(name);
                return;
            }
            checkAttributeStringCoercion(value, name);
            node.setAttribute(name, "" + value);
          }
        }
        function setValueForNamespacedAttribute(node, namespace, name, value) {
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                node.removeAttribute(name);
                return;
            }
            checkAttributeStringCoercion(value, name);
            node.setAttributeNS(namespace, name, "" + value);
          }
        }
        function getToStringValue(value) {
          switch (typeof value) {
            case "bigint":
            case "boolean":
            case "number":
            case "string":
            case "undefined":
              return value;
            case "object":
              return checkFormFieldValueStringCoercion(value), value;
            default:
              return "";
          }
        }
        function isCheckable(elem) {
          var type = elem.type;
          return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
        }
        function trackValueOnNode(node, valueField, currentValue) {
          var descriptor = Object.getOwnPropertyDescriptor(
            node.constructor.prototype,
            valueField
          );
          if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
            var get2 = descriptor.get, set2 = descriptor.set;
            Object.defineProperty(node, valueField, {
              configurable: true,
              get: function() {
                return get2.call(this);
              },
              set: function(value) {
                checkFormFieldValueStringCoercion(value);
                currentValue = "" + value;
                set2.call(this, value);
              }
            });
            Object.defineProperty(node, valueField, {
              enumerable: descriptor.enumerable
            });
            return {
              getValue: function() {
                return currentValue;
              },
              setValue: function(value) {
                checkFormFieldValueStringCoercion(value);
                currentValue = "" + value;
              },
              stopTracking: function() {
                node._valueTracker = null;
                delete node[valueField];
              }
            };
          }
        }
        function track(node) {
          if (!node._valueTracker) {
            var valueField = isCheckable(node) ? "checked" : "value";
            node._valueTracker = trackValueOnNode(
              node,
              valueField,
              "" + node[valueField]
            );
          }
        }
        function updateValueIfChanged(node) {
          if (!node) return false;
          var tracker = node._valueTracker;
          if (!tracker) return true;
          var lastValue = tracker.getValue();
          var value = "";
          node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
          node = value;
          return node !== lastValue ? (tracker.setValue(node), true) : false;
        }
        function getActiveElement(doc) {
          doc = doc || ("undefined" !== typeof document ? document : void 0);
          if ("undefined" === typeof doc) return null;
          try {
            return doc.activeElement || doc.body;
          } catch (e) {
            return doc.body;
          }
        }
        function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
          return value.replace(
            escapeSelectorAttributeValueInsideDoubleQuotesRegex,
            function(ch) {
              return "\\" + ch.charCodeAt(0).toString(16) + " ";
            }
          );
        }
        function validateInputProps(element, props) {
          void 0 === props.checked || void 0 === props.defaultChecked || didWarnCheckedDefaultChecked || (console.error(
            "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component",
            props.type
          ), didWarnCheckedDefaultChecked = true);
          void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue$1 || (console.error(
            "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component",
            props.type
          ), didWarnValueDefaultValue$1 = true);
        }
        function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
          element.name = "";
          null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? (checkAttributeStringCoercion(type, "type"), element.type = type) : element.removeAttribute("type");
          if (null != value)
            if ("number" === type) {
              if (0 === value && "" === element.value || element.value != value)
                element.value = "" + getToStringValue(value);
            } else
              element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
          else
            "submit" !== type && "reset" !== type || element.removeAttribute("value");
          null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
          null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
          null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
          null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? (checkAttributeStringCoercion(name, "name"), element.name = "" + getToStringValue(name)) : element.removeAttribute("name");
        }
        function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
          null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (checkAttributeStringCoercion(type, "type"), element.type = type);
          if (null != value || null != defaultValue) {
            if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) {
              track(element);
              return;
            }
            defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
            value = null != value ? "" + getToStringValue(value) : defaultValue;
            isHydrating2 || value === element.value || (element.value = value);
            element.defaultValue = value;
          }
          checked = null != checked ? checked : defaultChecked;
          checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
          element.checked = isHydrating2 ? element.checked : !!checked;
          element.defaultChecked = !!checked;
          null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (checkAttributeStringCoercion(name, "name"), element.name = name);
          track(element);
        }
        function setDefaultValue(node, type, value) {
          "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
        }
        function validateOptionProps(element, props) {
          null == props.value && ("object" === typeof props.children && null !== props.children ? React9.Children.forEach(props.children, function(child) {
            null == child || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || didWarnInvalidChild || (didWarnInvalidChild = true, console.error(
              "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
            ));
          }) : null == props.dangerouslySetInnerHTML || didWarnInvalidInnerHTML || (didWarnInvalidInnerHTML = true, console.error(
            "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
          )));
          null == props.selected || didWarnSelectedSetOnOption || (console.error(
            "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
          ), didWarnSelectedSetOnOption = true);
        }
        function getDeclarationErrorAddendum() {
          var ownerName = getCurrentFiberOwnerNameInDevOrNull();
          return ownerName ? "\n\nCheck the render method of `" + ownerName + "`." : "";
        }
        function updateOptions(node, multiple, propValue, setDefaultSelected) {
          node = node.options;
          if (multiple) {
            multiple = {};
            for (var i = 0; i < propValue.length; i++)
              multiple["$" + propValue[i]] = true;
            for (propValue = 0; propValue < node.length; propValue++)
              i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
          } else {
            propValue = "" + getToStringValue(propValue);
            multiple = null;
            for (i = 0; i < node.length; i++) {
              if (node[i].value === propValue) {
                node[i].selected = true;
                setDefaultSelected && (node[i].defaultSelected = true);
                return;
              }
              null !== multiple || node[i].disabled || (multiple = node[i]);
            }
            null !== multiple && (multiple.selected = true);
          }
        }
        function validateSelectProps(element, props) {
          for (element = 0; element < valuePropNames.length; element++) {
            var propName = valuePropNames[element];
            if (null != props[propName]) {
              var propNameIsArray = isArrayImpl(props[propName]);
              props.multiple && !propNameIsArray ? console.error(
                "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
                propName,
                getDeclarationErrorAddendum()
              ) : !props.multiple && propNameIsArray && console.error(
                "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
                propName,
                getDeclarationErrorAddendum()
              );
            }
          }
          void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue || (console.error(
            "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
          ), didWarnValueDefaultValue = true);
        }
        function validateTextareaProps(element, props) {
          void 0 === props.value || void 0 === props.defaultValue || didWarnValDefaultVal || (console.error(
            "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component"
          ), didWarnValDefaultVal = true);
          null != props.children && null == props.value && console.error(
            "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
          );
        }
        function updateTextarea(element, value, defaultValue) {
          if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
            element.defaultValue !== value && (element.defaultValue = value);
            return;
          }
          element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        }
        function initTextarea(element, value, defaultValue, children) {
          if (null == value) {
            if (null != children) {
              if (null != defaultValue)
                throw Error(
                  "If you supply `defaultValue` on a <textarea>, do not pass children."
                );
              if (isArrayImpl(children)) {
                if (1 < children.length)
                  throw Error("<textarea> can only have at most one child.");
                children = children[0];
              }
              defaultValue = children;
            }
            null == defaultValue && (defaultValue = "");
            value = defaultValue;
          }
          defaultValue = getToStringValue(value);
          element.defaultValue = defaultValue;
          children = element.textContent;
          children === defaultValue && "" !== children && null !== children && (element.value = children);
          track(element);
        }
        function findNotableNode(node, indent) {
          return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;
        }
        function indentation(indent) {
          return "  " + "  ".repeat(indent);
        }
        function added(indent) {
          return "+ " + "  ".repeat(indent);
        }
        function removed(indent) {
          return "- " + "  ".repeat(indent);
        }
        function describeFiberType(fiber) {
          switch (fiber.tag) {
            case 26:
            case 27:
            case 5:
              return fiber.type;
            case 16:
              return "Lazy";
            case 31:
              return "Activity";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 0:
            case 15:
              return fiber = fiber.type, fiber.displayName || fiber.name || null;
            case 11:
              return fiber = fiber.type.render, fiber.displayName || fiber.name || null;
            case 1:
              return fiber = fiber.type, fiber.displayName || fiber.name || null;
            default:
              return null;
          }
        }
        function describeTextNode(content, maxLength) {
          return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{"..."}' : "{" + content.slice(0, maxLength - 7) + '..."}' : "{" + content + "}") : content.length > maxLength ? 5 > maxLength ? '{"..."}' : content.slice(0, maxLength - 3) + "..." : content;
        }
        function describeTextDiff(clientText, serverProps, indent) {
          var maxLength = 120 - 2 * indent;
          if (null === serverProps)
            return added(indent) + describeTextNode(clientText, maxLength) + "\n";
          if ("string" === typeof serverProps) {
            for (var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++) ;
            firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = "..." + clientText.slice(firstDiff - 8), serverProps = "..." + serverProps.slice(firstDiff - 8));
            return added(indent) + describeTextNode(clientText, maxLength) + "\n" + removed(indent) + describeTextNode(serverProps, maxLength) + "\n";
          }
          return indentation(indent) + describeTextNode(clientText, maxLength) + "\n";
        }
        function objectName(object) {
          return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m, p0) {
            return p0;
          });
        }
        function describeValue(value, maxLength) {
          switch (typeof value) {
            case "string":
              return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '"..."' : value.slice(0, maxLength - 4) + '..."' : value;
            case "object":
              if (null === value) return "null";
              if (isArrayImpl(value)) return "[...]";
              if (value.$$typeof === REACT_ELEMENT_TYPE)
                return (maxLength = getComponentNameFromType(value.type)) ? "<" + maxLength + ">" : "<...>";
              var name = objectName(value);
              if ("Object" === name) {
                name = "";
                maxLength -= 2;
                for (var propName in value)
                  if (value.hasOwnProperty(propName)) {
                    var jsonPropName = JSON.stringify(propName);
                    jsonPropName !== '"' + propName + '"' && (propName = jsonPropName);
                    maxLength -= propName.length - 2;
                    jsonPropName = describeValue(
                      value[propName],
                      15 > maxLength ? maxLength : 15
                    );
                    maxLength -= jsonPropName.length;
                    if (0 > maxLength) {
                      name += "" === name ? "..." : ", ...";
                      break;
                    }
                    name += ("" === name ? "" : ",") + propName + ":" + jsonPropName;
                  }
                return "{" + name + "}";
              }
              return name;
            case "function":
              return (maxLength = value.displayName || value.name) ? "function " + maxLength : "function";
            default:
              return String(value);
          }
        }
        function describePropValue(value, maxLength) {
          return "string" !== typeof value || needsEscaping.test(value) ? "{" + describeValue(value, maxLength - 2) + "}" : value.length > maxLength - 2 ? 5 > maxLength ? '"..."' : '"' + value.slice(0, maxLength - 5) + '..."' : '"' + value + '"';
        }
        function describeExpandedElement(type, props, rowPrefix) {
          var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;
          for (propName in props)
            if (props.hasOwnProperty(propName) && "children" !== propName) {
              var propValue = describePropValue(
                props[propName],
                120 - rowPrefix.length - propName.length - 1
              );
              remainingRowLength -= propName.length + propValue.length + 2;
              properties.push(propName + "=" + propValue);
            }
          return 0 === properties.length ? rowPrefix + "<" + type + ">\n" : 0 < remainingRowLength ? rowPrefix + "<" + type + " " + properties.join(" ") + ">\n" : rowPrefix + "<" + type + "\n" + rowPrefix + "  " + properties.join("\n" + rowPrefix + "  ") + "\n" + rowPrefix + ">\n";
        }
        function describePropertiesDiff(clientObject, serverObject, indent) {
          var properties = "", remainingServerProperties = assign2({}, serverObject), propName;
          for (propName in clientObject)
            if (clientObject.hasOwnProperty(propName)) {
              delete remainingServerProperties[propName];
              var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);
              serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + ": " + clientPropValue + "\n", properties += removed(indent) + propName + ": " + maxLength + "\n") : properties += added(indent) + propName + ": " + clientPropValue + "\n";
            }
          for (var _propName in remainingServerProperties)
            remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(
              remainingServerProperties[_propName],
              120 - 2 * indent - _propName.length - 2
            ), properties += removed(indent) + _propName + ": " + clientObject + "\n");
          return properties;
        }
        function describeElementDiff(type, clientProps, serverProps, indent) {
          var content = "", serverPropNames = /* @__PURE__ */ new Map();
          for (propName$jscomp$0 in serverProps)
            serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(
              propName$jscomp$0.toLowerCase(),
              propName$jscomp$0
            );
          if (1 === serverPropNames.size && serverPropNames.has("children"))
            content += describeExpandedElement(
              type,
              clientProps,
              indentation(indent)
            );
          else {
            for (var _propName2 in clientProps)
              if (clientProps.hasOwnProperty(_propName2) && "children" !== _propName2) {
                var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());
                if (void 0 !== serverPropName) {
                  serverPropNames.delete(_propName2.toLowerCase());
                  var propName$jscomp$0 = clientProps[_propName2];
                  serverPropName = serverProps[serverPropName];
                  var clientPropValue = describePropValue(
                    propName$jscomp$0,
                    maxLength$jscomp$0
                  );
                  maxLength$jscomp$0 = describePropValue(
                    serverPropName,
                    maxLength$jscomp$0
                  );
                  "object" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && "object" === typeof serverPropName && null !== serverPropName && "Object" === objectName(propName$jscomp$0) && "Object" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf("...") || -1 < maxLength$jscomp$0.indexOf("...")) ? content += indentation(indent + 1) + _propName2 + "={{\n" + describePropertiesDiff(
                    propName$jscomp$0,
                    serverPropName,
                    indent + 2
                  ) + indentation(indent + 1) + "}}\n" : (content += added(indent + 1) + _propName2 + "=" + clientPropValue + "\n", content += removed(indent + 1) + _propName2 + "=" + maxLength$jscomp$0 + "\n");
                } else
                  content += indentation(indent + 1) + _propName2 + "=" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + "\n";
              }
            serverPropNames.forEach(function(propName) {
              if ("children" !== propName) {
                var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
                content += removed(indent + 1) + propName + "=" + describePropValue(serverProps[propName], maxLength) + "\n";
              }
            });
            content = "" === content ? indentation(indent) + "<" + type + ">\n" : indentation(indent) + "<" + type + "\n" + content + indentation(indent) + ">\n";
          }
          type = serverProps.children;
          clientProps = clientProps.children;
          if ("string" === typeof type || "number" === typeof type || "bigint" === typeof type) {
            serverPropNames = "";
            if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
              serverPropNames = "" + clientProps;
            content += describeTextDiff(serverPropNames, "" + type, indent + 1);
          } else if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
            content = null == type ? content + describeTextDiff("" + clientProps, null, indent + 1) : content + describeTextDiff("" + clientProps, void 0, indent + 1);
          return content;
        }
        function describeSiblingFiber(fiber, indent) {
          var type = describeFiberType(fiber);
          if (null === type) {
            type = "";
            for (fiber = fiber.child; fiber; )
              type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;
            return type;
          }
          return indentation(indent) + "<" + type + ">\n";
        }
        function describeNode(node, indent) {
          var skipToNode = findNotableNode(node, indent);
          if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode))
            return indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1);
          skipToNode = "";
          var debugInfo = node.fiber._debugInfo;
          if (debugInfo)
            for (var i = 0; i < debugInfo.length; i++) {
              var serverComponentName = debugInfo[i].name;
              "string" === typeof serverComponentName && (skipToNode += indentation(indent) + "<" + serverComponentName + ">\n", indent++);
            }
          debugInfo = "";
          i = node.fiber.pendingProps;
          if (6 === node.fiber.tag)
            debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;
          else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName)
            if (void 0 === node.serverProps) {
              debugInfo = indent;
              var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = "";
              for (propName in i)
                if (i.hasOwnProperty(propName) && "children" !== propName) {
                  var propValue = describePropValue(i[propName], 15);
                  maxLength -= propName.length + propValue.length + 2;
                  if (0 > maxLength) {
                    content += " ...";
                    break;
                  }
                  content += " " + propName + "=" + propValue;
                }
              debugInfo = indentation(debugInfo) + "<" + serverComponentName + content + ">\n";
              indent++;
            } else
              null === node.serverProps ? (debugInfo = describeExpandedElement(
                serverComponentName,
                i,
                added(indent)
              ), indent++) : "string" === typeof node.serverProps ? console.error(
                "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
              ) : (debugInfo = describeElementDiff(
                serverComponentName,
                i,
                node.serverProps,
                indent
              ), indent++);
          var propName = "";
          i = node.fiber.child;
          for (serverComponentName = 0; i && serverComponentName < node.children.length; )
            maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;
          i && 0 < node.children.length && (propName += indentation(indent) + "...\n");
          i = node.serverTail;
          null === node.serverProps && indent--;
          for (node = 0; node < i.length; node++)
            serverComponentName = i[node], propName = "string" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + "\n") : propName + describeExpandedElement(
              serverComponentName.type,
              serverComponentName.props,
              removed(indent)
            );
          return skipToNode + debugInfo + propName;
        }
        function describeDiff(rootNode) {
          try {
            return "\n\n" + describeNode(rootNode, 0);
          } catch (x) {
            return "";
          }
        }
        function describeAncestors(ancestor, child, props) {
          for (var fiber = child, node = null, distanceFromLeaf = 0; fiber; )
            fiber === ancestor && (distanceFromLeaf = 0), node = {
              fiber,
              children: null !== node ? [node] : [],
              serverProps: fiber === child ? props : fiber === ancestor ? null : void 0,
              serverTail: [],
              distanceFromLeaf
            }, distanceFromLeaf++, fiber = fiber.return;
          return null !== node ? describeDiff(node).replaceAll(/^[+-]/gm, ">") : "";
        }
        function updatedAncestorInfoDev(oldInfo, tag) {
          var ancestorInfo = assign2({}, oldInfo || emptyAncestorInfoDev), info = { tag };
          -1 !== inScopeTags.indexOf(tag) && (ancestorInfo.aTagInScope = null, ancestorInfo.buttonTagInScope = null, ancestorInfo.nobrTagInScope = null);
          -1 !== buttonScopeTags.indexOf(tag) && (ancestorInfo.pTagInButtonScope = null);
          -1 !== specialTags.indexOf(tag) && "address" !== tag && "div" !== tag && "p" !== tag && (ancestorInfo.listItemTagAutoclosing = null, ancestorInfo.dlItemTagAutoclosing = null);
          ancestorInfo.current = info;
          "form" === tag && (ancestorInfo.formTag = info);
          "a" === tag && (ancestorInfo.aTagInScope = info);
          "button" === tag && (ancestorInfo.buttonTagInScope = info);
          "nobr" === tag && (ancestorInfo.nobrTagInScope = info);
          "p" === tag && (ancestorInfo.pTagInButtonScope = info);
          "li" === tag && (ancestorInfo.listItemTagAutoclosing = info);
          if ("dd" === tag || "dt" === tag)
            ancestorInfo.dlItemTagAutoclosing = info;
          "#document" === tag || "html" === tag ? ancestorInfo.containerTagInScope = null : ancestorInfo.containerTagInScope || (ancestorInfo.containerTagInScope = info);
          null !== oldInfo || "#document" !== tag && "html" !== tag && "body" !== tag ? true === ancestorInfo.implicitRootScope && (ancestorInfo.implicitRootScope = false) : ancestorInfo.implicitRootScope = true;
          return ancestorInfo;
        }
        function isTagValidWithParent(tag, parentTag, implicitRootScope) {
          switch (parentTag) {
            case "select":
              return "hr" === tag || "option" === tag || "optgroup" === tag || "script" === tag || "template" === tag || "#text" === tag;
            case "optgroup":
              return "option" === tag || "#text" === tag;
            case "option":
              return "#text" === tag;
            case "tr":
              return "th" === tag || "td" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "tbody":
            case "thead":
            case "tfoot":
              return "tr" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "colgroup":
              return "col" === tag || "template" === tag;
            case "table":
              return "caption" === tag || "colgroup" === tag || "tbody" === tag || "tfoot" === tag || "thead" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "head":
              return "base" === tag || "basefont" === tag || "bgsound" === tag || "link" === tag || "meta" === tag || "title" === tag || "noscript" === tag || "noframes" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "html":
              if (implicitRootScope) break;
              return "head" === tag || "body" === tag || "frameset" === tag;
            case "frameset":
              return "frame" === tag;
            case "#document":
              if (!implicitRootScope) return "html" === tag;
          }
          switch (tag) {
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return "h1" !== parentTag && "h2" !== parentTag && "h3" !== parentTag && "h4" !== parentTag && "h5" !== parentTag && "h6" !== parentTag;
            case "rp":
            case "rt":
              return -1 === impliedEndTags.indexOf(parentTag);
            case "caption":
            case "col":
            case "colgroup":
            case "frameset":
            case "frame":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              return null == parentTag;
            case "head":
              return implicitRootScope || null === parentTag;
            case "html":
              return implicitRootScope && "#document" === parentTag || null === parentTag;
            case "body":
              return implicitRootScope && ("#document" === parentTag || "html" === parentTag) || null === parentTag;
          }
          return true;
        }
        function findInvalidAncestorForTag(tag, ancestorInfo) {
          switch (tag) {
            case "address":
            case "article":
            case "aside":
            case "blockquote":
            case "center":
            case "details":
            case "dialog":
            case "dir":
            case "div":
            case "dl":
            case "fieldset":
            case "figcaption":
            case "figure":
            case "footer":
            case "header":
            case "hgroup":
            case "main":
            case "menu":
            case "nav":
            case "ol":
            case "p":
            case "section":
            case "summary":
            case "ul":
            case "pre":
            case "listing":
            case "table":
            case "hr":
            case "xmp":
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return ancestorInfo.pTagInButtonScope;
            case "form":
              return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
            case "li":
              return ancestorInfo.listItemTagAutoclosing;
            case "dd":
            case "dt":
              return ancestorInfo.dlItemTagAutoclosing;
            case "button":
              return ancestorInfo.buttonTagInScope;
            case "a":
              return ancestorInfo.aTagInScope;
            case "nobr":
              return ancestorInfo.nobrTagInScope;
          }
          return null;
        }
        function findAncestor(parent, tagName) {
          for (; parent; ) {
            switch (parent.tag) {
              case 5:
              case 26:
              case 27:
                if (parent.type === tagName) return parent;
            }
            parent = parent.return;
          }
          return null;
        }
        function validateDOMNesting(childTag, ancestorInfo) {
          ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
          var parentInfo = ancestorInfo.current;
          ancestorInfo = (parentInfo = isTagValidWithParent(
            childTag,
            parentInfo && parentInfo.tag,
            ancestorInfo.implicitRootScope
          ) ? null : parentInfo) ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
          ancestorInfo = parentInfo || ancestorInfo;
          if (!ancestorInfo) return true;
          var ancestorTag = ancestorInfo.tag;
          ancestorInfo = String(!!parentInfo) + "|" + childTag + "|" + ancestorTag;
          if (didWarn[ancestorInfo]) return false;
          didWarn[ancestorInfo] = true;
          var ancestor = (ancestorInfo = current) ? findAncestor(ancestorInfo.return, ancestorTag) : null, ancestorDescription = null !== ancestorInfo && null !== ancestor ? describeAncestors(ancestor, ancestorInfo, null) : "", tagDisplayName = "<" + childTag + ">";
          parentInfo ? (parentInfo = "", "table" === ancestorTag && "tr" === childTag && (parentInfo += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error(
            "In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s",
            tagDisplayName,
            ancestorTag,
            parentInfo,
            ancestorDescription
          )) : console.error(
            "In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s",
            tagDisplayName,
            ancestorTag,
            ancestorDescription
          );
          ancestorInfo && (childTag = ancestorInfo.return, null === ancestor || null === childTag || ancestor === childTag && childTag._debugOwner === ancestorInfo._debugOwner || runWithFiberInDEV(ancestor, function() {
            console.error(
              "<%s> cannot contain a nested %s.\nSee this log for the ancestor stack trace.",
              ancestorTag,
              tagDisplayName
            );
          }));
          return false;
        }
        function validateTextNesting(childText, parentTag, implicitRootScope) {
          if (implicitRootScope || isTagValidWithParent("#text", parentTag, false))
            return true;
          implicitRootScope = "#text|" + parentTag;
          if (didWarn[implicitRootScope]) return false;
          didWarn[implicitRootScope] = true;
          var ancestor = (implicitRootScope = current) ? findAncestor(implicitRootScope, parentTag) : null;
          implicitRootScope = null !== implicitRootScope && null !== ancestor ? describeAncestors(
            ancestor,
            implicitRootScope,
            6 !== implicitRootScope.tag ? { children: null } : null
          ) : "";
          /\S/.test(childText) ? console.error(
            "In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.%s",
            parentTag,
            implicitRootScope
          ) : console.error(
            "In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.%s",
            parentTag,
            implicitRootScope
          );
          return false;
        }
        function setTextContent(node, text) {
          if (text) {
            var firstChild = node.firstChild;
            if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
              firstChild.nodeValue = text;
              return;
            }
          }
          node.textContent = text;
        }
        function camelize(string) {
          return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
          });
        }
        function setValueForStyle(style3, styleName, value) {
          var isCustomProperty = 0 === styleName.indexOf("--");
          isCustomProperty || (-1 < styleName.indexOf("-") ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
            "Unsupported style property %s. Did you mean %s?",
            styleName,
            camelize(styleName.replace(msPattern, "ms-"))
          )) : badVendoredStyleNamePattern.test(styleName) ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
            "Unsupported vendor-prefixed style property %s. Did you mean %s?",
            styleName,
            styleName.charAt(0).toUpperCase() + styleName.slice(1)
          )) : !badStyleValueWithSemicolonPattern.test(value) || warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = true, console.error(
            `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
            styleName,
            value.replace(badStyleValueWithSemicolonPattern, "")
          )), "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error(
            "`NaN` is an invalid value for the `%s` css style property.",
            styleName
          )) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error(
            "`Infinity` is an invalid value for the `%s` css style property.",
            styleName
          ))));
          null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style3.setProperty(styleName, "") : "float" === styleName ? style3.cssFloat = "" : style3[styleName] = "" : isCustomProperty ? style3.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style3.cssFloat = value : (checkCSSPropertyStringCoercion(value, styleName), style3[styleName] = ("" + value).trim()) : style3[styleName] = value + "px";
        }
        function setValueForStyles(node, styles, prevStyles) {
          if (null != styles && "object" !== typeof styles)
            throw Error(
              "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
            );
          styles && Object.freeze(styles);
          node = node.style;
          if (null != prevStyles) {
            if (styles) {
              var expandedUpdates = {};
              if (prevStyles) {
                for (var key in prevStyles)
                  if (prevStyles.hasOwnProperty(key) && !styles.hasOwnProperty(key))
                    for (var longhands = shorthandToLonghand[key] || [key], i = 0; i < longhands.length; i++)
                      expandedUpdates[longhands[i]] = key;
              }
              for (var _key in styles)
                if (styles.hasOwnProperty(_key) && (!prevStyles || prevStyles[_key] !== styles[_key]))
                  for (key = shorthandToLonghand[_key] || [_key], longhands = 0; longhands < key.length; longhands++)
                    expandedUpdates[key[longhands]] = _key;
              _key = {};
              for (var key$jscomp$0 in styles)
                for (key = shorthandToLonghand[key$jscomp$0] || [key$jscomp$0], longhands = 0; longhands < key.length; longhands++)
                  _key[key[longhands]] = key$jscomp$0;
              key$jscomp$0 = {};
              for (var _key2 in expandedUpdates)
                if (key = expandedUpdates[_key2], (longhands = _key[_key2]) && key !== longhands && (i = key + "," + longhands, !key$jscomp$0[i])) {
                  key$jscomp$0[i] = true;
                  i = console;
                  var value = styles[key];
                  i.error.call(
                    i,
                    "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
                    null == value || "boolean" === typeof value || "" === value ? "Removing" : "Updating",
                    key,
                    longhands
                  );
                }
            }
            for (var styleName in prevStyles)
              !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
            for (var _styleName in styles)
              _key2 = styles[_styleName], styles.hasOwnProperty(_styleName) && prevStyles[_styleName] !== _key2 && setValueForStyle(node, _styleName, _key2);
          } else
            for (expandedUpdates in styles)
              styles.hasOwnProperty(expandedUpdates) && setValueForStyle(node, expandedUpdates, styles[expandedUpdates]);
        }
        function isCustomElement(tagName) {
          if (-1 === tagName.indexOf("-")) return false;
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        function getAttributeAlias(name) {
          return aliases.get(name) || name;
        }
        function validateProperty$1(tagName, name) {
          if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
            return true;
          if (rARIACamel$1.test(name)) {
            tagName = "aria-" + name.slice(4).toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
                name
              ), warnedProperties$1[name] = true;
            if (name !== tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. Did you mean `%s`?",
                name,
                tagName
              ), warnedProperties$1[name] = true;
          }
          if (rARIA$1.test(name)) {
            tagName = name.toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName) return warnedProperties$1[name] = true, false;
            name !== tagName && (console.error(
              "Unknown ARIA attribute `%s`. Did you mean `%s`?",
              name,
              tagName
            ), warnedProperties$1[name] = true);
          }
          return true;
        }
        function validateProperties$2(type, props) {
          var invalidProps = [], key;
          for (key in props)
            validateProperty$1(type, key) || invalidProps.push(key);
          props = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === invalidProps.length ? console.error(
            "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          ) : 1 < invalidProps.length && console.error(
            "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          );
        }
        function validateProperty(tagName, name, value, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
            return true;
          var lowerCasedName = name.toLowerCase();
          if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
            return console.error(
              "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
            ), warnedProperties[name] = true;
          if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name))
            return true;
          if (null != eventRegistry) {
            tagName = eventRegistry.possibleRegistrationNames;
            if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
              return true;
            eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
            if (null != eventRegistry)
              return console.error(
                "Invalid event handler property `%s`. Did you mean `%s`?",
                name,
                eventRegistry
              ), warnedProperties[name] = true;
            if (EVENT_NAME_REGEX.test(name))
              return console.error(
                "Unknown event handler property `%s`. It will be ignored.",
                name
              ), warnedProperties[name] = true;
          } else if (EVENT_NAME_REGEX.test(name))
            return INVALID_EVENT_NAME_REGEX.test(name) && console.error(
              "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
              name
            ), warnedProperties[name] = true;
          if (rARIA.test(name) || rARIACamel.test(name)) return true;
          if ("innerhtml" === lowerCasedName)
            return console.error(
              "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
            ), warnedProperties[name] = true;
          if ("aria" === lowerCasedName)
            return console.error(
              "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
            ), warnedProperties[name] = true;
          if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value)
            return console.error(
              "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
              typeof value
            ), warnedProperties[name] = true;
          if ("number" === typeof value && isNaN(value))
            return console.error(
              "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
              name
            ), warnedProperties[name] = true;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name)
              return console.error(
                "Invalid DOM property `%s`. Did you mean `%s`?",
                name,
                lowerCasedName
              ), warnedProperties[name] = true;
          } else if (name !== lowerCasedName)
            return console.error(
              "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
              name,
              lowerCasedName
            ), warnedProperties[name] = true;
          switch (name) {
            case "dangerouslySetInnerHTML":
            case "children":
            case "style":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              return true;
            case "innerText":
            case "textContent":
              return true;
          }
          switch (typeof value) {
            case "boolean":
              switch (name) {
                case "autoFocus":
                case "checked":
                case "multiple":
                case "muted":
                case "selected":
                case "contentEditable":
                case "spellCheck":
                case "draggable":
                case "value":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                case "capture":
                case "download":
                case "inert":
                  return true;
                default:
                  lowerCasedName = name.toLowerCase().slice(0, 5);
                  if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                    return true;
                  value ? console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                    value,
                    name,
                    name,
                    value,
                    name
                  ) : console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                    value,
                    name,
                    name,
                    value,
                    name,
                    name,
                    name
                  );
                  return warnedProperties[name] = true;
              }
            case "function":
            case "symbol":
              return warnedProperties[name] = true, false;
            case "string":
              if ("false" === value || "true" === value) {
                switch (name) {
                  case "checked":
                  case "selected":
                  case "multiple":
                  case "muted":
                  case "allowFullScreen":
                  case "async":
                  case "autoPlay":
                  case "controls":
                  case "default":
                  case "defer":
                  case "disabled":
                  case "disablePictureInPicture":
                  case "disableRemotePlayback":
                  case "formNoValidate":
                  case "hidden":
                  case "loop":
                  case "noModule":
                  case "noValidate":
                  case "open":
                  case "playsInline":
                  case "readOnly":
                  case "required":
                  case "reversed":
                  case "scoped":
                  case "seamless":
                  case "itemScope":
                  case "inert":
                    break;
                  default:
                    return true;
                }
                console.error(
                  "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
                  value,
                  name,
                  "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
                  name,
                  value
                );
                warnedProperties[name] = true;
              }
          }
          return true;
        }
        function warnUnknownProperties(type, props, eventRegistry) {
          var unknownProps = [], key;
          for (key in props)
            validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
          props = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === unknownProps.length ? console.error(
            "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          ) : 1 < unknownProps.length && console.error(
            "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          );
        }
        function sanitizeURL(url) {
          return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
        }
        function noop$1() {
        }
        function getEventTarget(nativeEvent) {
          nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
          nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
          return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
        }
        function restoreStateOfTarget(target) {
          var internalInstance = getInstanceFromNode(target);
          if (internalInstance && (target = internalInstance.stateNode)) {
            var props = target[internalPropsKey] || null;
            a: switch (target = internalInstance.stateNode, internalInstance.type) {
              case "input":
                updateInput(
                  target,
                  props.value,
                  props.defaultValue,
                  props.defaultValue,
                  props.checked,
                  props.defaultChecked,
                  props.type,
                  props.name
                );
                internalInstance = props.name;
                if ("radio" === props.type && null != internalInstance) {
                  for (props = target; props.parentNode; ) props = props.parentNode;
                  checkAttributeStringCoercion(internalInstance, "name");
                  props = props.querySelectorAll(
                    'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                      "" + internalInstance
                    ) + '"][type="radio"]'
                  );
                  for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                    var otherNode = props[internalInstance];
                    if (otherNode !== target && otherNode.form === target.form) {
                      var otherProps = otherNode[internalPropsKey] || null;
                      if (!otherProps)
                        throw Error(
                          "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
                        );
                      updateInput(
                        otherNode,
                        otherProps.value,
                        otherProps.defaultValue,
                        otherProps.defaultValue,
                        otherProps.checked,
                        otherProps.defaultChecked,
                        otherProps.type,
                        otherProps.name
                      );
                    }
                  }
                  for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                    otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
                }
                break a;
              case "textarea":
                updateTextarea(target, props.value, props.defaultValue);
                break a;
              case "select":
                internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
            }
          }
        }
        function batchedUpdates$1(fn, a, b) {
          if (isInsideEventHandler) return fn(a, b);
          isInsideEventHandler = true;
          try {
            var JSCompiler_inline_result = fn(a);
            return JSCompiler_inline_result;
          } finally {
            if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
              if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
                for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
            }
          }
        }
        function getListener(inst, registrationName) {
          var stateNode = inst.stateNode;
          if (null === stateNode) return null;
          var props = stateNode[internalPropsKey] || null;
          if (null === props) return null;
          stateNode = props[registrationName];
          a: switch (registrationName) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
              inst = !props;
              break a;
            default:
              inst = false;
          }
          if (inst) return null;
          if (stateNode && "function" !== typeof stateNode)
            throw Error(
              "Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof stateNode + "` type."
            );
          return stateNode;
        }
        function getData() {
          if (fallbackText) return fallbackText;
          var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
          for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
          var minEnd = startLength - start;
          for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
          return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
        }
        function getEventCharCode(nativeEvent) {
          var keyCode = nativeEvent.keyCode;
          "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
          10 === nativeEvent && (nativeEvent = 13);
          return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
        }
        function functionThatReturnsTrue() {
          return true;
        }
        function functionThatReturnsFalse() {
          return false;
        }
        function createSyntheticEvent(Interface) {
          function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
            this._reactName = reactName;
            this._targetInst = targetInst;
            this.type = reactEventType;
            this.nativeEvent = nativeEvent;
            this.target = nativeEventTarget;
            this.currentTarget = null;
            for (var propName in Interface)
              Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
            this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
          }
          assign2(SyntheticBaseEvent.prototype, {
            preventDefault: function() {
              this.defaultPrevented = true;
              var event = this.nativeEvent;
              event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
            },
            stopPropagation: function() {
              var event = this.nativeEvent;
              event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
            },
            persist: function() {
            },
            isPersistent: functionThatReturnsTrue
          });
          return SyntheticBaseEvent;
        }
        function modifierStateGetter(keyArg) {
          var nativeEvent = this.nativeEvent;
          return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
        }
        function getEventModifierState() {
          return modifierStateGetter;
        }
        function isFallbackCompositionEnd(domEventName, nativeEvent) {
          switch (domEventName) {
            case "keyup":
              return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
            case "keydown":
              return nativeEvent.keyCode !== START_KEYCODE;
            case "keypress":
            case "mousedown":
            case "focusout":
              return true;
            default:
              return false;
          }
        }
        function getDataFromCustomEvent(nativeEvent) {
          nativeEvent = nativeEvent.detail;
          return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
        }
        function getNativeBeforeInputChars(domEventName, nativeEvent) {
          switch (domEventName) {
            case "compositionend":
              return getDataFromCustomEvent(nativeEvent);
            case "keypress":
              if (nativeEvent.which !== SPACEBAR_CODE) return null;
              hasSpaceKeypress = true;
              return SPACEBAR_CHAR;
            case "textInput":
              return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
            default:
              return null;
          }
        }
        function getFallbackBeforeInputChars(domEventName, nativeEvent) {
          if (isComposing)
            return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
          switch (domEventName) {
            case "paste":
              return null;
            case "keypress":
              if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
                if (nativeEvent.char && 1 < nativeEvent.char.length)
                  return nativeEvent.char;
                if (nativeEvent.which)
                  return String.fromCharCode(nativeEvent.which);
              }
              return null;
            case "compositionend":
              return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
            default:
              return null;
          }
        }
        function isTextInputElement(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
        }
        function isEventSupported(eventNameSuffix) {
          if (!canUseDOM) return false;
          eventNameSuffix = "on" + eventNameSuffix;
          var isSupported = eventNameSuffix in document;
          isSupported || (isSupported = document.createElement("div"), isSupported.setAttribute(eventNameSuffix, "return;"), isSupported = "function" === typeof isSupported[eventNameSuffix]);
          return isSupported;
        }
        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
          restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
          inst = accumulateTwoPhaseListeners(inst, "onChange");
          0 < inst.length && (nativeEvent = new SyntheticEvent(
            "onChange",
            "change",
            null,
            nativeEvent,
            target
          ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
        }
        function runEventInBatch(dispatchQueue) {
          processDispatchQueue(dispatchQueue, 0);
        }
        function getInstIfValueChanged(targetInst) {
          var targetNode = getNodeFromInstance(targetInst);
          if (updateValueIfChanged(targetNode)) return targetInst;
        }
        function getTargetInstForChangeEvent(domEventName, targetInst) {
          if ("change" === domEventName) return targetInst;
        }
        function stopWatchingForValueChange() {
          activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
        }
        function handlePropertyChange(nativeEvent) {
          if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(
              dispatchQueue,
              activeElementInst$1,
              nativeEvent,
              getEventTarget(nativeEvent)
            );
            batchedUpdates$1(runEventInBatch, dispatchQueue);
          }
        }
        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
          "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
        }
        function getTargetInstForInputEventPolyfill(domEventName) {
          if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
            return getInstIfValueChanged(activeElementInst$1);
        }
        function getTargetInstForClickEvent(domEventName, targetInst) {
          if ("click" === domEventName) return getInstIfValueChanged(targetInst);
        }
        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
          if ("input" === domEventName || "change" === domEventName)
            return getInstIfValueChanged(targetInst);
        }
        function is(x, y) {
          return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
        }
        function shallowEqual(objA, objB) {
          if (objectIs(objA, objB)) return true;
          if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
            return false;
          var keysA = Object.keys(objA), keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) return false;
          for (keysB = 0; keysB < keysA.length; keysB++) {
            var currentKey = keysA[keysB];
            if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
              return false;
          }
          return true;
        }
        function getLeafNode(node) {
          for (; node && node.firstChild; ) node = node.firstChild;
          return node;
        }
        function getNodeForCharacterOffset(root2, offset) {
          var node = getLeafNode(root2);
          root2 = 0;
          for (var nodeEnd; node; ) {
            if (3 === node.nodeType) {
              nodeEnd = root2 + node.textContent.length;
              if (root2 <= offset && nodeEnd >= offset)
                return { node, offset: offset - root2 };
              root2 = nodeEnd;
            }
            a: {
              for (; node; ) {
                if (node.nextSibling) {
                  node = node.nextSibling;
                  break a;
                }
                node = node.parentNode;
              }
              node = void 0;
            }
            node = getLeafNode(node);
          }
        }
        function containsNode(outerNode, innerNode) {
          return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
        }
        function getActiveElementDeep(containerInfo) {
          containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
          for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
            try {
              var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
            } catch (err) {
              JSCompiler_inline_result = false;
            }
            if (JSCompiler_inline_result) containerInfo = element.contentWindow;
            else break;
            element = getActiveElement(containerInfo.document);
          }
          return element;
        }
        function hasSelectionCapabilities(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
        }
        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
          var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
          mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
            anchorNode: doc.anchorNode,
            anchorOffset: doc.anchorOffset,
            focusNode: doc.focusNode,
            focusOffset: doc.focusOffset
          }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
            "onSelect",
            "select",
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
        }
        function makePrefixMap(styleProp, eventName) {
          var prefixes = {};
          prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
          prefixes["Webkit" + styleProp] = "webkit" + eventName;
          prefixes["Moz" + styleProp] = "moz" + eventName;
          return prefixes;
        }
        function getVendorPrefixedEventName(eventName) {
          if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
          if (!vendorPrefixes[eventName]) return eventName;
          var prefixMap = vendorPrefixes[eventName], styleProp;
          for (styleProp in prefixMap)
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style2)
              return prefixedEventNames[eventName] = prefixMap[styleProp];
          return eventName;
        }
        function registerSimpleEvent(domEventName, reactName) {
          topLevelEventsToReactNames.set(domEventName, reactName);
          registerTwoPhaseEvent(reactName, [domEventName]);
        }
        function getArrayKind(array) {
          for (var kind = EMPTY_ARRAY, i = 0; i < array.length; i++) {
            var value = array[i];
            if ("object" === typeof value && null !== value)
              if (isArrayImpl(value) && 2 === value.length && "string" === typeof value[0]) {
                if (kind !== EMPTY_ARRAY && kind !== ENTRIES_ARRAY)
                  return COMPLEX_ARRAY;
                kind = ENTRIES_ARRAY;
              } else return COMPLEX_ARRAY;
            else {
              if ("function" === typeof value || "string" === typeof value && 50 < value.length || kind !== EMPTY_ARRAY && kind !== PRIMITIVE_ARRAY)
                return COMPLEX_ARRAY;
              kind = PRIMITIVE_ARRAY;
            }
          }
          return kind;
        }
        function addObjectToProperties(object, properties, indent, prefix2) {
          for (var key in object)
            hasOwnProperty.call(object, key) && "_" !== key[0] && addValueToProperties(key, object[key], properties, indent, prefix2);
        }
        function addValueToProperties(propertyName, value, properties, indent, prefix2) {
          switch (typeof value) {
            case "object":
              if (null === value) {
                value = "null";
                break;
              } else {
                if (value.$$typeof === REACT_ELEMENT_TYPE) {
                  var typeName2 = getComponentNameFromType(value.type) || "\u2026", key = value.key;
                  value = value.props;
                  var propsKeys = Object.keys(value), propsLength = propsKeys.length;
                  if (null == key && 0 === propsLength) {
                    value = "<" + typeName2 + " />";
                    break;
                  }
                  if (3 > indent || 1 === propsLength && "children" === propsKeys[0] && null == key) {
                    value = "<" + typeName2 + " \u2026 />";
                    break;
                  }
                  properties.push([
                    prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
                    "<" + typeName2
                  ]);
                  null !== key && addValueToProperties(
                    "key",
                    key,
                    properties,
                    indent + 1,
                    prefix2
                  );
                  propertyName = false;
                  for (var propKey in value)
                    "children" === propKey ? null != value.children && (!isArrayImpl(value.children) || 0 < value.children.length) && (propertyName = true) : hasOwnProperty.call(value, propKey) && "_" !== propKey[0] && addValueToProperties(
                      propKey,
                      value[propKey],
                      properties,
                      indent + 1,
                      prefix2
                    );
                  properties.push([
                    "",
                    propertyName ? ">\u2026</" + typeName2 + ">" : "/>"
                  ]);
                  return;
                }
                typeName2 = Object.prototype.toString.call(value);
                typeName2 = typeName2.slice(8, typeName2.length - 1);
                if ("Array" === typeName2) {
                  if (propKey = getArrayKind(value), propKey === PRIMITIVE_ARRAY || propKey === EMPTY_ARRAY) {
                    value = JSON.stringify(value);
                    break;
                  } else if (propKey === ENTRIES_ARRAY) {
                    properties.push([
                      prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
                      ""
                    ]);
                    for (propertyName = 0; propertyName < value.length; propertyName++)
                      typeName2 = value[propertyName], addValueToProperties(
                        typeName2[0],
                        typeName2[1],
                        properties,
                        indent + 1,
                        prefix2
                      );
                    return;
                  }
                }
                if ("Promise" === typeName2) {
                  if ("fulfilled" === value.status) {
                    if (typeName2 = properties.length, addValueToProperties(
                      propertyName,
                      value.value,
                      properties,
                      indent,
                      prefix2
                    ), properties.length > typeName2) {
                      properties = properties[typeName2];
                      properties[1] = "Promise<" + (properties[1] || "Object") + ">";
                      return;
                    }
                  } else if ("rejected" === value.status && (typeName2 = properties.length, addValueToProperties(
                    propertyName,
                    value.reason,
                    properties,
                    indent,
                    prefix2
                  ), properties.length > typeName2)) {
                    properties = properties[typeName2];
                    properties[1] = "Rejected Promise<" + properties[1] + ">";
                    return;
                  }
                  properties.push([
                    "\xA0\xA0".repeat(indent) + propertyName,
                    "Promise"
                  ]);
                  return;
                }
                "Object" === typeName2 && (propKey = Object.getPrototypeOf(value)) && "function" === typeof propKey.constructor && (typeName2 = propKey.constructor.name);
                properties.push([
                  prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
                  "Object" === typeName2 ? 3 > indent ? "" : "\u2026" : typeName2
                ]);
                3 > indent && addObjectToProperties(value, properties, indent + 1, prefix2);
                return;
              }
            case "function":
              value = "" === value.name ? "() => {}" : value.name + "() {}";
              break;
            case "string":
              value = value === OMITTED_PROP_ERROR ? "\u2026" : JSON.stringify(value);
              break;
            case "undefined":
              value = "undefined";
              break;
            case "boolean":
              value = value ? "true" : "false";
              break;
            default:
              value = String(value);
          }
          properties.push([
            prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
            value
          ]);
        }
        function addObjectDiffToProperties(prev, next, properties, indent) {
          var isDeeplyEqual = true;
          for (key in prev)
            key in next || (properties.push([
              REMOVED + "\xA0\xA0".repeat(indent) + key,
              "\u2026"
            ]), isDeeplyEqual = false);
          for (var _key in next)
            if (_key in prev) {
              var key = prev[_key];
              var nextValue = next[_key];
              if (key !== nextValue) {
                if (0 === indent && "children" === _key)
                  isDeeplyEqual = "\xA0\xA0".repeat(indent) + _key, properties.push(
                    [REMOVED + isDeeplyEqual, "\u2026"],
                    [ADDED + isDeeplyEqual, "\u2026"]
                  );
                else {
                  if (!(3 <= indent)) {
                    if ("object" === typeof key && "object" === typeof nextValue && null !== key && null !== nextValue && key.$$typeof === nextValue.$$typeof)
                      if (nextValue.$$typeof === REACT_ELEMENT_TYPE) {
                        if (key.type === nextValue.type && key.key === nextValue.key) {
                          key = getComponentNameFromType(nextValue.type) || "\u2026";
                          isDeeplyEqual = "\xA0\xA0".repeat(indent) + _key;
                          key = "<" + key + " \u2026 />";
                          properties.push(
                            [REMOVED + isDeeplyEqual, key],
                            [ADDED + isDeeplyEqual, key]
                          );
                          isDeeplyEqual = false;
                          continue;
                        }
                      } else {
                        var prevKind = Object.prototype.toString.call(key), nextKind = Object.prototype.toString.call(nextValue);
                        if (prevKind === nextKind && ("[object Object]" === nextKind || "[object Array]" === nextKind)) {
                          prevKind = [
                            UNCHANGED + "\xA0\xA0".repeat(indent) + _key,
                            "[object Array]" === nextKind ? "Array" : ""
                          ];
                          properties.push(prevKind);
                          nextKind = properties.length;
                          addObjectDiffToProperties(
                            key,
                            nextValue,
                            properties,
                            indent + 1
                          ) ? nextKind === properties.length && (prevKind[1] = "Referentially unequal but deeply equal objects. Consider memoization.") : isDeeplyEqual = false;
                          continue;
                        }
                      }
                    else if ("function" === typeof key && "function" === typeof nextValue && key.name === nextValue.name && key.length === nextValue.length && (prevKind = Function.prototype.toString.call(key), nextKind = Function.prototype.toString.call(nextValue), prevKind === nextKind)) {
                      key = "" === nextValue.name ? "() => {}" : nextValue.name + "() {}";
                      properties.push([
                        UNCHANGED + "\xA0\xA0".repeat(indent) + _key,
                        key + " Referentially unequal function closure. Consider memoization."
                      ]);
                      continue;
                    }
                  }
                  addValueToProperties(_key, key, properties, indent, REMOVED);
                  addValueToProperties(_key, nextValue, properties, indent, ADDED);
                }
                isDeeplyEqual = false;
              }
            } else
              properties.push([
                ADDED + "\xA0\xA0".repeat(indent) + _key,
                "\u2026"
              ]), isDeeplyEqual = false;
          return isDeeplyEqual;
        }
        function setCurrentTrackFromLanes(lanes) {
          currentTrack = lanes & 63 ? "Blocking" : lanes & 64 ? "Gesture" : lanes & 4194176 ? "Transition" : lanes & 62914560 ? "Suspense" : lanes & 2080374784 ? "Idle" : "Other";
        }
        function logComponentTrigger(fiber, startTime, endTime, trigger) {
          supportsUserTiming && (reusableComponentOptions.start = startTime, reusableComponentOptions.end = endTime, reusableComponentDevToolDetails.color = "warning", reusableComponentDevToolDetails.tooltipText = trigger, reusableComponentDevToolDetails.properties = null, (fiber = fiber._debugTask) ? fiber.run(
            performance.measure.bind(
              performance,
              trigger,
              reusableComponentOptions
            )
          ) : performance.measure(trigger, reusableComponentOptions));
        }
        function logComponentReappeared(fiber, startTime, endTime) {
          logComponentTrigger(fiber, startTime, endTime, "Reconnect");
        }
        function logComponentRender(fiber, startTime, endTime, wasHydrated, committedLanes) {
          var name = getComponentNameFromFiber(fiber);
          if (null !== name && supportsUserTiming) {
            var alternate = fiber.alternate, selfTime = fiber.actualDuration;
            if (null === alternate || alternate.child !== fiber.child)
              for (var child = fiber.child; null !== child; child = child.sibling)
                selfTime -= child.actualDuration;
            wasHydrated = 0.5 > selfTime ? wasHydrated ? "tertiary-light" : "primary-light" : 10 > selfTime ? wasHydrated ? "tertiary" : "primary" : 100 > selfTime ? wasHydrated ? "tertiary-dark" : "primary-dark" : "error";
            var props = fiber.memoizedProps;
            selfTime = fiber._debugTask;
            null !== props && null !== alternate && alternate.memoizedProps !== props ? (child = [resuableChangedPropsEntry], props = addObjectDiffToProperties(
              alternate.memoizedProps,
              props,
              child,
              0
            ), 1 < child.length && (props && !alreadyWarnedForDeepEquality && 0 === (alternate.lanes & committedLanes) && 100 < fiber.actualDuration ? (alreadyWarnedForDeepEquality = true, child[0] = reusableDeeplyEqualPropsEntry, reusableComponentDevToolDetails.color = "warning", reusableComponentDevToolDetails.tooltipText = DEEP_EQUALITY_WARNING) : (reusableComponentDevToolDetails.color = wasHydrated, reusableComponentDevToolDetails.tooltipText = name), reusableComponentDevToolDetails.properties = child, reusableComponentOptions.start = startTime, reusableComponentOptions.end = endTime, null != selfTime ? selfTime.run(
              performance.measure.bind(
                performance,
                "\u200B" + name,
                reusableComponentOptions
              )
            ) : performance.measure(
              "\u200B" + name,
              reusableComponentOptions
            ))) : null != selfTime ? selfTime.run(
              console.timeStamp.bind(
                console,
                name,
                startTime,
                endTime,
                COMPONENTS_TRACK,
                void 0,
                wasHydrated
              )
            ) : console.timeStamp(
              name,
              startTime,
              endTime,
              COMPONENTS_TRACK,
              void 0,
              wasHydrated
            );
          }
        }
        function logComponentErrored(fiber, startTime, endTime, errors) {
          if (supportsUserTiming) {
            var name = getComponentNameFromFiber(fiber);
            if (null !== name) {
              for (var debugTask = null, properties = [], i = 0; i < errors.length; i++) {
                var capturedValue = errors[i];
                null == debugTask && null !== capturedValue.source && (debugTask = capturedValue.source._debugTask);
                capturedValue = capturedValue.value;
                properties.push([
                  "Error",
                  "object" === typeof capturedValue && null !== capturedValue && "string" === typeof capturedValue.message ? String(capturedValue.message) : String(capturedValue)
                ]);
              }
              null !== fiber.key && addValueToProperties("key", fiber.key, properties, 0, "");
              null !== fiber.memoizedProps && addObjectToProperties(fiber.memoizedProps, properties, 0, "");
              null == debugTask && (debugTask = fiber._debugTask);
              fiber = {
                start: startTime,
                end: endTime,
                detail: {
                  devtools: {
                    color: "error",
                    track: COMPONENTS_TRACK,
                    tooltipText: 13 === fiber.tag ? "Hydration failed" : "Error boundary caught an error",
                    properties
                  }
                }
              };
              debugTask ? debugTask.run(
                performance.measure.bind(performance, "\u200B" + name, fiber)
              ) : performance.measure("\u200B" + name, fiber);
            }
          }
        }
        function logComponentEffect(fiber, startTime, endTime, selfTime, errors) {
          if (null !== errors) {
            if (supportsUserTiming) {
              var name = getComponentNameFromFiber(fiber);
              if (null !== name) {
                selfTime = [];
                for (var i = 0; i < errors.length; i++) {
                  var error = errors[i].value;
                  selfTime.push([
                    "Error",
                    "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error)
                  ]);
                }
                null !== fiber.key && addValueToProperties("key", fiber.key, selfTime, 0, "");
                null !== fiber.memoizedProps && addObjectToProperties(fiber.memoizedProps, selfTime, 0, "");
                startTime = {
                  start: startTime,
                  end: endTime,
                  detail: {
                    devtools: {
                      color: "error",
                      track: COMPONENTS_TRACK,
                      tooltipText: "A lifecycle or effect errored",
                      properties: selfTime
                    }
                  }
                };
                (fiber = fiber._debugTask) ? fiber.run(
                  performance.measure.bind(
                    performance,
                    "\u200B" + name,
                    startTime
                  )
                ) : performance.measure("\u200B" + name, startTime);
              }
            }
          } else
            name = getComponentNameFromFiber(fiber), null !== name && supportsUserTiming && (errors = 1 > selfTime ? "secondary-light" : 100 > selfTime ? "secondary" : 500 > selfTime ? "secondary-dark" : "error", (fiber = fiber._debugTask) ? fiber.run(
              console.timeStamp.bind(
                console,
                name,
                startTime,
                endTime,
                COMPONENTS_TRACK,
                void 0,
                errors
              )
            ) : console.timeStamp(
              name,
              startTime,
              endTime,
              COMPONENTS_TRACK,
              void 0,
              errors
            ));
        }
        function logRenderPhase(startTime, endTime, lanes, debugTask) {
          if (supportsUserTiming && !(endTime <= startTime)) {
            var color = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark";
            lanes = (lanes & 536870912) === lanes ? "Prepared" : (lanes & 201326741) === lanes ? "Hydrated" : "Render";
            debugTask ? debugTask.run(
              console.timeStamp.bind(
                console,
                lanes,
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                color
              )
            ) : console.timeStamp(
              lanes,
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              color
            );
          }
        }
        function logSuspendedRenderPhase(startTime, endTime, lanes, debugTask) {
          !supportsUserTiming || endTime <= startTime || (lanes = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              "Prewarm",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              lanes
            )
          ) : console.timeStamp(
            "Prewarm",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            lanes
          ));
        }
        function logSuspendedWithDelayPhase(startTime, endTime, lanes, debugTask) {
          !supportsUserTiming || endTime <= startTime || (lanes = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              "Suspended",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              lanes
            )
          ) : console.timeStamp(
            "Suspended",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            lanes
          ));
        }
        function logRecoveredRenderPhase(startTime, endTime, lanes, recoverableErrors, hydrationFailed, debugTask) {
          if (supportsUserTiming && !(endTime <= startTime)) {
            lanes = [];
            for (var i = 0; i < recoverableErrors.length; i++) {
              var error = recoverableErrors[i].value;
              lanes.push([
                "Recoverable Error",
                "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error)
              ]);
            }
            startTime = {
              start: startTime,
              end: endTime,
              detail: {
                devtools: {
                  color: "primary-dark",
                  track: currentTrack,
                  trackGroup: LANES_TRACK_GROUP,
                  tooltipText: hydrationFailed ? "Hydration Failed" : "Recovered after Error",
                  properties: lanes
                }
              }
            };
            debugTask ? debugTask.run(
              performance.measure.bind(performance, "Recovered", startTime)
            ) : performance.measure("Recovered", startTime);
          }
        }
        function logErroredRenderPhase(startTime, endTime, lanes, debugTask) {
          !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              "Errored",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "error"
            )
          ) : console.timeStamp(
            "Errored",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "error"
          ));
        }
        function logSuspendedCommitPhase(startTime, endTime, reason, debugTask) {
          !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              reason,
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "secondary-light"
            )
          ) : console.timeStamp(
            reason,
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "secondary-light"
          ));
        }
        function logCommitErrored(startTime, endTime, errors, passive, debugTask) {
          if (supportsUserTiming && !(endTime <= startTime)) {
            for (var properties = [], i = 0; i < errors.length; i++) {
              var error = errors[i].value;
              properties.push([
                "Error",
                "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error)
              ]);
            }
            startTime = {
              start: startTime,
              end: endTime,
              detail: {
                devtools: {
                  color: "error",
                  track: currentTrack,
                  trackGroup: LANES_TRACK_GROUP,
                  tooltipText: passive ? "Remaining Effects Errored" : "Commit Errored",
                  properties
                }
              }
            };
            debugTask ? debugTask.run(
              performance.measure.bind(performance, "Errored", startTime)
            ) : performance.measure("Errored", startTime);
          }
        }
        function logAnimatingPhase(startTime, endTime, debugTask) {
          !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              "Animating",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "secondary-dark"
            )
          ) : console.timeStamp(
            "Animating",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "secondary-dark"
          ));
        }
        function finishQueueingConcurrentUpdates() {
          for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
            var fiber = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var queue = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var update = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var lane = concurrentQueues[i];
            concurrentQueues[i++] = null;
            if (null !== queue && null !== update) {
              var pending = queue.pending;
              null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
              queue.pending = update;
            }
            0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
          }
        }
        function enqueueUpdate$1(fiber, queue, update, lane) {
          concurrentQueues[concurrentQueuesIndex++] = fiber;
          concurrentQueues[concurrentQueuesIndex++] = queue;
          concurrentQueues[concurrentQueuesIndex++] = update;
          concurrentQueues[concurrentQueuesIndex++] = lane;
          concurrentlyUpdatedLanes |= lane;
          fiber.lanes |= lane;
          fiber = fiber.alternate;
          null !== fiber && (fiber.lanes |= lane);
        }
        function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
          enqueueUpdate$1(fiber, queue, update, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function enqueueConcurrentRenderForLane(fiber, lane) {
          enqueueUpdate$1(fiber, null, null, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
          sourceFiber.lanes |= lane;
          var alternate = sourceFiber.alternate;
          null !== alternate && (alternate.lanes |= lane);
          for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
            parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & OffscreenVisible || (isHidden = true)), sourceFiber = parent, parent = parent.return;
          return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
        }
        function getRootForUpdatedFiber(sourceFiber) {
          if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
            throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error(
              "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
            );
          nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error(
            "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
          ));
          null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
          for (var node = sourceFiber, parent = node.return; null !== parent; )
            null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;
          return 3 === node.tag ? node.stateNode : null;
        }
        function resolveFunctionForHotReloading(type) {
          if (null === resolveFamily) return type;
          var family = resolveFamily(type);
          return void 0 === family ? type : family.current;
        }
        function resolveForwardRefForHotReloading(type) {
          if (null === resolveFamily) return type;
          var family = resolveFamily(type);
          return void 0 === family ? null !== type && void 0 !== type && "function" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = { $$typeof: REACT_FORWARD_REF_TYPE, render: family }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;
        }
        function isCompatibleFamilyForHotReloading(fiber, element) {
          if (null === resolveFamily) return false;
          var prevType = fiber.elementType;
          element = element.type;
          var needsCompareFamilies = false, $$typeofNextType = "object" === typeof element && null !== element ? element.$$typeof : null;
          switch (fiber.tag) {
            case 1:
              "function" === typeof element && (needsCompareFamilies = true);
              break;
            case 0:
              "function" === typeof element ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            case 11:
              $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            case 14:
            case 15:
              $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            default:
              return false;
          }
          return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? true : false;
        }
        function markFailedErrorBoundaryForHotReloading(fiber) {
          null !== resolveFamily && "function" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = /* @__PURE__ */ new WeakSet()), failedBoundaries.add(fiber));
        }
        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
          do {
            var _fiber = fiber, alternate = _fiber.alternate, child = _fiber.child, sibling = _fiber.sibling, tag = _fiber.tag;
            _fiber = _fiber.type;
            var candidateType = null;
            switch (tag) {
              case 0:
              case 15:
              case 1:
                candidateType = _fiber;
                break;
              case 11:
                candidateType = _fiber.render;
            }
            if (null === resolveFamily)
              throw Error("Expected resolveFamily to be set during hot reload.");
            var needsRender = false;
            _fiber = false;
            null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? _fiber = true : updatedFamilies.has(candidateType) && (1 === tag ? _fiber = true : needsRender = true)));
            null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (_fiber = true);
            _fiber && (fiber._debugNeedsRemount = true);
            if (_fiber || needsRender)
              alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
            null === child || _fiber || scheduleFibersWithFamiliesRecursively(
              child,
              updatedFamilies,
              staleFamilies
            );
            if (null === sibling) break;
            fiber = sibling;
          } while (1);
        }
        function FiberNode(tag, pendingProps, key, mode) {
          this.tag = tag;
          this.key = key;
          this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
          this.index = 0;
          this.refCleanup = this.ref = null;
          this.pendingProps = pendingProps;
          this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
          this.mode = mode;
          this.subtreeFlags = this.flags = 0;
          this.deletions = null;
          this.childLanes = this.lanes = 0;
          this.alternate = null;
          this.actualDuration = -0;
          this.actualStartTime = -1.1;
          this.treeBaseDuration = this.selfBaseDuration = -0;
          this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null;
          this._debugNeedsRemount = false;
          this._debugHookTypes = null;
          hasBadMapPolyfill || "function" !== typeof Object.preventExtensions || Object.preventExtensions(this);
        }
        function shouldConstruct(Component) {
          Component = Component.prototype;
          return !(!Component || !Component.isReactComponent);
        }
        function createWorkInProgress(current2, pendingProps) {
          var workInProgress2 = current2.alternate;
          null === workInProgress2 ? (workInProgress2 = createFiber(
            current2.tag,
            pendingProps,
            current2.key,
            current2.mode
          ), workInProgress2.elementType = current2.elementType, workInProgress2.type = current2.type, workInProgress2.stateNode = current2.stateNode, workInProgress2._debugOwner = current2._debugOwner, workInProgress2._debugStack = current2._debugStack, workInProgress2._debugTask = current2._debugTask, workInProgress2._debugHookTypes = current2._debugHookTypes, workInProgress2.alternate = current2, current2.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current2.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.actualDuration = -0, workInProgress2.actualStartTime = -1.1);
          workInProgress2.flags = current2.flags & 65011712;
          workInProgress2.childLanes = current2.childLanes;
          workInProgress2.lanes = current2.lanes;
          workInProgress2.child = current2.child;
          workInProgress2.memoizedProps = current2.memoizedProps;
          workInProgress2.memoizedState = current2.memoizedState;
          workInProgress2.updateQueue = current2.updateQueue;
          pendingProps = current2.dependencies;
          workInProgress2.dependencies = null === pendingProps ? null : {
            lanes: pendingProps.lanes,
            firstContext: pendingProps.firstContext,
            _debugThenableState: pendingProps._debugThenableState
          };
          workInProgress2.sibling = current2.sibling;
          workInProgress2.index = current2.index;
          workInProgress2.ref = current2.ref;
          workInProgress2.refCleanup = current2.refCleanup;
          workInProgress2.selfBaseDuration = current2.selfBaseDuration;
          workInProgress2.treeBaseDuration = current2.treeBaseDuration;
          workInProgress2._debugInfo = current2._debugInfo;
          workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
          switch (workInProgress2.tag) {
            case 0:
            case 15:
              workInProgress2.type = resolveFunctionForHotReloading(current2.type);
              break;
            case 1:
              workInProgress2.type = resolveFunctionForHotReloading(current2.type);
              break;
            case 11:
              workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
          }
          return workInProgress2;
        }
        function resetWorkInProgress(workInProgress2, renderLanes2) {
          workInProgress2.flags &= 65011714;
          var current2 = workInProgress2.alternate;
          null === current2 ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null, workInProgress2.selfBaseDuration = 0, workInProgress2.treeBaseDuration = 0) : (workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue, workInProgress2.type = current2.type, renderLanes2 = current2.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
            lanes: renderLanes2.lanes,
            firstContext: renderLanes2.firstContext,
            _debugThenableState: renderLanes2._debugThenableState
          }, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration);
          return workInProgress2;
        }
        function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
          var fiberTag = 0, resolvedType = type;
          if ("function" === typeof type)
            shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);
          else if ("string" === typeof type)
            fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
          else
            a: switch (type) {
              case REACT_ACTIVITY_TYPE:
                return key = createFiber(31, pendingProps, key, mode), key.elementType = REACT_ACTIVITY_TYPE, key.lanes = lanes, key;
              case REACT_FRAGMENT_TYPE:
                return createFiberFromFragment(
                  pendingProps.children,
                  mode,
                  lanes,
                  key
                );
              case REACT_STRICT_MODE_TYPE:
                fiberTag = 8;
                mode |= StrictLegacyMode;
                mode |= StrictEffectsMode;
                break;
              case REACT_PROFILER_TYPE:
                return type = pendingProps, owner = mode, "string" !== typeof type.id && console.error(
                  'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
                  typeof type.id
                ), key = createFiber(12, type, key, owner | ProfileMode), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, key;
              case REACT_SUSPENSE_TYPE:
                return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;
              case REACT_SUSPENSE_LIST_TYPE:
                return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;
              default:
                if ("object" === typeof type && null !== type)
                  switch (type.$$typeof) {
                    case REACT_CONTEXT_TYPE:
                      fiberTag = 10;
                      break a;
                    case REACT_CONSUMER_TYPE:
                      fiberTag = 9;
                      break a;
                    case REACT_FORWARD_REF_TYPE:
                      fiberTag = 11;
                      resolvedType = resolveForwardRefForHotReloading(resolvedType);
                      break a;
                    case REACT_MEMO_TYPE:
                      fiberTag = 14;
                      break a;
                    case REACT_LAZY_TYPE:
                      fiberTag = 16;
                      resolvedType = null;
                      break a;
                  }
                resolvedType = "";
                if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length)
                  resolvedType += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                null === type ? pendingProps = "null" : isArrayImpl(type) ? pendingProps = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", resolvedType = " Did you accidentally export a JSX literal instead of a component?") : pendingProps = typeof type;
                (fiberTag = owner ? getComponentNameFromOwner(owner) : null) && (resolvedType += "\n\nCheck the render method of `" + fiberTag + "`.");
                fiberTag = 29;
                pendingProps = Error(
                  "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (pendingProps + "." + resolvedType)
                );
                resolvedType = null;
            }
          key = createFiber(fiberTag, pendingProps, key, mode);
          key.elementType = type;
          key.type = resolvedType;
          key.lanes = lanes;
          key._debugOwner = owner;
          return key;
        }
        function createFiberFromElement(element, mode, lanes) {
          mode = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            element._owner,
            mode,
            lanes
          );
          mode._debugOwner = element._owner;
          mode._debugStack = element._debugStack;
          mode._debugTask = element._debugTask;
          return mode;
        }
        function createFiberFromFragment(elements, mode, lanes, key) {
          elements = createFiber(7, elements, key, mode);
          elements.lanes = lanes;
          return elements;
        }
        function createFiberFromText(content, mode, lanes) {
          content = createFiber(6, content, null, mode);
          content.lanes = lanes;
          return content;
        }
        function createFiberFromDehydratedFragment(dehydratedNode) {
          var fiber = createFiber(18, null, null, NoMode);
          fiber.stateNode = dehydratedNode;
          return fiber;
        }
        function createFiberFromPortal(portal, mode, lanes) {
          mode = createFiber(
            4,
            null !== portal.children ? portal.children : [],
            portal.key,
            mode
          );
          mode.lanes = lanes;
          mode.stateNode = {
            containerInfo: portal.containerInfo,
            pendingChildren: null,
            implementation: portal.implementation
          };
          return mode;
        }
        function createCapturedValueAtFiber(value, source) {
          if ("object" === typeof value && null !== value) {
            var existing = CapturedStacks.get(value);
            if (void 0 !== existing) return existing;
            source = {
              value,
              source,
              stack: getStackByFiberInDevAndProd(source)
            };
            CapturedStacks.set(value, source);
            return source;
          }
          return {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
        }
        function pushTreeFork(workInProgress2, totalChildren) {
          warnIfNotHydrating();
          forkStack[forkStackIndex++] = treeForkCount;
          forkStack[forkStackIndex++] = treeForkProvider;
          treeForkProvider = workInProgress2;
          treeForkCount = totalChildren;
        }
        function pushTreeId(workInProgress2, totalChildren, index) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextProvider = workInProgress2;
          var baseIdWithLeadingBit = treeContextId;
          workInProgress2 = treeContextOverflow;
          var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
          baseIdWithLeadingBit &= ~(1 << baseLength);
          index += 1;
          var length = 32 - clz32(totalChildren) + baseLength;
          if (30 < length) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
            baseIdWithLeadingBit >>= numberOfOverflowBits;
            baseLength -= numberOfOverflowBits;
            treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
            treeContextOverflow = length + workInProgress2;
          } else
            treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
        }
        function pushMaterializedTreeId(workInProgress2) {
          warnIfNotHydrating();
          null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
        }
        function popTreeContext(workInProgress2) {
          for (; workInProgress2 === treeForkProvider; )
            treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
          for (; workInProgress2 === treeContextProvider; )
            treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
        }
        function getSuspendedTreeContext() {
          warnIfNotHydrating();
          return null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null;
        }
        function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextId = suspendedContext.id;
          treeContextOverflow = suspendedContext.overflow;
          treeContextProvider = workInProgress2;
        }
        function warnIfNotHydrating() {
          isHydrating || console.error(
            "Expected to be hydrating. This is a bug in React. Please file an issue."
          );
        }
        function buildHydrationDiffNode(fiber, distanceFromLeaf) {
          if (null === fiber.return) {
            if (null === hydrationDiffRootDEV)
              hydrationDiffRootDEV = {
                fiber,
                children: [],
                serverProps: void 0,
                serverTail: [],
                distanceFromLeaf
              };
            else {
              if (hydrationDiffRootDEV.fiber !== fiber)
                throw Error(
                  "Saw multiple hydration diff roots in a pass. This is a bug in React."
                );
              hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
            }
            return hydrationDiffRootDEV;
          }
          var siblings = buildHydrationDiffNode(
            fiber.return,
            distanceFromLeaf + 1
          ).children;
          if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber)
            return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;
          distanceFromLeaf = {
            fiber,
            children: [],
            serverProps: void 0,
            serverTail: [],
            distanceFromLeaf
          };
          siblings.push(distanceFromLeaf);
          return distanceFromLeaf;
        }
        function warnIfHydrating() {
          isHydrating && console.error(
            "We should not be hydrating here. This is a bug in React. Please file a bug."
          );
        }
        function warnNonHydratedInstance(fiber, rejectedCandidate) {
          didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));
        }
        function throwOnHydrationMismatch(fiber) {
          var fromText = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : false, diff = "", diffRoot = hydrationDiffRootDEV;
          null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));
          queueHydrationError(
            createCapturedValueAtFiber(
              Error(
                "Hydration failed because the server rendered " + (fromText ? "text" : "HTML") + " didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" + diff
              ),
              fiber
            )
          );
          throw HydrationMismatchException;
        }
        function prepareToHydrateHostInstance(fiber) {
          var didHydrate = fiber.stateNode;
          var type = fiber.type, props = fiber.memoizedProps;
          didHydrate[internalInstanceKey] = fiber;
          didHydrate[internalPropsKey] = props;
          validatePropertiesInDevelopment(type, props);
          switch (type) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", didHydrate);
              listenToNonDelegatedEvent("close", didHydrate);
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", didHydrate);
              break;
            case "video":
            case "audio":
              for (type = 0; type < mediaEventTypes.length; type++)
                listenToNonDelegatedEvent(mediaEventTypes[type], didHydrate);
              break;
            case "source":
              listenToNonDelegatedEvent("error", didHydrate);
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", didHydrate);
              listenToNonDelegatedEvent("load", didHydrate);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", didHydrate);
              break;
            case "input":
              checkControlledValueProps("input", props);
              listenToNonDelegatedEvent("invalid", didHydrate);
              validateInputProps(didHydrate, props);
              initInput(
                didHydrate,
                props.value,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name,
                true
              );
              break;
            case "option":
              validateOptionProps(didHydrate, props);
              break;
            case "select":
              checkControlledValueProps("select", props);
              listenToNonDelegatedEvent("invalid", didHydrate);
              validateSelectProps(didHydrate, props);
              break;
            case "textarea":
              checkControlledValueProps("textarea", props), listenToNonDelegatedEvent("invalid", didHydrate), validateTextareaProps(didHydrate, props), initTextarea(
                didHydrate,
                props.value,
                props.defaultValue,
                props.children
              );
          }
          type = props.children;
          "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || didHydrate.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(didHydrate.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", didHydrate), listenToNonDelegatedEvent("toggle", didHydrate)), null != props.onScroll && listenToNonDelegatedEvent("scroll", didHydrate), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", didHydrate), null != props.onClick && (didHydrate.onclick = noop$1), didHydrate = true) : didHydrate = false;
          didHydrate || throwOnHydrationMismatch(fiber, true);
        }
        function popToNextHostParent(fiber) {
          for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
            switch (hydrationParentFiber.tag) {
              case 5:
              case 31:
              case 13:
                rootOrSingletonContext = false;
                return;
              case 27:
              case 3:
                rootOrSingletonContext = true;
                return;
              default:
                hydrationParentFiber = hydrationParentFiber.return;
            }
        }
        function popHydrationState(fiber) {
          if (fiber !== hydrationParentFiber) return false;
          if (!isHydrating)
            return popToNextHostParent(fiber), isHydrating = true, false;
          var tag = fiber.tag, JSCompiler_temp;
          if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
            if (JSCompiler_temp = 5 === tag)
              JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
            JSCompiler_temp = !JSCompiler_temp;
          }
          if (JSCompiler_temp && nextHydratableInstance) {
            for (JSCompiler_temp = nextHydratableInstance; JSCompiler_temp; ) {
              var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(JSCompiler_temp);
              diffNode.serverTail.push(description);
              JSCompiler_temp = "Suspense" === description.type ? getNextHydratableInstanceAfterHydrationBoundary(JSCompiler_temp) : getNextHydratable(JSCompiler_temp.nextSibling);
            }
            throwOnHydrationMismatch(fiber);
          }
          popToNextHostParent(fiber);
          if (13 === tag) {
            fiber = fiber.memoizedState;
            fiber = null !== fiber ? fiber.dehydrated : null;
            if (!fiber)
              throw Error(
                "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
              );
            nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
          } else if (31 === tag) {
            fiber = fiber.memoizedState;
            fiber = null !== fiber ? fiber.dehydrated : null;
            if (!fiber)
              throw Error(
                "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
              );
            nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
          } else
            27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
          return true;
        }
        function resetHydrationState() {
          nextHydratableInstance = hydrationParentFiber = null;
          didSuspendOrErrorDEV = isHydrating = false;
        }
        function upgradeHydrationErrorsToRecoverable() {
          var queuedErrors = hydrationErrors;
          null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
            workInProgressRootRecoverableErrors,
            queuedErrors
          ), hydrationErrors = null);
          return queuedErrors;
        }
        function queueHydrationError(error) {
          null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
        }
        function emitPendingHydrationWarnings() {
          var diffRoot = hydrationDiffRootDEV;
          if (null !== diffRoot) {
            hydrationDiffRootDEV = null;
            for (var diff = describeDiff(diffRoot); 0 < diffRoot.children.length; )
              diffRoot = diffRoot.children[0];
            runWithFiberInDEV(diffRoot.fiber, function() {
              console.error(
                "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s",
                "https://react.dev/link/hydration-mismatch",
                diff
              );
            });
          }
        }
        function resetContextDependencies() {
          lastContextDependency = currentlyRenderingFiber$1 = null;
          isDisallowedContextReadInDEV = false;
        }
        function pushProvider(providerFiber, context2, nextValue) {
          push(valueCursor, context2._currentValue, providerFiber);
          context2._currentValue = nextValue;
          push(rendererCursorDEV, context2._currentRenderer, providerFiber);
          void 0 !== context2._currentRenderer && null !== context2._currentRenderer && context2._currentRenderer !== rendererSigil && console.error(
            "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
          );
          context2._currentRenderer = rendererSigil;
        }
        function popProvider(context2, providerFiber) {
          context2._currentValue = valueCursor.current;
          var currentRenderer = rendererCursorDEV.current;
          pop(rendererCursorDEV, providerFiber);
          context2._currentRenderer = currentRenderer;
          pop(valueCursor, providerFiber);
        }
        function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
          for (; null !== parent; ) {
            var alternate = parent.alternate;
            (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
            if (parent === propagationRoot) break;
            parent = parent.return;
          }
          parent !== propagationRoot && console.error(
            "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
          var fiber = workInProgress2.child;
          null !== fiber && (fiber.return = workInProgress2);
          for (; null !== fiber; ) {
            var list = fiber.dependencies;
            if (null !== list) {
              var nextFiber = fiber.child;
              list = list.firstContext;
              a: for (; null !== list; ) {
                var dependency = list;
                list = fiber;
                for (var i = 0; i < contexts.length; i++)
                  if (dependency.context === contexts[i]) {
                    list.lanes |= renderLanes2;
                    dependency = list.alternate;
                    null !== dependency && (dependency.lanes |= renderLanes2);
                    scheduleContextWorkOnParentPath(
                      list.return,
                      renderLanes2,
                      workInProgress2
                    );
                    forcePropagateEntireTree || (nextFiber = null);
                    break a;
                  }
                list = dependency.next;
              }
            } else if (18 === fiber.tag) {
              nextFiber = fiber.return;
              if (null === nextFiber)
                throw Error(
                  "We just came from a parent so we must have had a parent. This is a bug in React."
                );
              nextFiber.lanes |= renderLanes2;
              list = nextFiber.alternate;
              null !== list && (list.lanes |= renderLanes2);
              scheduleContextWorkOnParentPath(
                nextFiber,
                renderLanes2,
                workInProgress2
              );
              nextFiber = null;
            } else nextFiber = fiber.child;
            if (null !== nextFiber) nextFiber.return = fiber;
            else
              for (nextFiber = fiber; null !== nextFiber; ) {
                if (nextFiber === workInProgress2) {
                  nextFiber = null;
                  break;
                }
                fiber = nextFiber.sibling;
                if (null !== fiber) {
                  fiber.return = nextFiber.return;
                  nextFiber = fiber;
                  break;
                }
                nextFiber = nextFiber.return;
              }
            fiber = nextFiber;
          }
        }
        function propagateParentContextChanges(current2, workInProgress2, renderLanes2, forcePropagateEntireTree) {
          current2 = null;
          for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
            if (!isInsidePropagationBailout) {
              if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
              else if (0 !== (parent.flags & 262144)) break;
            }
            if (10 === parent.tag) {
              var currentParent = parent.alternate;
              if (null === currentParent)
                throw Error("Should have a current fiber. This is a bug in React.");
              currentParent = currentParent.memoizedProps;
              if (null !== currentParent) {
                var context2 = parent.type;
                objectIs(parent.pendingProps.value, currentParent.value) || (null !== current2 ? current2.push(context2) : current2 = [context2]);
              }
            } else if (parent === hostTransitionProviderCursor.current) {
              currentParent = parent.alternate;
              if (null === currentParent)
                throw Error("Should have a current fiber. This is a bug in React.");
              currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current2 ? current2.push(HostTransitionContext) : current2 = [HostTransitionContext]);
            }
            parent = parent.return;
          }
          null !== current2 && propagateContextChanges(
            workInProgress2,
            current2,
            renderLanes2,
            forcePropagateEntireTree
          );
          workInProgress2.flags |= 262144;
        }
        function checkIfContextChanged(currentDependencies) {
          for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
            if (!objectIs(
              currentDependencies.context._currentValue,
              currentDependencies.memoizedValue
            ))
              return true;
            currentDependencies = currentDependencies.next;
          }
          return false;
        }
        function prepareToReadContext(workInProgress2) {
          currentlyRenderingFiber$1 = workInProgress2;
          lastContextDependency = null;
          workInProgress2 = workInProgress2.dependencies;
          null !== workInProgress2 && (workInProgress2.firstContext = null);
        }
        function readContext(context2) {
          isDisallowedContextReadInDEV && console.error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
          return readContextForConsumer(currentlyRenderingFiber$1, context2);
        }
        function readContextDuringReconciliation(consumer, context2) {
          null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
          return readContextForConsumer(consumer, context2);
        }
        function readContextForConsumer(consumer, context2) {
          var value = context2._currentValue;
          context2 = { context: context2, memoizedValue: value, next: null };
          if (null === lastContextDependency) {
            if (null === consumer)
              throw Error(
                "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
              );
            lastContextDependency = context2;
            consumer.dependencies = {
              lanes: 0,
              firstContext: context2,
              _debugThenableState: null
            };
            consumer.flags |= 524288;
          } else lastContextDependency = lastContextDependency.next = context2;
          return value;
        }
        function createCache() {
          return {
            controller: new AbortControllerLocal(),
            data: /* @__PURE__ */ new Map(),
            refCount: 0
          };
        }
        function retainCache(cache) {
          cache.controller.signal.aborted && console.warn(
            "A cache instance was retained after it was already freed. This likely indicates a bug in React."
          );
          cache.refCount++;
        }
        function releaseCache(cache) {
          cache.refCount--;
          0 > cache.refCount && console.warn(
            "A cache instance was released after it was already freed. This likely indicates a bug in React."
          );
          0 === cache.refCount && scheduleCallback$2(NormalPriority2, function() {
            cache.controller.abort();
          });
        }
        function startUpdateTimerByLane(lane, method, fiber) {
          if (0 !== (lane & 127))
            0 > blockingUpdateTime && (blockingUpdateTime = now(), blockingUpdateTask = createTask(method), blockingUpdateMethodName = method, null != fiber && (blockingUpdateComponentName = getComponentNameFromFiber(fiber)), (executionContext & (RenderContext | CommitContext)) !== NoContext && (componentEffectSpawnedUpdate = true, blockingUpdateType = SPAWNED_UPDATE), lane = resolveEventTimeStamp(), method = resolveEventType(), lane !== blockingEventRepeatTime || method !== blockingEventType ? blockingEventRepeatTime = -1.1 : null !== method && (blockingUpdateType = SPAWNED_UPDATE), blockingEventTime = lane, blockingEventType = method);
          else if (0 !== (lane & 4194048) && 0 > transitionUpdateTime && (transitionUpdateTime = now(), transitionUpdateTask = createTask(method), transitionUpdateMethodName = method, null != fiber && (transitionUpdateComponentName = getComponentNameFromFiber(fiber)), 0 > transitionStartTime)) {
            lane = resolveEventTimeStamp();
            method = resolveEventType();
            if (lane !== transitionEventRepeatTime || method !== transitionEventType)
              transitionEventRepeatTime = -1.1;
            transitionEventTime = lane;
            transitionEventType = method;
          }
        }
        function startHostActionTimer(fiber) {
          if (0 > blockingUpdateTime) {
            blockingUpdateTime = now();
            blockingUpdateTask = null != fiber._debugTask ? fiber._debugTask : null;
            (executionContext & (RenderContext | CommitContext)) !== NoContext && (blockingUpdateType = SPAWNED_UPDATE);
            var newEventTime = resolveEventTimeStamp(), newEventType = resolveEventType();
            newEventTime !== blockingEventRepeatTime || newEventType !== blockingEventType ? blockingEventRepeatTime = -1.1 : null !== newEventType && (blockingUpdateType = SPAWNED_UPDATE);
            blockingEventTime = newEventTime;
            blockingEventType = newEventType;
          }
          if (0 > transitionUpdateTime && (transitionUpdateTime = now(), transitionUpdateTask = null != fiber._debugTask ? fiber._debugTask : null, 0 > transitionStartTime)) {
            fiber = resolveEventTimeStamp();
            newEventTime = resolveEventType();
            if (fiber !== transitionEventRepeatTime || newEventTime !== transitionEventType)
              transitionEventRepeatTime = -1.1;
            transitionEventTime = fiber;
            transitionEventType = newEventTime;
          }
        }
        function pushNestedEffectDurations() {
          var prevEffectDuration = profilerEffectDuration;
          profilerEffectDuration = 0;
          return prevEffectDuration;
        }
        function popNestedEffectDurations(prevEffectDuration) {
          var elapsedTime = profilerEffectDuration;
          profilerEffectDuration = prevEffectDuration;
          return elapsedTime;
        }
        function bubbleNestedEffectDurations(prevEffectDuration) {
          var elapsedTime = profilerEffectDuration;
          profilerEffectDuration += prevEffectDuration;
          return elapsedTime;
        }
        function resetComponentEffectTimers() {
          componentEffectEndTime = componentEffectStartTime = -1.1;
        }
        function pushComponentEffectStart() {
          var prevEffectStart = componentEffectStartTime;
          componentEffectStartTime = -1.1;
          return prevEffectStart;
        }
        function popComponentEffectStart(prevEffectStart) {
          0 <= prevEffectStart && (componentEffectStartTime = prevEffectStart);
        }
        function pushComponentEffectDuration() {
          var prevEffectDuration = componentEffectDuration;
          componentEffectDuration = -0;
          return prevEffectDuration;
        }
        function popComponentEffectDuration(prevEffectDuration) {
          0 <= prevEffectDuration && (componentEffectDuration = prevEffectDuration);
        }
        function pushComponentEffectErrors() {
          var prevErrors = componentEffectErrors;
          componentEffectErrors = null;
          return prevErrors;
        }
        function pushComponentEffectDidSpawnUpdate() {
          var prev = componentEffectSpawnedUpdate;
          componentEffectSpawnedUpdate = false;
          return prev;
        }
        function startProfilerTimer(fiber) {
          profilerStartTime = now();
          0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
        }
        function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
          if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            fiber.selfBaseDuration = elapsedTime;
            profilerStartTime = -1;
          }
        }
        function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
          if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            profilerStartTime = -1;
          }
        }
        function recordEffectDuration() {
          if (0 <= profilerStartTime) {
            var endTime = now(), elapsedTime = endTime - profilerStartTime;
            profilerStartTime = -1;
            profilerEffectDuration += elapsedTime;
            componentEffectDuration += elapsedTime;
            componentEffectEndTime = endTime;
          }
        }
        function recordEffectError(errorInfo) {
          null === componentEffectErrors && (componentEffectErrors = []);
          componentEffectErrors.push(errorInfo);
          null === commitErrors && (commitErrors = []);
          commitErrors.push(errorInfo);
        }
        function startEffectTimer() {
          profilerStartTime = now();
          0 > componentEffectStartTime && (componentEffectStartTime = profilerStartTime);
        }
        function transferActualDuration(fiber) {
          for (var child = fiber.child; child; )
            fiber.actualDuration += child.actualDuration, child = child.sibling;
        }
        function entangleAsyncAction(transition, thenable) {
          if (null === currentEntangledListeners) {
            var entangledListeners = currentEntangledListeners = [];
            currentEntangledPendingCount = 0;
            currentEntangledLane = requestTransitionLane();
            currentEntangledActionThenable = {
              status: "pending",
              value: void 0,
              then: function(resolve) {
                entangledListeners.push(resolve);
              }
            };
          }
          currentEntangledPendingCount++;
          thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
          return thenable;
        }
        function pingEngtangledActionScope() {
          if (0 === --currentEntangledPendingCount && (-1 < transitionUpdateTime || (transitionStartTime = -1.1), null !== currentEntangledListeners)) {
            null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
            var listeners = currentEntangledListeners;
            currentEntangledListeners = null;
            currentEntangledLane = 0;
            currentEntangledActionThenable = null;
            for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
          }
        }
        function chainThenableValue(thenable, result) {
          var listeners = [], thenableWithOverride = {
            status: "pending",
            value: null,
            reason: null,
            then: function(resolve) {
              listeners.push(resolve);
            }
          };
          thenable.then(
            function() {
              thenableWithOverride.status = "fulfilled";
              thenableWithOverride.value = result;
              for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
            },
            function(error) {
              thenableWithOverride.status = "rejected";
              thenableWithOverride.reason = error;
              for (error = 0; error < listeners.length; error++)
                (0, listeners[error])(void 0);
            }
          );
          return thenableWithOverride;
        }
        function peekCacheFromPool() {
          var cacheResumedFromPreviousRender = resumedCache.current;
          return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
        }
        function pushTransition(offscreenWorkInProgress, prevCachePool) {
          null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
        }
        function getSuspendedCache() {
          var cacheFromPool = peekCacheFromPool();
          return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
        }
        function createThenableState() {
          return { didWarnAboutUncachedPromise: false, thenables: [] };
        }
        function isThenableResolved(thenable) {
          thenable = thenable.status;
          return "fulfilled" === thenable || "rejected" === thenable;
        }
        function trackUsedThenable(thenableState2, thenable, index) {
          null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = true);
          var trackedThenables = thenableState2.thenables;
          index = trackedThenables[index];
          void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState2.didWarnAboutUncachedPromise || (thenableState2.didWarnAboutUncachedPromise = true, console.error(
            "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
          )), thenable.then(noop$1, noop$1), thenable = index);
          if (void 0 === thenable._debugInfo) {
            thenableState2 = performance.now();
            trackedThenables = thenable.displayName;
            var ioInfo = {
              name: "string" === typeof trackedThenables ? trackedThenables : "Promise",
              start: thenableState2,
              end: thenableState2,
              value: thenable
            };
            thenable._debugInfo = [{ awaited: ioInfo }];
            "fulfilled" !== thenable.status && "rejected" !== thenable.status && (thenableState2 = function() {
              ioInfo.end = performance.now();
            }, thenable.then(thenableState2, thenableState2));
          }
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            default:
              if ("string" === typeof thenable.status)
                thenable.then(noop$1, noop$1);
              else {
                thenableState2 = workInProgressRoot;
                if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                  throw Error(
                    "An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
                  );
                thenableState2 = thenable;
                thenableState2.status = "pending";
                thenableState2.then(
                  function(fulfilledValue) {
                    if ("pending" === thenable.status) {
                      var fulfilledThenable = thenable;
                      fulfilledThenable.status = "fulfilled";
                      fulfilledThenable.value = fulfilledValue;
                    }
                  },
                  function(error) {
                    if ("pending" === thenable.status) {
                      var rejectedThenable = thenable;
                      rejectedThenable.status = "rejected";
                      rejectedThenable.reason = error;
                    }
                  }
                );
              }
              switch (thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
              }
              suspendedThenable = thenable;
              needsToResetSuspendedThenableDEV = true;
              throw SuspenseException;
          }
        }
        function resolveLazy(lazyType) {
          try {
            return callLazyInitInDEV(lazyType);
          } catch (x) {
            if (null !== x && "object" === typeof x && "function" === typeof x.then)
              throw suspendedThenable = x, needsToResetSuspendedThenableDEV = true, SuspenseException;
            throw x;
          }
        }
        function getSuspendedThenable() {
          if (null === suspendedThenable)
            throw Error(
              "Expected a suspended thenable. This is a bug in React. Please file an issue."
            );
          var thenable = suspendedThenable;
          suspendedThenable = null;
          needsToResetSuspendedThenableDEV = false;
          return thenable;
        }
        function checkIfUseWrappedInAsyncCatch(rejectedReason) {
          if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
            throw Error(
              "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
            );
        }
        function pushDebugInfo(debugInfo) {
          var previousDebugInfo = currentDebugInfo;
          null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));
          return previousDebugInfo;
        }
        function getCurrentDebugTask() {
          var debugInfo = currentDebugInfo;
          if (null != debugInfo) {
            for (var i = debugInfo.length - 1; 0 <= i; i--)
              if (null != debugInfo[i].name) {
                var debugTask = debugInfo[i].debugTask;
                if (null != debugTask) return debugTask;
              }
          }
          return null;
        }
        function validateFragmentProps(element, fiber, returnFiber) {
          for (var keys3 = Object.keys(element.props), i = 0; i < keys3.length; i++) {
            var key = keys3[i];
            if ("children" !== key && "key" !== key) {
              null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);
              runWithFiberInDEV(
                fiber,
                function(erroredKey) {
                  console.error(
                    "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                    erroredKey
                  );
                },
                key
              );
              break;
            }
          }
        }
        function unwrapThenable(thenable) {
          var index = thenableIndexCounter$1;
          thenableIndexCounter$1 += 1;
          null === thenableState$1 && (thenableState$1 = createThenableState());
          return trackUsedThenable(thenableState$1, thenable, index);
        }
        function coerceRef(workInProgress2, element) {
          element = element.props.ref;
          workInProgress2.ref = void 0 !== element ? element : null;
        }
        function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
          if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
            throw Error(
              'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
            );
          returnFiber = Object.prototype.toString.call(newChild);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        function throwOnInvalidObjectType(returnFiber, newChild) {
          var debugTask = getCurrentDebugTask();
          null !== debugTask ? debugTask.run(
            throwOnInvalidObjectTypeImpl.bind(null, returnFiber, newChild)
          ) : throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        function warnOnFunctionTypeImpl(returnFiber, invalidChild) {
          var parentName = getComponentNameFromFiber(returnFiber) || "Component";
          ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = true, invalidChild = invalidChild.displayName || invalidChild.name || "Component", 3 === returnFiber.tag ? console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)",
            invalidChild,
            invalidChild,
            invalidChild
          ) : console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>",
            invalidChild,
            invalidChild,
            parentName,
            invalidChild,
            parentName
          ));
        }
        function warnOnFunctionType(returnFiber, invalidChild) {
          var debugTask = getCurrentDebugTask();
          null !== debugTask ? debugTask.run(
            warnOnFunctionTypeImpl.bind(null, returnFiber, invalidChild)
          ) : warnOnFunctionTypeImpl(returnFiber, invalidChild);
        }
        function warnOnSymbolTypeImpl(returnFiber, invalidChild) {
          var parentName = getComponentNameFromFiber(returnFiber) || "Component";
          ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = true, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error(
            "Symbols are not valid as a React child.\n  root.render(%s)",
            invalidChild
          ) : console.error(
            "Symbols are not valid as a React child.\n  <%s>%s</%s>",
            parentName,
            invalidChild,
            parentName
          ));
        }
        function warnOnSymbolType(returnFiber, invalidChild) {
          var debugTask = getCurrentDebugTask();
          null !== debugTask ? debugTask.run(
            warnOnSymbolTypeImpl.bind(null, returnFiber, invalidChild)
          ) : warnOnSymbolTypeImpl(returnFiber, invalidChild);
        }
        function createChildReconciler(shouldTrackSideEffects) {
          function deleteChild(returnFiber, childToDelete) {
            if (shouldTrackSideEffects) {
              var deletions = returnFiber.deletions;
              null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
            }
          }
          function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) return null;
            for (; null !== currentFirstChild; )
              deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
            return null;
          }
          function mapRemainingChildren(currentFirstChild) {
            for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
              null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
            return existingChildren;
          }
          function useFiber(fiber, pendingProps) {
            fiber = createWorkInProgress(fiber, pendingProps);
            fiber.index = 0;
            fiber.sibling = null;
            return fiber;
          }
          function placeChild(newFiber, lastPlacedIndex, newIndex) {
            newFiber.index = newIndex;
            if (!shouldTrackSideEffects)
              return newFiber.flags |= 1048576, lastPlacedIndex;
            newIndex = newFiber.alternate;
            if (null !== newIndex)
              return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
            newFiber.flags |= 67108866;
            return lastPlacedIndex;
          }
          function placeSingleChild(newFiber) {
            shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
            return newFiber;
          }
          function updateTextNode(returnFiber, current2, textContent, lanes) {
            if (null === current2 || 6 !== current2.tag)
              return current2 = createFiberFromText(
                textContent,
                returnFiber.mode,
                lanes
              ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, textContent);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updateElement(returnFiber, current2, element, lanes) {
            var elementType = element.type;
            if (elementType === REACT_FRAGMENT_TYPE)
              return current2 = updateFragment(
                returnFiber,
                current2,
                element.props.children,
                lanes,
                element.key
              ), validateFragmentProps(element, current2, returnFiber), current2;
            if (null !== current2 && (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element) || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type))
              return current2 = useFiber(current2, element.props), coerceRef(current2, element), current2.return = returnFiber, current2._debugOwner = element._owner, current2._debugInfo = currentDebugInfo, current2;
            current2 = createFiberFromElement(element, returnFiber.mode, lanes);
            coerceRef(current2, element);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updatePortal(returnFiber, current2, portal, lanes) {
            if (null === current2 || 4 !== current2.tag || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation)
              return current2 = createFiberFromPortal(portal, returnFiber.mode, lanes), current2.return = returnFiber, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, portal.children || []);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updateFragment(returnFiber, current2, fragment, lanes, key) {
            if (null === current2 || 7 !== current2.tag)
              return current2 = createFiberFromFragment(
                fragment,
                returnFiber.mode,
                lanes,
                key
              ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, fragment);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function createChild(returnFiber, newChild, lanes) {
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return newChild = createFiberFromText(
                "" + newChild,
                returnFiber.mode,
                lanes
              ), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugTask = returnFiber._debugTask, newChild._debugInfo = currentDebugInfo, newChild;
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return lanes = createFiberFromElement(
                    newChild,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
                case REACT_PORTAL_TYPE:
                  return newChild = createFiberFromPortal(
                    newChild,
                    returnFiber.mode,
                    lanes
                  ), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
                case REACT_LAZY_TYPE:
                  var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                  newChild = resolveLazy(newChild);
                  returnFiber = createChild(returnFiber, newChild, lanes);
                  currentDebugInfo = _prevDebugInfo;
                  return returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild))
                return lanes = createFiberFromFragment(
                  newChild,
                  returnFiber.mode,
                  lanes,
                  null
                ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
              if ("function" === typeof newChild.then)
                return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(
                  returnFiber,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = _prevDebugInfo, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return createChild(
                  returnFiber,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function updateSlot(returnFiber, oldFiber, newChild, lanes) {
            var key = null !== oldFiber ? oldFiber.key : null;
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes
                  ), currentDebugInfo = key, returnFiber) : null;
                case REACT_PORTAL_TYPE:
                  return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
                case REACT_LAZY_TYPE:
                  return key = pushDebugInfo(newChild._debugInfo), newChild = resolveLazy(newChild), returnFiber = updateSlot(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes
                  ), currentDebugInfo = key, returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
                if (null !== key) return null;
                key = pushDebugInfo(newChild._debugInfo);
                returnFiber = updateFragment(
                  returnFiber,
                  oldFiber,
                  newChild,
                  lanes,
                  null
                );
                currentDebugInfo = key;
                return returnFiber;
              }
              if ("function" === typeof newChild.then)
                return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(
                  returnFiber,
                  oldFiber,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = key, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return updateSlot(
                  returnFiber,
                  oldFiber,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return newIdx = existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                    returnFiber,
                    newIdx,
                    newChild,
                    lanes
                  ), currentDebugInfo = existingChildren, returnFiber;
                case REACT_PORTAL_TYPE:
                  return existingChildren = existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
                case REACT_LAZY_TYPE:
                  var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
                  newChild = resolveLazy(newChild);
                  returnFiber = updateFromMap(
                    existingChildren,
                    returnFiber,
                    newIdx,
                    newChild,
                    lanes
                  );
                  currentDebugInfo = _prevDebugInfo7;
                  return returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild))
                return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes,
                  null
                ), currentDebugInfo = existingChildren, returnFiber;
              if ("function" === typeof newChild.then)
                return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = _prevDebugInfo7, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys) {
            if ("object" !== typeof child || null === child) return knownKeys;
            switch (child.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                warnForMissingKey(returnFiber, workInProgress2, child);
                var key = child.key;
                if ("string" !== typeof key) break;
                if (null === knownKeys) {
                  knownKeys = /* @__PURE__ */ new Set();
                  knownKeys.add(key);
                  break;
                }
                if (!knownKeys.has(key)) {
                  knownKeys.add(key);
                  break;
                }
                runWithFiberInDEV(workInProgress2, function() {
                  console.error(
                    "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.",
                    key
                  );
                });
                break;
              case REACT_LAZY_TYPE:
                child = resolveLazy(child), warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys);
            }
            return knownKeys;
          }
          function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
            for (var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
              oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
              var newFiber = updateSlot(
                returnFiber,
                oldFiber,
                newChildren[newIdx],
                lanes
              );
              if (null === newFiber) {
                null === oldFiber && (oldFiber = nextOldFiber);
                break;
              }
              knownKeys = warnOnInvalidKey(
                returnFiber,
                newFiber,
                newChildren[newIdx],
                knownKeys
              );
              shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
              currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
              null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (newIdx === newChildren.length)
              return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
            if (null === oldFiber) {
              for (; newIdx < newChildren.length; newIdx++)
                oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  newChildren[newIdx],
                  knownKeys
                ), currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
              nextOldFiber = updateFromMap(
                oldFiber,
                returnFiber,
                newIdx,
                newChildren[newIdx],
                lanes
              ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                newChildren[newIdx],
                knownKeys
              ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
                null === nextOldFiber.key ? newIdx : nextOldFiber.key
              ), currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
            shouldTrackSideEffects && oldFiber.forEach(function(child) {
              return deleteChild(returnFiber, child);
            });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
            if (null == newChildren)
              throw Error("An iterable object provided no iterator.");
            for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
              oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
              var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
              if (null === newFiber) {
                null === oldFiber && (oldFiber = nextOldFiber);
                break;
              }
              knownKeys = warnOnInvalidKey(
                returnFiber,
                newFiber,
                step.value,
                knownKeys
              );
              shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
              currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
              null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (step.done)
              return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
            if (null === oldFiber) {
              for (; !step.done; newIdx++, step = newChildren.next())
                oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  step.value,
                  knownKeys
                ), currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
              nextOldFiber = updateFromMap(
                oldFiber,
                returnFiber,
                newIdx,
                step.value,
                lanes
              ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                step.value,
                knownKeys
              ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
                null === nextOldFiber.key ? newIdx : nextOldFiber.key
              ), currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
            shouldTrackSideEffects && oldFiber.forEach(function(child) {
              return deleteChild(returnFiber, child);
            });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
            "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                  a: {
                    for (var key = newChild.key; null !== currentFirstChild; ) {
                      if (currentFirstChild.key === key) {
                        key = newChild.type;
                        if (key === REACT_FRAGMENT_TYPE) {
                          if (7 === currentFirstChild.tag) {
                            deleteRemainingChildren(
                              returnFiber,
                              currentFirstChild.sibling
                            );
                            lanes = useFiber(
                              currentFirstChild,
                              newChild.props.children
                            );
                            lanes.return = returnFiber;
                            lanes._debugOwner = newChild._owner;
                            lanes._debugInfo = currentDebugInfo;
                            validateFragmentProps(newChild, lanes, returnFiber);
                            returnFiber = lanes;
                            break a;
                          }
                        } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(
                          currentFirstChild,
                          newChild
                        ) || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(currentFirstChild, newChild.props);
                          coerceRef(lanes, newChild);
                          lanes.return = returnFiber;
                          lanes._debugOwner = newChild._owner;
                          lanes._debugInfo = currentDebugInfo;
                          returnFiber = lanes;
                          break a;
                        }
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      } else deleteChild(returnFiber, currentFirstChild);
                      currentFirstChild = currentFirstChild.sibling;
                    }
                    newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                      newChild.props.children,
                      returnFiber.mode,
                      lanes,
                      newChild.key
                    ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(
                      newChild,
                      returnFiber.mode,
                      lanes
                    ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);
                  }
                  returnFiber = placeSingleChild(returnFiber);
                  currentDebugInfo = prevDebugInfo;
                  return returnFiber;
                case REACT_PORTAL_TYPE:
                  a: {
                    prevDebugInfo = newChild;
                    for (newChild = prevDebugInfo.key; null !== currentFirstChild; ) {
                      if (currentFirstChild.key === newChild)
                        if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            prevDebugInfo.children || []
                          );
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        } else {
                          deleteRemainingChildren(returnFiber, currentFirstChild);
                          break;
                        }
                      else deleteChild(returnFiber, currentFirstChild);
                      currentFirstChild = currentFirstChild.sibling;
                    }
                    lanes = createFiberFromPortal(
                      prevDebugInfo,
                      returnFiber.mode,
                      lanes
                    );
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                  }
                  return placeSingleChild(returnFiber);
                case REACT_LAZY_TYPE:
                  return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = resolveLazy(newChild), returnFiber = reconcileChildFibersImpl(
                    returnFiber,
                    currentFirstChild,
                    newChild,
                    lanes
                  ), currentDebugInfo = prevDebugInfo, returnFiber;
              }
              if (isArrayImpl(newChild))
                return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                ), currentDebugInfo = prevDebugInfo, returnFiber;
              if (getIteratorFn(newChild)) {
                prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                key = getIteratorFn(newChild);
                if ("function" !== typeof key)
                  throw Error(
                    "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
                  );
                var newChildren = key.call(newChild);
                if (newChildren === newChild) {
                  if (0 !== returnFiber.tag || "[object GeneratorFunction]" !== Object.prototype.toString.call(returnFiber.type) || "[object Generator]" !== Object.prototype.toString.call(newChildren))
                    didWarnAboutGenerators || console.error(
                      "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
                    ), didWarnAboutGenerators = true;
                } else
                  newChild.entries !== key || didWarnAboutMaps || (console.error(
                    "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                  ), didWarnAboutMaps = true);
                returnFiber = reconcileChildrenIterator(
                  returnFiber,
                  currentFirstChild,
                  newChildren,
                  lanes
                );
                currentDebugInfo = prevDebugInfo;
                return returnFiber;
              }
              if ("function" === typeof newChild.then)
                return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = prevDebugInfo, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return prevDebugInfo = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(
                returnFiber,
                currentFirstChild.sibling
              ), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(
                prevDebugInfo,
                returnFiber.mode,
                lanes
              ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return deleteRemainingChildren(returnFiber, currentFirstChild);
          }
          return function(returnFiber, currentFirstChild, newChild, lanes) {
            var prevDebugInfo = currentDebugInfo;
            currentDebugInfo = null;
            try {
              thenableIndexCounter$1 = 0;
              var firstChildFiber = reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
              thenableState$1 = null;
              return firstChildFiber;
            } catch (x) {
              if (x === SuspenseException || x === SuspenseActionException) throw x;
              var fiber = createFiber(29, x, null, returnFiber.mode);
              fiber.lanes = lanes;
              fiber.return = returnFiber;
              var debugInfo = fiber._debugInfo = currentDebugInfo;
              fiber._debugOwner = returnFiber._debugOwner;
              fiber._debugTask = returnFiber._debugTask;
              if (null != debugInfo) {
                for (var i = debugInfo.length - 1; 0 <= i; i--)
                  if ("string" === typeof debugInfo[i].stack) {
                    fiber._debugOwner = debugInfo[i];
                    fiber._debugTask = debugInfo[i].debugTask;
                    break;
                  }
              }
              return fiber;
            } finally {
              currentDebugInfo = prevDebugInfo;
            }
          };
        }
        function validateSuspenseListNestedChild(childSlot, index) {
          var isAnArray = isArrayImpl(childSlot);
          childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
          return isAnArray || childSlot ? (isAnArray = isAnArray ? "array" : "iterable", console.error(
            "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
            isAnArray,
            index,
            isAnArray
          ), false) : true;
        }
        function initializeUpdateQueue(fiber) {
          fiber.updateQueue = {
            baseState: fiber.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: { pending: null, lanes: 0, hiddenCallbacks: null },
            callbacks: null
          };
        }
        function cloneUpdateQueue(current2, workInProgress2) {
          current2 = current2.updateQueue;
          workInProgress2.updateQueue === current2 && (workInProgress2.updateQueue = {
            baseState: current2.baseState,
            firstBaseUpdate: current2.firstBaseUpdate,
            lastBaseUpdate: current2.lastBaseUpdate,
            shared: current2.shared,
            callbacks: null
          });
        }
        function createUpdate(lane) {
          return {
            lane,
            tag: UpdateState,
            payload: null,
            callback: null,
            next: null
          };
        }
        function enqueueUpdate(fiber, update, lane) {
          var updateQueue = fiber.updateQueue;
          if (null === updateQueue) return null;
          updateQueue = updateQueue.shared;
          if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {
            var componentName2 = getComponentNameFromFiber(fiber);
            console.error(
              "An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s",
              componentName2
            );
            didWarnUpdateInsideUpdate = true;
          }
          if ((executionContext & RenderContext) !== NoContext)
            return componentName2 = updateQueue.pending, null === componentName2 ? update.next = update : (update.next = componentName2.next, componentName2.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;
          enqueueUpdate$1(fiber, updateQueue, update, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function entangleTransitions(root2, fiber, lane) {
          fiber = fiber.updateQueue;
          if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
            var queueLanes = fiber.lanes;
            queueLanes &= root2.pendingLanes;
            lane |= queueLanes;
            fiber.lanes = lane;
            markRootEntangled(root2, lane);
          }
        }
        function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
          var queue = workInProgress2.updateQueue, current2 = workInProgress2.alternate;
          if (null !== current2 && (current2 = current2.updateQueue, queue === current2)) {
            var newFirst = null, newLast = null;
            queue = queue.firstBaseUpdate;
            if (null !== queue) {
              do {
                var clone = {
                  lane: queue.lane,
                  tag: queue.tag,
                  payload: queue.payload,
                  callback: null,
                  next: null
                };
                null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
                queue = queue.next;
              } while (null !== queue);
              null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
            } else newFirst = newLast = capturedUpdate;
            queue = {
              baseState: current2.baseState,
              firstBaseUpdate: newFirst,
              lastBaseUpdate: newLast,
              shared: current2.shared,
              callbacks: current2.callbacks
            };
            workInProgress2.updateQueue = queue;
            return;
          }
          workInProgress2 = queue.lastBaseUpdate;
          null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
          queue.lastBaseUpdate = capturedUpdate;
        }
        function suspendIfUpdateReadFromEntangledAsyncAction() {
          if (didReadFromEntangledAsyncAction) {
            var entangledActionThenable = currentEntangledActionThenable;
            if (null !== entangledActionThenable) throw entangledActionThenable;
          }
        }
        function processUpdateQueue(workInProgress2, props, instance$jscomp$0, renderLanes2) {
          didReadFromEntangledAsyncAction = false;
          var queue = workInProgress2.updateQueue;
          hasForceUpdate = false;
          currentlyProcessingQueue = queue.shared;
          var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
          if (null !== pendingQueue) {
            queue.shared.pending = null;
            var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = null;
            null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
            lastBaseUpdate = lastPendingUpdate;
            var current2 = workInProgress2.alternate;
            null !== current2 && (current2 = current2.updateQueue, pendingQueue = current2.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current2.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current2.lastBaseUpdate = lastPendingUpdate));
          }
          if (null !== firstBaseUpdate) {
            var newState = queue.baseState;
            lastBaseUpdate = 0;
            current2 = firstPendingUpdate = lastPendingUpdate = null;
            pendingQueue = firstBaseUpdate;
            do {
              var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
              if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
                0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
                null !== current2 && (current2 = current2.next = {
                  lane: 0,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: null,
                  next: null
                });
                a: {
                  updateLane = workInProgress2;
                  var partialState = pendingQueue;
                  var nextProps = props, instance = instance$jscomp$0;
                  switch (partialState.tag) {
                    case ReplaceState:
                      partialState = partialState.payload;
                      if ("function" === typeof partialState) {
                        isDisallowedContextReadInDEV = true;
                        var nextState = partialState.call(
                          instance,
                          newState,
                          nextProps
                        );
                        if (updateLane.mode & StrictLegacyMode) {
                          setIsStrictModeForDevtools(true);
                          try {
                            partialState.call(instance, newState, nextProps);
                          } finally {
                            setIsStrictModeForDevtools(false);
                          }
                        }
                        isDisallowedContextReadInDEV = false;
                        newState = nextState;
                        break a;
                      }
                      newState = partialState;
                      break a;
                    case CaptureUpdate:
                      updateLane.flags = updateLane.flags & -65537 | 128;
                    case UpdateState:
                      nextState = partialState.payload;
                      if ("function" === typeof nextState) {
                        isDisallowedContextReadInDEV = true;
                        partialState = nextState.call(
                          instance,
                          newState,
                          nextProps
                        );
                        if (updateLane.mode & StrictLegacyMode) {
                          setIsStrictModeForDevtools(true);
                          try {
                            nextState.call(instance, newState, nextProps);
                          } finally {
                            setIsStrictModeForDevtools(false);
                          }
                        }
                        isDisallowedContextReadInDEV = false;
                      } else partialState = nextState;
                      if (null === partialState || void 0 === partialState) break a;
                      newState = assign2({}, newState, partialState);
                      break a;
                    case ForceUpdate:
                      hasForceUpdate = true;
                  }
                }
                updateLane = pendingQueue.callback;
                null !== updateLane && (workInProgress2.flags |= 64, isHiddenUpdate && (workInProgress2.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
              } else
                isHiddenUpdate = {
                  lane: updateLane,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: pendingQueue.callback,
                  next: null
                }, null === current2 ? (firstPendingUpdate = current2 = isHiddenUpdate, lastPendingUpdate = newState) : current2 = current2.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
              pendingQueue = pendingQueue.next;
              if (null === pendingQueue)
                if (pendingQueue = queue.shared.pending, null === pendingQueue)
                  break;
                else
                  isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
            } while (1);
            null === current2 && (lastPendingUpdate = newState);
            queue.baseState = lastPendingUpdate;
            queue.firstBaseUpdate = firstPendingUpdate;
            queue.lastBaseUpdate = current2;
            null === firstBaseUpdate && (queue.shared.lanes = 0);
            workInProgressRootSkippedLanes |= lastBaseUpdate;
            workInProgress2.lanes = lastBaseUpdate;
            workInProgress2.memoizedState = newState;
          }
          currentlyProcessingQueue = null;
        }
        function callCallback(callback, context2) {
          if ("function" !== typeof callback)
            throw Error(
              "Invalid argument passed as callback. Expected a function. Instead received: " + callback
            );
          callback.call(context2);
        }
        function commitHiddenCallbacks(updateQueue, context2) {
          var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
          if (null !== hiddenCallbacks)
            for (updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)
              callCallback(hiddenCallbacks[updateQueue], context2);
        }
        function commitCallbacks(updateQueue, context2) {
          var callbacks = updateQueue.callbacks;
          if (null !== callbacks)
            for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
              callCallback(callbacks[updateQueue], context2);
        }
        function pushHiddenContext(fiber, context2) {
          var prevEntangledRenderLanes = entangledRenderLanes;
          push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
          push(currentTreeHiddenStackCursor, context2, fiber);
          entangledRenderLanes = prevEntangledRenderLanes | context2.baseLanes;
        }
        function reuseHiddenContextOnStack(fiber) {
          push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
          push(
            currentTreeHiddenStackCursor,
            currentTreeHiddenStackCursor.current,
            fiber
          );
        }
        function popHiddenContext(fiber) {
          entangledRenderLanes = prevEntangledRenderLanesCursor.current;
          pop(currentTreeHiddenStackCursor, fiber);
          pop(prevEntangledRenderLanesCursor, fiber);
        }
        function pushPrimaryTreeSuspenseHandler(handler) {
          var current2 = handler.alternate;
          push(
            suspenseStackCursor,
            suspenseStackCursor.current & SubtreeSuspenseContextMask,
            handler
          );
          push(suspenseHandlerStackCursor, handler, handler);
          null === shellBoundary && (null === current2 || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current2.memoizedState && (shellBoundary = handler));
        }
        function pushDehydratedActivitySuspenseHandler(fiber) {
          push(suspenseStackCursor, suspenseStackCursor.current, fiber);
          push(suspenseHandlerStackCursor, fiber, fiber);
          null === shellBoundary && (shellBoundary = fiber);
        }
        function pushOffscreenSuspenseHandler(fiber) {
          22 === fiber.tag ? (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack(fiber);
        }
        function reuseSuspenseHandlerOnStack(fiber) {
          push(suspenseStackCursor, suspenseStackCursor.current, fiber);
          push(
            suspenseHandlerStackCursor,
            suspenseHandlerStackCursor.current,
            fiber
          );
        }
        function popSuspenseHandler(fiber) {
          pop(suspenseHandlerStackCursor, fiber);
          shellBoundary === fiber && (shellBoundary = null);
          pop(suspenseStackCursor, fiber);
        }
        function findFirstSuspended(row) {
          for (var node = row; null !== node; ) {
            if (13 === node.tag) {
              var state = node.memoizedState;
              if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state)))
                return node;
            } else if (19 === node.tag && ("forwards" === node.memoizedProps.revealOrder || "backwards" === node.memoizedProps.revealOrder || "unstable_legacy-backwards" === node.memoizedProps.revealOrder || "together" === node.memoizedProps.revealOrder)) {
              if (0 !== (node.flags & 128)) return node;
            } else if (null !== node.child) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === row) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === row) return null;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
          return null;
        }
        function mountHookTypesDev() {
          var hookName = currentHookNameInDev;
          null === hookTypesDev ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
        }
        function updateHookTypesDev() {
          var hookName = currentHookNameInDev;
          if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {
            var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
            if (!didWarnAboutMismatchedHooksForComponent.has(componentName2) && (didWarnAboutMismatchedHooksForComponent.add(componentName2), null !== hookTypesDev)) {
              for (var table = "", i = 0; i <= hookTypesUpdateIndexDev; i++) {
                var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;
                for (oldHookName = i + 1 + ". " + oldHookName; 30 > oldHookName.length; )
                  oldHookName += " ";
                oldHookName += newHookName + "\n";
                table += oldHookName;
              }
              console.error(
                "React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
                componentName2,
                table
              );
            }
          }
        }
        function checkDepsAreArrayDev(deps) {
          void 0 === deps || null === deps || isArrayImpl(deps) || console.error(
            "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
            currentHookNameInDev,
            typeof deps
          );
        }
        function warnOnUseFormStateInDev() {
          var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
          didWarnAboutUseFormState.has(componentName2) || (didWarnAboutUseFormState.add(componentName2), console.error(
            "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
            componentName2
          ));
        }
        function throwInvalidHookError() {
          throw Error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (ignorePreviousDependencies) return false;
          if (null === prevDeps)
            return console.error(
              "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
              currentHookNameInDev
            ), false;
          nextDeps.length !== prevDeps.length && console.error(
            "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
            currentHookNameInDev,
            "[" + prevDeps.join(", ") + "]",
            "[" + nextDeps.join(", ") + "]"
          );
          for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
            if (!objectIs(nextDeps[i], prevDeps[i])) return false;
          return true;
        }
        function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
          renderLanes = nextRenderLanes;
          currentlyRenderingFiber = workInProgress2;
          hookTypesDev = null !== current2 ? current2._debugHookTypes : null;
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
          if ("[object AsyncFunction]" === Object.prototype.toString.call(Component) || "[object AsyncGeneratorFunction]" === Object.prototype.toString.call(Component))
            nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error(
              "%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.",
              null === nextRenderLanes ? "An unknown Component" : "<" + nextRenderLanes + ">"
            ));
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          workInProgress2.lanes = 0;
          ReactSharedInternals.H = null !== current2 && null !== current2.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;
          shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress2.mode & StrictLegacyMode) !== NoMode;
          var children = callComponentInDEV(Component, props, secondArg);
          shouldDoubleInvokeUserFnsInHooksDEV = false;
          didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(
            workInProgress2,
            Component,
            props,
            secondArg
          ));
          if (nextRenderLanes) {
            setIsStrictModeForDevtools(true);
            try {
              children = renderWithHooksAgain(
                workInProgress2,
                Component,
                props,
                secondArg
              );
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          finishRenderingHooks(current2, workInProgress2);
          return children;
        }
        function finishRenderingHooks(current2, workInProgress2) {
          workInProgress2._debugHookTypes = hookTypesDev;
          null === workInProgress2.dependencies ? null !== thenableState && (workInProgress2.dependencies = {
            lanes: 0,
            firstContext: null,
            _debugThenableState: thenableState
          }) : workInProgress2.dependencies._debugThenableState = thenableState;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
          renderLanes = 0;
          hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
          hookTypesUpdateIndexDev = -1;
          null !== current2 && (current2.flags & 65011712) !== (workInProgress2.flags & 65011712) && console.error(
            "Internal React error: Expected static flag was missing. Please notify the React team."
          );
          didScheduleRenderPhaseUpdate = false;
          thenableIndexCounter = 0;
          thenableState = null;
          if (didRenderTooFewHooks)
            throw Error(
              "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
            );
          null === current2 || didReceiveUpdate || (current2 = current2.dependencies, null !== current2 && checkIfContextChanged(current2) && (didReceiveUpdate = true));
          needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = false, current2 = true) : current2 = false;
          current2 && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Unknown", didWarnAboutUseWrappedInTryCatch.has(workInProgress2) || didWarnAboutAsyncClientComponent.has(workInProgress2) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress2), console.error(
            "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
          )));
        }
        function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
          currentlyRenderingFiber = workInProgress2;
          var numberOfReRenders = 0;
          do {
            didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
            thenableIndexCounter = 0;
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            if (numberOfReRenders >= RE_RENDER_LIMIT)
              throw Error(
                "Too many re-renders. React limits the number of renders to prevent an infinite loop."
              );
            numberOfReRenders += 1;
            ignorePreviousDependencies = false;
            workInProgressHook = currentHook = null;
            if (null != workInProgress2.updateQueue) {
              var children = workInProgress2.updateQueue;
              children.lastEffect = null;
              children.events = null;
              children.stores = null;
              null != children.memoCache && (children.memoCache.index = 0);
            }
            hookTypesUpdateIndexDev = -1;
            ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
            children = callComponentInDEV(Component, props, secondArg);
          } while (didScheduleRenderPhaseUpdateDuringThisPass);
          return children;
        }
        function TransitionAwareHostComponent() {
          var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
          maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
          dispatcher = dispatcher.useState()[0];
          (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
          return maybeThenable;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = 0 !== localIdCounter;
          localIdCounter = 0;
          return didRenderIdHook;
        }
        function bailoutHooks(current2, workInProgress2, lanes) {
          workInProgress2.updateQueue = current2.updateQueue;
          workInProgress2.flags = (workInProgress2.mode & StrictEffectsMode) !== NoMode ? workInProgress2.flags & -402655237 : workInProgress2.flags & -2053;
          current2.lanes &= ~lanes;
        }
        function resetHooksOnUnwind(workInProgress2) {
          if (didScheduleRenderPhaseUpdate) {
            for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
              var queue = workInProgress2.queue;
              null !== queue && (queue.pending = null);
              workInProgress2 = workInProgress2.next;
            }
            didScheduleRenderPhaseUpdate = false;
          }
          renderLanes = 0;
          hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
          hookTypesUpdateIndexDev = -1;
          currentHookNameInDev = null;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          thenableIndexCounter = localIdCounter = 0;
          thenableState = null;
        }
        function mountWorkInProgressHook() {
          var hook = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
          return workInProgressHook;
        }
        function updateWorkInProgressHook() {
          if (null === currentHook) {
            var nextCurrentHook = currentlyRenderingFiber.alternate;
            nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
          } else nextCurrentHook = currentHook.next;
          var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
          if (null !== nextWorkInProgressHook)
            workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
          else {
            if (null === nextCurrentHook) {
              if (null === currentlyRenderingFiber.alternate)
                throw Error(
                  "Update hook called on initial render. This is likely a bug in React. Please file an issue."
                );
              throw Error("Rendered more hooks than during the previous render.");
            }
            currentHook = nextCurrentHook;
            nextCurrentHook = {
              memoizedState: currentHook.memoizedState,
              baseState: currentHook.baseState,
              baseQueue: currentHook.baseQueue,
              queue: currentHook.queue,
              next: null
            };
            null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
          }
          return workInProgressHook;
        }
        function createFunctionComponentUpdateQueue() {
          return { lastEffect: null, events: null, stores: null, memoCache: null };
        }
        function useThenable(thenable) {
          var index = thenableIndexCounter;
          thenableIndexCounter += 1;
          null === thenableState && (thenableState = createThenableState());
          thenable = trackUsedThenable(thenableState, thenable, index);
          index = currentlyRenderingFiber;
          null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);
          return thenable;
        }
        function use(usable) {
          if (null !== usable && "object" === typeof usable) {
            if ("function" === typeof usable.then) return useThenable(usable);
            if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
          }
          throw Error("An unsupported type was passed to use(): " + String(usable));
        }
        function useMemoCache(size) {
          var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
          null !== updateQueue && (memoCache = updateQueue.memoCache);
          if (null == memoCache) {
            var current2 = currentlyRenderingFiber.alternate;
            null !== current2 && (current2 = current2.updateQueue, null !== current2 && (current2 = current2.memoCache, null != current2 && (memoCache = {
              data: current2.data.map(function(array) {
                return array.slice();
              }),
              index: 0
            })));
          }
          null == memoCache && (memoCache = { data: [], index: 0 });
          null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
          updateQueue.memoCache = memoCache;
          updateQueue = memoCache.data[memoCache.index];
          if (void 0 === updateQueue || ignorePreviousDependencies)
            for (updateQueue = memoCache.data[memoCache.index] = Array(size), current2 = 0; current2 < size; current2++)
              updateQueue[current2] = REACT_MEMO_CACHE_SENTINEL;
          else
            updateQueue.length !== size && console.error(
              "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
              updateQueue.length,
              size
            );
          memoCache.index++;
          return updateQueue;
        }
        function basicStateReducer(state, action) {
          return "function" === typeof action ? action(state) : action;
        }
        function mountReducer(reducer2, initialArg, init) {
          var hook = mountWorkInProgressHook();
          if (void 0 !== init) {
            var initialState = init(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                init(initialArg);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          } else initialState = initialArg;
          hook.memoizedState = hook.baseState = initialState;
          reducer2 = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer2,
            lastRenderedState: initialState
          };
          hook.queue = reducer2;
          reducer2 = reducer2.dispatch = dispatchReducerAction.bind(
            null,
            currentlyRenderingFiber,
            reducer2
          );
          return [hook.memoizedState, reducer2];
        }
        function updateReducer(reducer2) {
          var hook = updateWorkInProgressHook();
          return updateReducerImpl(hook, currentHook, reducer2);
        }
        function updateReducerImpl(hook, current2, reducer2) {
          var queue = hook.queue;
          if (null === queue)
            throw Error(
              "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
            );
          queue.lastRenderedReducer = reducer2;
          var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
          if (null !== pendingQueue) {
            if (null !== baseQueue) {
              var baseFirst = baseQueue.next;
              baseQueue.next = pendingQueue.next;
              pendingQueue.next = baseFirst;
            }
            current2.baseQueue !== baseQueue && console.error(
              "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
            );
            current2.baseQueue = baseQueue = pendingQueue;
            queue.pending = null;
          }
          pendingQueue = hook.baseState;
          if (null === baseQueue) hook.memoizedState = pendingQueue;
          else {
            current2 = baseQueue.next;
            var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current2, didReadFromEntangledAsyncAction2 = false;
            do {
              var updateLane = update.lane & -536870913;
              if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
                var revertLane = update.revertLane;
                if (0 === revertLane)
                  null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                    lane: 0,
                    revertLane: 0,
                    gesture: null,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                else if ((renderLanes & revertLane) === revertLane) {
                  update = update.next;
                  revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                  continue;
                } else
                  updateLane = {
                    lane: 0,
                    revertLane: update.revertLane,
                    gesture: null,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
                updateLane = update.action;
                shouldDoubleInvokeUserFnsInHooksDEV && reducer2(pendingQueue, updateLane);
                pendingQueue = update.hasEagerState ? update.eagerState : reducer2(pendingQueue, updateLane);
              } else
                revertLane = {
                  lane: updateLane,
                  revertLane: update.revertLane,
                  gesture: update.gesture,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
              update = update.next;
            } while (null !== update && update !== current2);
            null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
            if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction2 && (reducer2 = currentEntangledActionThenable, null !== reducer2)))
              throw reducer2;
            hook.memoizedState = pendingQueue;
            hook.baseState = baseFirst;
            hook.baseQueue = newBaseQueueLast;
            queue.lastRenderedState = pendingQueue;
          }
          null === baseQueue && (queue.lanes = 0);
          return [hook.memoizedState, queue.dispatch];
        }
        function rerenderReducer(reducer2) {
          var hook = updateWorkInProgressHook(), queue = hook.queue;
          if (null === queue)
            throw Error(
              "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
            );
          queue.lastRenderedReducer = reducer2;
          var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
          if (null !== lastRenderPhaseUpdate) {
            queue.pending = null;
            var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            do
              newState = reducer2(newState, update.action), update = update.next;
            while (update !== lastRenderPhaseUpdate);
            objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
            hook.memoizedState = newState;
            null === hook.baseQueue && (hook.baseState = newState);
            queue.lastRenderedState = newState;
          }
          return [newState, dispatch];
        }
        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
          if (isHydrating) {
            if (void 0 === getServerSnapshot)
              throw Error(
                "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
              );
            var nextSnapshot = getServerSnapshot();
            didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error(
              "The result of getServerSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true);
          } else {
            nextSnapshot = getSnapshot();
            didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true));
            if (null === workInProgressRoot)
              throw Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            0 !== (workInProgressRootRenderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
          }
          hook.memoizedState = nextSnapshot;
          getServerSnapshot = { value: nextSnapshot, getSnapshot };
          hook.queue = getServerSnapshot;
          mountEffect(
            subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe),
            [subscribe]
          );
          fiber.flags |= 2048;
          pushSimpleEffect(
            HasEffect | Passive,
            { destroy: void 0 },
            updateStoreInstance.bind(
              null,
              fiber,
              getServerSnapshot,
              nextSnapshot,
              getSnapshot
            ),
            null
          );
          return nextSnapshot;
        }
        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
          if (isHydrating$jscomp$0) {
            if (void 0 === getServerSnapshot)
              throw Error(
                "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
              );
            getServerSnapshot = getServerSnapshot();
          } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
            var cachedSnapshot = getSnapshot();
            objectIs(getServerSnapshot, cachedSnapshot) || (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true);
          }
          if (cachedSnapshot = !objectIs(
            (currentHook || hook).memoizedState,
            getServerSnapshot
          ))
            hook.memoizedState = getServerSnapshot, didReceiveUpdate = true;
          hook = hook.queue;
          var create = subscribeToStore.bind(null, fiber, hook, subscribe);
          updateEffectImpl(2048, Passive, create, [subscribe]);
          if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {
            fiber.flags |= 2048;
            pushSimpleEffect(
              HasEffect | Passive,
              { destroy: void 0 },
              updateStoreInstance.bind(
                null,
                fiber,
                hook,
                getServerSnapshot,
                getSnapshot
              ),
              null
            );
            if (null === workInProgressRoot)
              throw Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            isHydrating$jscomp$0 || 0 !== (renderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          return getServerSnapshot;
        }
        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
          fiber.flags |= 16384;
          fiber = { getSnapshot, value: renderedSnapshot };
          getSnapshot = currentlyRenderingFiber.updateQueue;
          null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
        }
        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
          inst.value = nextSnapshot;
          inst.getSnapshot = getSnapshot;
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        }
        function subscribeToStore(fiber, inst, subscribe) {
          return subscribe(function() {
            checkIfSnapshotChanged(inst) && (startUpdateTimerByLane(2, "updateSyncExternalStore()", fiber), forceStoreRerender(fiber));
          });
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          inst = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(inst, nextValue);
          } catch (error) {
            return true;
          }
        }
        function forceStoreRerender(fiber) {
          var root2 = enqueueConcurrentRenderForLane(fiber, 2);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
        }
        function mountStateImpl(initialState) {
          var hook = mountWorkInProgressHook();
          if ("function" === typeof initialState) {
            var initialStateInitializer = initialState;
            initialState = initialStateInitializer();
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                initialStateInitializer();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          }
          hook.memoizedState = hook.baseState = initialState;
          hook.queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialState
          };
          return hook;
        }
        function mountState(initialState) {
          initialState = mountStateImpl(initialState);
          var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
          queue.dispatch = dispatch;
          return [initialState.memoizedState, dispatch];
        }
        function mountOptimistic(passthrough) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = hook.baseState = passthrough;
          var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
          };
          hook.queue = queue;
          hook = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            true,
            queue
          );
          queue.dispatch = hook;
          return [passthrough, hook];
        }
        function updateOptimistic(passthrough, reducer2) {
          var hook = updateWorkInProgressHook();
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer2);
        }
        function updateOptimisticImpl(hook, current2, passthrough, reducer2) {
          hook.baseState = passthrough;
          return updateReducerImpl(
            hook,
            currentHook,
            "function" === typeof reducer2 ? reducer2 : basicStateReducer
          );
        }
        function rerenderOptimistic(passthrough, reducer2) {
          var hook = updateWorkInProgressHook();
          if (null !== currentHook)
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer2);
          hook.baseState = passthrough;
          return [passthrough, hook.queue.dispatch];
        }
        function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
          if (isRenderPhaseUpdate(fiber))
            throw Error("Cannot update form state while rendering.");
          fiber = actionQueue.action;
          if (null !== fiber) {
            var actionNode = {
              payload,
              action: fiber,
              next: null,
              isTransition: true,
              status: "pending",
              value: null,
              reason: null,
              listeners: [],
              then: function(listener) {
                actionNode.listeners.push(listener);
              }
            };
            null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
            setState(actionNode);
            setPendingState = actionQueue.pending;
            null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
          }
        }
        function runActionStateAction(actionQueue, node) {
          var action = node.action, payload = node.payload, prevState = actionQueue.state;
          if (node.isTransition) {
            var prevTransition = ReactSharedInternals.T, currentTransition = {};
            currentTransition._updatedFibers = /* @__PURE__ */ new Set();
            ReactSharedInternals.T = currentTransition;
            try {
              var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
              null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
              handleActionReturnValue(actionQueue, node, returnValue);
            } catch (error) {
              onActionError(actionQueue, node, error);
            } finally {
              null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(
                "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
              ), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn(
                "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
              ));
            }
          } else
            try {
              currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);
            } catch (error$4) {
              onActionError(actionQueue, node, error$4);
            }
        }
        function handleActionReturnValue(actionQueue, node, returnValue) {
          null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(
            function(nextState) {
              onActionSuccess(actionQueue, node, nextState);
            },
            function(error) {
              return onActionError(actionQueue, node, error);
            }
          ), node.isTransition || console.error(
            "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
          )) : onActionSuccess(actionQueue, node, returnValue);
        }
        function onActionSuccess(actionQueue, actionNode, nextState) {
          actionNode.status = "fulfilled";
          actionNode.value = nextState;
          notifyActionListeners(actionNode);
          actionQueue.state = nextState;
          actionNode = actionQueue.pending;
          null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
        }
        function onActionError(actionQueue, actionNode, error) {
          var last2 = actionQueue.pending;
          actionQueue.pending = null;
          if (null !== last2) {
            last2 = last2.next;
            do
              actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
            while (actionNode !== last2);
          }
          actionQueue.action = null;
        }
        function notifyActionListeners(actionNode) {
          actionNode = actionNode.listeners;
          for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
        }
        function actionStateReducer(oldState, newState) {
          return newState;
        }
        function mountActionState(action, initialStateProp) {
          if (isHydrating) {
            var ssrFormState = workInProgressRoot.formState;
            if (null !== ssrFormState) {
              a: {
                var isMatching = currentlyRenderingFiber;
                if (isHydrating) {
                  if (nextHydratableInstance) {
                    b: {
                      var markerInstance = nextHydratableInstance;
                      for (var inRootOrSingleton = rootOrSingletonContext; 8 !== markerInstance.nodeType; ) {
                        if (!inRootOrSingleton) {
                          markerInstance = null;
                          break b;
                        }
                        markerInstance = getNextHydratable(
                          markerInstance.nextSibling
                        );
                        if (null === markerInstance) {
                          markerInstance = null;
                          break b;
                        }
                      }
                      inRootOrSingleton = markerInstance.data;
                      markerInstance = inRootOrSingleton === FORM_STATE_IS_MATCHING || inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING ? markerInstance : null;
                    }
                    if (markerInstance) {
                      nextHydratableInstance = getNextHydratable(
                        markerInstance.nextSibling
                      );
                      isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
                      break a;
                    }
                  }
                  throwOnHydrationMismatch(isMatching);
                }
                isMatching = false;
              }
              isMatching && (initialStateProp = ssrFormState[0]);
            }
          }
          ssrFormState = mountWorkInProgressHook();
          ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
          isMatching = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: actionStateReducer,
            lastRenderedState: initialStateProp
          };
          ssrFormState.queue = isMatching;
          ssrFormState = dispatchSetState.bind(
            null,
            currentlyRenderingFiber,
            isMatching
          );
          isMatching.dispatch = ssrFormState;
          isMatching = mountStateImpl(false);
          inRootOrSingleton = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            false,
            isMatching.queue
          );
          isMatching = mountWorkInProgressHook();
          markerInstance = {
            state: initialStateProp,
            dispatch: null,
            action,
            pending: null
          };
          isMatching.queue = markerInstance;
          ssrFormState = dispatchActionState.bind(
            null,
            currentlyRenderingFiber,
            markerInstance,
            inRootOrSingleton,
            ssrFormState
          );
          markerInstance.dispatch = ssrFormState;
          isMatching.memoizedState = action;
          return [initialStateProp, ssrFormState, false];
        }
        function updateActionState(action) {
          var stateHook = updateWorkInProgressHook();
          return updateActionStateImpl(stateHook, currentHook, action);
        }
        function updateActionStateImpl(stateHook, currentStateHook, action) {
          currentStateHook = updateReducerImpl(
            stateHook,
            currentStateHook,
            actionStateReducer
          )[0];
          stateHook = updateReducer(basicStateReducer)[0];
          if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
            try {
              var state = useThenable(currentStateHook);
            } catch (x) {
              if (x === SuspenseException) throw SuspenseActionException;
              throw x;
            }
          else state = currentStateHook;
          currentStateHook = updateWorkInProgressHook();
          var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
          action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
            HasEffect | Passive,
            { destroy: void 0 },
            actionStateActionEffect.bind(null, actionQueue, action),
            null
          ));
          return [state, dispatch, stateHook];
        }
        function actionStateActionEffect(actionQueue, action) {
          actionQueue.action = action;
        }
        function rerenderActionState(action) {
          var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
          if (null !== currentStateHook)
            return updateActionStateImpl(stateHook, currentStateHook, action);
          updateWorkInProgressHook();
          stateHook = stateHook.memoizedState;
          currentStateHook = updateWorkInProgressHook();
          var dispatch = currentStateHook.queue.dispatch;
          currentStateHook.memoizedState = action;
          return [stateHook, dispatch, false];
        }
        function pushSimpleEffect(tag, inst, create, deps) {
          tag = { tag, create, deps, inst, next: null };
          inst = currentlyRenderingFiber.updateQueue;
          null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
          create = inst.lastEffect;
          null === create ? inst.lastEffect = tag.next = tag : (deps = create.next, create.next = tag, tag.next = deps, inst.lastEffect = tag);
          return tag;
        }
        function mountRef(initialValue) {
          var hook = mountWorkInProgressHook();
          initialValue = { current: initialValue };
          return hook.memoizedState = initialValue;
        }
        function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
          var hook = mountWorkInProgressHook();
          currentlyRenderingFiber.flags |= fiberFlags;
          hook.memoizedState = pushSimpleEffect(
            HasEffect | hookFlags,
            { destroy: void 0 },
            create,
            void 0 === deps ? null : deps
          );
        }
        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var inst = hook.memoizedState.inst;
          null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
            HasEffect | hookFlags,
            inst,
            create,
            deps
          ));
        }
        function mountEffect(create, deps) {
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode ? mountEffectImpl(276826112, Passive, create, deps) : mountEffectImpl(8390656, Passive, create, deps);
        }
        function useEffectEventImpl(payload) {
          currentlyRenderingFiber.flags |= 4;
          var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
          if (null === componentUpdateQueue)
            componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
          else {
            var events = componentUpdateQueue.events;
            null === events ? componentUpdateQueue.events = [payload] : events.push(payload);
          }
        }
        function mountEvent(callback) {
          var hook = mountWorkInProgressHook(), ref = { impl: callback };
          hook.memoizedState = ref;
          return function() {
            if ((executionContext & RenderContext) !== NoContext)
              throw Error(
                "A function wrapped in useEffectEvent can't be called during rendering."
              );
            return ref.impl.apply(void 0, arguments);
          };
        }
        function updateEvent(callback) {
          var ref = updateWorkInProgressHook().memoizedState;
          useEffectEventImpl({ ref, nextImpl: callback });
          return function() {
            if ((executionContext & RenderContext) !== NoContext)
              throw Error(
                "A function wrapped in useEffectEvent can't be called during rendering."
              );
            return ref.impl.apply(void 0, arguments);
          };
        }
        function mountLayoutEffect(create, deps) {
          var fiberFlags = 4194308;
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
          return mountEffectImpl(fiberFlags, Layout, create, deps);
        }
        function imperativeHandleEffect(create, ref) {
          if ("function" === typeof ref) {
            create = create();
            var refCleanup = ref(create);
            return function() {
              "function" === typeof refCleanup ? refCleanup() : ref(null);
            };
          }
          if (null !== ref && void 0 !== ref)
            return ref.hasOwnProperty("current") || console.error(
              "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
              "an object with keys {" + Object.keys(ref).join(", ") + "}"
            ), create = create(), ref.current = create, function() {
              ref.current = null;
            };
        }
        function mountImperativeHandle(ref, create, deps) {
          "function" !== typeof create && console.error(
            "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
            null !== create ? typeof create : "null"
          );
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          var fiberFlags = 4194308;
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
          mountEffectImpl(
            fiberFlags,
            Layout,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        }
        function updateImperativeHandle(ref, create, deps) {
          "function" !== typeof create && console.error(
            "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
            null !== create ? typeof create : "null"
          );
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          updateEffectImpl(
            4,
            Layout,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        }
        function mountCallback(callback, deps) {
          mountWorkInProgressHook().memoizedState = [
            callback,
            void 0 === deps ? null : deps
          ];
          return callback;
        }
        function updateCallback(callback, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var prevState = hook.memoizedState;
          if (null !== deps && areHookInputsEqual(deps, prevState[1]))
            return prevState[0];
          hook.memoizedState = [callback, deps];
          return callback;
        }
        function mountMemo(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var nextValue = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [nextValue, deps];
          return nextValue;
        }
        function updateMemo(nextCreate, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var prevState = hook.memoizedState;
          if (null !== deps && areHookInputsEqual(deps, prevState[1]))
            return prevState[0];
          prevState = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [prevState, deps];
          return prevState;
        }
        function mountDeferredValue(value, initialValue) {
          var hook = mountWorkInProgressHook();
          return mountDeferredValueImpl(hook, value, initialValue);
        }
        function updateDeferredValue(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        }
        function rerenderDeferredValue(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        }
        function mountDeferredValueImpl(hook, value, initialValue) {
          if (void 0 === initialValue || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
            return hook.memoizedState = value;
          hook.memoizedState = initialValue;
          hook = requestDeferredLane();
          currentlyRenderingFiber.lanes |= hook;
          workInProgressRootSkippedLanes |= hook;
          return initialValue;
        }
        function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
          if (objectIs(value, prevValue)) return value;
          if (null !== currentTreeHiddenStackCursor.current)
            return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
          if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
            return didReceiveUpdate = true, hook.memoizedState = value;
          hook = requestDeferredLane();
          currentlyRenderingFiber.lanes |= hook;
          workInProgressRootSkippedLanes |= hook;
          return prevValue;
        }
        function releaseAsyncTransition() {
          ReactSharedInternals.asyncTransitions--;
        }
        function startTransition(fiber, queue, pendingState, finishedState, callback) {
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 0 !== previousPriority && previousPriority < ContinuousEventPriority ? previousPriority : ContinuousEventPriority;
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          ReactSharedInternals.T = currentTransition;
          dispatchOptimisticSetState(fiber, false, queue, pendingState);
          try {
            var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
              ReactSharedInternals.asyncTransitions++;
              returnValue.then(releaseAsyncTransition, releaseAsyncTransition);
              var thenableForFinishedState = chainThenableValue(
                returnValue,
                finishedState
              );
              dispatchSetStateInternal(
                fiber,
                queue,
                thenableForFinishedState,
                requestUpdateLane(fiber)
              );
            } else
              dispatchSetStateInternal(
                fiber,
                queue,
                finishedState,
                requestUpdateLane(fiber)
              );
          } catch (error) {
            dispatchSetStateInternal(
              fiber,
              queue,
              { then: function() {
              }, status: "rejected", reason: error },
              requestUpdateLane(fiber)
            );
          } finally {
            ReactDOMSharedInternals.p = previousPriority, null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(
              "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
            ), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            ));
          }
        }
        function startHostTransition(formFiber, pendingState, action, formData) {
          if (5 !== formFiber.tag)
            throw Error(
              "Expected the form instance to be a HostComponent. This is a bug in React."
            );
          var queue = ensureFormComponentIsStateful(formFiber).queue;
          startHostActionTimer(formFiber);
          startTransition(
            formFiber,
            queue,
            pendingState,
            NotPendingTransition,
            null === action ? noop : function() {
              requestFormReset$1(formFiber);
              return action(formData);
            }
          );
        }
        function ensureFormComponentIsStateful(formFiber) {
          var existingStateHook = formFiber.memoizedState;
          if (null !== existingStateHook) return existingStateHook;
          existingStateHook = {
            memoizedState: NotPendingTransition,
            baseState: NotPendingTransition,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: NotPendingTransition
            },
            next: null
          };
          var initialResetState = {};
          existingStateHook.next = {
            memoizedState: initialResetState,
            baseState: initialResetState,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialResetState
            },
            next: null
          };
          formFiber.memoizedState = existingStateHook;
          formFiber = formFiber.alternate;
          null !== formFiber && (formFiber.memoizedState = existingStateHook);
          return existingStateHook;
        }
        function requestFormReset$1(formFiber) {
          null === ReactSharedInternals.T && console.error(
            "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
          );
          var stateHook = ensureFormComponentIsStateful(formFiber);
          null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
          dispatchSetStateInternal(
            formFiber,
            stateHook.next.queue,
            {},
            requestUpdateLane(formFiber)
          );
        }
        function mountTransition() {
          var stateHook = mountStateImpl(false);
          stateHook = startTransition.bind(
            null,
            currentlyRenderingFiber,
            stateHook.queue,
            true,
            false
          );
          mountWorkInProgressHook().memoizedState = stateHook;
          return [false, stateHook];
        }
        function updateTransition() {
          var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        }
        function rerenderTransition() {
          var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        }
        function useHostTransitionStatus() {
          return readContext(HostTransitionContext);
        }
        function mountId() {
          var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
          if (isHydrating) {
            var treeId = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;
            identifierPrefix = "_" + identifierPrefix + "R_" + treeId;
            treeId = localIdCounter++;
            0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
            identifierPrefix += "_";
          } else
            treeId = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + treeId.toString(32) + "_";
          return hook.memoizedState = identifierPrefix;
        }
        function mountRefresh() {
          return mountWorkInProgressHook().memoizedState = refreshCache.bind(
            null,
            currentlyRenderingFiber
          );
        }
        function refreshCache(fiber, seedKey) {
          for (var provider = fiber.return; null !== provider; ) {
            switch (provider.tag) {
              case 24:
              case 3:
                var lane = requestUpdateLane(provider), refreshUpdate = createUpdate(lane), root2 = enqueueUpdate(provider, refreshUpdate, lane);
                null !== root2 && (startUpdateTimerByLane(lane, "refresh()", fiber), scheduleUpdateOnFiber(root2, provider, lane), entangleTransitions(root2, provider, lane));
                fiber = createCache();
                null !== seedKey && void 0 !== seedKey && null !== root2 && console.error(
                  "The seed argument is not enabled outside experimental channels."
                );
                refreshUpdate.payload = { cache: fiber };
                return;
            }
            provider = provider.return;
          }
        }
        function dispatchReducerAction(fiber, queue, action) {
          var args = arguments;
          "function" === typeof args[3] && console.error(
            "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
          );
          args = requestUpdateLane(fiber);
          var update = {
            lane: args,
            revertLane: 0,
            gesture: null,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, update) : (update = enqueueConcurrentHookUpdate(fiber, queue, update, args), null !== update && (startUpdateTimerByLane(args, "dispatch()", fiber), scheduleUpdateOnFiber(update, fiber, args), entangleTransitionUpdate(update, queue, args)));
        }
        function dispatchSetState(fiber, queue, action) {
          var args = arguments;
          "function" === typeof args[3] && console.error(
            "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
          );
          args = requestUpdateLane(fiber);
          dispatchSetStateInternal(fiber, queue, action, args) && startUpdateTimerByLane(args, "setState()", fiber);
        }
        function dispatchSetStateInternal(fiber, queue, action, lane) {
          var update = {
            lane,
            revertLane: 0,
            gesture: null,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
          else {
            var alternate = fiber.alternate;
            if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
                update.hasEagerState = true;
                update.eagerState = eagerState;
                if (objectIs(eagerState, currentState))
                  return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
              } catch (error) {
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            }
            action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
            if (null !== action)
              return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
          }
          return false;
        }
        function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
          null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error(
            "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
          );
          action = {
            lane: 2,
            revertLane: requestTransitionLane(),
            gesture: null,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            if (throwIfDuringRender)
              throw Error("Cannot update optimistic state while rendering.");
            console.error("Cannot call startTransition while rendering.");
          } else
            throwIfDuringRender = enqueueConcurrentHookUpdate(
              fiber,
              queue,
              action,
              2
            ), null !== throwIfDuringRender && (startUpdateTimerByLane(2, "setOptimistic()", fiber), scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2));
        }
        function isRenderPhaseUpdate(fiber) {
          var alternate = fiber.alternate;
          return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
        }
        function enqueueRenderPhaseUpdate(queue, update) {
          didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
          var pending = queue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        function entangleTransitionUpdate(root2, queue, lane) {
          if (0 !== (lane & 4194048)) {
            var queueLanes = queue.lanes;
            queueLanes &= root2.pendingLanes;
            lane |= queueLanes;
            queue.lanes = lane;
            markRootEntangled(root2, lane);
          }
        }
        function warnOnInvalidCallback(callback) {
          if (null !== callback && "function" !== typeof callback) {
            var key = String(callback);
            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(
              "Expected the last optional `callback` argument to be a function. Instead received: %s.",
              callback
            ));
          }
        }
        function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
          var prevState = workInProgress2.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              partialState = getDerivedStateFromProps(nextProps, prevState);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          void 0 === partialState && (ctor = getComponentNameFromType(ctor) || "Component", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error(
            "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
            ctor
          )));
          prevState = null === partialState || void 0 === partialState ? prevState : assign2({}, prevState, partialState);
          workInProgress2.memoizedState = prevState;
          0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = prevState);
        }
        function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
          var instance = workInProgress2.stateNode;
          if ("function" === typeof instance.shouldComponentUpdate) {
            oldProps = instance.shouldComponentUpdate(
              newProps,
              newState,
              nextContext
            );
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                oldProps = instance.shouldComponentUpdate(
                  newProps,
                  newState,
                  nextContext
                );
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            void 0 === oldProps && console.error(
              "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
              getComponentNameFromType(ctor) || "Component"
            );
            return oldProps;
          }
          return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
        }
        function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
          var oldState = instance.state;
          "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
          "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
          instance.state !== oldState && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Component", didWarnAboutStateAssignmentForComponent.has(workInProgress2) || (didWarnAboutStateAssignmentForComponent.add(workInProgress2), console.error(
            "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
            workInProgress2
          )), classComponentUpdater.enqueueReplaceState(
            instance,
            instance.state,
            null
          ));
        }
        function resolveClassComponentProps(Component, baseProps) {
          var newProps = baseProps;
          if ("ref" in baseProps) {
            newProps = {};
            for (var propName in baseProps)
              "ref" !== propName && (newProps[propName] = baseProps[propName]);
          }
          if (Component = Component.defaultProps) {
            newProps === baseProps && (newProps = assign2({}, newProps));
            for (var _propName in Component)
              void 0 === newProps[_propName] && (newProps[_propName] = Component[_propName]);
          }
          return newProps;
        }
        function defaultOnUncaughtError(error) {
          reportGlobalError(error);
          console.warn(
            "%s\n\n%s\n",
            componentName ? "An error occurred in the <" + componentName + "> component." : "An error occurred in one of your React components.",
            "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
          );
        }
        function defaultOnCaughtError(error) {
          var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component." : "The above error occurred in one of your React components.", recreateMessage = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((errorBoundaryName || "Anonymous") + ".");
          if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
            var JSCompiler_inline_result = error.environmentName;
            error = [
              "%o\n\n%s\n\n%s\n",
              error,
              componentNameMessage,
              recreateMessage
            ].slice(0);
            "string" === typeof error[0] ? error.splice(
              0,
              1,
              badgeFormat + " " + error[0],
              badgeStyle,
              pad2 + JSCompiler_inline_result + pad2,
              resetStyle
            ) : error.splice(
              0,
              0,
              badgeFormat,
              badgeStyle,
              pad2 + JSCompiler_inline_result + pad2,
              resetStyle
            );
            error.unshift(console);
            JSCompiler_inline_result = bind.apply(console.error, error);
            JSCompiler_inline_result();
          } else
            console.error(
              "%o\n\n%s\n\n%s\n",
              error,
              componentNameMessage,
              recreateMessage
            );
        }
        function defaultOnRecoverableError(error) {
          reportGlobalError(error);
        }
        function logUncaughtError(root2, errorInfo) {
          try {
            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
            errorBoundaryName = null;
            var error = errorInfo.value;
            if (null !== ReactSharedInternals.actQueue)
              ReactSharedInternals.thrownErrors.push(error);
            else {
              var onUncaughtError = root2.onUncaughtError;
              onUncaughtError(error, { componentStack: errorInfo.stack });
            }
          } catch (e$5) {
            setTimeout(function() {
              throw e$5;
            });
          }
        }
        function logCaughtError(root2, boundary, errorInfo) {
          try {
            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
            errorBoundaryName = getComponentNameFromFiber(boundary);
            var onCaughtError = root2.onCaughtError;
            onCaughtError(errorInfo.value, {
              componentStack: errorInfo.stack,
              errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
            });
          } catch (e$6) {
            setTimeout(function() {
              throw e$6;
            });
          }
        }
        function createRootErrorUpdate(root2, errorInfo, lane) {
          lane = createUpdate(lane);
          lane.tag = CaptureUpdate;
          lane.payload = { element: null };
          lane.callback = function() {
            runWithFiberInDEV(errorInfo.source, logUncaughtError, root2, errorInfo);
          };
          return lane;
        }
        function createClassErrorUpdate(lane) {
          lane = createUpdate(lane);
          lane.tag = CaptureUpdate;
          return lane;
        }
        function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
          var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
          if ("function" === typeof getDerivedStateFromError) {
            var error = errorInfo.value;
            update.payload = function() {
              return getDerivedStateFromError(error);
            };
            update.callback = function() {
              markFailedErrorBoundaryForHotReloading(fiber);
              runWithFiberInDEV(
                errorInfo.source,
                logCaughtError,
                root2,
                fiber,
                errorInfo
              );
            };
          }
          var inst = fiber.stateNode;
          null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
            markFailedErrorBoundaryForHotReloading(fiber);
            runWithFiberInDEV(
              errorInfo.source,
              logCaughtError,
              root2,
              fiber,
              errorInfo
            );
            "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
            callComponentDidCatchInDEV(this, errorInfo);
            "function" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error(
              "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
              getComponentNameFromFiber(fiber) || "Unknown"
            );
          });
        }
        function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
          sourceFiber.flags |= 32768;
          isDevToolsPresent && restorePendingUpdaters(root2, rootRenderLanes);
          if (null !== value && "object" === typeof value && "function" === typeof value.then) {
            returnFiber = sourceFiber.alternate;
            null !== returnFiber && propagateParentContextChanges(
              returnFiber,
              sourceFiber,
              rootRenderLanes,
              true
            );
            isHydrating && (didSuspendOrErrorDEV = true);
            sourceFiber = suspenseHandlerStackCursor.current;
            if (null !== sourceFiber) {
              switch (sourceFiber.tag) {
                case 31:
                case 13:
                  return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
                case 22:
                  return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                    transitions: null,
                    markerInstances: null,
                    retryQueue: /* @__PURE__ */ new Set([value])
                  }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
              }
              throw Error(
                "Unexpected Suspense handler tag (" + sourceFiber.tag + "). This is a bug in React."
              );
            }
            attachPingListener(root2, value, rootRenderLanes);
            renderDidSuspendDelayIfPossible();
            return false;
          }
          if (isHydrating)
            return didSuspendOrErrorDEV = true, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(
              createCapturedValueAtFiber(
                Error(
                  "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
                  { cause: value }
                ),
                sourceFiber
              )
            )) : (value !== HydrationMismatchException && queueHydrationError(
              createCapturedValueAtFiber(
                Error(
                  "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
                  { cause: value }
                ),
                sourceFiber
              )
            ), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
              root2.stateNode,
              value,
              rootRenderLanes
            ), enqueueCapturedUpdate(root2, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), false;
          var error = createCapturedValueAtFiber(
            Error(
              "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
              { cause: value }
            ),
            sourceFiber
          );
          null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [error] : workInProgressRootConcurrentErrors.push(error);
          workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);
          if (null === returnFiber) return true;
          value = createCapturedValueAtFiber(value, sourceFiber);
          sourceFiber = returnFiber;
          do {
            switch (sourceFiber.tag) {
              case 3:
                return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(
                  sourceFiber.stateNode,
                  value,
                  root2
                ), enqueueCapturedUpdate(sourceFiber, root2), false;
              case 1:
                if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== error && "function" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error))))
                  return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                    rootRenderLanes,
                    root2,
                    sourceFiber,
                    value
                  ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
            }
            sourceFiber = sourceFiber.return;
          } while (null !== sourceFiber);
          return false;
        }
        function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
          workInProgress2.child = null === current2 ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
            workInProgress2,
            current2.child,
            nextChildren,
            renderLanes2
          );
        }
        function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
          Component = Component.render;
          var ref = workInProgress2.ref;
          if ("ref" in nextProps) {
            var propsWithoutRef = {};
            for (var key in nextProps)
              "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
          } else propsWithoutRef = nextProps;
          prepareToReadContext(workInProgress2);
          nextProps = renderWithHooks(
            current2,
            workInProgress2,
            Component,
            propsWithoutRef,
            ref,
            renderLanes2
          );
          key = checkDidRenderIdHook();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && key && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
          return workInProgress2.child;
        }
        function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (null === current2) {
            var type = Component.type;
            if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
              return Component = resolveFunctionForHotReloading(type), workInProgress2.tag = 15, workInProgress2.type = Component, validateFunctionComponentInDev(workInProgress2, type), updateSimpleMemoComponent(
                current2,
                workInProgress2,
                Component,
                nextProps,
                renderLanes2
              );
            current2 = createFiberFromTypeAndProps(
              Component.type,
              null,
              nextProps,
              workInProgress2,
              workInProgress2.mode,
              renderLanes2
            );
            current2.ref = workInProgress2.ref;
            current2.return = workInProgress2;
            return workInProgress2.child = current2;
          }
          type = current2.child;
          if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
            var prevProps = type.memoizedProps;
            Component = Component.compare;
            Component = null !== Component ? Component : shallowEqual;
            if (Component(prevProps, nextProps) && current2.ref === workInProgress2.ref)
              return bailoutOnAlreadyFinishedWork(
                current2,
                workInProgress2,
                renderLanes2
              );
          }
          workInProgress2.flags |= 1;
          current2 = createWorkInProgress(type, nextProps);
          current2.ref = workInProgress2.ref;
          current2.return = workInProgress2;
          return workInProgress2.child = current2;
        }
        function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (null !== current2) {
            var prevProps = current2.memoizedProps;
            if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type)
              if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current2, renderLanes2))
                0 !== (current2.flags & 131072) && (didReceiveUpdate = true);
              else
                return workInProgress2.lanes = current2.lanes, bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          return updateFunctionComponent(
            current2,
            workInProgress2,
            Component,
            nextProps,
            renderLanes2
          );
        }
        function updateOffscreenComponent(current2, workInProgress2, renderLanes2, nextProps) {
          var nextChildren = nextProps.children, prevState = null !== current2 ? current2.memoizedState : null;
          null === current2 && null === workInProgress2.stateNode && (workInProgress2.stateNode = {
            _visibility: OffscreenVisible,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
          });
          if ("hidden" === nextProps.mode) {
            if (0 !== (workInProgress2.flags & 128)) {
              prevState = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
              if (null !== current2) {
                nextProps = workInProgress2.child = current2.child;
                for (nextChildren = 0; null !== nextProps; )
                  nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
                nextProps = nextChildren & ~prevState;
              } else nextProps = 0, workInProgress2.child = null;
              return deferHiddenOffscreenComponent(
                current2,
                workInProgress2,
                prevState,
                renderLanes2,
                nextProps
              );
            }
            if (0 !== (renderLanes2 & 536870912))
              workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current2 && pushTransition(
                workInProgress2,
                null !== prevState ? prevState.cachePool : null
              ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(workInProgress2), pushOffscreenSuspenseHandler(workInProgress2);
            else
              return nextProps = workInProgress2.lanes = 536870912, deferHiddenOffscreenComponent(
                current2,
                workInProgress2,
                null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
                renderLanes2,
                nextProps
              );
          } else
            null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current2 && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(workInProgress2), reuseSuspenseHandlerOnStack(workInProgress2));
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function bailoutOffscreenComponent(current2, workInProgress2) {
          null !== current2 && 22 === current2.tag || null !== workInProgress2.stateNode || (workInProgress2.stateNode = {
            _visibility: OffscreenVisible,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
          });
          return workInProgress2.sibling;
        }
        function deferHiddenOffscreenComponent(current2, workInProgress2, nextBaseLanes, renderLanes2, remainingChildLanes) {
          var JSCompiler_inline_result = peekCacheFromPool();
          JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
            parent: CacheContext._currentValue,
            pool: JSCompiler_inline_result
          };
          workInProgress2.memoizedState = {
            baseLanes: nextBaseLanes,
            cachePool: JSCompiler_inline_result
          };
          null !== current2 && pushTransition(workInProgress2, null);
          reuseHiddenContextOnStack(workInProgress2);
          pushOffscreenSuspenseHandler(workInProgress2);
          null !== current2 && propagateParentContextChanges(current2, workInProgress2, renderLanes2, true);
          workInProgress2.childLanes = remainingChildLanes;
          return null;
        }
        function mountActivityChildren(workInProgress2, nextProps) {
          var hiddenProp = nextProps.hidden;
          void 0 !== hiddenProp && console.error(
            `<Activity> doesn't accept a hidden prop. Use mode="hidden" instead.
- <Activity %s>
+ <Activity %s>`,
            true === hiddenProp ? "hidden" : false === hiddenProp ? "hidden={false}" : "hidden={...}",
            hiddenProp ? 'mode="hidden"' : 'mode="visible"'
          );
          nextProps = mountWorkInProgressOffscreenFiber(
            { mode: nextProps.mode, children: nextProps.children },
            workInProgress2.mode
          );
          nextProps.ref = workInProgress2.ref;
          workInProgress2.child = nextProps;
          nextProps.return = workInProgress2;
          return nextProps;
        }
        function retryActivityComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          current2 = mountActivityChildren(
            workInProgress2,
            workInProgress2.pendingProps
          );
          current2.flags |= 2;
          popSuspenseHandler(workInProgress2);
          workInProgress2.memoizedState = null;
          return current2;
        }
        function updateActivityComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps, didSuspend = 0 !== (workInProgress2.flags & 128);
          workInProgress2.flags &= -129;
          if (null === current2) {
            if (isHydrating) {
              if ("hidden" === nextProps.mode)
                return current2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.lanes = 536870912, bailoutOffscreenComponent(null, current2);
              pushDehydratedActivitySuspenseHandler(workInProgress2);
              (current2 = nextHydratableInstance) ? (renderLanes2 = canHydrateHydrationBoundary(
                current2,
                rootOrSingletonContext
              ), renderLanes2 = null !== renderLanes2 && renderLanes2.data === ACTIVITY_START_DATA ? renderLanes2 : null, null !== renderLanes2 && (nextProps = {
                dehydrated: renderLanes2,
                treeContext: getSuspendedTreeContext(),
                retryLane: 536870912,
                hydrationErrors: null
              }, workInProgress2.memoizedState = nextProps, nextProps = createFiberFromDehydratedFragment(renderLanes2), nextProps.return = workInProgress2, workInProgress2.child = nextProps, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : renderLanes2 = null;
              if (null === renderLanes2)
                throw warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2);
              workInProgress2.lanes = 536870912;
              return null;
            }
            return mountActivityChildren(workInProgress2, nextProps);
          }
          var prevState = current2.memoizedState;
          if (null !== prevState) {
            var activityInstance = prevState.dehydrated;
            pushDehydratedActivitySuspenseHandler(workInProgress2);
            if (didSuspend)
              if (workInProgress2.flags & 256)
                workInProgress2.flags &= -257, workInProgress2 = retryActivityComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              else if (null !== workInProgress2.memoizedState)
                workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null;
              else
                throw Error(
                  "Client rendering an Activity suspended it again. This is a bug in React."
                );
            else if (warnIfHydrating(), 0 !== (renderLanes2 & 536870912) && markRenderDerivedCause(workInProgress2), didReceiveUpdate || propagateParentContextChanges(
              current2,
              workInProgress2,
              renderLanes2,
              false
            ), didSuspend = 0 !== (renderLanes2 & current2.childLanes), didReceiveUpdate || didSuspend) {
              nextProps = workInProgressRoot;
              if (null !== nextProps && (activityInstance = getBumpedLaneForHydration(
                nextProps,
                renderLanes2
              ), 0 !== activityInstance && activityInstance !== prevState.retryLane))
                throw prevState.retryLane = activityInstance, enqueueConcurrentRenderForLane(current2, activityInstance), scheduleUpdateOnFiber(nextProps, current2, activityInstance), SelectiveHydrationException;
              renderDidSuspendDelayIfPossible();
              workInProgress2 = retryActivityComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2
              );
            } else
              current2 = prevState.treeContext, nextHydratableInstance = getNextHydratable(
                activityInstance.nextSibling
              ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, null !== current2 && restoreSuspendedTreeContext(workInProgress2, current2), workInProgress2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.flags |= 4096;
            return workInProgress2;
          }
          prevState = current2.child;
          nextProps = { mode: nextProps.mode, children: nextProps.children };
          0 !== (renderLanes2 & 536870912) && 0 !== (renderLanes2 & current2.lanes) && markRenderDerivedCause(workInProgress2);
          current2 = createWorkInProgress(prevState, nextProps);
          current2.ref = workInProgress2.ref;
          workInProgress2.child = current2;
          current2.return = workInProgress2;
          return current2;
        }
        function markRef(current2, workInProgress2) {
          var ref = workInProgress2.ref;
          if (null === ref)
            null !== current2 && null !== current2.ref && (workInProgress2.flags |= 4194816);
          else {
            if ("function" !== typeof ref && "object" !== typeof ref)
              throw Error(
                "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
              );
            if (null === current2 || current2.ref !== ref)
              workInProgress2.flags |= 4194816;
          }
        }
        function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (Component.prototype && "function" === typeof Component.prototype.render) {
            var componentName2 = getComponentNameFromType(Component) || "Unknown";
            didWarnAboutBadClass[componentName2] || (console.error(
              "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
              componentName2,
              componentName2
            ), didWarnAboutBadClass[componentName2] = true);
          }
          workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
            workInProgress2,
            null
          );
          null === current2 && (validateFunctionComponentInDev(workInProgress2, workInProgress2.type), Component.contextTypes && (componentName2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypes[componentName2] || (didWarnAboutContextTypes[componentName2] = true, console.error(
            "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
            componentName2
          ))));
          prepareToReadContext(workInProgress2);
          Component = renderWithHooks(
            current2,
            workInProgress2,
            Component,
            nextProps,
            void 0,
            renderLanes2
          );
          nextProps = checkDidRenderIdHook();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, Component, renderLanes2);
          return workInProgress2.child;
        }
        function replayFunctionComponent(current2, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
          prepareToReadContext(workInProgress2);
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
          workInProgress2.updateQueue = null;
          nextProps = renderWithHooksAgain(
            workInProgress2,
            Component,
            nextProps,
            secondArg
          );
          finishRenderingHooks(current2, workInProgress2);
          Component = checkDidRenderIdHook();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && Component && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
          return workInProgress2.child;
        }
        function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          switch (shouldErrorImpl(workInProgress2)) {
            case false:
              var _instance = workInProgress2.stateNode, state = new workInProgress2.type(
                workInProgress2.memoizedProps,
                _instance.context
              ).state;
              _instance.updater.enqueueSetState(_instance, state, null);
              break;
            case true:
              workInProgress2.flags |= 128;
              workInProgress2.flags |= 65536;
              _instance = Error("Simulated error coming from DevTools");
              var lane = renderLanes2 & -renderLanes2;
              workInProgress2.lanes |= lane;
              state = workInProgressRoot;
              if (null === state)
                throw Error(
                  "Expected a work-in-progress root. This is a bug in React. Please file an issue."
                );
              lane = createClassErrorUpdate(lane);
              initializeClassErrorUpdate(
                lane,
                state,
                workInProgress2,
                createCapturedValueAtFiber(_instance, workInProgress2)
              );
              enqueueCapturedUpdate(workInProgress2, lane);
          }
          prepareToReadContext(workInProgress2);
          if (null === workInProgress2.stateNode) {
            state = emptyContextObject;
            _instance = Component.contextType;
            "contextType" in Component && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = void 0 === _instance ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof _instance ? " However, it is set to a " + typeof _instance + "." : _instance.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(_instance).join(", ") + "}.", console.error(
              "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
              getComponentNameFromType(Component) || "Component",
              lane
            ));
            "object" === typeof _instance && null !== _instance && (state = readContext(_instance));
            _instance = new Component(nextProps, state);
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                _instance = new Component(nextProps, state);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            state = workInProgress2.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;
            _instance.updater = classComponentUpdater;
            workInProgress2.stateNode = _instance;
            _instance._reactInternals = workInProgress2;
            _instance._reactInternalInstance = fakeInternalInstance;
            "function" === typeof Component.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component) || "Component", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error(
              "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
              state,
              null === _instance.state ? "null" : "undefined",
              state
            )));
            if ("function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate) {
              var foundWillUpdateName = lane = state = null;
              "function" === typeof _instance.componentWillMount && true !== _instance.componentWillMount.__suppressDeprecationWarning ? state = "componentWillMount" : "function" === typeof _instance.UNSAFE_componentWillMount && (state = "UNSAFE_componentWillMount");
              "function" === typeof _instance.componentWillReceiveProps && true !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = "componentWillReceiveProps" : "function" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = "UNSAFE_componentWillReceiveProps");
              "function" === typeof _instance.componentWillUpdate && true !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
              if (null !== state || null !== lane || null !== foundWillUpdateName) {
                _instance = getComponentNameFromType(Component) || "Component";
                var newApiName = "function" === typeof Component.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(
                  "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                  _instance,
                  newApiName,
                  null !== state ? "\n  " + state : "",
                  null !== lane ? "\n  " + lane : "",
                  null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
                ));
              }
            }
            _instance = workInProgress2.stateNode;
            state = getComponentNameFromType(Component) || "Component";
            _instance.render || (Component.prototype && "function" === typeof Component.prototype.render ? console.error(
              "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
              state
            ) : console.error(
              "No `render` method found on the %s instance: you may have forgotten to define `render`.",
              state
            ));
            !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error(
              "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
              state
            );
            _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error(
              "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
              state
            );
            _instance.contextType && console.error(
              "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
              state
            );
            Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error(
              "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
              state
            ));
            Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error(
              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
              state
            ));
            "function" === typeof _instance.componentShouldUpdate && console.error(
              "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
              state
            );
            Component.prototype && Component.prototype.isPureReactComponent && "undefined" !== typeof _instance.shouldComponentUpdate && console.error(
              "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
              getComponentNameFromType(Component) || "A pure component"
            );
            "function" === typeof _instance.componentDidUnmount && console.error(
              "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
              state
            );
            "function" === typeof _instance.componentDidReceiveProps && console.error(
              "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
              state
            );
            "function" === typeof _instance.componentWillRecieveProps && console.error(
              "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
              state
            );
            "function" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error(
              "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
              state
            );
            lane = _instance.props !== nextProps;
            void 0 !== _instance.props && lane && console.error(
              "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
              state
            );
            _instance.defaultProps && console.error(
              "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
              state,
              state
            );
            "function" !== typeof _instance.getSnapshotBeforeUpdate || "function" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error(
              "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
              getComponentNameFromType(Component)
            ));
            "function" === typeof _instance.getDerivedStateFromProps && console.error(
              "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              state
            );
            "function" === typeof _instance.getDerivedStateFromError && console.error(
              "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              state
            );
            "function" === typeof Component.getSnapshotBeforeUpdate && console.error(
              "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
              state
            );
            (lane = _instance.state) && ("object" !== typeof lane || isArrayImpl(lane)) && console.error("%s.state: must be set to an object or null", state);
            "function" === typeof _instance.getChildContext && "object" !== typeof Component.childContextTypes && console.error(
              "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
              state
            );
            _instance = workInProgress2.stateNode;
            _instance.props = nextProps;
            _instance.state = workInProgress2.memoizedState;
            _instance.refs = {};
            initializeUpdateQueue(workInProgress2);
            state = Component.contextType;
            _instance.context = "object" === typeof state && null !== state ? readContext(state) : emptyContextObject;
            _instance.state === nextProps && (state = getComponentNameFromType(Component) || "Component", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error(
              "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
              state
            )));
            workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
              workInProgress2,
              _instance
            );
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
              workInProgress2,
              _instance
            );
            _instance.state = workInProgress2.memoizedState;
            state = Component.getDerivedStateFromProps;
            "function" === typeof state && (applyDerivedStateFromProps(
              workInProgress2,
              Component,
              state,
              nextProps
            ), _instance.state = workInProgress2.memoizedState);
            "function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || (state = _instance.state, "function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error(
              "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
              getComponentNameFromFiber(workInProgress2) || "Component"
            ), classComponentUpdater.enqueueReplaceState(
              _instance,
              _instance.state,
              null
            )), processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress2.memoizedState);
            "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308);
            (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728);
            _instance = true;
          } else if (null === current2) {
            _instance = workInProgress2.stateNode;
            var unresolvedOldProps = workInProgress2.memoizedProps;
            lane = resolveClassComponentProps(Component, unresolvedOldProps);
            _instance.props = lane;
            var oldContext = _instance.context;
            foundWillUpdateName = Component.contextType;
            state = emptyContextObject;
            "object" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));
            newApiName = Component.getDerivedStateFromProps;
            foundWillUpdateName = "function" === typeof newApiName || "function" === typeof _instance.getSnapshotBeforeUpdate;
            unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
            foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(
              workInProgress2,
              _instance,
              nextProps,
              state
            );
            hasForceUpdate = false;
            var oldState = workInProgress2.memoizedState;
            _instance.state = oldState;
            processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
            suspendIfUpdateReadFromEntangledAsyncAction();
            oldContext = workInProgress2.memoizedState;
            unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof newApiName && (applyDerivedStateFromProps(
              workInProgress2,
              Component,
              newApiName,
              nextProps
            ), oldContext = workInProgress2.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(
              workInProgress2,
              Component,
              lane,
              nextProps,
              oldState,
              oldContext,
              state
            )) ? (foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || ("function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728)) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), _instance = false);
          } else {
            _instance = workInProgress2.stateNode;
            cloneUpdateQueue(current2, workInProgress2);
            state = workInProgress2.memoizedProps;
            foundWillUpdateName = resolveClassComponentProps(Component, state);
            _instance.props = foundWillUpdateName;
            newApiName = workInProgress2.pendingProps;
            oldState = _instance.context;
            oldContext = Component.contextType;
            lane = emptyContextObject;
            "object" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));
            unresolvedOldProps = Component.getDerivedStateFromProps;
            (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof _instance.getSnapshotBeforeUpdate) || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(
              workInProgress2,
              _instance,
              nextProps,
              lane
            );
            hasForceUpdate = false;
            oldState = workInProgress2.memoizedState;
            _instance.state = oldState;
            processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
            suspendIfUpdateReadFromEntangledAsyncAction();
            var newState = workInProgress2.memoizedState;
            state !== newApiName || oldState !== newState || hasForceUpdate || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
              workInProgress2,
              Component,
              unresolvedOldProps,
              nextProps
            ), newState = workInProgress2.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(
              workInProgress2,
              Component,
              foundWillUpdateName,
              nextProps,
              oldState,
              newState,
              lane
            ) || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies)) ? (oldContext || "function" !== typeof _instance.UNSAFE_componentWillUpdate && "function" !== typeof _instance.componentWillUpdate || ("function" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), "function" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(
              nextProps,
              newState,
              lane
            )), "function" === typeof _instance.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), _instance = false);
          }
          lane = _instance;
          markRef(current2, workInProgress2);
          state = 0 !== (workInProgress2.flags & 128);
          if (lane || state) {
            lane = workInProgress2.stateNode;
            setCurrentFiber(workInProgress2);
            if (state && "function" !== typeof Component.getDerivedStateFromError)
              Component = null, profilerStartTime = -1;
            else if (Component = callRenderInDEV(lane), workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                callRenderInDEV(lane);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            workInProgress2.flags |= 1;
            null !== current2 && state ? (workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              current2.child,
              null,
              renderLanes2
            ), workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              Component,
              renderLanes2
            )) : reconcileChildren(current2, workInProgress2, Component, renderLanes2);
            workInProgress2.memoizedState = lane.state;
            current2 = workInProgress2.child;
          } else
            current2 = bailoutOnAlreadyFinishedWork(
              current2,
              workInProgress2,
              renderLanes2
            );
          renderLanes2 = workInProgress2.stateNode;
          _instance && renderLanes2.props !== nextProps && (didWarnAboutReassigningProps || console.error(
            "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
            getComponentNameFromFiber(workInProgress2) || "a component"
          ), didWarnAboutReassigningProps = true);
          return current2;
        }
        function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2) {
          resetHydrationState();
          workInProgress2.flags |= 256;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function validateFunctionComponentInDev(workInProgress2, Component) {
          Component && Component.childContextTypes && console.error(
            "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
            Component.displayName || Component.name || "Component"
          );
          "function" === typeof Component.getDerivedStateFromProps && (workInProgress2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] || (console.error(
            "%s: Function components do not support getDerivedStateFromProps.",
            workInProgress2
          ), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] = true));
          "object" === typeof Component.contextType && null !== Component.contextType && (Component = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error(
            "%s: Function components do not support contextType.",
            Component
          ), didWarnAboutContextTypeOnFunctionComponent[Component] = true));
        }
        function mountSuspenseOffscreenState(renderLanes2) {
          return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
        }
        function getRemainingWorkInPrimaryTree(current2, primaryTreeDidDefer, renderLanes2) {
          current2 = null !== current2 ? current2.childLanes & ~renderLanes2 : 0;
          primaryTreeDidDefer && (current2 |= workInProgressDeferredLane);
          return current2;
        }
        function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
          var JSCompiler_object_inline_digest_2724;
          var JSCompiler_object_inline_stack_2725 = workInProgress2.pendingProps;
          shouldSuspendImpl(workInProgress2) && (workInProgress2.flags |= 128);
          var JSCompiler_object_inline_message_2723 = false;
          var didSuspend = 0 !== (workInProgress2.flags & 128);
          (JSCompiler_object_inline_digest_2724 = didSuspend) || (JSCompiler_object_inline_digest_2724 = null !== current2 && null === current2.memoizedState ? false : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
          JSCompiler_object_inline_digest_2724 && (JSCompiler_object_inline_message_2723 = true, workInProgress2.flags &= -129);
          JSCompiler_object_inline_digest_2724 = 0 !== (workInProgress2.flags & 32);
          workInProgress2.flags &= -33;
          if (null === current2) {
            if (isHydrating) {
              JSCompiler_object_inline_message_2723 ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
              (current2 = nextHydratableInstance) ? (renderLanes2 = canHydrateHydrationBoundary(
                current2,
                rootOrSingletonContext
              ), renderLanes2 = null !== renderLanes2 && renderLanes2.data !== ACTIVITY_START_DATA ? renderLanes2 : null, null !== renderLanes2 && (JSCompiler_object_inline_digest_2724 = {
                dehydrated: renderLanes2,
                treeContext: getSuspendedTreeContext(),
                retryLane: 536870912,
                hydrationErrors: null
              }, workInProgress2.memoizedState = JSCompiler_object_inline_digest_2724, JSCompiler_object_inline_digest_2724 = createFiberFromDehydratedFragment(renderLanes2), JSCompiler_object_inline_digest_2724.return = workInProgress2, workInProgress2.child = JSCompiler_object_inline_digest_2724, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : renderLanes2 = null;
              if (null === renderLanes2)
                throw warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2);
              isSuspenseInstanceFallback(renderLanes2) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912;
              return null;
            }
            var nextPrimaryChildren = JSCompiler_object_inline_stack_2725.children;
            JSCompiler_object_inline_stack_2725 = JSCompiler_object_inline_stack_2725.fallback;
            if (JSCompiler_object_inline_message_2723) {
              reuseSuspenseHandlerOnStack(workInProgress2);
              var mode = workInProgress2.mode;
              nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
                { mode: "hidden", children: nextPrimaryChildren },
                mode
              );
              JSCompiler_object_inline_stack_2725 = createFiberFromFragment(
                JSCompiler_object_inline_stack_2725,
                mode,
                renderLanes2,
                null
              );
              nextPrimaryChildren.return = workInProgress2;
              JSCompiler_object_inline_stack_2725.return = workInProgress2;
              nextPrimaryChildren.sibling = JSCompiler_object_inline_stack_2725;
              workInProgress2.child = nextPrimaryChildren;
              JSCompiler_object_inline_stack_2725 = workInProgress2.child;
              JSCompiler_object_inline_stack_2725.memoizedState = mountSuspenseOffscreenState(renderLanes2);
              JSCompiler_object_inline_stack_2725.childLanes = getRemainingWorkInPrimaryTree(
                current2,
                JSCompiler_object_inline_digest_2724,
                renderLanes2
              );
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return bailoutOffscreenComponent(
                null,
                JSCompiler_object_inline_stack_2725
              );
            }
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            return mountSuspensePrimaryChildren(
              workInProgress2,
              nextPrimaryChildren
            );
          }
          var prevState = current2.memoizedState;
          if (null !== prevState) {
            var JSCompiler_object_inline_componentStack_2726 = prevState.dehydrated;
            if (null !== JSCompiler_object_inline_componentStack_2726) {
              if (didSuspend)
                workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = JSCompiler_object_inline_stack_2725.fallback, mode = workInProgress2.mode, JSCompiler_object_inline_stack_2725 = mountWorkInProgressOffscreenFiber(
                  {
                    mode: "visible",
                    children: JSCompiler_object_inline_stack_2725.children
                  },
                  mode
                ), nextPrimaryChildren = createFiberFromFragment(
                  nextPrimaryChildren,
                  mode,
                  renderLanes2,
                  null
                ), nextPrimaryChildren.flags |= 2, JSCompiler_object_inline_stack_2725.return = workInProgress2, nextPrimaryChildren.return = workInProgress2, JSCompiler_object_inline_stack_2725.sibling = nextPrimaryChildren, workInProgress2.child = JSCompiler_object_inline_stack_2725, reconcileChildFibers(
                  workInProgress2,
                  current2.child,
                  null,
                  renderLanes2
                ), JSCompiler_object_inline_stack_2725 = workInProgress2.child, JSCompiler_object_inline_stack_2725.memoizedState = mountSuspenseOffscreenState(renderLanes2), JSCompiler_object_inline_stack_2725.childLanes = getRemainingWorkInPrimaryTree(
                  current2,
                  JSCompiler_object_inline_digest_2724,
                  renderLanes2
                ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = bailoutOffscreenComponent(
                  null,
                  JSCompiler_object_inline_stack_2725
                ));
              else if (pushPrimaryTreeSuspenseHandler(workInProgress2), warnIfHydrating(), 0 !== (renderLanes2 & 536870912) && markRenderDerivedCause(workInProgress2), isSuspenseInstanceFallback(
                JSCompiler_object_inline_componentStack_2726
              )) {
                JSCompiler_object_inline_digest_2724 = JSCompiler_object_inline_componentStack_2726.nextSibling && JSCompiler_object_inline_componentStack_2726.nextSibling.dataset;
                if (JSCompiler_object_inline_digest_2724) {
                  nextPrimaryChildren = JSCompiler_object_inline_digest_2724.dgst;
                  var message = JSCompiler_object_inline_digest_2724.msg;
                  mode = JSCompiler_object_inline_digest_2724.stck;
                  var componentStack = JSCompiler_object_inline_digest_2724.cstck;
                }
                JSCompiler_object_inline_message_2723 = message;
                JSCompiler_object_inline_digest_2724 = nextPrimaryChildren;
                JSCompiler_object_inline_stack_2725 = mode;
                JSCompiler_object_inline_componentStack_2726 = componentStack;
                nextPrimaryChildren = JSCompiler_object_inline_message_2723;
                mode = JSCompiler_object_inline_componentStack_2726;
                nextPrimaryChildren = nextPrimaryChildren ? Error(nextPrimaryChildren) : Error(
                  "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
                );
                nextPrimaryChildren.stack = JSCompiler_object_inline_stack_2725 || "";
                nextPrimaryChildren.digest = JSCompiler_object_inline_digest_2724;
                JSCompiler_object_inline_digest_2724 = void 0 === mode ? null : mode;
                JSCompiler_object_inline_stack_2725 = {
                  value: nextPrimaryChildren,
                  source: null,
                  stack: JSCompiler_object_inline_digest_2724
                };
                "string" === typeof JSCompiler_object_inline_digest_2724 && CapturedStacks.set(
                  nextPrimaryChildren,
                  JSCompiler_object_inline_stack_2725
                );
                queueHydrationError(JSCompiler_object_inline_stack_2725);
                workInProgress2 = retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              } else if (didReceiveUpdate || propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), JSCompiler_object_inline_digest_2724 = 0 !== (renderLanes2 & current2.childLanes), didReceiveUpdate || JSCompiler_object_inline_digest_2724) {
                JSCompiler_object_inline_digest_2724 = workInProgressRoot;
                if (null !== JSCompiler_object_inline_digest_2724 && (JSCompiler_object_inline_stack_2725 = getBumpedLaneForHydration(
                  JSCompiler_object_inline_digest_2724,
                  renderLanes2
                ), 0 !== JSCompiler_object_inline_stack_2725 && JSCompiler_object_inline_stack_2725 !== prevState.retryLane))
                  throw prevState.retryLane = JSCompiler_object_inline_stack_2725, enqueueConcurrentRenderForLane(
                    current2,
                    JSCompiler_object_inline_stack_2725
                  ), scheduleUpdateOnFiber(
                    JSCompiler_object_inline_digest_2724,
                    current2,
                    JSCompiler_object_inline_stack_2725
                  ), SelectiveHydrationException;
                isSuspenseInstancePending(
                  JSCompiler_object_inline_componentStack_2726
                ) || renderDidSuspendDelayIfPossible();
                workInProgress2 = retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              } else
                isSuspenseInstancePending(
                  JSCompiler_object_inline_componentStack_2726
                ) ? (workInProgress2.flags |= 192, workInProgress2.child = current2.child, workInProgress2 = null) : (current2 = prevState.treeContext, nextHydratableInstance = getNextHydratable(
                  JSCompiler_object_inline_componentStack_2726.nextSibling
                ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, null !== current2 && restoreSuspendedTreeContext(workInProgress2, current2), workInProgress2 = mountSuspensePrimaryChildren(
                  workInProgress2,
                  JSCompiler_object_inline_stack_2725.children
                ), workInProgress2.flags |= 4096);
              return workInProgress2;
            }
          }
          if (JSCompiler_object_inline_message_2723)
            return reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = JSCompiler_object_inline_stack_2725.fallback, mode = workInProgress2.mode, componentStack = current2.child, JSCompiler_object_inline_componentStack_2726 = componentStack.sibling, JSCompiler_object_inline_stack_2725 = createWorkInProgress(
              componentStack,
              {
                mode: "hidden",
                children: JSCompiler_object_inline_stack_2725.children
              }
            ), JSCompiler_object_inline_stack_2725.subtreeFlags = componentStack.subtreeFlags & 65011712, null !== JSCompiler_object_inline_componentStack_2726 ? nextPrimaryChildren = createWorkInProgress(
              JSCompiler_object_inline_componentStack_2726,
              nextPrimaryChildren
            ) : (nextPrimaryChildren = createFiberFromFragment(
              nextPrimaryChildren,
              mode,
              renderLanes2,
              null
            ), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress2, JSCompiler_object_inline_stack_2725.return = workInProgress2, JSCompiler_object_inline_stack_2725.sibling = nextPrimaryChildren, workInProgress2.child = JSCompiler_object_inline_stack_2725, bailoutOffscreenComponent(null, JSCompiler_object_inline_stack_2725), JSCompiler_object_inline_stack_2725 = workInProgress2.child, nextPrimaryChildren = current2.child.memoizedState, null === nextPrimaryChildren ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes2) : (mode = nextPrimaryChildren.cachePool, null !== mode ? (componentStack = CacheContext._currentValue, mode = mode.parent !== componentStack ? { parent: componentStack, pool: componentStack } : mode) : mode = getSuspendedCache(), nextPrimaryChildren = {
              baseLanes: nextPrimaryChildren.baseLanes | renderLanes2,
              cachePool: mode
            }), JSCompiler_object_inline_stack_2725.memoizedState = nextPrimaryChildren, JSCompiler_object_inline_stack_2725.childLanes = getRemainingWorkInPrimaryTree(
              current2,
              JSCompiler_object_inline_digest_2724,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(
              current2.child,
              JSCompiler_object_inline_stack_2725
            );
          null !== prevState && (renderLanes2 & 62914560) === renderLanes2 && 0 !== (renderLanes2 & current2.lanes) && markRenderDerivedCause(workInProgress2);
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          renderLanes2 = current2.child;
          current2 = renderLanes2.sibling;
          renderLanes2 = createWorkInProgress(renderLanes2, {
            mode: "visible",
            children: JSCompiler_object_inline_stack_2725.children
          });
          renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
          null !== current2 && (JSCompiler_object_inline_digest_2724 = workInProgress2.deletions, null === JSCompiler_object_inline_digest_2724 ? (workInProgress2.deletions = [current2], workInProgress2.flags |= 16) : JSCompiler_object_inline_digest_2724.push(current2));
          workInProgress2.child = renderLanes2;
          workInProgress2.memoizedState = null;
          return renderLanes2;
        }
        function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
          primaryChildren = mountWorkInProgressOffscreenFiber(
            { mode: "visible", children: primaryChildren },
            workInProgress2.mode
          );
          primaryChildren.return = workInProgress2;
          return workInProgress2.child = primaryChildren;
        }
        function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
          offscreenProps = createFiber(22, offscreenProps, null, mode);
          offscreenProps.lanes = 0;
          return offscreenProps;
        }
        function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          current2 = mountSuspensePrimaryChildren(
            workInProgress2,
            workInProgress2.pendingProps.children
          );
          current2.flags |= 2;
          workInProgress2.memoizedState = null;
          return current2;
        }
        function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
          fiber.lanes |= renderLanes2;
          var alternate = fiber.alternate;
          null !== alternate && (alternate.lanes |= renderLanes2);
          scheduleContextWorkOnParentPath(
            fiber.return,
            renderLanes2,
            propagationRoot
          );
        }
        function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, treeForkCount2) {
          var renderState = workInProgress2.memoizedState;
          null === renderState ? workInProgress2.memoizedState = {
            isBackwards,
            rendering: null,
            renderingStartTime: 0,
            last: lastContentRow,
            tail,
            tailMode,
            treeForkCount: treeForkCount2
          } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount2);
        }
        function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail, newChildren = nextProps.children, suspenseContext = suspenseStackCursor.current;
          (nextProps = 0 !== (suspenseContext & ForceSuspenseFallback)) ? (suspenseContext = suspenseContext & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress2.flags |= 128) : suspenseContext &= SubtreeSuspenseContextMask;
          push(suspenseStackCursor, suspenseContext, workInProgress2);
          suspenseContext = null == revealOrder ? "null" : revealOrder;
          if ("forwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder && "together" !== revealOrder && "independent" !== revealOrder && !didWarnAboutRevealOrder[suspenseContext])
            if (didWarnAboutRevealOrder[suspenseContext] = true, null == revealOrder)
              console.error(
                'The default for the <SuspenseList revealOrder="..."> prop is changing. To be future compatible you must explictly specify either "independent" (the current default), "together", "forwards" or "legacy_unstable-backwards".'
              );
            else if ("backwards" === revealOrder)
              console.error(
                'The rendering order of <SuspenseList revealOrder="backwards"> is changing. To be future compatible you must specify revealOrder="legacy_unstable-backwards" instead.'
              );
            else if ("string" === typeof revealOrder)
              switch (revealOrder.toLowerCase()) {
                case "together":
                case "forwards":
                case "backwards":
                case "independent":
                  console.error(
                    '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                    revealOrder,
                    revealOrder.toLowerCase()
                  );
                  break;
                case "forward":
                case "backward":
                  console.error(
                    '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                    revealOrder,
                    revealOrder.toLowerCase()
                  );
                  break;
                default:
                  console.error(
                    '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?',
                    revealOrder
                  );
              }
            else
              console.error(
                '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?',
                revealOrder
              );
          suspenseContext = null == tailMode ? "null" : tailMode;
          if (!didWarnAboutTailOptions[suspenseContext])
            if (null == tailMode) {
              if ("forwards" === revealOrder || "backwards" === revealOrder || "unstable_legacy-backwards" === revealOrder)
                didWarnAboutTailOptions[suspenseContext] = true, console.error(
                  'The default for the <SuspenseList tail="..."> prop is changing. To be future compatible you must explictly specify either "visible" (the current default), "collapsed" or "hidden".'
                );
            } else
              "visible" !== tailMode && "collapsed" !== tailMode && "hidden" !== tailMode ? (didWarnAboutTailOptions[suspenseContext] = true, console.error(
                '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "visible", "collapsed" or "hidden"?',
                tailMode
              )) : "forwards" !== revealOrder && "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder && (didWarnAboutTailOptions[suspenseContext] = true, console.error(
                '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
                tailMode
              ));
          a: if (("forwards" === revealOrder || "backwards" === revealOrder || "unstable_legacy-backwards" === revealOrder) && void 0 !== newChildren && null !== newChildren && false !== newChildren)
            if (isArrayImpl(newChildren))
              for (suspenseContext = 0; suspenseContext < newChildren.length; suspenseContext++) {
                if (!validateSuspenseListNestedChild(
                  newChildren[suspenseContext],
                  suspenseContext
                ))
                  break a;
              }
            else if (suspenseContext = getIteratorFn(newChildren), "function" === typeof suspenseContext) {
              if (suspenseContext = suspenseContext.call(newChildren))
                for (var step = suspenseContext.next(), _i = 0; !step.done; step = suspenseContext.next()) {
                  if (!validateSuspenseListNestedChild(step.value, _i)) break a;
                  _i++;
                }
            } else
              console.error(
                'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
                revealOrder
              );
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          isHydrating ? (warnIfNotHydrating(), newChildren = treeForkCount) : newChildren = 0;
          if (!nextProps && null !== current2 && 0 !== (current2.flags & 128))
            a: for (current2 = workInProgress2.child; null !== current2; ) {
              if (13 === current2.tag)
                null !== current2.memoizedState && scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
              else if (19 === current2.tag)
                scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
              else if (null !== current2.child) {
                current2.child.return = current2;
                current2 = current2.child;
                continue;
              }
              if (current2 === workInProgress2) break a;
              for (; null === current2.sibling; ) {
                if (null === current2.return || current2.return === workInProgress2)
                  break a;
                current2 = current2.return;
              }
              current2.sibling.return = current2.return;
              current2 = current2.sibling;
            }
          switch (revealOrder) {
            case "forwards":
              renderLanes2 = workInProgress2.child;
              for (revealOrder = null; null !== renderLanes2; )
                current2 = renderLanes2.alternate, null !== current2 && null === findFirstSuspended(current2) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
              renderLanes2 = revealOrder;
              null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
              initSuspenseListRenderState(
                workInProgress2,
                false,
                revealOrder,
                renderLanes2,
                tailMode,
                newChildren
              );
              break;
            case "backwards":
            case "unstable_legacy-backwards":
              renderLanes2 = null;
              revealOrder = workInProgress2.child;
              for (workInProgress2.child = null; null !== revealOrder; ) {
                current2 = revealOrder.alternate;
                if (null !== current2 && null === findFirstSuspended(current2)) {
                  workInProgress2.child = revealOrder;
                  break;
                }
                current2 = revealOrder.sibling;
                revealOrder.sibling = renderLanes2;
                renderLanes2 = revealOrder;
                revealOrder = current2;
              }
              initSuspenseListRenderState(
                workInProgress2,
                true,
                renderLanes2,
                null,
                tailMode,
                newChildren
              );
              break;
            case "together":
              initSuspenseListRenderState(
                workInProgress2,
                false,
                null,
                null,
                void 0,
                newChildren
              );
              break;
            default:
              workInProgress2.memoizedState = null;
          }
          return workInProgress2.child;
        }
        function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
          null !== current2 && (workInProgress2.dependencies = current2.dependencies);
          profilerStartTime = -1;
          workInProgressRootSkippedLanes |= workInProgress2.lanes;
          if (0 === (renderLanes2 & workInProgress2.childLanes))
            if (null !== current2) {
              if (propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), 0 === (renderLanes2 & workInProgress2.childLanes))
                return null;
            } else return null;
          if (null !== current2 && workInProgress2.child !== current2.child)
            throw Error("Resuming work not yet implemented.");
          if (null !== workInProgress2.child) {
            current2 = workInProgress2.child;
            renderLanes2 = createWorkInProgress(current2, current2.pendingProps);
            workInProgress2.child = renderLanes2;
            for (renderLanes2.return = workInProgress2; null !== current2.sibling; )
              current2 = current2.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current2, current2.pendingProps), renderLanes2.return = workInProgress2;
            renderLanes2.sibling = null;
          }
          return workInProgress2.child;
        }
        function checkScheduledUpdateOrContext(current2, renderLanes2) {
          if (0 !== (current2.lanes & renderLanes2)) return true;
          current2 = current2.dependencies;
          return null !== current2 && checkIfContextChanged(current2) ? true : false;
        }
        function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
          switch (workInProgress2.tag) {
            case 3:
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              pushProvider(
                workInProgress2,
                CacheContext,
                current2.memoizedState.cache
              );
              resetHydrationState();
              break;
            case 27:
            case 5:
              pushHostContext(workInProgress2);
              break;
            case 4:
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              break;
            case 10:
              pushProvider(
                workInProgress2,
                workInProgress2.type,
                workInProgress2.memoizedProps.value
              );
              break;
            case 12:
              0 !== (renderLanes2 & workInProgress2.childLanes) && (workInProgress2.flags |= 4);
              workInProgress2.flags |= 2048;
              var stateNode = workInProgress2.stateNode;
              stateNode.effectDuration = -0;
              stateNode.passiveEffectDuration = -0;
              break;
            case 31:
              if (null !== workInProgress2.memoizedState)
                return workInProgress2.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress2), null;
              break;
            case 13:
              stateNode = workInProgress2.memoizedState;
              if (null !== stateNode) {
                if (null !== stateNode.dehydrated)
                  return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
                if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                  return updateSuspenseComponent(
                    current2,
                    workInProgress2,
                    renderLanes2
                  );
                pushPrimaryTreeSuspenseHandler(workInProgress2);
                current2 = bailoutOnAlreadyFinishedWork(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
                return null !== current2 ? current2.sibling : null;
              }
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              break;
            case 19:
              var didSuspendBefore = 0 !== (current2.flags & 128);
              stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes);
              stateNode || (propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes));
              if (didSuspendBefore) {
                if (stateNode)
                  return updateSuspenseListComponent(
                    current2,
                    workInProgress2,
                    renderLanes2
                  );
                workInProgress2.flags |= 128;
              }
              didSuspendBefore = workInProgress2.memoizedState;
              null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
              push(
                suspenseStackCursor,
                suspenseStackCursor.current,
                workInProgress2
              );
              if (stateNode) break;
              else return null;
            case 22:
              return workInProgress2.lanes = 0, updateOffscreenComponent(
                current2,
                workInProgress2,
                renderLanes2,
                workInProgress2.pendingProps
              );
            case 24:
              pushProvider(
                workInProgress2,
                CacheContext,
                current2.memoizedState.cache
              );
          }
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        function beginWork(current2, workInProgress2, renderLanes2) {
          if (workInProgress2._debugNeedsRemount && null !== current2) {
            renderLanes2 = createFiberFromTypeAndProps(
              workInProgress2.type,
              workInProgress2.key,
              workInProgress2.pendingProps,
              workInProgress2._debugOwner || null,
              workInProgress2.mode,
              workInProgress2.lanes
            );
            renderLanes2._debugStack = workInProgress2._debugStack;
            renderLanes2._debugTask = workInProgress2._debugTask;
            var returnFiber = workInProgress2.return;
            if (null === returnFiber) throw Error("Cannot swap the root fiber.");
            current2.alternate = null;
            workInProgress2.alternate = null;
            renderLanes2.index = workInProgress2.index;
            renderLanes2.sibling = workInProgress2.sibling;
            renderLanes2.return = workInProgress2.return;
            renderLanes2.ref = workInProgress2.ref;
            renderLanes2._debugInfo = workInProgress2._debugInfo;
            if (workInProgress2 === returnFiber.child)
              returnFiber.child = renderLanes2;
            else {
              var prevSibling = returnFiber.child;
              if (null === prevSibling)
                throw Error("Expected parent to have a child.");
              for (; prevSibling.sibling !== workInProgress2; )
                if (prevSibling = prevSibling.sibling, null === prevSibling)
                  throw Error("Expected to find the previous sibling.");
              prevSibling.sibling = renderLanes2;
            }
            workInProgress2 = returnFiber.deletions;
            null === workInProgress2 ? (returnFiber.deletions = [current2], returnFiber.flags |= 16) : workInProgress2.push(current2);
            renderLanes2.flags |= 2;
            return renderLanes2;
          }
          if (null !== current2)
            if (current2.memoizedProps !== workInProgress2.pendingProps || workInProgress2.type !== current2.type)
              didReceiveUpdate = true;
            else {
              if (!checkScheduledUpdateOrContext(current2, renderLanes2) && 0 === (workInProgress2.flags & 128))
                return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              didReceiveUpdate = 0 !== (current2.flags & 131072) ? true : false;
            }
          else {
            didReceiveUpdate = false;
            if (returnFiber = isHydrating)
              warnIfNotHydrating(), returnFiber = 0 !== (workInProgress2.flags & 1048576);
            returnFiber && (returnFiber = workInProgress2.index, warnIfNotHydrating(), pushTreeId(workInProgress2, treeForkCount, returnFiber));
          }
          workInProgress2.lanes = 0;
          switch (workInProgress2.tag) {
            case 16:
              a: if (returnFiber = workInProgress2.pendingProps, current2 = resolveLazy(workInProgress2.elementType), workInProgress2.type = current2, "function" === typeof current2)
                shouldConstruct(current2) ? (returnFiber = resolveClassComponentProps(
                  current2,
                  returnFiber
                ), workInProgress2.tag = 1, workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateClassComponent(
                  null,
                  workInProgress2,
                  current2,
                  returnFiber,
                  renderLanes2
                )) : (workInProgress2.tag = 0, validateFunctionComponentInDev(workInProgress2, current2), workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateFunctionComponent(
                  null,
                  workInProgress2,
                  current2,
                  returnFiber,
                  renderLanes2
                ));
              else {
                if (void 0 !== current2 && null !== current2) {
                  if (prevSibling = current2.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {
                    workInProgress2.tag = 11;
                    workInProgress2.type = current2 = resolveForwardRefForHotReloading(current2);
                    workInProgress2 = updateForwardRef(
                      null,
                      workInProgress2,
                      current2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else if (prevSibling === REACT_MEMO_TYPE) {
                    workInProgress2.tag = 14;
                    workInProgress2 = updateMemoComponent(
                      null,
                      workInProgress2,
                      current2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  }
                }
                workInProgress2 = "";
                null !== current2 && "object" === typeof current2 && current2.$$typeof === REACT_LAZY_TYPE && (workInProgress2 = " Did you wrap a component in React.lazy() more than once?");
                renderLanes2 = getComponentNameFromType(current2) || current2;
                throw Error(
                  "Element type is invalid. Received a promise that resolves to: " + renderLanes2 + ". Lazy element type must resolve to a class or function." + workInProgress2
                );
              }
              return workInProgress2;
            case 0:
              return updateFunctionComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 1:
              return returnFiber = workInProgress2.type, prevSibling = resolveClassComponentProps(
                returnFiber,
                workInProgress2.pendingProps
              ), updateClassComponent(
                current2,
                workInProgress2,
                returnFiber,
                prevSibling,
                renderLanes2
              );
            case 3:
              a: {
                pushHostContainer(
                  workInProgress2,
                  workInProgress2.stateNode.containerInfo
                );
                if (null === current2)
                  throw Error(
                    "Should have a current fiber. This is a bug in React."
                  );
                returnFiber = workInProgress2.pendingProps;
                var prevState = workInProgress2.memoizedState;
                prevSibling = prevState.element;
                cloneUpdateQueue(current2, workInProgress2);
                processUpdateQueue(workInProgress2, returnFiber, null, renderLanes2);
                var nextState = workInProgress2.memoizedState;
                returnFiber = nextState.cache;
                pushProvider(workInProgress2, CacheContext, returnFiber);
                returnFiber !== prevState.cache && propagateContextChanges(
                  workInProgress2,
                  [CacheContext],
                  renderLanes2,
                  true
                );
                suspendIfUpdateReadFromEntangledAsyncAction();
                returnFiber = nextState.element;
                if (prevState.isDehydrated)
                  if (prevState = {
                    element: returnFiber,
                    isDehydrated: false,
                    cache: nextState.cache
                  }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                    workInProgress2 = mountHostRootWithoutHydrating(
                      current2,
                      workInProgress2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else if (returnFiber !== prevSibling) {
                    prevSibling = createCapturedValueAtFiber(
                      Error(
                        "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                      ),
                      workInProgress2
                    );
                    queueHydrationError(prevSibling);
                    workInProgress2 = mountHostRootWithoutHydrating(
                      current2,
                      workInProgress2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else {
                    current2 = workInProgress2.stateNode.containerInfo;
                    switch (current2.nodeType) {
                      case 9:
                        current2 = current2.body;
                        break;
                      default:
                        current2 = "HTML" === current2.nodeName ? current2.ownerDocument.body : current2;
                    }
                    nextHydratableInstance = getNextHydratable(current2.firstChild);
                    hydrationParentFiber = workInProgress2;
                    isHydrating = true;
                    hydrationErrors = null;
                    didSuspendOrErrorDEV = false;
                    hydrationDiffRootDEV = null;
                    rootOrSingletonContext = true;
                    renderLanes2 = mountChildFibers(
                      workInProgress2,
                      null,
                      returnFiber,
                      renderLanes2
                    );
                    for (workInProgress2.child = renderLanes2; renderLanes2; )
                      renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
                  }
                else {
                  resetHydrationState();
                  if (returnFiber === prevSibling) {
                    workInProgress2 = bailoutOnAlreadyFinishedWork(
                      current2,
                      workInProgress2,
                      renderLanes2
                    );
                    break a;
                  }
                  reconcileChildren(
                    current2,
                    workInProgress2,
                    returnFiber,
                    renderLanes2
                  );
                }
                workInProgress2 = workInProgress2.child;
              }
              return workInProgress2;
            case 26:
              return markRef(current2, workInProgress2), null === current2 ? (renderLanes2 = getResource(
                workInProgress2.type,
                null,
                workInProgress2.pendingProps,
                null
              )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current2 = workInProgress2.pendingProps, returnFiber = requiredContext(
                rootInstanceStackCursor.current
              ), returnFiber = getOwnerDocumentFromRootContainer(
                returnFiber
              ).createElement(renderLanes2), returnFiber[internalInstanceKey] = workInProgress2, returnFiber[internalPropsKey] = current2, setInitialProperties(returnFiber, renderLanes2, current2), markNodeAsHoistable(returnFiber), workInProgress2.stateNode = returnFiber) : workInProgress2.memoizedState = getResource(
                workInProgress2.type,
                current2.memoizedProps,
                workInProgress2.pendingProps,
                current2.memoizedState
              ), null;
            case 27:
              return pushHostContext(workInProgress2), null === current2 && isHydrating && (returnFiber = requiredContext(rootInstanceStackCursor.current), prevSibling = getHostContext(), returnFiber = workInProgress2.stateNode = resolveSingletonInstance(
                workInProgress2.type,
                workInProgress2.pendingProps,
                returnFiber,
                prevSibling,
                false
              ), didSuspendOrErrorDEV || (prevSibling = diffHydratedProperties(
                returnFiber,
                workInProgress2.type,
                workInProgress2.pendingProps,
                prevSibling
              ), null !== prevSibling && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevSibling)), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, prevSibling = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = prevSibling, nextHydratableInstance = getNextHydratable(
                returnFiber.firstChild
              )) : nextHydratableInstance = prevSibling), reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), markRef(current2, workInProgress2), null === current2 && (workInProgress2.flags |= 4194304), workInProgress2.child;
            case 5:
              return null === current2 && isHydrating && (prevState = getHostContext(), returnFiber = validateDOMNesting(
                workInProgress2.type,
                prevState.ancestorInfo
              ), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(
                prevSibling,
                workInProgress2.type,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== nextState ? (workInProgress2.stateNode = nextState, didSuspendOrErrorDEV || (prevState = diffHydratedProperties(
                nextState,
                workInProgress2.type,
                workInProgress2.pendingProps,
                prevState
              ), null !== prevState && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevState)), hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
                nextState.firstChild
              ), rootOrSingletonContext = false, prevState = true) : prevState = false, nextState = !prevState), nextState && (returnFiber && warnNonHydratedInstance(workInProgress2, prevSibling), throwOnHydrationMismatch(workInProgress2))), pushHostContext(workInProgress2), prevSibling = workInProgress2.type, prevState = workInProgress2.pendingProps, nextState = null !== current2 ? current2.memoizedProps : null, returnFiber = prevState.children, shouldSetTextContent(prevSibling, prevState) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress2.flags |= 32), null !== workInProgress2.memoizedState && (prevSibling = renderWithHooks(
                current2,
                workInProgress2,
                TransitionAwareHostComponent,
                null,
                null,
                renderLanes2
              ), HostTransitionContext._currentValue = prevSibling), markRef(current2, workInProgress2), reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 6:
              return null === current2 && isHydrating && (renderLanes2 = workInProgress2.pendingProps, current2 = getHostContext(), returnFiber = current2.ancestorInfo.current, renderLanes2 = null != returnFiber ? validateTextNesting(
                renderLanes2,
                returnFiber.tag,
                current2.ancestorInfo.implicitRootScope
              ) : true, current2 = nextHydratableInstance, (returnFiber = !current2) || (returnFiber = canHydrateTextInstance(
                current2,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== returnFiber ? (workInProgress2.stateNode = returnFiber, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, returnFiber = true) : returnFiber = false, returnFiber = !returnFiber), returnFiber && (renderLanes2 && warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2))), null;
            case 13:
              return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
            case 4:
              return pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              ), returnFiber = workInProgress2.pendingProps, null === current2 ? workInProgress2.child = reconcileChildFibers(
                workInProgress2,
                null,
                returnFiber,
                renderLanes2
              ) : reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 11:
              return updateForwardRef(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 7:
              return reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps,
                renderLanes2
              ), workInProgress2.child;
            case 8:
              return reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 12:
              return workInProgress2.flags |= 4, workInProgress2.flags |= 2048, returnFiber = workInProgress2.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 10:
              return returnFiber = workInProgress2.type, prevSibling = workInProgress2.pendingProps, prevState = prevSibling.value, "value" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = true, console.error(
                "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
              )), pushProvider(workInProgress2, returnFiber, prevState), reconcileChildren(
                current2,
                workInProgress2,
                prevSibling.children,
                renderLanes2
              ), workInProgress2.child;
            case 9:
              return prevSibling = workInProgress2.type._context, returnFiber = workInProgress2.pendingProps.children, "function" !== typeof returnFiber && console.error(
                "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
              ), prepareToReadContext(workInProgress2), prevSibling = readContext(prevSibling), returnFiber = callComponentInDEV(
                returnFiber,
                prevSibling,
                void 0
              ), workInProgress2.flags |= 1, reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 14:
              return updateMemoComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 15:
              return updateSimpleMemoComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 19:
              return updateSuspenseListComponent(
                current2,
                workInProgress2,
                renderLanes2
              );
            case 31:
              return updateActivityComponent(current2, workInProgress2, renderLanes2);
            case 22:
              return updateOffscreenComponent(
                current2,
                workInProgress2,
                renderLanes2,
                workInProgress2.pendingProps
              );
            case 24:
              return prepareToReadContext(workInProgress2), returnFiber = readContext(CacheContext), null === current2 ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, prevState = createCache(), prevSibling.pooledCache = prevState, retainCache(prevState), null !== prevState && (prevSibling.pooledCacheLanes |= renderLanes2), prevSibling = prevState), workInProgress2.memoizedState = {
                parent: returnFiber,
                cache: prevSibling
              }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, prevSibling)) : (0 !== (current2.lanes & renderLanes2) && (cloneUpdateQueue(current2, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current2.memoizedState, prevState = workInProgress2.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {
                parent: returnFiber,
                cache: returnFiber
              }, workInProgress2.memoizedState = prevSibling, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = prevSibling), pushProvider(workInProgress2, CacheContext, returnFiber)) : (returnFiber = prevState.cache, pushProvider(workInProgress2, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              ))), reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 29:
              throw workInProgress2.pendingProps;
          }
          throw Error(
            "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function markUpdate(workInProgress2) {
          workInProgress2.flags |= 4;
        }
        function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, oldProps, newProps, renderLanes2) {
          if (type = (workInProgress2.mode & SuspenseyImagesMode) !== NoMode)
            type = false;
          if (type) {
            if (workInProgress2.flags |= 16777216, (renderLanes2 & 335544128) === renderLanes2)
              if (workInProgress2.stateNode.complete) workInProgress2.flags |= 8192;
              else if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
              else
                throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
          } else workInProgress2.flags &= -16777217;
        }
        function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
          if ("stylesheet" !== resource.type || (resource.state.loading & Inserted) !== NotLoaded)
            workInProgress2.flags &= -16777217;
          else if (workInProgress2.flags |= 16777216, !preloadResource(resource))
            if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
            else
              throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
        }
        function scheduleRetryEffect(workInProgress2, retryQueue) {
          null !== retryQueue && (workInProgress2.flags |= 4);
          workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
        }
        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
          if (!isHydrating)
            switch (renderState.tailMode) {
              case "hidden":
                hasRenderedATailFallback = renderState.tail;
                for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                  null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
                null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
                break;
              case "collapsed":
                lastTailNode = renderState.tail;
                for (var _lastTailNode = null; null !== lastTailNode; )
                  null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;
                null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;
            }
        }
        function bubbleProperties(completedWork) {
          var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
          if (didBailout)
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              for (var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2; )
                newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 65011712, subtreeFlags |= _child2.flags & 65011712, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
              completedWork.treeBaseDuration = _treeBaseDuration;
            } else
              for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
                newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 65011712, subtreeFlags |= _treeBaseDuration.flags & 65011712, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
          else if ((completedWork.mode & ProfileMode) !== NoMode) {
            _treeBaseDuration = completedWork.actualDuration;
            _child2 = completedWork.selfBaseDuration;
            for (var child = completedWork.child; null !== child; )
              newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;
            completedWork.actualDuration = _treeBaseDuration;
            completedWork.treeBaseDuration = _child2;
          } else
            for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
              newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
          completedWork.subtreeFlags |= subtreeFlags;
          completedWork.childLanes = newChildLanes;
          return didBailout;
        }
        function completeWork(current2, workInProgress2, renderLanes2) {
          var newProps = workInProgress2.pendingProps;
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return bubbleProperties(workInProgress2), null;
            case 1:
              return bubbleProperties(workInProgress2), null;
            case 3:
              renderLanes2 = workInProgress2.stateNode;
              newProps = null;
              null !== current2 && (newProps = current2.memoizedState.cache);
              workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
              popProvider(CacheContext, workInProgress2);
              popHostContainer(workInProgress2);
              renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
              if (null === current2 || null === current2.child)
                popHydrationState(workInProgress2) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress2)) : null === current2 || current2.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
              bubbleProperties(workInProgress2);
              return null;
            case 26:
              var type = workInProgress2.type, nextResource = workInProgress2.memoizedState;
              null === current2 ? (markUpdate(workInProgress2), null !== nextResource ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                nextResource
              )) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
                workInProgress2,
                type,
                null,
                newProps,
                renderLanes2
              ))) : nextResource ? nextResource !== current2.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                nextResource
              )) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current2 = current2.memoizedProps, current2 !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
                workInProgress2,
                type,
                current2,
                newProps,
                renderLanes2
              ));
              return null;
            case 27:
              popHostContext(workInProgress2);
              renderLanes2 = requiredContext(rootInstanceStackCursor.current);
              type = workInProgress2.type;
              if (null !== current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if (!newProps) {
                  if (null === workInProgress2.stateNode)
                    throw Error(
                      "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                    );
                  bubbleProperties(workInProgress2);
                  return null;
                }
                current2 = getHostContext();
                popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current2) : (current2 = resolveSingletonInstance(
                  type,
                  newProps,
                  renderLanes2,
                  current2,
                  true
                ), workInProgress2.stateNode = current2, markUpdate(workInProgress2));
              }
              bubbleProperties(workInProgress2);
              return null;
            case 5:
              popHostContext(workInProgress2);
              type = workInProgress2.type;
              if (null !== current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if (!newProps) {
                  if (null === workInProgress2.stateNode)
                    throw Error(
                      "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                    );
                  bubbleProperties(workInProgress2);
                  return null;
                }
                var _currentHostContext = getHostContext();
                if (popHydrationState(workInProgress2))
                  prepareToHydrateHostInstance(workInProgress2, _currentHostContext);
                else {
                  nextResource = requiredContext(rootInstanceStackCursor.current);
                  validateDOMNesting(type, _currentHostContext.ancestorInfo);
                  _currentHostContext = _currentHostContext.context;
                  nextResource = getOwnerDocumentFromRootContainer(nextResource);
                  switch (_currentHostContext) {
                    case HostContextNamespaceSvg:
                      nextResource = nextResource.createElementNS(
                        SVG_NAMESPACE,
                        type
                      );
                      break;
                    case HostContextNamespaceMath:
                      nextResource = nextResource.createElementNS(
                        MATH_NAMESPACE,
                        type
                      );
                      break;
                    default:
                      switch (type) {
                        case "svg":
                          nextResource = nextResource.createElementNS(
                            SVG_NAMESPACE,
                            type
                          );
                          break;
                        case "math":
                          nextResource = nextResource.createElementNS(
                            MATH_NAMESPACE,
                            type
                          );
                          break;
                        case "script":
                          nextResource = nextResource.createElement("div");
                          nextResource.innerHTML = "<script><\/script>";
                          nextResource = nextResource.removeChild(
                            nextResource.firstChild
                          );
                          break;
                        case "select":
                          nextResource = "string" === typeof newProps.is ? nextResource.createElement("select", {
                            is: newProps.is
                          }) : nextResource.createElement("select");
                          newProps.multiple ? nextResource.multiple = true : newProps.size && (nextResource.size = newProps.size);
                          break;
                        default:
                          nextResource = "string" === typeof newProps.is ? nextResource.createElement(type, {
                            is: newProps.is
                          }) : nextResource.createElement(type), -1 === type.indexOf("-") && (type !== type.toLowerCase() && console.error(
                            "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
                            type
                          ), "[object HTMLUnknownElement]" !== Object.prototype.toString.call(nextResource) || hasOwnProperty.call(warnedUnknownTags, type) || (warnedUnknownTags[type] = true, console.error(
                            "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
                            type
                          )));
                      }
                  }
                  nextResource[internalInstanceKey] = workInProgress2;
                  nextResource[internalPropsKey] = newProps;
                  a: for (_currentHostContext = workInProgress2.child; null !== _currentHostContext; ) {
                    if (5 === _currentHostContext.tag || 6 === _currentHostContext.tag)
                      nextResource.appendChild(_currentHostContext.stateNode);
                    else if (4 !== _currentHostContext.tag && 27 !== _currentHostContext.tag && null !== _currentHostContext.child) {
                      _currentHostContext.child.return = _currentHostContext;
                      _currentHostContext = _currentHostContext.child;
                      continue;
                    }
                    if (_currentHostContext === workInProgress2) break a;
                    for (; null === _currentHostContext.sibling; ) {
                      if (null === _currentHostContext.return || _currentHostContext.return === workInProgress2)
                        break a;
                      _currentHostContext = _currentHostContext.return;
                    }
                    _currentHostContext.sibling.return = _currentHostContext.return;
                    _currentHostContext = _currentHostContext.sibling;
                  }
                  workInProgress2.stateNode = nextResource;
                  a: switch (setInitialProperties(nextResource, type, newProps), type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      newProps = !!newProps.autoFocus;
                      break a;
                    case "img":
                      newProps = true;
                      break a;
                    default:
                      newProps = false;
                  }
                  newProps && markUpdate(workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              preloadInstanceAndSuspendIfNeeded(
                workInProgress2,
                workInProgress2.type,
                null === current2 ? null : current2.memoizedProps,
                workInProgress2.pendingProps,
                renderLanes2
              );
              return null;
            case 6:
              if (current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                  throw Error(
                    "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                  );
                current2 = requiredContext(rootInstanceStackCursor.current);
                renderLanes2 = getHostContext();
                if (popHydrationState(workInProgress2)) {
                  current2 = workInProgress2.stateNode;
                  renderLanes2 = workInProgress2.memoizedProps;
                  type = !didSuspendOrErrorDEV;
                  newProps = null;
                  nextResource = hydrationParentFiber;
                  if (null !== nextResource)
                    switch (nextResource.tag) {
                      case 3:
                        type && (type = diffHydratedTextForDevWarnings(
                          current2,
                          renderLanes2,
                          newProps
                        ), null !== type && (buildHydrationDiffNode(workInProgress2, 0).serverProps = type));
                        break;
                      case 27:
                      case 5:
                        newProps = nextResource.memoizedProps, type && (type = diffHydratedTextForDevWarnings(
                          current2,
                          renderLanes2,
                          newProps
                        ), null !== type && (buildHydrationDiffNode(
                          workInProgress2,
                          0
                        ).serverProps = type));
                    }
                  current2[internalInstanceKey] = workInProgress2;
                  current2 = current2.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current2.nodeValue, renderLanes2) ? true : false;
                  current2 || throwOnHydrationMismatch(workInProgress2, true);
                } else
                  type = renderLanes2.ancestorInfo.current, null != type && validateTextNesting(
                    newProps,
                    type.tag,
                    renderLanes2.ancestorInfo.implicitRootScope
                  ), current2 = getOwnerDocumentFromRootContainer(current2).createTextNode(
                    newProps
                  ), current2[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current2;
              }
              bubbleProperties(workInProgress2);
              return null;
            case 31:
              renderLanes2 = workInProgress2.memoizedState;
              if (null === current2 || null !== current2.memoizedState) {
                newProps = popHydrationState(workInProgress2);
                if (null !== renderLanes2) {
                  if (null === current2) {
                    if (!newProps)
                      throw Error(
                        "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                      );
                    current2 = workInProgress2.memoizedState;
                    current2 = null !== current2 ? current2.dehydrated : null;
                    if (!current2)
                      throw Error(
                        "Expected to have a hydrated activity instance. This error is likely caused by a bug in React. Please file an issue."
                      );
                    current2[internalInstanceKey] = workInProgress2;
                    bubbleProperties(workInProgress2);
                    (workInProgress2.mode & ProfileMode) !== NoMode && null !== renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
                  } else
                    emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress2.flags & 128) && (renderLanes2 = workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && null !== renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
                  current2 = false;
                } else
                  renderLanes2 = upgradeHydrationErrorsToRecoverable(), null !== current2 && null !== current2.memoizedState && (current2.memoizedState.hydrationErrors = renderLanes2), current2 = true;
                if (!current2) {
                  if (workInProgress2.flags & 256)
                    return popSuspenseHandler(workInProgress2), workInProgress2;
                  popSuspenseHandler(workInProgress2);
                  return null;
                }
                if (0 !== (workInProgress2.flags & 128))
                  throw Error(
                    "Client rendering an Activity suspended it again. This is a bug in React."
                  );
              }
              bubbleProperties(workInProgress2);
              return null;
            case 13:
              newProps = workInProgress2.memoizedState;
              if (null === current2 || null !== current2.memoizedState && null !== current2.memoizedState.dehydrated) {
                type = newProps;
                nextResource = popHydrationState(workInProgress2);
                if (null !== type && null !== type.dehydrated) {
                  if (null === current2) {
                    if (!nextResource)
                      throw Error(
                        "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                      );
                    nextResource = workInProgress2.memoizedState;
                    nextResource = null !== nextResource ? nextResource.dehydrated : null;
                    if (!nextResource)
                      throw Error(
                        "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                      );
                    nextResource[internalInstanceKey] = workInProgress2;
                    bubbleProperties(workInProgress2);
                    (workInProgress2.mode & ProfileMode) !== NoMode && null !== type && (type = workInProgress2.child, null !== type && (workInProgress2.treeBaseDuration -= type.treeBaseDuration));
                  } else
                    emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress2.flags & 128) && (type = workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && null !== type && (type = workInProgress2.child, null !== type && (workInProgress2.treeBaseDuration -= type.treeBaseDuration));
                  type = false;
                } else
                  type = upgradeHydrationErrorsToRecoverable(), null !== current2 && null !== current2.memoizedState && (current2.memoizedState.hydrationErrors = type), type = true;
                if (!type) {
                  if (workInProgress2.flags & 256)
                    return popSuspenseHandler(workInProgress2), workInProgress2;
                  popSuspenseHandler(workInProgress2);
                  return null;
                }
              }
              popSuspenseHandler(workInProgress2);
              if (0 !== (workInProgress2.flags & 128))
                return workInProgress2.lanes = renderLanes2, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2;
              renderLanes2 = null !== newProps;
              current2 = null !== current2 && null !== current2.memoizedState;
              renderLanes2 && (newProps = workInProgress2.child, type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
              renderLanes2 !== current2 && renderLanes2 && (workInProgress2.child.flags |= 8192);
              scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
              bubbleProperties(workInProgress2);
              (workInProgress2.mode & ProfileMode) !== NoMode && renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
              return null;
            case 4:
              return popHostContainer(workInProgress2), null === current2 && listenToAllSupportedEvents(
                workInProgress2.stateNode.containerInfo
              ), bubbleProperties(workInProgress2), null;
            case 10:
              return popProvider(workInProgress2.type, workInProgress2), bubbleProperties(workInProgress2), null;
            case 19:
              pop(suspenseStackCursor, workInProgress2);
              newProps = workInProgress2.memoizedState;
              if (null === newProps) return bubbleProperties(workInProgress2), null;
              type = 0 !== (workInProgress2.flags & 128);
              nextResource = newProps.rendering;
              if (null === nextResource)
                if (type) cutOffTailIfNeeded(newProps, false);
                else {
                  if (workInProgressRootExitStatus !== RootInProgress || null !== current2 && 0 !== (current2.flags & 128))
                    for (current2 = workInProgress2.child; null !== current2; ) {
                      nextResource = findFirstSuspended(current2);
                      if (null !== nextResource) {
                        workInProgress2.flags |= 128;
                        cutOffTailIfNeeded(newProps, false);
                        current2 = nextResource.updateQueue;
                        workInProgress2.updateQueue = current2;
                        scheduleRetryEffect(workInProgress2, current2);
                        workInProgress2.subtreeFlags = 0;
                        current2 = renderLanes2;
                        for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                          resetWorkInProgress(renderLanes2, current2), renderLanes2 = renderLanes2.sibling;
                        push(
                          suspenseStackCursor,
                          suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback,
                          workInProgress2
                        );
                        isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount);
                        return workInProgress2.child;
                      }
                      current2 = current2.sibling;
                    }
                  null !== newProps.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
                }
              else {
                if (!type)
                  if (current2 = findFirstSuspended(nextResource), null !== current2) {
                    if (workInProgress2.flags |= 128, type = true, current2 = current2.updateQueue, workInProgress2.updateQueue = current2, scheduleRetryEffect(workInProgress2, current2), cutOffTailIfNeeded(newProps, true), null === newProps.tail && "hidden" === newProps.tailMode && !nextResource.alternate && !isHydrating)
                      return bubbleProperties(workInProgress2), null;
                  } else
                    2 * now$1() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
                newProps.isBackwards ? (nextResource.sibling = workInProgress2.child, workInProgress2.child = nextResource) : (current2 = newProps.last, null !== current2 ? current2.sibling = nextResource : workInProgress2.child = nextResource, newProps.last = nextResource);
              }
              if (null !== newProps.tail)
                return current2 = newProps.tail, newProps.rendering = current2, newProps.tail = current2.sibling, newProps.renderingStartTime = now$1(), current2.sibling = null, renderLanes2 = suspenseStackCursor.current, renderLanes2 = type ? renderLanes2 & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes2 & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes2, workInProgress2), isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount), current2;
              bubbleProperties(workInProgress2);
              return null;
            case 22:
            case 23:
              return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), newProps = null !== workInProgress2.memoizedState, null !== current2 ? null !== current2.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (renderLanes2 = current2.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current2 && pop(resumedCache, workInProgress2), null;
            case 24:
              return renderLanes2 = null, null !== current2 && (renderLanes2 = current2.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext, workInProgress2), bubbleProperties(workInProgress2), null;
            case 25:
              return null;
            case 30:
              return null;
          }
          throw Error(
            "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function unwindWork(current2, workInProgress2) {
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case 1:
              return current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 3:
              return popProvider(CacheContext, workInProgress2), popHostContainer(workInProgress2), current2 = workInProgress2.flags, 0 !== (current2 & 65536) && 0 === (current2 & 128) ? (workInProgress2.flags = current2 & -65537 | 128, workInProgress2) : null;
            case 26:
            case 27:
            case 5:
              return popHostContext(workInProgress2), null;
            case 31:
              if (null !== workInProgress2.memoizedState) {
                popSuspenseHandler(workInProgress2);
                if (null === workInProgress2.alternate)
                  throw Error(
                    "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
                  );
                resetHydrationState();
              }
              current2 = workInProgress2.flags;
              return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 13:
              popSuspenseHandler(workInProgress2);
              current2 = workInProgress2.memoizedState;
              if (null !== current2 && null !== current2.dehydrated) {
                if (null === workInProgress2.alternate)
                  throw Error(
                    "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
                  );
                resetHydrationState();
              }
              current2 = workInProgress2.flags;
              return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 19:
              return pop(suspenseStackCursor, workInProgress2), null;
            case 4:
              return popHostContainer(workInProgress2), null;
            case 10:
              return popProvider(workInProgress2.type, workInProgress2), null;
            case 22:
            case 23:
              return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), null !== current2 && pop(resumedCache, workInProgress2), current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 24:
              return popProvider(CacheContext, workInProgress2), null;
            case 25:
              return null;
            default:
              return null;
          }
        }
        function unwindInterruptedWork(current2, interruptedWork) {
          popTreeContext(interruptedWork);
          switch (interruptedWork.tag) {
            case 3:
              popProvider(CacheContext, interruptedWork);
              popHostContainer(interruptedWork);
              break;
            case 26:
            case 27:
            case 5:
              popHostContext(interruptedWork);
              break;
            case 4:
              popHostContainer(interruptedWork);
              break;
            case 31:
              null !== interruptedWork.memoizedState && popSuspenseHandler(interruptedWork);
              break;
            case 13:
              popSuspenseHandler(interruptedWork);
              break;
            case 19:
              pop(suspenseStackCursor, interruptedWork);
              break;
            case 10:
              popProvider(interruptedWork.type, interruptedWork);
              break;
            case 22:
            case 23:
              popSuspenseHandler(interruptedWork);
              popHiddenContext(interruptedWork);
              null !== current2 && pop(resumedCache, interruptedWork);
              break;
            case 24:
              popProvider(CacheContext, interruptedWork);
          }
        }
        function shouldProfile(current2) {
          return (current2.mode & ProfileMode) !== NoMode;
        }
        function commitHookLayoutEffects(finishedWork, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
        }
        function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ), recordEffectDuration()) : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
        }
        function commitHookEffectListMount(flags, finishedWork) {
          try {
            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
              var firstEffect = lastEffect.next;
              updateQueue = firstEffect;
              do {
                if ((updateQueue.tag & flags) === flags && (lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = runWithFiberInDEV(
                  finishedWork,
                  callCreateInDEV,
                  updateQueue
                ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), void 0 !== lastEffect && "function" !== typeof lastEffect)) {
                  var hookName = void 0;
                  hookName = 0 !== (updateQueue.tag & Layout) ? "useLayoutEffect" : 0 !== (updateQueue.tag & Insertion) ? "useInsertionEffect" : "useEffect";
                  var addendum = void 0;
                  addendum = null === lastEffect ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : "function" === typeof lastEffect.then ? "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching" : " You returned: " + lastEffect;
                  runWithFiberInDEV(
                    finishedWork,
                    function(n, a) {
                      console.error(
                        "%s must not return anything besides a function, which is used for clean-up.%s",
                        n,
                        a
                      );
                    },
                    hookName,
                    addendum
                  );
                }
                updateQueue = updateQueue.next;
              } while (updateQueue !== firstEffect);
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
          try {
            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
              var firstEffect = lastEffect.next;
              updateQueue = firstEffect;
              do {
                if ((updateQueue.tag & flags) === flags) {
                  var inst = updateQueue.inst, destroy = inst.destroy;
                  void 0 !== destroy && (inst.destroy = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = finishedWork, runWithFiberInDEV(
                    lastEffect,
                    callDestroyInDEV,
                    lastEffect,
                    nearestMountedAncestor,
                    destroy
                  ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false));
                }
                updateQueue = updateQueue.next;
              } while (updateQueue !== firstEffect);
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHookPassiveMountEffects(finishedWork, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
        }
        function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ), recordEffectDuration()) : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
        }
        function commitClassCallbacks(finishedWork) {
          var updateQueue = finishedWork.updateQueue;
          if (null !== updateQueue) {
            var instance = finishedWork.stateNode;
            finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error(
              "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ), instance.state !== finishedWork.memoizedState && console.error(
              "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ));
            try {
              runWithFiberInDEV(
                finishedWork,
                commitCallbacks,
                updateQueue,
                instance
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }
        function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
          return instance.getSnapshotBeforeUpdate(prevProps, prevState);
        }
        function commitClassSnapshot(finishedWork, current2) {
          var prevProps = current2.memoizedProps, prevState = current2.memoizedState;
          current2 = finishedWork.stateNode;
          finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current2.props !== finishedWork.memoizedProps && console.error(
            "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ), current2.state !== finishedWork.memoizedState && console.error(
            "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ));
          try {
            var resolvedPrevProps = resolveClassComponentProps(
              finishedWork.type,
              prevProps
            );
            var snapshot = runWithFiberInDEV(
              finishedWork,
              callGetSnapshotBeforeUpdates,
              current2,
              resolvedPrevProps,
              prevState
            );
            prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
            void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {
              console.error(
                "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
                getComponentNameFromFiber(finishedWork)
              );
            }));
            current2.__reactInternalSnapshotBeforeUpdate = snapshot;
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
          instance.props = resolveClassComponentProps(
            current2.type,
            current2.memoizedProps
          );
          instance.state = current2.memoizedState;
          shouldProfile(current2) ? (startEffectTimer(), runWithFiberInDEV(
            current2,
            callComponentWillUnmountInDEV,
            current2,
            nearestMountedAncestor,
            instance
          ), recordEffectDuration()) : runWithFiberInDEV(
            current2,
            callComponentWillUnmountInDEV,
            current2,
            nearestMountedAncestor,
            instance
          );
        }
        function commitAttachRef(finishedWork) {
          var ref = finishedWork.ref;
          if (null !== ref) {
            switch (finishedWork.tag) {
              case 26:
              case 27:
              case 5:
                var instanceToUse = finishedWork.stateNode;
                break;
              case 30:
                instanceToUse = finishedWork.stateNode;
                break;
              default:
                instanceToUse = finishedWork.stateNode;
            }
            if ("function" === typeof ref)
              if (shouldProfile(finishedWork))
                try {
                  startEffectTimer(), finishedWork.refCleanup = ref(instanceToUse);
                } finally {
                  recordEffectDuration();
                }
              else finishedWork.refCleanup = ref(instanceToUse);
            else
              "string" === typeof ref ? console.error("String refs are no longer supported.") : ref.hasOwnProperty("current") || console.error(
                "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
                getComponentNameFromFiber(finishedWork)
              ), ref.current = instanceToUse;
          }
        }
        function safelyAttachRef(current2, nearestMountedAncestor) {
          try {
            runWithFiberInDEV(current2, commitAttachRef, current2);
          } catch (error) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error);
          }
        }
        function safelyDetachRef(current2, nearestMountedAncestor) {
          var ref = current2.ref, refCleanup = current2.refCleanup;
          if (null !== ref)
            if ("function" === typeof refCleanup)
              try {
                if (shouldProfile(current2))
                  try {
                    startEffectTimer(), runWithFiberInDEV(current2, refCleanup);
                  } finally {
                    recordEffectDuration(current2);
                  }
                else runWithFiberInDEV(current2, refCleanup);
              } catch (error) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error);
              } finally {
                current2.refCleanup = null, current2 = current2.alternate, null != current2 && (current2.refCleanup = null);
              }
            else if ("function" === typeof ref)
              try {
                if (shouldProfile(current2))
                  try {
                    startEffectTimer(), runWithFiberInDEV(current2, ref, null);
                  } finally {
                    recordEffectDuration(current2);
                  }
                else runWithFiberInDEV(current2, ref, null);
              } catch (error$7) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error$7);
              }
            else ref.current = null;
        }
        function commitProfiler(finishedWork, current2, commitStartTime2, effectDuration) {
          var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;
          _finishedWork$memoize = _finishedWork$memoize.onRender;
          current2 = null === current2 ? "mount" : "update";
          currentUpdateIsNested && (current2 = "nested-update");
          "function" === typeof _finishedWork$memoize && _finishedWork$memoize(
            id,
            current2,
            finishedWork.actualDuration,
            finishedWork.treeBaseDuration,
            finishedWork.actualStartTime,
            commitStartTime2
          );
          "function" === typeof onCommit && onCommit(id, current2, effectDuration, commitStartTime2);
        }
        function commitProfilerPostCommitImpl(finishedWork, current2, commitStartTime2, passiveEffectDuration) {
          var _finishedWork$memoize2 = finishedWork.memoizedProps;
          finishedWork = _finishedWork$memoize2.id;
          _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
          current2 = null === current2 ? "mount" : "update";
          currentUpdateIsNested && (current2 = "nested-update");
          "function" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(
            finishedWork,
            current2,
            passiveEffectDuration,
            commitStartTime2
          );
        }
        function commitHostMount(finishedWork) {
          var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
          try {
            runWithFiberInDEV(
              finishedWork,
              commitMount,
              instance,
              type,
              props,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHostUpdate(finishedWork, newProps, oldProps) {
          try {
            runWithFiberInDEV(
              finishedWork,
              commitUpdate,
              finishedWork.stateNode,
              finishedWork.type,
              oldProps,
              newProps,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function isHostParent(fiber) {
          return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
        }
        function getHostSibling(fiber) {
          a: for (; ; ) {
            for (; null === fiber.sibling; ) {
              if (null === fiber.return || isHostParent(fiber.return)) return null;
              fiber = fiber.return;
            }
            fiber.sibling.return = fiber.return;
            for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
              if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
              if (fiber.flags & 2) continue a;
              if (null === fiber.child || 4 === fiber.tag) continue a;
              else fiber.child.return = fiber, fiber = fiber.child;
            }
            if (!(fiber.flags & 2)) return fiber.stateNode;
          }
        }
        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
          var tag = node.tag;
          if (5 === tag || 6 === tag)
            node = node.stateNode, before ? (warnForReactChildrenConflict(parent), (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before)) : (warnForReactChildrenConflict(parent), before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
          else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
            for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
              insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
        }
        function insertOrAppendPlacementNode(node, before, parent) {
          var tag = node.tag;
          if (5 === tag || 6 === tag)
            node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
          else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
            for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
              insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
        }
        function commitPlacement(finishedWork) {
          for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
            if (isHostParent(parentFiber)) {
              hostParentFiber = parentFiber;
              break;
            }
            parentFiber = parentFiber.return;
          }
          if (null == hostParentFiber)
            throw Error(
              "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
            );
          switch (hostParentFiber.tag) {
            case 27:
              hostParentFiber = hostParentFiber.stateNode;
              parentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(
                finishedWork,
                parentFiber,
                hostParentFiber
              );
              break;
            case 5:
              parentFiber = hostParentFiber.stateNode;
              hostParentFiber.flags & 32 && (resetTextContent(parentFiber), hostParentFiber.flags &= -33);
              hostParentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(
                finishedWork,
                hostParentFiber,
                parentFiber
              );
              break;
            case 3:
            case 4:
              hostParentFiber = hostParentFiber.stateNode.containerInfo;
              parentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(
                finishedWork,
                parentFiber,
                hostParentFiber
              );
              break;
            default:
              throw Error(
                "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
              );
          }
        }
        function commitHostSingletonAcquisition(finishedWork) {
          var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
          try {
            runWithFiberInDEV(
              finishedWork,
              acquireSingletonInstance,
              finishedWork.type,
              props,
              singleton,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function isHydratingParent(current2, finishedWork) {
          return 31 === finishedWork.tag ? (finishedWork = finishedWork.memoizedState, null !== current2.memoizedState && null === finishedWork) : 13 === finishedWork.tag ? (current2 = current2.memoizedState, finishedWork = finishedWork.memoizedState, null !== current2 && null !== current2.dehydrated && (null === finishedWork || null === finishedWork.dehydrated)) : 3 === finishedWork.tag ? current2.memoizedState.isDehydrated && 0 === (finishedWork.flags & 256) : false;
        }
        function commitBeforeMutationEffects(root2, firstChild) {
          root2 = root2.containerInfo;
          eventsEnabled = _enabled;
          root2 = getActiveElementDeep(root2);
          if (hasSelectionCapabilities(root2)) {
            if ("selectionStart" in root2)
              var JSCompiler_temp = {
                start: root2.selectionStart,
                end: root2.selectionEnd
              };
            else
              a: {
                JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
                var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
                if (selection && 0 !== selection.rangeCount) {
                  JSCompiler_temp = selection.anchorNode;
                  var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                  selection = selection.focusOffset;
                  try {
                    JSCompiler_temp.nodeType, focusNode.nodeType;
                  } catch (e$2) {
                    JSCompiler_temp = null;
                    break a;
                  }
                  var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
                  b: for (; ; ) {
                    for (var next; ; ) {
                      node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                      node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                      3 === node.nodeType && (length += node.nodeValue.length);
                      if (null === (next = node.firstChild)) break;
                      parentNode = node;
                      node = next;
                    }
                    for (; ; ) {
                      if (node === root2) break b;
                      parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                      parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                      if (null !== (next = node.nextSibling)) break;
                      node = parentNode;
                      parentNode = node.parentNode;
                    }
                    node = next;
                  }
                  JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
                } else JSCompiler_temp = null;
              }
            JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
          } else JSCompiler_temp = null;
          selectionInformation = {
            focusedElem: root2,
            selectionRange: JSCompiler_temp
          };
          _enabled = false;
          for (nextEffect = firstChild; null !== nextEffect; )
            if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root2)
              root2.return = firstChild, nextEffect = root2;
            else
              for (; null !== nextEffect; ) {
                root2 = firstChild = nextEffect;
                JSCompiler_temp = root2.alternate;
                anchorOffset = root2.flags;
                switch (root2.tag) {
                  case 0:
                    if (0 !== (anchorOffset & 4) && (root2 = root2.updateQueue, root2 = null !== root2 ? root2.events : null, null !== root2))
                      for (JSCompiler_temp = 0; JSCompiler_temp < root2.length; JSCompiler_temp++)
                        anchorOffset = root2[JSCompiler_temp], anchorOffset.ref.impl = anchorOffset.nextImpl;
                    break;
                  case 11:
                  case 15:
                    break;
                  case 1:
                    0 !== (anchorOffset & 1024) && null !== JSCompiler_temp && commitClassSnapshot(root2, JSCompiler_temp);
                    break;
                  case 3:
                    if (0 !== (anchorOffset & 1024)) {
                      if (root2 = root2.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                        clearContainerSparingly(root2);
                      else if (1 === JSCompiler_temp)
                        switch (root2.nodeName) {
                          case "HEAD":
                          case "HTML":
                          case "BODY":
                            clearContainerSparingly(root2);
                            break;
                          default:
                            root2.textContent = "";
                        }
                    }
                    break;
                  case 5:
                  case 26:
                  case 27:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    if (0 !== (anchorOffset & 1024))
                      throw Error(
                        "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                      );
                }
                root2 = firstChild.sibling;
                if (null !== root2) {
                  root2.return = firstChild.return;
                  nextEffect = root2;
                  break;
                }
                nextEffect = firstChild.return;
              }
        }
        function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);
              break;
            case 1:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (flags & 4)
                if (finishedRoot = finishedWork.stateNode, null === current2)
                  finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                    "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                    "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  )), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                    finishedWork,
                    callComponentDidMountInDEV,
                    finishedWork,
                    finishedRoot
                  ), recordEffectDuration()) : runWithFiberInDEV(
                    finishedWork,
                    callComponentDidMountInDEV,
                    finishedWork,
                    finishedRoot
                  );
                else {
                  var prevProps = resolveClassComponentProps(
                    finishedWork.type,
                    current2.memoizedProps
                  );
                  current2 = current2.memoizedState;
                  finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                    "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                    "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ));
                  shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current2,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  ), recordEffectDuration()) : runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current2,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
                }
              flags & 64 && commitClassCallbacks(finishedWork);
              flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 3:
              current2 = pushNestedEffectDurations();
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {
                prevProps = null;
                if (null !== finishedWork.child)
                  switch (finishedWork.child.tag) {
                    case 27:
                    case 5:
                      prevProps = finishedWork.child.stateNode;
                      break;
                    case 1:
                      prevProps = finishedWork.child.stateNode;
                  }
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitCallbacks,
                    flags,
                    prevProps
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              finishedRoot.effectDuration += popNestedEffectDurations(current2);
              break;
            case 27:
              null === current2 && flags & 4 && commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (null === current2) {
                if (flags & 4) commitHostMount(finishedWork);
                else if (flags & 64) {
                  finishedRoot = finishedWork.type;
                  current2 = finishedWork.memoizedProps;
                  prevProps = finishedWork.stateNode;
                  try {
                    runWithFiberInDEV(
                      finishedWork,
                      commitHydratedInstance,
                      prevProps,
                      finishedRoot,
                      current2,
                      finishedWork
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      finishedWork,
                      finishedWork.return,
                      error
                    );
                  }
                }
              }
              flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              if (flags & 4) {
                flags = pushNestedEffectDurations();
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                finishedRoot = finishedWork.stateNode;
                finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfiler,
                    finishedWork,
                    current2,
                    commitStartTime,
                    finishedRoot.effectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              break;
            case 31:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 13:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (flags = retryDehydratedSuspenseBoundary.bind(
                null,
                finishedWork
              ), registerSuspenseInstanceRetry(finishedRoot, flags))));
              break;
            case 22:
              flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
              if (!flags) {
                current2 = null !== current2 && null !== current2.memoizedState || offscreenSubtreeWasHidden;
                prevProps = offscreenSubtreeIsHidden;
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeIsHidden = flags;
                (offscreenSubtreeWasHidden = current2) && !prevOffscreenSubtreeWasHidden ? (recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  0 !== (finishedWork.subtreeFlags & 8772)
                ), (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(
                  finishedWork,
                  componentEffectStartTime,
                  componentEffectEndTime
                )) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                offscreenSubtreeIsHidden = prevProps;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              }
              break;
            case 30:
              break;
            default:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          ), null === finishedWork.alternate && null !== finishedWork.return && null !== finishedWork.return.alternate && 0.05 < componentEffectEndTime - componentEffectStartTime && (isHydratingParent(
            finishedWork.return.alternate,
            finishedWork.return
          ) || logComponentTrigger(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            "Mount"
          )));
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function detachFiberAfterEffects(fiber) {
          var alternate = fiber.alternate;
          null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
          fiber.child = null;
          fiber.deletions = null;
          fiber.sibling = null;
          5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
          fiber.stateNode = null;
          fiber._debugOwner = null;
          fiber.return = null;
          fiber.dependencies = null;
          fiber.memoizedProps = null;
          fiber.memoizedState = null;
          fiber.pendingProps = null;
          fiber.stateNode = null;
          fiber.updateQueue = null;
        }
        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
          for (parent = parent.child; null !== parent; )
            commitDeletionEffectsOnFiber(
              finishedRoot,
              nearestMountedAncestor,
              parent
            ), parent = parent.sibling;
        }
        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
            try {
              injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %o",
                err
              ));
            }
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
          switch (deletedFiber.tag) {
            case 26:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (finishedRoot = deletedFiber.stateNode, finishedRoot.parentNode.removeChild(finishedRoot));
              break;
            case 27:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
              isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              runWithFiberInDEV(
                deletedFiber,
                releaseSingletonInstance,
                deletedFiber.stateNode
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            case 5:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            case 6:
              prevHostParent = hostParent;
              prevHostParentIsContainer = hostParentIsContainer;
              hostParent = null;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              if (null !== hostParent)
                if (hostParentIsContainer)
                  try {
                    runWithFiberInDEV(
                      deletedFiber,
                      removeChildFromContainer,
                      hostParent,
                      deletedFiber.stateNode
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error
                    );
                  }
                else
                  try {
                    runWithFiberInDEV(
                      deletedFiber,
                      removeChild,
                      hostParent,
                      deletedFiber.stateNode
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error
                    );
                  }
              break;
            case 18:
              null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearHydrationBoundary(
                9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
                deletedFiber.stateNode
              ), retryIfBlockedOn(finishedRoot)) : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
              break;
            case 4:
              prevHostParent = hostParent;
              prevHostParentIsContainer = hostParentIsContainer;
              hostParent = deletedFiber.stateNode.containerInfo;
              hostParentIsContainer = true;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookEffectListUnmount(
                Insertion,
                deletedFiber,
                nearestMountedAncestor
              );
              offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(
                deletedFiber,
                nearestMountedAncestor,
                Layout
              );
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 1:
              offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
                deletedFiber,
                nearestMountedAncestor,
                prevHostParent
              ));
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 21:
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 22:
              offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              offscreenSubtreeWasHidden = prevHostParent;
              break;
            default:
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
          }
          (deletedFiber.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            deletedFiber,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
          if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot))) {
            finishedRoot = finishedRoot.dehydrated;
            try {
              runWithFiberInDEV(
                finishedWork,
                commitHydratedActivityInstance,
                finishedRoot
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }
        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
          if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
            try {
              runWithFiberInDEV(
                finishedWork,
                commitHydratedSuspenseInstance,
                finishedRoot
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
        }
        function getRetryCache(finishedWork) {
          switch (finishedWork.tag) {
            case 31:
            case 13:
            case 19:
              var retryCache = finishedWork.stateNode;
              null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
              return retryCache;
            case 22:
              return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
            default:
              throw Error(
                "Unexpected Suspense handler tag (" + finishedWork.tag + "). This is a bug in React."
              );
          }
        }
        function attachSuspenseRetryListeners(finishedWork, wakeables) {
          var retryCache = getRetryCache(finishedWork);
          wakeables.forEach(function(wakeable) {
            if (!retryCache.has(wakeable)) {
              retryCache.add(wakeable);
              if (isDevToolsPresent)
                if (null !== inProgressLanes && null !== inProgressRoot)
                  restorePendingUpdaters(inProgressRoot, inProgressLanes);
                else
                  throw Error(
                    "Expected finished root and lanes to be set. This is a bug in React."
                  );
              var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
              wakeable.then(retry, retry);
            }
          });
        }
        function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
          var deletions = parentFiber.deletions;
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var root2 = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i], prevEffectStart = pushComponentEffectStart(), parent = returnFiber;
              a: for (; null !== parent; ) {
                switch (parent.tag) {
                  case 27:
                    if (isSingletonScope(parent.type)) {
                      hostParent = parent.stateNode;
                      hostParentIsContainer = false;
                      break a;
                    }
                    break;
                  case 5:
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  case 3:
                  case 4:
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break a;
                }
                parent = parent.return;
              }
              if (null === hostParent)
                throw Error(
                  "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
                );
              commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
              hostParent = null;
              hostParentIsContainer = false;
              (deletedFiber.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                deletedFiber,
                componentEffectStartTime,
                componentEffectEndTime,
                "Unmount"
              );
              popComponentEffectStart(prevEffectStart);
              root2 = deletedFiber;
              returnFiber = root2.alternate;
              null !== returnFiber && (returnFiber.return = null);
              root2.return = null;
            }
          if (parentFiber.subtreeFlags & 13886)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
        }
        function commitMutationEffectsOnFiber(finishedWork, root2) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), current2 = finishedWork.alternate, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (commitHookEffectListUnmount(
                Insertion | HasEffect,
                finishedWork,
                finishedWork.return
              ), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(
                finishedWork,
                finishedWork.return,
                Layout | HasEffect
              ));
              break;
            case 1:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              if (flags & 64 && offscreenSubtreeIsHidden && (flags = finishedWork.updateQueue, null !== flags && (current2 = flags.callbacks, null !== current2))) {
                var existingHiddenCallbacks = flags.shared.hiddenCallbacks;
                flags.shared.hiddenCallbacks = null === existingHiddenCallbacks ? current2 : existingHiddenCallbacks.concat(current2);
              }
              break;
            case 26:
              existingHiddenCallbacks = currentHoistableRoot;
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              if (flags & 4) {
                var currentResource = null !== current2 ? current2.memoizedState : null;
                flags = finishedWork.memoizedState;
                if (null === current2)
                  if (null === flags)
                    if (null === finishedWork.stateNode) {
                      a: {
                        flags = finishedWork.type;
                        current2 = finishedWork.memoizedProps;
                        existingHiddenCallbacks = existingHiddenCallbacks.ownerDocument || existingHiddenCallbacks;
                        b: switch (flags) {
                          case "title":
                            currentResource = existingHiddenCallbacks.getElementsByTagName(
                              "title"
                            )[0];
                            if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || currentResource.namespaceURI === SVG_NAMESPACE || currentResource.hasAttribute("itemprop"))
                              currentResource = existingHiddenCallbacks.createElement(flags), existingHiddenCallbacks.head.insertBefore(
                                currentResource,
                                existingHiddenCallbacks.querySelector(
                                  "head > title"
                                )
                              );
                            setInitialProperties(currentResource, flags, current2);
                            currentResource[internalInstanceKey] = finishedWork;
                            markNodeAsHoistable(currentResource);
                            flags = currentResource;
                            break a;
                          case "link":
                            var maybeNodes = getHydratableHoistableCache(
                              "link",
                              "href",
                              existingHiddenCallbacks
                            ).get(flags + (current2.href || ""));
                            if (maybeNodes) {
                              for (var i = 0; i < maybeNodes.length; i++)
                                if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current2.href || "" === current2.href ? null : current2.href) && currentResource.getAttribute("rel") === (null == current2.rel ? null : current2.rel) && currentResource.getAttribute("title") === (null == current2.title ? null : current2.title) && currentResource.getAttribute("crossorigin") === (null == current2.crossOrigin ? null : current2.crossOrigin)) {
                                  maybeNodes.splice(i, 1);
                                  break b;
                                }
                            }
                            currentResource = existingHiddenCallbacks.createElement(flags);
                            setInitialProperties(currentResource, flags, current2);
                            existingHiddenCallbacks.head.appendChild(
                              currentResource
                            );
                            break;
                          case "meta":
                            if (maybeNodes = getHydratableHoistableCache(
                              "meta",
                              "content",
                              existingHiddenCallbacks
                            ).get(flags + (current2.content || ""))) {
                              for (i = 0; i < maybeNodes.length; i++)
                                if (currentResource = maybeNodes[i], checkAttributeStringCoercion(
                                  current2.content,
                                  "content"
                                ), currentResource.getAttribute("content") === (null == current2.content ? null : "" + current2.content) && currentResource.getAttribute("name") === (null == current2.name ? null : current2.name) && currentResource.getAttribute("property") === (null == current2.property ? null : current2.property) && currentResource.getAttribute("http-equiv") === (null == current2.httpEquiv ? null : current2.httpEquiv) && currentResource.getAttribute("charset") === (null == current2.charSet ? null : current2.charSet)) {
                                  maybeNodes.splice(i, 1);
                                  break b;
                                }
                            }
                            currentResource = existingHiddenCallbacks.createElement(flags);
                            setInitialProperties(currentResource, flags, current2);
                            existingHiddenCallbacks.head.appendChild(
                              currentResource
                            );
                            break;
                          default:
                            throw Error(
                              'getNodesForType encountered a type it did not expect: "' + flags + '". This is a bug in React.'
                            );
                        }
                        currentResource[internalInstanceKey] = finishedWork;
                        markNodeAsHoistable(currentResource);
                        flags = currentResource;
                      }
                      finishedWork.stateNode = flags;
                    } else
                      mountHoistable(
                        existingHiddenCallbacks,
                        finishedWork.type,
                        finishedWork.stateNode
                      );
                  else
                    finishedWork.stateNode = acquireResource(
                      existingHiddenCallbacks,
                      flags,
                      finishedWork.memoizedProps
                    );
                else
                  currentResource !== flags ? (null === currentResource ? null !== current2.stateNode && (current2 = current2.stateNode, current2.parentNode.removeChild(current2)) : currentResource.count--, null === flags ? mountHoistable(
                    existingHiddenCallbacks,
                    finishedWork.type,
                    finishedWork.stateNode
                  ) : acquireResource(
                    existingHiddenCallbacks,
                    flags,
                    finishedWork.memoizedProps
                  )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                    finishedWork,
                    finishedWork.memoizedProps,
                    current2.memoizedProps
                  );
              }
              break;
            case 27:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              null !== current2 && flags & 4 && commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current2.memoizedProps
              );
              break;
            case 5:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              if (finishedWork.flags & 32) {
                existingHiddenCallbacks = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    resetTextContent,
                    existingHiddenCallbacks
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              flags & 4 && null != finishedWork.stateNode && (existingHiddenCallbacks = finishedWork.memoizedProps, commitHostUpdate(
                finishedWork,
                existingHiddenCallbacks,
                null !== current2 ? current2.memoizedProps : existingHiddenCallbacks
              ));
              flags & 1024 && (needsFormReset = true, "form" !== finishedWork.type && console.error(
                "Unexpected host component type. Expected a form. This is a bug in React."
              ));
              break;
            case 6:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & 4) {
                if (null === finishedWork.stateNode)
                  throw Error(
                    "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
                  );
                flags = finishedWork.memoizedProps;
                current2 = null !== current2 ? current2.memoizedProps : flags;
                existingHiddenCallbacks = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitTextUpdate,
                    existingHiddenCallbacks,
                    current2,
                    flags
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              break;
            case 3:
              existingHiddenCallbacks = pushNestedEffectDurations();
              tagCaches = null;
              currentResource = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(root2.containerInfo);
              recursivelyTraverseMutationEffects(root2, finishedWork);
              currentHoistableRoot = currentResource;
              commitReconciliationEffects(finishedWork);
              if (flags & 4 && null !== current2 && current2.memoizedState.isDehydrated)
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitHydratedContainer,
                    root2.containerInfo
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
              root2.effectDuration += popNestedEffectDurations(
                existingHiddenCallbacks
              );
              break;
            case 4:
              flags = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                finishedWork.stateNode.containerInfo
              );
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              currentHoistableRoot = flags;
              break;
            case 12:
              flags = pushNestedEffectDurations();
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);
              break;
            case 31:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 13:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current2 && null !== current2.memoizedState) && (globalMostRecentFallbackTime = now$1());
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 22:
              existingHiddenCallbacks = null !== finishedWork.memoizedState;
              var wasHidden = null !== current2 && null !== current2.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || existingHiddenCallbacks;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
              recursivelyTraverseMutationEffects(root2, finishedWork);
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
              wasHidden && !existingHiddenCallbacks && !prevOffscreenSubtreeIsHidden && !prevOffscreenSubtreeWasHidden && (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(
                finishedWork,
                componentEffectStartTime,
                componentEffectEndTime
              );
              commitReconciliationEffects(finishedWork);
              if (flags & 8192)
                a: for (root2 = finishedWork.stateNode, root2._visibility = existingHiddenCallbacks ? root2._visibility & ~OffscreenVisible : root2._visibility | OffscreenVisible, !existingHiddenCallbacks || null === current2 || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || (recursivelyTraverseDisappearLayoutEffects(finishedWork), (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                  finishedWork,
                  componentEffectStartTime,
                  componentEffectEndTime,
                  "Disconnect"
                )), current2 = null, root2 = finishedWork; ; ) {
                  if (5 === root2.tag || 26 === root2.tag) {
                    if (null === current2) {
                      wasHidden = current2 = root2;
                      try {
                        currentResource = wasHidden.stateNode, existingHiddenCallbacks ? runWithFiberInDEV(
                          wasHidden,
                          hideInstance,
                          currentResource
                        ) : runWithFiberInDEV(
                          wasHidden,
                          unhideInstance,
                          wasHidden.stateNode,
                          wasHidden.memoizedProps
                        );
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if (6 === root2.tag) {
                    if (null === current2) {
                      wasHidden = root2;
                      try {
                        maybeNodes = wasHidden.stateNode, existingHiddenCallbacks ? runWithFiberInDEV(
                          wasHidden,
                          hideTextInstance,
                          maybeNodes
                        ) : runWithFiberInDEV(
                          wasHidden,
                          unhideTextInstance,
                          maybeNodes,
                          wasHidden.memoizedProps
                        );
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if (18 === root2.tag) {
                    if (null === current2) {
                      wasHidden = root2;
                      try {
                        i = wasHidden.stateNode, existingHiddenCallbacks ? runWithFiberInDEV(
                          wasHidden,
                          hideDehydratedBoundary,
                          i
                        ) : runWithFiberInDEV(
                          wasHidden,
                          unhideDehydratedBoundary,
                          wasHidden.stateNode
                        );
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
                    root2.child.return = root2;
                    root2 = root2.child;
                    continue;
                  }
                  if (root2 === finishedWork) break a;
                  for (; null === root2.sibling; ) {
                    if (null === root2.return || root2.return === finishedWork)
                      break a;
                    current2 === root2 && (current2 = null);
                    root2 = root2.return;
                  }
                  current2 === root2 && (current2 = null);
                  root2.sibling.return = root2.return;
                  root2 = root2.sibling;
                }
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current2 = flags.retryQueue, null !== current2 && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current2))));
              break;
            case 19:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 30:
              break;
            case 21:
              break;
            default:
              recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          ), null === finishedWork.alternate && null !== finishedWork.return && null !== finishedWork.return.alternate && 0.05 < componentEffectEndTime - componentEffectStartTime && (isHydratingParent(
            finishedWork.return.alternate,
            finishedWork.return
          ) || logComponentTrigger(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            "Mount"
          )));
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function commitReconciliationEffects(finishedWork) {
          var flags = finishedWork.flags;
          if (flags & 2) {
            try {
              runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
            finishedWork.flags &= -3;
          }
          flags & 4096 && (finishedWork.flags &= -4097);
        }
        function recursivelyResetForms(parentFiber) {
          if (parentFiber.subtreeFlags & 1024)
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var fiber = parentFiber;
              recursivelyResetForms(fiber);
              5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
              parentFiber = parentFiber.sibling;
            }
        }
        function recursivelyTraverseLayoutEffects(root2, parentFiber) {
          if (parentFiber.subtreeFlags & 8772)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
        }
        function disappearLayoutEffects(finishedWork) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookLayoutUnmountEffects(
                finishedWork,
                finishedWork.return,
                Layout
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 1:
              safelyDetachRef(finishedWork, finishedWork.return);
              var instance = finishedWork.stateNode;
              "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
                finishedWork,
                finishedWork.return,
                instance
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 27:
              runWithFiberInDEV(
                finishedWork,
                releaseSingletonInstance,
                finishedWork.stateNode
              );
            case 26:
            case 5:
              safelyDetachRef(finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 30:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            default:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;
        }
        function reappearLayoutEffects(finishedRoot, current2, finishedWork, includeWorkInProgressEffects) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              commitHookLayoutEffects(finishedWork, Layout);
              break;
            case 1:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              current2 = finishedWork.stateNode;
              "function" === typeof current2.componentDidMount && runWithFiberInDEV(
                finishedWork,
                callComponentDidMountInDEV,
                finishedWork,
                current2
              );
              current2 = finishedWork.updateQueue;
              if (null !== current2) {
                finishedRoot = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitHiddenCallbacks,
                    current2,
                    finishedRoot
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 27:
              commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && null === current2 && flags & 4 && commitHostMount(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              if (includeWorkInProgressEffects && flags & 4) {
                flags = pushNestedEffectDurations();
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
                includeWorkInProgressEffects = finishedWork.stateNode;
                includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfiler,
                    finishedWork,
                    current2,
                    commitStartTime,
                    includeWorkInProgressEffects.effectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
              break;
            case 31:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 13:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 30:
              break;
            default:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
          includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            reappearLayoutEffects(
              finishedRoot,
              parentFiber.alternate,
              parentFiber,
              includeWorkInProgressEffects
            ), parentFiber = parentFiber.sibling;
        }
        function commitOffscreenPassiveMountEffects(current2, finishedWork) {
          var previousCache = null;
          null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (previousCache = current2.memoizedState.cachePool.pool);
          current2 = null;
          null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current2 = finishedWork.memoizedState.cachePool.pool);
          current2 !== previousCache && (null != current2 && retainCache(current2), null != previousCache && releaseCache(previousCache));
        }
        function commitCachePassiveMountEffect(current2, finishedWork) {
          current2 = null;
          null !== finishedWork.alternate && (current2 = finishedWork.alternate.memoizedState.cache);
          finishedWork = finishedWork.memoizedState.cache;
          finishedWork !== current2 && (retainCache(finishedWork), null != current2 && releaseCache(current2));
        }
        function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions, endTime) {
          if (parentFiber.subtreeFlags & 10256 || 0 !== parentFiber.actualDuration && (null === parentFiber.alternate || parentFiber.alternate.child !== parentFiber.child))
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var nextSibling = parentFiber.sibling;
              commitPassiveMountOnFiber(
                root2,
                parentFiber,
                committedLanes,
                committedTransitions,
                null !== nextSibling ? nextSibling.actualStartTime : endTime
              );
              parentFiber = nextSibling;
            }
        }
        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), prevDeepEquality = alreadyWarnedForDeepEquality, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              (finishedWork.mode & ProfileMode) !== NoMode && 0 < finishedWork.actualStartTime && 0 !== (finishedWork.flags & 1) && logComponentRender(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                inHydratedSubtree,
                committedLanes
              );
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
              break;
            case 1:
              (finishedWork.mode & ProfileMode) !== NoMode && 0 < finishedWork.actualStartTime && (0 !== (finishedWork.flags & 128) ? logComponentErrored(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                []
              ) : 0 !== (finishedWork.flags & 1) && logComponentRender(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                inHydratedSubtree,
                committedLanes
              ));
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              break;
            case 3:
              var prevProfilerEffectDuration = pushNestedEffectDurations(), wasInHydratedSubtree = inHydratedSubtree;
              inHydratedSubtree = null !== finishedWork.alternate && finishedWork.alternate.memoizedState.isDehydrated && 0 === (finishedWork.flags & 256);
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              inHydratedSubtree = wasInHydratedSubtree;
              flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), committedTransitions = finishedWork.memoizedState.cache, committedTransitions !== committedLanes && (retainCache(committedTransitions), null != committedLanes && releaseCache(committedLanes)));
              finishedRoot.passiveEffectDuration += popNestedEffectDurations(
                prevProfilerEffectDuration
              );
              break;
            case 12:
              if (flags & 2048) {
                flags = pushNestedEffectDurations();
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  endTime
                );
                finishedRoot = finishedWork.stateNode;
                finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfilerPostCommitImpl,
                    finishedWork,
                    finishedWork.alternate,
                    commitStartTime,
                    finishedRoot.passiveEffectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  endTime
                );
              break;
            case 31:
              flags = inHydratedSubtree;
              prevProfilerEffectDuration = null !== finishedWork.alternate ? finishedWork.alternate.memoizedState : null;
              wasInHydratedSubtree = finishedWork.memoizedState;
              null !== prevProfilerEffectDuration && null === wasInHydratedSubtree ? (wasInHydratedSubtree = finishedWork.deletions, null !== wasInHydratedSubtree && 0 < wasInHydratedSubtree.length && 18 === wasInHydratedSubtree[0].tag ? (inHydratedSubtree = false, prevProfilerEffectDuration = prevProfilerEffectDuration.hydrationErrors, null !== prevProfilerEffectDuration && logComponentErrored(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                prevProfilerEffectDuration
              )) : inHydratedSubtree = true) : inHydratedSubtree = false;
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              inHydratedSubtree = flags;
              break;
            case 13:
              flags = inHydratedSubtree;
              prevProfilerEffectDuration = null !== finishedWork.alternate ? finishedWork.alternate.memoizedState : null;
              wasInHydratedSubtree = finishedWork.memoizedState;
              null === prevProfilerEffectDuration || null === prevProfilerEffectDuration.dehydrated || null !== wasInHydratedSubtree && null !== wasInHydratedSubtree.dehydrated ? inHydratedSubtree = false : (wasInHydratedSubtree = finishedWork.deletions, null !== wasInHydratedSubtree && 0 < wasInHydratedSubtree.length && 18 === wasInHydratedSubtree[0].tag ? (inHydratedSubtree = false, prevProfilerEffectDuration = prevProfilerEffectDuration.hydrationErrors, null !== prevProfilerEffectDuration && logComponentErrored(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                prevProfilerEffectDuration
              )) : inHydratedSubtree = true);
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              inHydratedSubtree = flags;
              break;
            case 23:
              break;
            case 22:
              wasInHydratedSubtree = finishedWork.stateNode;
              prevProfilerEffectDuration = finishedWork.alternate;
              null !== finishedWork.memoizedState ? wasInHydratedSubtree._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              ) : wasInHydratedSubtree._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              ) : (wasInHydratedSubtree._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                0 !== (finishedWork.subtreeFlags & 10256) || 0 !== finishedWork.actualDuration && (null === finishedWork.alternate || finishedWork.alternate.child !== finishedWork.child),
                endTime
              ), (finishedWork.mode & ProfileMode) === NoMode || inHydratedSubtree || (finishedRoot = finishedWork.actualStartTime, 0 <= finishedRoot && 0.05 < endTime - finishedRoot && logComponentReappeared(finishedWork, finishedRoot, endTime), 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(
                finishedWork,
                componentEffectStartTime,
                componentEffectEndTime
              )));
              flags & 2048 && commitOffscreenPassiveMountEffects(
                prevProfilerEffectDuration,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
          }
          if ((finishedWork.mode & ProfileMode) !== NoMode) {
            if (finishedRoot = !inHydratedSubtree && null === finishedWork.alternate && null !== finishedWork.return && null !== finishedWork.return.alternate)
              committedLanes = finishedWork.actualStartTime, 0 <= committedLanes && 0.05 < endTime - committedLanes && logComponentTrigger(
                finishedWork,
                committedLanes,
                endTime,
                "Mount"
              );
            0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
              finishedWork,
              componentEffectStartTime,
              componentEffectEndTime,
              componentEffectDuration,
              componentEffectErrors
            ), finishedRoot && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
              finishedWork,
              componentEffectStartTime,
              componentEffectEndTime,
              "Mount"
            ));
          }
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
          alreadyWarnedForDeepEquality = prevDeepEquality;
        }
        function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {
          includeWorkInProgressEffects = includeWorkInProgressEffects && (0 !== (parentFiber.subtreeFlags & 10256) || 0 !== parentFiber.actualDuration && (null === parentFiber.alternate || parentFiber.alternate.child !== parentFiber.child));
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var nextSibling = parentFiber.sibling;
            reconnectPassiveEffects(
              finishedRoot,
              parentFiber,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects,
              null !== nextSibling ? nextSibling.actualStartTime : endTime
            );
            parentFiber = nextSibling;
          }
        }
        function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), prevDeepEquality = alreadyWarnedForDeepEquality;
          includeWorkInProgressEffects && (finishedWork.mode & ProfileMode) !== NoMode && 0 < finishedWork.actualStartTime && 0 !== (finishedWork.flags & 1) && logComponentRender(
            finishedWork,
            finishedWork.actualStartTime,
            endTime,
            inHydratedSubtree,
            committedLanes
          );
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              );
              commitHookPassiveMountEffects(finishedWork, Passive);
              break;
            case 23:
              break;
            case 22:
              var _instance2 = finishedWork.stateNode;
              null !== finishedWork.memoizedState ? _instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              ) : (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              ));
              includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              );
              includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              );
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
          alreadyWarnedForDeepEquality = prevDeepEquality;
        }
        function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, endTime$jscomp$0) {
          if (parentFiber.subtreeFlags & 10256 || 0 !== parentFiber.actualDuration && (null === parentFiber.alternate || parentFiber.alternate.child !== parentFiber.child))
            for (var child = parentFiber.child; null !== child; ) {
              parentFiber = child.sibling;
              var finishedRoot = finishedRoot$jscomp$0, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, endTime = null !== parentFiber ? parentFiber.actualStartTime : endTime$jscomp$0, prevDeepEquality = alreadyWarnedForDeepEquality;
              (child.mode & ProfileMode) !== NoMode && 0 < child.actualStartTime && 0 !== (child.flags & 1) && logComponentRender(
                child,
                child.actualStartTime,
                endTime,
                inHydratedSubtree,
                committedLanes
              );
              var flags = child.flags;
              switch (child.tag) {
                case 22:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    child,
                    committedLanes,
                    committedTransitions,
                    endTime
                  );
                  flags & 2048 && commitOffscreenPassiveMountEffects(child.alternate, child);
                  break;
                case 24:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    child,
                    committedLanes,
                    committedTransitions,
                    endTime
                  );
                  flags & 2048 && commitCachePassiveMountEffect(child.alternate, child);
                  break;
                default:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    child,
                    committedLanes,
                    committedTransitions,
                    endTime
                  );
              }
              alreadyWarnedForDeepEquality = prevDeepEquality;
              child = parentFiber;
            }
        }
        function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
          if (parentFiber.subtreeFlags & suspenseyCommitFlag)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              accumulateSuspenseyCommitOnFiber(
                parentFiber,
                committedLanes,
                suspendedState
              ), parentFiber = parentFiber.sibling;
        }
        function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
          switch (fiber.tag) {
            case 26:
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              );
              fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
                suspendedState,
                currentHoistableRoot,
                fiber.memoizedState,
                fiber.memoizedProps
              );
              break;
            case 5:
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              );
              break;
            case 3:
            case 4:
              var previousHoistableRoot = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                fiber.stateNode.containerInfo
              );
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              );
              currentHoistableRoot = previousHoistableRoot;
              break;
            case 22:
              null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              ), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              ));
              break;
            default:
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              );
          }
        }
        function detachAlternateSiblings(parentFiber) {
          var previousFiber = parentFiber.alternate;
          if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
            previousFiber.child = null;
            do
              previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
            while (null !== parentFiber);
          }
        }
        function recursivelyTraversePassiveUnmountEffects(parentFiber) {
          var deletions = parentFiber.deletions;
          if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions)
              for (var i = 0; i < deletions.length; i++) {
                var childToDelete = deletions[i], prevEffectStart = pushComponentEffectStart();
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                  childToDelete,
                  parentFiber
                );
                (childToDelete.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                  childToDelete,
                  componentEffectStartTime,
                  componentEffectEndTime,
                  "Unmount"
                );
                popComponentEffectStart(prevEffectStart);
              }
            detachAlternateSiblings(parentFiber);
          }
          if (parentFiber.subtreeFlags & 10256)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
        }
        function commitPassiveUnmountOnFiber(finishedWork) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(
                finishedWork,
                finishedWork.return,
                Passive | HasEffect
              );
              break;
            case 3:
              var prevProfilerEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevProfilerEffectDuration);
              break;
            case 12:
              prevProfilerEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevProfilerEffectDuration);
              break;
            case 22:
              prevProfilerEffectDuration = finishedWork.stateNode;
              null !== finishedWork.memoizedState && prevProfilerEffectDuration._visibility & OffscreenPassiveEffectsConnected && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevProfilerEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork), (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                finishedWork,
                componentEffectStartTime,
                componentEffectEndTime,
                "Disconnect"
              )) : recursivelyTraversePassiveUnmountEffects(finishedWork);
              break;
            default:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
          componentEffectErrors = prevEffectErrors;
        }
        function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
          var deletions = parentFiber.deletions;
          if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions)
              for (var i = 0; i < deletions.length; i++) {
                var childToDelete = deletions[i], prevEffectStart = pushComponentEffectStart();
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                  childToDelete,
                  parentFiber
                );
                (childToDelete.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                  childToDelete,
                  componentEffectStartTime,
                  componentEffectEndTime,
                  "Unmount"
                );
                popComponentEffectStart(prevEffectStart);
              }
            detachAlternateSiblings(parentFiber);
          }
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;
        }
        function disconnectPassiveEffect(finishedWork) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              commitHookPassiveUnmountEffects(
                finishedWork,
                finishedWork.return,
                Passive
              );
              recursivelyTraverseDisconnectPassiveEffects(finishedWork);
              break;
            case 22:
              var instance = finishedWork.stateNode;
              instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));
              break;
            default:
              recursivelyTraverseDisconnectPassiveEffects(finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
          componentEffectErrors = prevEffectErrors;
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor$jscomp$0) {
          for (; null !== nextEffect; ) {
            var fiber = nextEffect, current2 = fiber, nearestMountedAncestor = nearestMountedAncestor$jscomp$0, prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
            switch (current2.tag) {
              case 0:
              case 11:
              case 15:
                commitHookPassiveUnmountEffects(
                  current2,
                  nearestMountedAncestor,
                  Passive
                );
                break;
              case 23:
              case 22:
                null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (nearestMountedAncestor = current2.memoizedState.cachePool.pool, null != nearestMountedAncestor && retainCache(nearestMountedAncestor));
                break;
              case 24:
                releaseCache(current2.memoizedState.cache);
            }
            (current2.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
              current2,
              componentEffectStartTime,
              componentEffectEndTime,
              componentEffectDuration,
              componentEffectErrors
            );
            popComponentEffectStart(prevEffectStart);
            popComponentEffectDuration(prevEffectDuration);
            componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
            componentEffectErrors = prevEffectErrors;
            current2 = fiber.child;
            if (null !== current2) current2.return = fiber, nextEffect = current2;
            else
              a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
                current2 = nextEffect;
                prevEffectStart = current2.sibling;
                prevEffectDuration = current2.return;
                detachFiberAfterEffects(current2);
                if (current2 === fiber) {
                  nextEffect = null;
                  break a;
                }
                if (null !== prevEffectStart) {
                  prevEffectStart.return = prevEffectDuration;
                  nextEffect = prevEffectStart;
                  break a;
                }
                nextEffect = prevEffectDuration;
              }
          }
        }
        function onCommitRoot() {
          commitHooks.forEach(function(commitHook) {
            return commitHook();
          });
        }
        function isConcurrentActEnvironment() {
          var isReactActEnvironmentGlobal = "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;
          isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error(
            "The current testing environment is not configured to support act(...)"
          );
          return isReactActEnvironmentGlobal;
        }
        function requestUpdateLane(fiber) {
          if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes)
            return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
          var transition = ReactSharedInternals.T;
          return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = /* @__PURE__ */ new Set()), transition._updatedFibers.add(fiber), requestTransitionLane()) : resolveUpdatePriority();
        }
        function requestDeferredLane() {
          if (0 === workInProgressDeferredLane)
            if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
              var lane = nextTransitionDeferredLane;
              nextTransitionDeferredLane <<= 1;
              0 === (nextTransitionDeferredLane & 3932160) && (nextTransitionDeferredLane = 262144);
              workInProgressDeferredLane = lane;
            } else workInProgressDeferredLane = 536870912;
          lane = suspenseHandlerStackCursor.current;
          null !== lane && (lane.flags |= 32);
          return workInProgressDeferredLane;
        }
        function scheduleUpdateOnFiber(root2, fiber, lane) {
          isRunningInsertionEffect && console.error("useInsertionEffect must not schedule updates.");
          isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = true);
          if (root2 === workInProgressRoot && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root2.cancelPendingCommit)
            prepareFreshStack(root2, 0), markRootSuspended(
              root2,
              workInProgressRootRenderLanes,
              workInProgressDeferredLane,
              false
            );
          markRootUpdated$1(root2, lane);
          if ((executionContext & RenderContext) !== NoContext && root2 === workInProgressRoot) {
            if (isRendering)
              switch (fiber.tag) {
                case 0:
                case 11:
                case 15:
                  root2 = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                  didWarnAboutUpdateInRenderForAnotherComponent.has(root2) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root2), fiber = getComponentNameFromFiber(fiber) || "Unknown", console.error(
                    "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                    fiber,
                    root2,
                    root2
                  ));
                  break;
                case 1:
                  didWarnAboutUpdateInRender || (console.error(
                    "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
                  ), didWarnAboutUpdateInRender = true);
              }
          } else
            isDevToolsPresent && addFiberToLanesMap(root2, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root2 === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(
              root2,
              workInProgressRootRenderLanes,
              workInProgressDeferredLane,
              false
            )), ensureRootIsScheduled(root2);
        }
        function performWorkOnRoot(root2, lanes, forceSync) {
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
            throw Error("Should not already be working.");
          if (0 !== workInProgressRootRenderLanes && null !== workInProgress) {
            var yieldedFiber = workInProgress, yieldEndTime = now$1();
            switch (yieldReason) {
              case SuspendedOnImmediate:
              case SuspendedOnData:
                var startTime = yieldStartTime;
                supportsUserTiming && ((yieldedFiber = yieldedFiber._debugTask) ? yieldedFiber.run(
                  console.timeStamp.bind(
                    console,
                    "Suspended",
                    startTime,
                    yieldEndTime,
                    COMPONENTS_TRACK,
                    void 0,
                    "primary-light"
                  )
                ) : console.timeStamp(
                  "Suspended",
                  startTime,
                  yieldEndTime,
                  COMPONENTS_TRACK,
                  void 0,
                  "primary-light"
                ));
                break;
              case SuspendedOnAction:
                startTime = yieldStartTime;
                supportsUserTiming && ((yieldedFiber = yieldedFiber._debugTask) ? yieldedFiber.run(
                  console.timeStamp.bind(
                    console,
                    "Action",
                    startTime,
                    yieldEndTime,
                    COMPONENTS_TRACK,
                    void 0,
                    "primary-light"
                  )
                ) : console.timeStamp(
                  "Action",
                  startTime,
                  yieldEndTime,
                  COMPONENTS_TRACK,
                  void 0,
                  "primary-light"
                ));
                break;
              default:
                supportsUserTiming && (yieldedFiber = yieldEndTime - yieldStartTime, 3 > yieldedFiber || console.timeStamp(
                  "Blocked",
                  yieldStartTime,
                  yieldEndTime,
                  COMPONENTS_TRACK,
                  void 0,
                  5 > yieldedFiber ? "primary-light" : 10 > yieldedFiber ? "primary" : 100 > yieldedFiber ? "primary-dark" : "error"
                ));
            }
          }
          startTime = (forceSync = !forceSync && 0 === (lanes & 127) && 0 === (lanes & root2.expiredLanes) || checkIfRootIsPrerendering(root2, lanes)) ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes, true);
          var renderWasConcurrent = forceSync;
          do {
            if (startTime === RootInProgress) {
              workInProgressRootIsPrerendering && !forceSync && markRootSuspended(root2, lanes, 0, false);
              lanes = workInProgressSuspendedReason;
              yieldStartTime = now();
              yieldReason = lanes;
              break;
            } else {
              yieldedFiber = now$1();
              yieldEndTime = root2.current.alternate;
              if (renderWasConcurrent && !isRenderConsistentWithExternalStores(yieldEndTime)) {
                setCurrentTrackFromLanes(lanes);
                yieldEndTime = renderStartTime;
                startTime = yieldedFiber;
                !supportsUserTiming || startTime <= yieldEndTime || (workInProgressUpdateTask ? workInProgressUpdateTask.run(
                  console.timeStamp.bind(
                    console,
                    "Teared Render",
                    yieldEndTime,
                    startTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    "error"
                  )
                ) : console.timeStamp(
                  "Teared Render",
                  yieldEndTime,
                  startTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  "error"
                ));
                finalizeRender(lanes, yieldedFiber);
                startTime = renderRootSync(root2, lanes, false);
                renderWasConcurrent = false;
                continue;
              }
              if (startTime === RootErrored) {
                renderWasConcurrent = lanes;
                if (root2.errorRecoveryDisabledLanes & renderWasConcurrent)
                  var errorRetryLanes = 0;
                else
                  errorRetryLanes = root2.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;
                if (0 !== errorRetryLanes) {
                  setCurrentTrackFromLanes(lanes);
                  logErroredRenderPhase(
                    renderStartTime,
                    yieldedFiber,
                    lanes,
                    workInProgressUpdateTask
                  );
                  finalizeRender(lanes, yieldedFiber);
                  lanes = errorRetryLanes;
                  a: {
                    yieldedFiber = root2;
                    startTime = renderWasConcurrent;
                    renderWasConcurrent = workInProgressRootConcurrentErrors;
                    var wasRootDehydrated = yieldedFiber.current.memoizedState.isDehydrated;
                    wasRootDehydrated && (prepareFreshStack(yieldedFiber, errorRetryLanes).flags |= 256);
                    errorRetryLanes = renderRootSync(
                      yieldedFiber,
                      errorRetryLanes,
                      false
                    );
                    if (errorRetryLanes !== RootErrored) {
                      if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                        yieldedFiber.errorRecoveryDisabledLanes |= startTime;
                        workInProgressRootInterleavedUpdatedLanes |= startTime;
                        startTime = RootSuspendedWithDelay;
                        break a;
                      }
                      yieldedFiber = workInProgressRootRecoverableErrors;
                      workInProgressRootRecoverableErrors = renderWasConcurrent;
                      null !== yieldedFiber && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = yieldedFiber : workInProgressRootRecoverableErrors.push.apply(
                        workInProgressRootRecoverableErrors,
                        yieldedFiber
                      ));
                    }
                    startTime = errorRetryLanes;
                  }
                  renderWasConcurrent = false;
                  if (startTime !== RootErrored) continue;
                  else yieldedFiber = now$1();
                }
              }
              if (startTime === RootFatalErrored) {
                setCurrentTrackFromLanes(lanes);
                logErroredRenderPhase(
                  renderStartTime,
                  yieldedFiber,
                  lanes,
                  workInProgressUpdateTask
                );
                finalizeRender(lanes, yieldedFiber);
                prepareFreshStack(root2, 0);
                markRootSuspended(root2, lanes, 0, true);
                break;
              }
              a: {
                forceSync = root2;
                switch (startTime) {
                  case RootInProgress:
                  case RootFatalErrored:
                    throw Error("Root did not complete. This is a bug in React.");
                  case RootSuspendedWithDelay:
                    if ((lanes & 4194048) !== lanes) break;
                  case RootSuspendedAtTheShell:
                    setCurrentTrackFromLanes(lanes);
                    logSuspendedRenderPhase(
                      renderStartTime,
                      yieldedFiber,
                      lanes,
                      workInProgressUpdateTask
                    );
                    finalizeRender(lanes, yieldedFiber);
                    yieldEndTime = lanes;
                    0 !== (yieldEndTime & 127) ? blockingSuspendedTime = yieldedFiber : 0 !== (yieldEndTime & 4194048) && (transitionSuspendedTime = yieldedFiber);
                    markRootSuspended(
                      forceSync,
                      lanes,
                      workInProgressDeferredLane,
                      !workInProgressRootDidSkipSuspendedSiblings
                    );
                    break a;
                  case RootErrored:
                    workInProgressRootRecoverableErrors = null;
                    break;
                  case RootSuspended:
                  case RootCompleted:
                    break;
                  default:
                    throw Error("Unknown root exit status.");
                }
                if (null !== ReactSharedInternals.actQueue)
                  commitRoot(
                    forceSync,
                    yieldEndTime,
                    lanes,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    startTime,
                    null,
                    null,
                    renderStartTime,
                    yieldedFiber
                  );
                else {
                  if ((lanes & 62914560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < renderWasConcurrent)) {
                    markRootSuspended(
                      forceSync,
                      lanes,
                      workInProgressDeferredLane,
                      !workInProgressRootDidSkipSuspendedSiblings
                    );
                    if (0 !== getNextLanes(forceSync, 0, true)) break a;
                    pendingEffectsLanes = lanes;
                    forceSync.timeoutHandle = scheduleTimeout(
                      commitRootWhenReady.bind(
                        null,
                        forceSync,
                        yieldEndTime,
                        workInProgressRootRecoverableErrors,
                        workInProgressTransitions,
                        workInProgressRootDidIncludeRecursiveRenderUpdate,
                        lanes,
                        workInProgressDeferredLane,
                        workInProgressRootInterleavedUpdatedLanes,
                        workInProgressSuspendedRetryLanes,
                        workInProgressRootDidSkipSuspendedSiblings,
                        startTime,
                        "Throttled",
                        renderStartTime,
                        yieldedFiber
                      ),
                      renderWasConcurrent
                    );
                    break a;
                  }
                  commitRootWhenReady(
                    forceSync,
                    yieldEndTime,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    startTime,
                    null,
                    renderStartTime,
                    yieldedFiber
                  );
                }
              }
            }
            break;
          } while (1);
          ensureRootIsScheduled(root2);
        }
        function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
          root2.timeoutHandle = noTimeout;
          var subtreeFlags = finishedWork.subtreeFlags, suspendedState = null;
          if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408)) {
            if (suspendedState = {
              stylesheets: null,
              count: 0,
              imgCount: 0,
              imgBytes: 0,
              suspenseyImages: [],
              waitingForImages: true,
              waitingForViewTransition: false,
              unsuspend: noop$1
            }, accumulateSuspenseyCommitOnFiber(finishedWork, lanes, suspendedState), subtreeFlags = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now$1() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now$1() : 0, subtreeFlags = waitForCommitToBeReady(suspendedState, subtreeFlags), null !== subtreeFlags) {
              pendingEffectsLanes = lanes;
              root2.cancelPendingCommit = subtreeFlags(
                commitRoot.bind(
                  null,
                  root2,
                  finishedWork,
                  lanes,
                  recoverableErrors,
                  transitions,
                  didIncludeRenderPhaseUpdate,
                  spawnedLane,
                  updatedLanes,
                  suspendedRetryLanes,
                  exitStatus,
                  suspendedState,
                  suspendedState.waitingForViewTransition ? "Waiting for the previous Animation" : 0 < suspendedState.count ? 0 < suspendedState.imgCount ? "Suspended on CSS and Images" : "Suspended on CSS" : 1 === suspendedState.imgCount ? "Suspended on an Image" : 0 < suspendedState.imgCount ? "Suspended on Images" : null,
                  completedRenderStartTime,
                  completedRenderEndTime
                )
              );
              markRootSuspended(
                root2,
                lanes,
                spawnedLane,
                !didSkipSuspendedSiblings
              );
              return;
            }
          }
          commitRoot(
            root2,
            finishedWork,
            lanes,
            recoverableErrors,
            transitions,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes,
            exitStatus,
            suspendedState,
            suspendedCommitReason,
            completedRenderStartTime,
            completedRenderEndTime
          );
        }
        function isRenderConsistentWithExternalStores(finishedWork) {
          for (var node = finishedWork; ; ) {
            var tag = node.tag;
            if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
              for (var i = 0; i < tag.length; i++) {
                var check = tag[i], getSnapshot = check.getSnapshot;
                check = check.value;
                try {
                  if (!objectIs(getSnapshot(), check)) return false;
                } catch (error) {
                  return false;
                }
              }
            tag = node.child;
            if (node.subtreeFlags & 16384 && null !== tag)
              tag.return = node, node = tag;
            else {
              if (node === finishedWork) break;
              for (; null === node.sibling; ) {
                if (null === node.return || node.return === finishedWork) return true;
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          return true;
        }
        function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
          suspendedLanes &= ~workInProgressRootPingedLanes;
          suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
          root2.suspendedLanes |= suspendedLanes;
          root2.pingedLanes &= ~suspendedLanes;
          didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
          didAttemptEntireTree = root2.expirationTimes;
          for (var lanes = suspendedLanes; 0 < lanes; ) {
            var index = 31 - clz32(lanes), lane = 1 << index;
            didAttemptEntireTree[index] = -1;
            lanes &= ~lane;
          }
          0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
        }
        function flushSyncWork$1() {
          return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
        }
        function resetWorkInProgressStack() {
          if (null !== workInProgress) {
            if (workInProgressSuspendedReason === NotSuspended)
              var interruptedWork = workInProgress.return;
            else
              interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
            for (; null !== interruptedWork; )
              unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
            workInProgress = null;
          }
        }
        function finalizeRender(lanes, finalizationTime) {
          0 !== (lanes & 127) && (blockingClampTime = finalizationTime);
          0 !== (lanes & 4194048) && (transitionClampTime = finalizationTime);
          0 !== (lanes & 62914560) && (retryClampTime = finalizationTime);
          0 !== (lanes & 2080374784) && (idleClampTime = finalizationTime);
        }
        function prepareFreshStack(root2, lanes) {
          supportsUserTiming && (console.timeStamp(
            "Blocking Track",
            3e-3,
            3e-3,
            "Blocking",
            LANES_TRACK_GROUP,
            "primary-light"
          ), console.timeStamp(
            "Transition Track",
            3e-3,
            3e-3,
            "Transition",
            LANES_TRACK_GROUP,
            "primary-light"
          ), console.timeStamp(
            "Suspense Track",
            3e-3,
            3e-3,
            "Suspense",
            LANES_TRACK_GROUP,
            "primary-light"
          ), console.timeStamp(
            "Idle Track",
            3e-3,
            3e-3,
            "Idle",
            LANES_TRACK_GROUP,
            "primary-light"
          ));
          var previousRenderStartTime = renderStartTime;
          renderStartTime = now();
          if (0 !== workInProgressRootRenderLanes && 0 < previousRenderStartTime) {
            setCurrentTrackFromLanes(workInProgressRootRenderLanes);
            if (workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootSuspendedWithDelay)
              logSuspendedRenderPhase(
                previousRenderStartTime,
                renderStartTime,
                lanes,
                workInProgressUpdateTask
              );
            else {
              var endTime = renderStartTime, debugTask = workInProgressUpdateTask;
              if (supportsUserTiming && !(endTime <= previousRenderStartTime)) {
                var color = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", label = (lanes & 536870912) === lanes ? "Prewarm" : (lanes & 201326741) === lanes ? "Interrupted Hydration" : "Interrupted Render";
                debugTask ? debugTask.run(
                  console.timeStamp.bind(
                    console,
                    label,
                    previousRenderStartTime,
                    endTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    color
                  )
                ) : console.timeStamp(
                  label,
                  previousRenderStartTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  color
                );
              }
            }
            finalizeRender(workInProgressRootRenderLanes, renderStartTime);
          }
          previousRenderStartTime = workInProgressUpdateTask;
          workInProgressUpdateTask = null;
          if (0 !== (lanes & 127)) {
            workInProgressUpdateTask = blockingUpdateTask;
            debugTask = 0 <= blockingUpdateTime && blockingUpdateTime < blockingClampTime ? blockingClampTime : blockingUpdateTime;
            endTime = 0 <= blockingEventTime && blockingEventTime < blockingClampTime ? blockingClampTime : blockingEventTime;
            color = 0 <= endTime ? endTime : 0 <= debugTask ? debugTask : renderStartTime;
            0 <= blockingSuspendedTime ? (setCurrentTrackFromLanes(2), logSuspendedWithDelayPhase(
              blockingSuspendedTime,
              color,
              lanes,
              previousRenderStartTime
            )) : 0 !== (animatingLanes & 127) && (setCurrentTrackFromLanes(2), logAnimatingPhase(blockingClampTime, color, animatingTask));
            previousRenderStartTime = debugTask;
            var eventTime = endTime, eventType = blockingEventType, eventIsRepeat = 0 < blockingEventRepeatTime, isSpawnedUpdate = blockingUpdateType === SPAWNED_UPDATE, isPingedUpdate = blockingUpdateType === PINGED_UPDATE;
            debugTask = renderStartTime;
            endTime = blockingUpdateTask;
            color = blockingUpdateMethodName;
            label = blockingUpdateComponentName;
            if (supportsUserTiming) {
              currentTrack = "Blocking";
              0 < previousRenderStartTime ? previousRenderStartTime > debugTask && (previousRenderStartTime = debugTask) : previousRenderStartTime = debugTask;
              0 < eventTime ? eventTime > previousRenderStartTime && (eventTime = previousRenderStartTime) : eventTime = previousRenderStartTime;
              if (null !== eventType && previousRenderStartTime > eventTime) {
                var color$jscomp$0 = eventIsRepeat ? "secondary-light" : "warning";
                endTime ? endTime.run(
                  console.timeStamp.bind(
                    console,
                    eventIsRepeat ? "Consecutive" : "Event: " + eventType,
                    eventTime,
                    previousRenderStartTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    color$jscomp$0
                  )
                ) : console.timeStamp(
                  eventIsRepeat ? "Consecutive" : "Event: " + eventType,
                  eventTime,
                  previousRenderStartTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  color$jscomp$0
                );
              }
              debugTask > previousRenderStartTime && (eventTime = isSpawnedUpdate ? "error" : (lanes & 738197653) === lanes ? "tertiary-light" : "primary-light", isSpawnedUpdate = isPingedUpdate ? "Promise Resolved" : isSpawnedUpdate ? "Cascading Update" : 5 < debugTask - previousRenderStartTime ? "Update Blocked" : "Update", isPingedUpdate = [], null != label && isPingedUpdate.push(["Component name", label]), null != color && isPingedUpdate.push(["Method name", color]), previousRenderStartTime = {
                start: previousRenderStartTime,
                end: debugTask,
                detail: {
                  devtools: {
                    properties: isPingedUpdate,
                    track: currentTrack,
                    trackGroup: LANES_TRACK_GROUP,
                    color: eventTime
                  }
                }
              }, endTime ? endTime.run(
                performance.measure.bind(
                  performance,
                  isSpawnedUpdate,
                  previousRenderStartTime
                )
              ) : performance.measure(isSpawnedUpdate, previousRenderStartTime));
            }
            blockingUpdateTime = -1.1;
            blockingUpdateType = 0;
            blockingUpdateComponentName = blockingUpdateMethodName = null;
            blockingSuspendedTime = -1.1;
            blockingEventRepeatTime = blockingEventTime;
            blockingEventTime = -1.1;
            blockingClampTime = now();
          }
          0 !== (lanes & 4194048) && (workInProgressUpdateTask = transitionUpdateTask, debugTask = 0 <= transitionStartTime && transitionStartTime < transitionClampTime ? transitionClampTime : transitionStartTime, previousRenderStartTime = 0 <= transitionUpdateTime && transitionUpdateTime < transitionClampTime ? transitionClampTime : transitionUpdateTime, endTime = 0 <= transitionEventTime && transitionEventTime < transitionClampTime ? transitionClampTime : transitionEventTime, color = 0 <= endTime ? endTime : 0 <= previousRenderStartTime ? previousRenderStartTime : renderStartTime, 0 <= transitionSuspendedTime ? (setCurrentTrackFromLanes(256), logSuspendedWithDelayPhase(
            transitionSuspendedTime,
            color,
            lanes,
            workInProgressUpdateTask
          )) : 0 !== (animatingLanes & 4194048) && (setCurrentTrackFromLanes(256), logAnimatingPhase(transitionClampTime, color, animatingTask)), isPingedUpdate = endTime, eventTime = transitionEventType, eventType = 0 < transitionEventRepeatTime, eventIsRepeat = transitionUpdateType === PINGED_UPDATE, color = renderStartTime, endTime = transitionUpdateTask, label = transitionUpdateMethodName, isSpawnedUpdate = transitionUpdateComponentName, supportsUserTiming && (currentTrack = "Transition", 0 < previousRenderStartTime ? previousRenderStartTime > color && (previousRenderStartTime = color) : previousRenderStartTime = color, 0 < debugTask ? debugTask > previousRenderStartTime && (debugTask = previousRenderStartTime) : debugTask = previousRenderStartTime, 0 < isPingedUpdate ? isPingedUpdate > debugTask && (isPingedUpdate = debugTask) : isPingedUpdate = debugTask, debugTask > isPingedUpdate && null !== eventTime && (color$jscomp$0 = eventType ? "secondary-light" : "warning", endTime ? endTime.run(
            console.timeStamp.bind(
              console,
              eventType ? "Consecutive" : "Event: " + eventTime,
              isPingedUpdate,
              debugTask,
              currentTrack,
              LANES_TRACK_GROUP,
              color$jscomp$0
            )
          ) : console.timeStamp(
            eventType ? "Consecutive" : "Event: " + eventTime,
            isPingedUpdate,
            debugTask,
            currentTrack,
            LANES_TRACK_GROUP,
            color$jscomp$0
          )), previousRenderStartTime > debugTask && (endTime ? endTime.run(
            console.timeStamp.bind(
              console,
              "Action",
              debugTask,
              previousRenderStartTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "primary-dark"
            )
          ) : console.timeStamp(
            "Action",
            debugTask,
            previousRenderStartTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "primary-dark"
          )), color > previousRenderStartTime && (debugTask = eventIsRepeat ? "Promise Resolved" : 5 < color - previousRenderStartTime ? "Update Blocked" : "Update", isPingedUpdate = [], null != isSpawnedUpdate && isPingedUpdate.push(["Component name", isSpawnedUpdate]), null != label && isPingedUpdate.push(["Method name", label]), previousRenderStartTime = {
            start: previousRenderStartTime,
            end: color,
            detail: {
              devtools: {
                properties: isPingedUpdate,
                track: currentTrack,
                trackGroup: LANES_TRACK_GROUP,
                color: "primary-light"
              }
            }
          }, endTime ? endTime.run(
            performance.measure.bind(
              performance,
              debugTask,
              previousRenderStartTime
            )
          ) : performance.measure(debugTask, previousRenderStartTime))), transitionUpdateTime = transitionStartTime = -1.1, transitionUpdateType = 0, transitionSuspendedTime = -1.1, transitionEventRepeatTime = transitionEventTime, transitionEventTime = -1.1, transitionClampTime = now());
          0 !== (lanes & 62914560) && 0 !== (animatingLanes & 62914560) && (setCurrentTrackFromLanes(4194304), logAnimatingPhase(retryClampTime, renderStartTime, animatingTask));
          0 !== (lanes & 2080374784) && 0 !== (animatingLanes & 2080374784) && (setCurrentTrackFromLanes(268435456), logAnimatingPhase(idleClampTime, renderStartTime, animatingTask));
          previousRenderStartTime = root2.timeoutHandle;
          previousRenderStartTime !== noTimeout && (root2.timeoutHandle = noTimeout, cancelTimeout(previousRenderStartTime));
          previousRenderStartTime = root2.cancelPendingCommit;
          null !== previousRenderStartTime && (root2.cancelPendingCommit = null, previousRenderStartTime());
          pendingEffectsLanes = 0;
          resetWorkInProgressStack();
          workInProgressRoot = root2;
          workInProgress = previousRenderStartTime = createWorkInProgress(
            root2.current,
            null
          );
          workInProgressRootRenderLanes = lanes;
          workInProgressSuspendedReason = NotSuspended;
          workInProgressThrownValue = null;
          workInProgressRootDidSkipSuspendedSiblings = false;
          workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
          workInProgressRootDidAttachPingListener = false;
          workInProgressRootExitStatus = RootInProgress;
          workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;
          workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
          workInProgressRootDidIncludeRecursiveRenderUpdate = false;
          0 !== (lanes & 8) && (lanes |= lanes & 32);
          endTime = root2.entangledLanes;
          if (0 !== endTime)
            for (root2 = root2.entanglements, endTime &= lanes; 0 < endTime; )
              debugTask = 31 - clz32(endTime), color = 1 << debugTask, lanes |= root2[debugTask], endTime &= ~color;
          entangledRenderLanes = lanes;
          finishQueueingConcurrentUpdates();
          root2 = getCurrentTime();
          1e3 < root2 - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = root2);
          ReactStrictModeWarnings.discardPendingWarnings();
          return previousRenderStartTime;
        }
        function handleThrow(root2, thrownValue) {
          currentlyRenderingFiber = null;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          ReactSharedInternals.getCurrentStack = null;
          isRendering = false;
          current = null;
          thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;
          workInProgressThrownValue = thrownValue;
          var erroredWork = workInProgress;
          null === erroredWork ? (workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(
            root2,
            createCapturedValueAtFiber(thrownValue, root2.current)
          )) : erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDuration(erroredWork);
        }
        function shouldRemainOnPreviousScreen() {
          var handler = suspenseHandlerStackCursor.current;
          return null === handler ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : false;
        }
        function pushDispatcher() {
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
        }
        function pushAsyncDispatcher() {
          var prevAsyncDispatcher = ReactSharedInternals.A;
          ReactSharedInternals.A = DefaultAsyncDispatcher;
          return prevAsyncDispatcher;
        }
        function markRenderDerivedCause(fiber) {
          null === workInProgressUpdateTask && (workInProgressUpdateTask = null == fiber._debugTask ? null : fiber._debugTask);
        }
        function renderDidSuspendDelayIfPossible() {
          workInProgressRootExitStatus = RootSuspendedWithDelay;
          workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
          0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
            workInProgressRoot,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        }
        function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root2.memoizedUpdaters;
              0 < memoizedUpdaters.size && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
              movePendingFibersToMemoized(root2, lanes);
            }
            workInProgressTransitions = null;
            prepareFreshStack(root2, lanes);
          }
          lanes = false;
          memoizedUpdaters = workInProgressRootExitStatus;
          a: do
            try {
              if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {
                var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
                switch (workInProgressSuspendedReason) {
                  case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    memoizedUpdaters = RootSuspendedAtTheShell;
                    break a;
                  case SuspendedOnImmediate:
                  case SuspendedOnData:
                  case SuspendedOnAction:
                  case SuspendedOnDeprecatedThrowPromise:
                    null === suspenseHandlerStackCursor.current && (lanes = true);
                    var reason = workInProgressSuspendedReason;
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                    if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                      memoizedUpdaters = RootInProgress;
                      break a;
                    }
                    break;
                  default:
                    reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                }
              }
              workLoopSync();
              memoizedUpdaters = workInProgressRootExitStatus;
              break;
            } catch (thrownValue$8) {
              handleThrow(root2, thrownValue$8);
            }
          while (1);
          lanes && root2.shellSuspendCounter++;
          resetContextDependencies();
          executionContext = prevExecutionContext;
          ReactSharedInternals.H = prevDispatcher;
          ReactSharedInternals.A = prevAsyncDispatcher;
          null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
          return memoizedUpdaters;
        }
        function workLoopSync() {
          for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
        }
        function renderRootConcurrent(root2, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root2.memoizedUpdaters;
              0 < memoizedUpdaters.size && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
              movePendingFibersToMemoized(root2, lanes);
            }
            workInProgressTransitions = null;
            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
            prepareFreshStack(root2, lanes);
          } else
            workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
              root2,
              lanes
            );
          a: do
            try {
              if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress)
                b: switch (lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason) {
                  case SuspendedOnError:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnError
                    );
                    break;
                  case SuspendedOnData:
                  case SuspendedOnAction:
                    if (isThenableResolved(memoizedUpdaters)) {
                      workInProgressSuspendedReason = NotSuspended;
                      workInProgressThrownValue = null;
                      replaySuspendedUnitOfWork(lanes);
                      break;
                    }
                    lanes = function() {
                      workInProgressSuspendedReason !== SuspendedOnData && workInProgressSuspendedReason !== SuspendedOnAction || workInProgressRoot !== root2 || (workInProgressSuspendedReason = SuspendedAndReadyToContinue);
                      ensureRootIsScheduled(root2);
                    };
                    memoizedUpdaters.then(lanes, lanes);
                    break a;
                  case SuspendedOnImmediate:
                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;
                    break a;
                  case SuspendedOnInstance:
                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
                    break a;
                  case SuspendedAndReadyToContinue:
                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedAndReadyToContinue
                    ));
                    break;
                  case SuspendedOnInstanceAndReadyToContinue:
                    var resource = null;
                    switch (workInProgress.tag) {
                      case 26:
                        resource = workInProgress.memoizedState;
                      case 5:
                      case 27:
                        var hostFiber = workInProgress;
                        if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {
                          workInProgressSuspendedReason = NotSuspended;
                          workInProgressThrownValue = null;
                          var sibling = hostFiber.sibling;
                          if (null !== sibling) workInProgress = sibling;
                          else {
                            var returnFiber = hostFiber.return;
                            null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                          }
                          break b;
                        }
                        break;
                      default:
                        console.error(
                          "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                        );
                    }
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnInstanceAndReadyToContinue
                    );
                    break;
                  case SuspendedOnDeprecatedThrowPromise:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnDeprecatedThrowPromise
                    );
                    break;
                  case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    workInProgressRootExitStatus = RootSuspendedAtTheShell;
                    break a;
                  default:
                    throw Error(
                      "Unexpected SuspendedReason. This is a bug in React."
                    );
                }
              null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrentByScheduler();
              break;
            } catch (thrownValue$9) {
              handleThrow(root2, thrownValue$9);
            }
          while (1);
          resetContextDependencies();
          ReactSharedInternals.H = prevDispatcher;
          ReactSharedInternals.A = prevAsyncDispatcher;
          executionContext = prevExecutionContext;
          if (null !== workInProgress) return RootInProgress;
          workInProgressRoot = null;
          workInProgressRootRenderLanes = 0;
          finishQueueingConcurrentUpdates();
          return workInProgressRootExitStatus;
        }
        function workLoopConcurrentByScheduler() {
          for (; null !== workInProgress && !shouldYield(); )
            performUnitOfWork(workInProgress);
        }
        function performUnitOfWork(unitOfWork) {
          var current2 = unitOfWork.alternate;
          (unitOfWork.mode & ProfileMode) !== NoMode ? (startProfilerTimer(unitOfWork), current2 = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current2,
            unitOfWork,
            entangledRenderLanes
          ), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current2 = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current2,
            unitOfWork,
            entangledRenderLanes
          );
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          null === current2 ? completeUnitOfWork(unitOfWork) : workInProgress = current2;
        }
        function replaySuspendedUnitOfWork(unitOfWork) {
          var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
        }
        function replayBeginWork(unitOfWork) {
          var current2 = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
          isProfilingMode && startProfilerTimer(unitOfWork);
          switch (unitOfWork.tag) {
            case 15:
            case 0:
              current2 = replayFunctionComponent(
                current2,
                unitOfWork,
                unitOfWork.pendingProps,
                unitOfWork.type,
                void 0,
                workInProgressRootRenderLanes
              );
              break;
            case 11:
              current2 = replayFunctionComponent(
                current2,
                unitOfWork,
                unitOfWork.pendingProps,
                unitOfWork.type.render,
                unitOfWork.ref,
                workInProgressRootRenderLanes
              );
              break;
            case 5:
              resetHooksOnUnwind(unitOfWork);
            default:
              unwindInterruptedWork(current2, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current2 = beginWork(current2, unitOfWork, entangledRenderLanes);
          }
          isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
          return current2;
        }
        function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
          resetContextDependencies();
          resetHooksOnUnwind(unitOfWork);
          thenableState$1 = null;
          thenableIndexCounter$1 = 0;
          var returnFiber = unitOfWork.return;
          try {
            if (throwException(
              root2,
              returnFiber,
              unitOfWork,
              thrownValue,
              workInProgressRootRenderLanes
            )) {
              workInProgressRootExitStatus = RootFatalErrored;
              logUncaughtError(
                root2,
                createCapturedValueAtFiber(thrownValue, root2.current)
              );
              workInProgress = null;
              return;
            }
          } catch (error) {
            if (null !== returnFiber) throw workInProgress = returnFiber, error;
            workInProgressRootExitStatus = RootFatalErrored;
            logUncaughtError(
              root2,
              createCapturedValueAtFiber(thrownValue, root2.current)
            );
            workInProgress = null;
            return;
          }
          if (unitOfWork.flags & 32768) {
            if (isHydrating || suspendedReason === SuspendedOnError) root2 = true;
            else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
              root2 = false;
            else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnAction || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise)
              suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
            unwindUnitOfWork(unitOfWork, root2);
          } else completeUnitOfWork(unitOfWork);
        }
        function completeUnitOfWork(unitOfWork) {
          var completedWork = unitOfWork;
          do {
            if (0 !== (completedWork.flags & 32768)) {
              unwindUnitOfWork(
                completedWork,
                workInProgressRootDidSkipSuspendedSiblings
              );
              return;
            }
            var current2 = completedWork.alternate;
            unitOfWork = completedWork.return;
            startProfilerTimer(completedWork);
            current2 = runWithFiberInDEV(
              completedWork,
              completeWork,
              current2,
              completedWork,
              entangledRenderLanes
            );
            (completedWork.mode & ProfileMode) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
            if (null !== current2) {
              workInProgress = current2;
              return;
            }
            completedWork = completedWork.sibling;
            if (null !== completedWork) {
              workInProgress = completedWork;
              return;
            }
            workInProgress = completedWork = unitOfWork;
          } while (null !== completedWork);
          workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
        }
        function unwindUnitOfWork(unitOfWork, skipSiblings) {
          do {
            var next = unwindWork(unitOfWork.alternate, unitOfWork);
            if (null !== next) {
              next.flags &= 32767;
              workInProgress = next;
              return;
            }
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
              stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
              next = unitOfWork.actualDuration;
              for (var child = unitOfWork.child; null !== child; )
                next += child.actualDuration, child = child.sibling;
              unitOfWork.actualDuration = next;
            }
            next = unitOfWork.return;
            null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
            if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
              workInProgress = unitOfWork;
              return;
            }
            workInProgress = unitOfWork = next;
          } while (null !== unitOfWork);
          workInProgressRootExitStatus = RootSuspendedAtTheShell;
          workInProgress = null;
        }
        function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, suspendedState, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
          root2.cancelPendingCommit = null;
          do
            flushPendingEffects();
          while (pendingEffectsStatus !== NO_PENDING_EFFECTS);
          ReactStrictModeWarnings.flushLegacyContextWarning();
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
            throw Error("Should not already be working.");
          setCurrentTrackFromLanes(lanes);
          exitStatus === RootErrored ? logErroredRenderPhase(
            completedRenderStartTime,
            completedRenderEndTime,
            lanes,
            workInProgressUpdateTask
          ) : null !== recoverableErrors ? logRecoveredRenderPhase(
            completedRenderStartTime,
            completedRenderEndTime,
            lanes,
            recoverableErrors,
            null !== finishedWork && null !== finishedWork.alternate && finishedWork.alternate.memoizedState.isDehydrated && 0 !== (finishedWork.flags & 256),
            workInProgressUpdateTask
          ) : logRenderPhase(
            completedRenderStartTime,
            completedRenderEndTime,
            lanes,
            workInProgressUpdateTask
          );
          if (null !== finishedWork) {
            0 === lanes && console.error(
              "finishedLanes should not be empty during a commit. This is a bug in React."
            );
            if (finishedWork === root2.current)
              throw Error(
                "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
              );
            didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
            didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
            markRootFinished(
              root2,
              lanes,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes
            );
            root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
            pendingFinishedWork = finishedWork;
            pendingEffectsRoot = root2;
            pendingEffectsLanes = lanes;
            pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
            pendingPassiveTransitions = transitions;
            pendingRecoverableErrors = recoverableErrors;
            pendingEffectsRenderEndTime = completedRenderEndTime;
            pendingSuspendedCommitReason = suspendedCommitReason;
            pendingDelayedCommitReason = IMMEDIATE_COMMIT;
            pendingSuspendedViewTransitionReason = null;
            0 !== finishedWork.actualDuration || 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
              schedulerEvent = window.event;
              pendingDelayedCommitReason === IMMEDIATE_COMMIT && (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);
              flushPassiveEffects();
              return null;
            })) : (root2.callbackNode = null, root2.callbackPriority = 0);
            commitErrors = null;
            commitStartTime = now();
            null !== suspendedCommitReason && logSuspendedCommitPhase(
              completedRenderEndTime,
              commitStartTime,
              suspendedCommitReason,
              workInProgressUpdateTask
            );
            recoverableErrors = 0 !== (finishedWork.flags & 13878);
            if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
              recoverableErrors = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              transitions = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              spawnedLane = executionContext;
              executionContext |= CommitContext;
              try {
                commitBeforeMutationEffects(root2, finishedWork, lanes);
              } finally {
                executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
              }
            }
            pendingEffectsStatus = PENDING_MUTATION_PHASE;
            flushMutationEffects();
            flushLayoutEffects();
            flushSpawnedWork();
          }
        }
        function flushMutationEffects() {
          if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
            if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
              rootMutationHasEffect = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              var previousPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              try {
                inProgressLanes = lanes;
                inProgressRoot = root2;
                resetComponentEffectTimers();
                commitMutationEffectsOnFiber(finishedWork, root2);
                inProgressRoot = inProgressLanes = null;
                lanes = selectionInformation;
                var curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = lanes.focusedElem, priorSelectionRange = lanes.selectionRange;
                if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
                  priorFocusedElem.ownerDocument.documentElement,
                  priorFocusedElem
                )) {
                  if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                    var start = priorSelectionRange.start, end = priorSelectionRange.end;
                    void 0 === end && (end = start);
                    if ("selectionStart" in priorFocusedElem)
                      priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                        end,
                        priorFocusedElem.value.length
                      );
                    else {
                      var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                      if (win.getSelection) {
                        var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(
                          priorSelectionRange.start,
                          length
                        ), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                        !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                        var startMarker = getNodeForCharacterOffset(
                          priorFocusedElem,
                          start$jscomp$0
                        ), endMarker = getNodeForCharacterOffset(
                          priorFocusedElem,
                          end$jscomp$0
                        );
                        if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                          var range2 = doc.createRange();
                          range2.setStart(startMarker.node, startMarker.offset);
                          selection.removeAllRanges();
                          start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range2), selection.extend(endMarker.node, endMarker.offset)) : (range2.setEnd(endMarker.node, endMarker.offset), selection.addRange(range2));
                        }
                      }
                    }
                  }
                  doc = [];
                  for (selection = priorFocusedElem; selection = selection.parentNode; )
                    1 === selection.nodeType && doc.push({
                      element: selection,
                      left: selection.scrollLeft,
                      top: selection.scrollTop
                    });
                  "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                  for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                    var info = doc[priorFocusedElem];
                    info.element.scrollLeft = info.left;
                    info.element.scrollTop = info.top;
                  }
                }
                _enabled = !!eventsEnabled;
                selectionInformation = eventsEnabled = null;
              } finally {
                executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
              }
            }
            root2.current = finishedWork;
            pendingEffectsStatus = PENDING_LAYOUT_PHASE;
          }
        }
        function flushLayoutEffects() {
          if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            var suspendedViewTransitionReason = pendingSuspendedViewTransitionReason;
            if (null !== suspendedViewTransitionReason) {
              commitStartTime = now();
              var startTime = commitEndTime, endTime = commitStartTime;
              !supportsUserTiming || endTime <= startTime || (animatingTask ? animatingTask.run(
                console.timeStamp.bind(
                  console,
                  suspendedViewTransitionReason,
                  startTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  "secondary-light"
                )
              ) : console.timeStamp(
                suspendedViewTransitionReason,
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                "secondary-light"
              ));
            }
            suspendedViewTransitionReason = pendingEffectsRoot;
            startTime = pendingFinishedWork;
            endTime = pendingEffectsLanes;
            var rootHasLayoutEffect = 0 !== (startTime.flags & 8772);
            if (0 !== (startTime.subtreeFlags & 8772) || rootHasLayoutEffect) {
              rootHasLayoutEffect = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              var _previousPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              var _prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              try {
                inProgressLanes = endTime, inProgressRoot = suspendedViewTransitionReason, resetComponentEffectTimers(), commitLayoutEffectOnFiber(
                  suspendedViewTransitionReason,
                  startTime.alternate,
                  startTime
                ), inProgressRoot = inProgressLanes = null;
              } finally {
                executionContext = _prevExecutionContext, ReactDOMSharedInternals.p = _previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
              }
            }
            suspendedViewTransitionReason = pendingEffectsRenderEndTime;
            startTime = pendingSuspendedCommitReason;
            commitEndTime = now();
            suspendedViewTransitionReason = null === startTime ? suspendedViewTransitionReason : commitStartTime;
            startTime = commitEndTime;
            endTime = pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;
            rootHasLayoutEffect = workInProgressUpdateTask;
            null !== commitErrors ? logCommitErrored(
              suspendedViewTransitionReason,
              startTime,
              commitErrors,
              false,
              rootHasLayoutEffect
            ) : !supportsUserTiming || startTime <= suspendedViewTransitionReason || (rootHasLayoutEffect ? rootHasLayoutEffect.run(
              console.timeStamp.bind(
                console,
                endTime ? "Commit Interrupted View Transition" : "Commit",
                suspendedViewTransitionReason,
                startTime,
                currentTrack,
                LANES_TRACK_GROUP,
                endTime ? "error" : "secondary-dark"
              )
            ) : console.timeStamp(
              endTime ? "Commit Interrupted View Transition" : "Commit",
              suspendedViewTransitionReason,
              startTime,
              currentTrack,
              LANES_TRACK_GROUP,
              endTime ? "error" : "secondary-dark"
            ));
            pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;
          }
        }
        function flushSpawnedWork() {
          if (pendingEffectsStatus === PENDING_SPAWNED_WORK || pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE) {
            if (pendingEffectsStatus === PENDING_SPAWNED_WORK) {
              var startViewTransitionStartTime = commitEndTime;
              commitEndTime = now();
              var endTime = commitEndTime, abortedViewTransition = pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;
              !supportsUserTiming || endTime <= startViewTransitionStartTime || (animatingTask ? animatingTask.run(
                console.timeStamp.bind(
                  console,
                  abortedViewTransition ? "Interrupted View Transition" : "Starting Animation",
                  startViewTransitionStartTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  abortedViewTransition ? "error" : "secondary-light"
                )
              ) : console.timeStamp(
                abortedViewTransition ? "Interrupted View Transition" : "Starting Animation",
                startViewTransitionStartTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                abortedViewTransition ? " error" : "secondary-light"
              ));
              pendingDelayedCommitReason !== ABORTED_VIEW_TRANSITION_COMMIT && (pendingDelayedCommitReason = ANIMATION_STARTED_COMMIT);
            }
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            requestPaint();
            startViewTransitionStartTime = pendingEffectsRoot;
            var finishedWork = pendingFinishedWork;
            endTime = pendingEffectsLanes;
            abortedViewTransition = pendingRecoverableErrors;
            var rootDidHavePassiveEffects = 0 !== finishedWork.actualDuration || 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256);
            rootDidHavePassiveEffects ? pendingEffectsStatus = PENDING_PASSIVE_PHASE : (pendingEffectsStatus = NO_PENDING_EFFECTS, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(
              startViewTransitionStartTime,
              startViewTransitionStartTime.pendingLanes
            ), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);
            var remainingLanes = startViewTransitionStartTime.pendingLanes;
            0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
            rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(startViewTransitionStartTime);
            remainingLanes = lanesToEventPriority(endTime);
            finishedWork = finishedWork.stateNode;
            if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
              try {
                var didError = 128 === (finishedWork.current.flags & 128);
                switch (remainingLanes) {
                  case DiscreteEventPriority:
                    var schedulerPriority = ImmediatePriority;
                    break;
                  case ContinuousEventPriority:
                    schedulerPriority = UserBlockingPriority;
                    break;
                  case DefaultEventPriority:
                    schedulerPriority = NormalPriority$1;
                    break;
                  case IdleEventPriority:
                    schedulerPriority = IdlePriority;
                    break;
                  default:
                    schedulerPriority = NormalPriority$1;
                }
                injectedHook.onCommitFiberRoot(
                  rendererID,
                  finishedWork,
                  schedulerPriority,
                  didError
                );
              } catch (err) {
                hasLoggedError || (hasLoggedError = true, console.error(
                  "React instrumentation encountered an error: %o",
                  err
                ));
              }
            isDevToolsPresent && startViewTransitionStartTime.memoizedUpdaters.clear();
            onCommitRoot();
            if (null !== abortedViewTransition) {
              didError = ReactSharedInternals.T;
              schedulerPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              ReactSharedInternals.T = null;
              try {
                var onRecoverableError = startViewTransitionStartTime.onRecoverableError;
                for (finishedWork = 0; finishedWork < abortedViewTransition.length; finishedWork++) {
                  var recoverableError = abortedViewTransition[finishedWork], errorInfo = makeErrorInfo(recoverableError.stack);
                  runWithFiberInDEV(
                    recoverableError.source,
                    onRecoverableError,
                    recoverableError.value,
                    errorInfo
                  );
                }
              } finally {
                ReactSharedInternals.T = didError, ReactDOMSharedInternals.p = schedulerPriority;
              }
            }
            0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
            ensureRootIsScheduled(startViewTransitionStartTime);
            remainingLanes = startViewTransitionStartTime.pendingLanes;
            0 !== (endTime & 261930) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = true, startViewTransitionStartTime === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = startViewTransitionStartTime)) : nestedUpdateCount = 0;
            rootDidHavePassiveEffects || finalizeRender(endTime, commitEndTime);
            flushSyncWorkAcrossRoots_impl(0, false);
          }
        }
        function makeErrorInfo(componentStack) {
          componentStack = { componentStack };
          Object.defineProperty(componentStack, "digest", {
            get: function() {
              console.error(
                'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
              );
            }
          });
          return componentStack;
        }
        function releaseRootPooledCache(root2, remainingLanes) {
          0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
        }
        function flushPendingEffects() {
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
          return flushPassiveEffects();
        }
        function flushPassiveEffects() {
          if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return false;
          var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
          pendingEffectsRemainingLanes = 0;
          var renderPriority = lanesToEventPriority(pendingEffectsLanes), priority = 0 === DefaultEventPriority || DefaultEventPriority > renderPriority ? DefaultEventPriority : renderPriority;
          renderPriority = ReactSharedInternals.T;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = priority;
            ReactSharedInternals.T = null;
            var transitions = pendingPassiveTransitions;
            pendingPassiveTransitions = null;
            priority = pendingEffectsRoot;
            var lanes = pendingEffectsLanes;
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            pendingFinishedWork = pendingEffectsRoot = null;
            pendingEffectsLanes = 0;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
              throw Error("Cannot flush passive effects while already rendering.");
            setCurrentTrackFromLanes(lanes);
            isFlushingPassiveEffects = true;
            didScheduleUpdateDuringPassiveEffects = false;
            var passiveEffectStartTime = 0;
            commitErrors = null;
            passiveEffectStartTime = now$1();
            if (pendingDelayedCommitReason === ANIMATION_STARTED_COMMIT)
              logAnimatingPhase(
                commitEndTime,
                passiveEffectStartTime,
                animatingTask
              );
            else {
              var startTime = commitEndTime, endTime = passiveEffectStartTime, delayedUntilPaint = pendingDelayedCommitReason === DELAYED_PASSIVE_COMMIT;
              !supportsUserTiming || endTime <= startTime || (workInProgressUpdateTask ? workInProgressUpdateTask.run(
                console.timeStamp.bind(
                  console,
                  delayedUntilPaint ? "Waiting for Paint" : "Waiting",
                  startTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  "secondary-light"
                )
              ) : console.timeStamp(
                delayedUntilPaint ? "Waiting for Paint" : "Waiting",
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                "secondary-light"
              ));
            }
            startTime = executionContext;
            executionContext |= CommitContext;
            var finishedWork = priority.current;
            resetComponentEffectTimers();
            commitPassiveUnmountOnFiber(finishedWork);
            var finishedWork$jscomp$0 = priority.current;
            finishedWork = pendingEffectsRenderEndTime;
            resetComponentEffectTimers();
            commitPassiveMountOnFiber(
              priority,
              finishedWork$jscomp$0,
              lanes,
              transitions,
              finishedWork
            );
            commitDoubleInvokeEffectsInDEV(priority);
            executionContext = startTime;
            var passiveEffectsEndTime = now$1();
            finishedWork$jscomp$0 = passiveEffectStartTime;
            finishedWork = workInProgressUpdateTask;
            null !== commitErrors ? logCommitErrored(
              finishedWork$jscomp$0,
              passiveEffectsEndTime,
              commitErrors,
              true,
              finishedWork
            ) : !supportsUserTiming || passiveEffectsEndTime <= finishedWork$jscomp$0 || (finishedWork ? finishedWork.run(
              console.timeStamp.bind(
                console,
                "Remaining Effects",
                finishedWork$jscomp$0,
                passiveEffectsEndTime,
                currentTrack,
                LANES_TRACK_GROUP,
                "secondary-dark"
              )
            ) : console.timeStamp(
              "Remaining Effects",
              finishedWork$jscomp$0,
              passiveEffectsEndTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "secondary-dark"
            ));
            finalizeRender(lanes, passiveEffectsEndTime);
            flushSyncWorkAcrossRoots_impl(0, false);
            didScheduleUpdateDuringPassiveEffects ? priority === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = priority) : nestedPassiveUpdateCount = 0;
            didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = false;
            if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
              try {
                injectedHook.onPostCommitFiberRoot(rendererID, priority);
              } catch (err) {
                hasLoggedError || (hasLoggedError = true, console.error(
                  "React instrumentation encountered an error: %o",
                  err
                ));
              }
            var stateNode = priority.current.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
            return true;
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root2, remainingLanes);
          }
        }
        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
          recordEffectError(sourceFiber);
          sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
          rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
          null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
        }
        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
          isRunningInsertionEffect = false;
          if (3 === sourceFiber.tag)
            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
          else {
            for (; null !== nearestMountedAncestor; ) {
              if (3 === nearestMountedAncestor.tag) {
                captureCommitPhaseErrorOnRoot(
                  nearestMountedAncestor,
                  sourceFiber,
                  error
                );
                return;
              }
              if (1 === nearestMountedAncestor.tag) {
                var instance = nearestMountedAncestor.stateNode;
                if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                  recordEffectError(sourceFiber);
                  error = createClassErrorUpdate(2);
                  instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                  null !== instance && (initializeClassErrorUpdate(
                    error,
                    instance,
                    nearestMountedAncestor,
                    sourceFiber
                  ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                  return;
                }
              }
              nearestMountedAncestor = nearestMountedAncestor.return;
            }
            console.error(
              "Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s",
              error
            );
          }
        }
        function attachPingListener(root2, wakeable, lanes) {
          var pingCache = root2.pingCache;
          if (null === pingCache) {
            pingCache = root2.pingCache = new PossiblyWeakMap();
            var threadIDs = /* @__PURE__ */ new Set();
            pingCache.set(wakeable, threadIDs);
          } else
            threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
          threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root2, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root2, lanes), wakeable.then(pingCache, pingCache));
        }
        function pingSuspendedRoot(root2, wakeable, pingedLanes) {
          var pingCache = root2.pingCache;
          null !== pingCache && pingCache.delete(wakeable);
          root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
          root2.warmLanes &= ~pingedLanes;
          0 !== (pingedLanes & 127) ? 0 > blockingUpdateTime && (blockingClampTime = blockingUpdateTime = now(), blockingUpdateTask = createTask("Promise Resolved"), blockingUpdateType = PINGED_UPDATE) : 0 !== (pingedLanes & 4194048) && 0 > transitionUpdateTime && (transitionClampTime = transitionUpdateTime = now(), transitionUpdateTask = createTask("Promise Resolved"), transitionUpdateType = PINGED_UPDATE);
          isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error(
            "A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"
          );
          workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
          ensureRootIsScheduled(root2);
        }
        function retryTimedOutBoundary(boundaryFiber, retryLane) {
          0 === retryLane && (retryLane = claimNextRetryLane());
          boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
          null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
        }
        function retryDehydratedSuspenseBoundary(boundaryFiber) {
          var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function resolveRetryWakeable(boundaryFiber, wakeable) {
          var retryLane = 0;
          switch (boundaryFiber.tag) {
            case 31:
            case 13:
              var retryCache = boundaryFiber.stateNode;
              var suspenseState = boundaryFiber.memoizedState;
              null !== suspenseState && (retryLane = suspenseState.retryLane);
              break;
            case 19:
              retryCache = boundaryFiber.stateNode;
              break;
            case 22:
              retryCache = boundaryFiber.stateNode._retryCache;
              break;
            default:
              throw Error(
                "Pinged unknown suspense boundary type. This is probably a bug in React."
              );
          }
          null !== retryCache && retryCache.delete(wakeable);
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {
          if (0 !== (parentFiber.subtreeFlags & 67117056))
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var root2 = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
              isStrictModeFiber = isInStrictMode || isStrictModeFiber;
              22 !== fiber.tag ? fiber.flags & 67108864 ? isStrictModeFiber && runWithFiberInDEV(
                fiber,
                doubleInvokeEffectsOnFiber,
                root2,
                fiber
              ) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(
                root2,
                fiber,
                isStrictModeFiber
              ) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(
                fiber,
                doubleInvokeEffectsOnFiber,
                root2,
                fiber
              ) : fiber.subtreeFlags & 67108864 && runWithFiberInDEV(
                fiber,
                recursivelyTraverseAndDoubleInvokeEffectsInDEV,
                root2,
                fiber,
                isStrictModeFiber
              ));
              parentFiber = parentFiber.sibling;
            }
        }
        function doubleInvokeEffectsOnFiber(root2, fiber) {
          setIsStrictModeForDevtools(true);
          try {
            disappearLayoutEffects(fiber), disconnectPassiveEffect(fiber), reappearLayoutEffects(root2, fiber.alternate, fiber, false), reconnectPassiveEffects(root2, fiber, 0, null, false, 0);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        function commitDoubleInvokeEffectsInDEV(root2) {
          var doubleInvokeEffects = true;
          root2.current.mode & (StrictLegacyMode | StrictEffectsMode) || (doubleInvokeEffects = false);
          recursivelyTraverseAndDoubleInvokeEffectsInDEV(
            root2,
            root2.current,
            doubleInvokeEffects
          );
        }
        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
          if ((executionContext & RenderContext) === NoContext) {
            var tag = fiber.tag;
            if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {
              tag = getComponentNameFromFiber(fiber) || "ReactComponent";
              if (null !== didWarnStateUpdateForNotYetMountedComponent) {
                if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
                didWarnStateUpdateForNotYetMountedComponent.add(tag);
              } else didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([tag]);
              runWithFiberInDEV(fiber, function() {
                console.error(
                  "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously tries to update the component. Move this work to useEffect instead."
                );
              });
            }
          }
        }
        function restorePendingUpdaters(root2, lanes) {
          isDevToolsPresent && root2.memoizedUpdaters.forEach(function(schedulingFiber) {
            addFiberToLanesMap(root2, schedulingFiber, lanes);
          });
        }
        function scheduleCallback$1(priorityLevel, callback) {
          var actQueue = ReactSharedInternals.actQueue;
          return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode$1) : scheduleCallback$3(priorityLevel, callback);
        }
        function warnIfUpdatesNotWrappedWithActDEV(fiber) {
          isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {
            console.error(
              "An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act",
              getComponentNameFromFiber(fiber)
            );
          });
        }
        function ensureRootIsScheduled(root2) {
          root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
          mightHavePendingSyncWork = true;
          null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = true, scheduleImmediateRootScheduleTask()) : didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
        }
        function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
          if (!isFlushingWork && mightHavePendingSyncWork) {
            isFlushingWork = true;
            do {
              var didPerformSomeWork = false;
              for (var root2 = firstScheduledRoot; null !== root2; ) {
                if (!onlyLegacy)
                  if (0 !== syncTransitionLanes) {
                    var pendingLanes = root2.pendingLanes;
                    if (0 === pendingLanes) var nextLanes = 0;
                    else {
                      var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
                      nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                      nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                      nextLanes = nextLanes & 201326741 ? nextLanes & 201326741 | 1 : nextLanes ? nextLanes | 2 : 0;
                    }
                    0 !== nextLanes && (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));
                  } else
                    nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(
                      root2,
                      root2 === workInProgressRoot ? nextLanes : 0,
                      null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
                    ), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root2, nextLanes) || (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));
                root2 = root2.next;
              }
            } while (didPerformSomeWork);
            isFlushingWork = false;
          }
        }
        function processRootScheduleInImmediateTask() {
          schedulerEvent = window.event;
          processRootScheduleInMicrotask();
        }
        function processRootScheduleInMicrotask() {
          mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = false;
          var syncTransitionLanes = 0;
          0 !== currentEventTransitionLane && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
          for (var currentTime = now$1(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
            var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
            if (0 === nextLanes)
              root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
            else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
              mightHavePendingSyncWork = true;
            root2 = next;
          }
          pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE || flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
          0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
        }
        function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
          for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
            var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];
            if (-1 === expirationTime) {
              if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
                expirationTimes[index] = computeExpirationTime(lane, currentTime);
            } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
            lanes &= ~lane;
          }
          currentTime = workInProgressRoot;
          suspendedLanes = workInProgressRootRenderLanes;
          suspendedLanes = getNextLanes(
            root2,
            root2 === currentTime ? suspendedLanes : 0,
            null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
          );
          pingedLanes = root2.callbackNode;
          if (0 === suspendedLanes || root2 === currentTime && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root2.cancelPendingCommit)
            return null !== pingedLanes && cancelCallback(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
          if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
            currentTime = suspendedLanes & -suspendedLanes;
            if (currentTime !== root2.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode)
              cancelCallback(pingedLanes);
            else return currentTime;
            switch (lanesToEventPriority(suspendedLanes)) {
              case DiscreteEventPriority:
              case ContinuousEventPriority:
                suspendedLanes = UserBlockingPriority;
                break;
              case DefaultEventPriority:
                suspendedLanes = NormalPriority$1;
                break;
              case IdleEventPriority:
                suspendedLanes = IdlePriority;
                break;
              default:
                suspendedLanes = NormalPriority$1;
            }
            pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
            null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
            root2.callbackPriority = currentTime;
            root2.callbackNode = suspendedLanes;
            return currentTime;
          }
          null !== pingedLanes && cancelCallback(pingedLanes);
          root2.callbackPriority = 2;
          root2.callbackNode = null;
          return 2;
        }
        function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
          nestedUpdateScheduled = currentUpdateIsNested = false;
          schedulerEvent = window.event;
          if (pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE)
            return root2.callbackNode = null, root2.callbackPriority = 0, null;
          var originalCallbackNode = root2.callbackNode;
          pendingDelayedCommitReason === IMMEDIATE_COMMIT && (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);
          if (flushPendingEffects() && root2.callbackNode !== originalCallbackNode)
            return null;
          var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
          workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
            root2,
            root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
            null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
          );
          if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
          performWorkOnRoot(
            root2,
            workInProgressRootRenderLanes$jscomp$0,
            didTimeout
          );
          scheduleTaskForRootDuringMicrotask(root2, now$1());
          return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
        }
        function performSyncWorkOnRoot(root2, lanes) {
          if (flushPendingEffects()) return null;
          currentUpdateIsNested = nestedUpdateScheduled;
          nestedUpdateScheduled = false;
          performWorkOnRoot(root2, lanes, true);
        }
        function cancelCallback(callbackNode) {
          callbackNode !== fakeActCallbackNode && null !== callbackNode && cancelCallback$1(callbackNode);
        }
        function scheduleImmediateRootScheduleTask() {
          null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {
            processRootScheduleInMicrotask();
            return null;
          });
          scheduleMicrotask(function() {
            (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(
              ImmediatePriority,
              processRootScheduleInImmediateTask
            ) : processRootScheduleInMicrotask();
          });
        }
        function requestTransitionLane() {
          if (0 === currentEventTransitionLane) {
            var actionScopeLane = currentEntangledLane;
            0 === actionScopeLane && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, 0 === (nextTransitionUpdateLane & 261888) && (nextTransitionUpdateLane = 256));
            currentEventTransitionLane = actionScopeLane;
          }
          return currentEventTransitionLane;
        }
        function coerceFormActionProp(actionProp) {
          if (null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp)
            return null;
          if ("function" === typeof actionProp) return actionProp;
          checkAttributeStringCoercion(actionProp, "action");
          return sanitizeURL("" + actionProp);
        }
        function createFormDataWithSubmitter(form, submitter) {
          var temp = submitter.ownerDocument.createElement("input");
          temp.name = submitter.name;
          temp.value = submitter.value;
          form.id && temp.setAttribute("form", form.id);
          submitter.parentNode.insertBefore(temp, submitter);
          form = new FormData(form);
          temp.parentNode.removeChild(temp);
          return form;
        }
        function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
          if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
            var action = coerceFormActionProp(
              (nativeEventTarget[internalPropsKey] || null).action
            ), submitter = nativeEvent.submitter;
            submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
            var event = new SyntheticEvent(
              "action",
              "action",
              null,
              nativeEvent,
              nativeEventTarget
            );
            dispatchQueue.push({
              event,
              listeners: [
                {
                  instance: null,
                  listener: function() {
                    if (nativeEvent.defaultPrevented) {
                      if (0 !== currentEventTransitionLane) {
                        var formData = submitter ? createFormDataWithSubmitter(
                          nativeEventTarget,
                          submitter
                        ) : new FormData(nativeEventTarget), pendingState = {
                          pending: true,
                          data: formData,
                          method: nativeEventTarget.method,
                          action
                        };
                        Object.freeze(pendingState);
                        startHostTransition(
                          maybeTargetInst,
                          pendingState,
                          null,
                          formData
                        );
                      }
                    } else
                      "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(
                        nativeEventTarget,
                        submitter
                      ) : new FormData(nativeEventTarget), pendingState = {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      }, Object.freeze(pendingState), startHostTransition(
                        maybeTargetInst,
                        pendingState,
                        action,
                        formData
                      ));
                  },
                  currentTarget: nativeEventTarget
                }
              ]
            });
          }
        }
        function executeDispatch(event, listener, currentTarget) {
          event.currentTarget = currentTarget;
          try {
            listener(event);
          } catch (error) {
            reportGlobalError(error);
          }
          event.currentTarget = null;
        }
        function processDispatchQueue(dispatchQueue, eventSystemFlags) {
          eventSystemFlags = 0 !== (eventSystemFlags & 4);
          for (var i = 0; i < dispatchQueue.length; i++) {
            var _dispatchQueue$i = dispatchQueue[i];
            a: {
              var previousInstance = void 0, event = _dispatchQueue$i.event;
              _dispatchQueue$i = _dispatchQueue$i.listeners;
              if (eventSystemFlags)
                for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                  var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                  _dispatchListeners$i = _dispatchListeners$i.listener;
                  if (instance !== previousInstance && event.isPropagationStopped())
                    break a;
                  null !== instance ? runWithFiberInDEV(
                    instance,
                    executeDispatch,
                    event,
                    _dispatchListeners$i,
                    currentTarget
                  ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
                  previousInstance = instance;
                }
              else
                for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                  _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                  instance = _dispatchListeners$i.instance;
                  currentTarget = _dispatchListeners$i.currentTarget;
                  _dispatchListeners$i = _dispatchListeners$i.listener;
                  if (instance !== previousInstance && event.isPropagationStopped())
                    break a;
                  null !== instance ? runWithFiberInDEV(
                    instance,
                    executeDispatch,
                    event,
                    _dispatchListeners$i,
                    currentTarget
                  ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
                  previousInstance = instance;
                }
            }
          }
        }
        function listenToNonDelegatedEvent(domEventName, targetElement) {
          nonDelegatedEvents.has(domEventName) || console.error(
            'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
            domEventName
          );
          var listenerSet = targetElement[internalEventHandlersKey];
          void 0 === listenerSet && (listenerSet = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
          var listenerSetKey = domEventName + "__bubble";
          listenerSet.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), listenerSet.add(listenerSetKey));
        }
        function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
          nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener && console.error(
            'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
            domEventName
          );
          var eventSystemFlags = 0;
          isCapturePhaseListener && (eventSystemFlags |= 4);
          addTrappedEventListener(
            target,
            domEventName,
            eventSystemFlags,
            isCapturePhaseListener
          );
        }
        function listenToAllSupportedEvents(rootContainerElement) {
          if (!rootContainerElement[listeningMarker]) {
            rootContainerElement[listeningMarker] = true;
            allNativeEvents.forEach(function(domEventName) {
              "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
            });
            var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
            null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
          }
        }
        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
          switch (getEventPriority(domEventName)) {
            case DiscreteEventPriority:
              var listenerWrapper = dispatchDiscreteEvent;
              break;
            case ContinuousEventPriority:
              listenerWrapper = dispatchContinuousEvent;
              break;
            default:
              listenerWrapper = dispatchEvent;
          }
          eventSystemFlags = listenerWrapper.bind(
            null,
            domEventName,
            eventSystemFlags,
            targetContainer
          );
          listenerWrapper = void 0;
          !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
          isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
            capture: true,
            passive: listenerWrapper
          }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
            passive: listenerWrapper
          }) : targetContainer.addEventListener(
            domEventName,
            eventSystemFlags,
            false
          );
        }
        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
          var ancestorInst = targetInst$jscomp$0;
          if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
            a: for (; ; ) {
              if (null === targetInst$jscomp$0) return;
              var nodeTag = targetInst$jscomp$0.tag;
              if (3 === nodeTag || 4 === nodeTag) {
                var container = targetInst$jscomp$0.stateNode.containerInfo;
                if (container === targetContainer) break;
                if (4 === nodeTag)
                  for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                    var grandTag = nodeTag.tag;
                    if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                      return;
                    nodeTag = nodeTag.return;
                  }
                for (; null !== container; ) {
                  nodeTag = getClosestInstanceFromNode(container);
                  if (null === nodeTag) return;
                  grandTag = nodeTag.tag;
                  if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                    targetInst$jscomp$0 = ancestorInst = nodeTag;
                    continue a;
                  }
                  container = container.parentNode;
                }
              }
              targetInst$jscomp$0 = targetInst$jscomp$0.return;
            }
          batchedUpdates$1(function() {
            var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
            a: {
              var reactName = topLevelEventsToReactNames.get(domEventName);
              if (void 0 !== reactName) {
                var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
                switch (domEventName) {
                  case "keypress":
                    if (0 === getEventCharCode(nativeEvent)) break a;
                  case "keydown":
                  case "keyup":
                    SyntheticEventCtor = SyntheticKeyboardEvent;
                    break;
                  case "focusin":
                    reactEventType = "focus";
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "focusout":
                    reactEventType = "blur";
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "beforeblur":
                  case "afterblur":
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "click":
                    if (2 === nativeEvent.button) break a;
                  case "auxclick":
                  case "dblclick":
                  case "mousedown":
                  case "mousemove":
                  case "mouseup":
                  case "mouseout":
                  case "mouseover":
                  case "contextmenu":
                    SyntheticEventCtor = SyntheticMouseEvent;
                    break;
                  case "drag":
                  case "dragend":
                  case "dragenter":
                  case "dragexit":
                  case "dragleave":
                  case "dragover":
                  case "dragstart":
                  case "drop":
                    SyntheticEventCtor = SyntheticDragEvent;
                    break;
                  case "touchcancel":
                  case "touchend":
                  case "touchmove":
                  case "touchstart":
                    SyntheticEventCtor = SyntheticTouchEvent;
                    break;
                  case ANIMATION_END:
                  case ANIMATION_ITERATION:
                  case ANIMATION_START:
                    SyntheticEventCtor = SyntheticAnimationEvent;
                    break;
                  case TRANSITION_END:
                    SyntheticEventCtor = SyntheticTransitionEvent;
                    break;
                  case "scroll":
                  case "scrollend":
                    SyntheticEventCtor = SyntheticUIEvent;
                    break;
                  case "wheel":
                    SyntheticEventCtor = SyntheticWheelEvent;
                    break;
                  case "copy":
                  case "cut":
                  case "paste":
                    SyntheticEventCtor = SyntheticClipboardEvent;
                    break;
                  case "gotpointercapture":
                  case "lostpointercapture":
                  case "pointercancel":
                  case "pointerdown":
                  case "pointermove":
                  case "pointerout":
                  case "pointerover":
                  case "pointerup":
                    SyntheticEventCtor = SyntheticPointerEvent;
                    break;
                  case "toggle":
                  case "beforetoggle":
                    SyntheticEventCtor = SyntheticToggleEvent;
                }
                var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
                inCapturePhase = [];
                for (var instance = targetInst, lastHostComponent; null !== instance; ) {
                  var _instance2 = instance;
                  lastHostComponent = _instance2.stateNode;
                  _instance2 = _instance2.tag;
                  5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === lastHostComponent || null === reactEventName || (_instance2 = getListener(instance, reactEventName), null != _instance2 && inCapturePhase.push(
                    createDispatchListener(
                      instance,
                      _instance2,
                      lastHostComponent
                    )
                  ));
                  if (accumulateTargetOnly) break;
                  instance = instance.return;
                }
                0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                  reactName,
                  reactEventType,
                  null,
                  nativeEvent,
                  nativeEventTarget
                ), dispatchQueue.push({
                  event: reactName,
                  listeners: inCapturePhase
                }));
              }
            }
            if (0 === (eventSystemFlags & 7)) {
              a: {
                reactName = "mouseover" === domEventName || "pointerover" === domEventName;
                SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
                if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                  break a;
                if (SyntheticEventCtor || reactName) {
                  reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                  if (SyntheticEventCtor) {
                    if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                      reactEventType = null;
                  } else SyntheticEventCtor = null, reactEventType = targetInst;
                  if (SyntheticEventCtor !== reactEventType) {
                    inCapturePhase = SyntheticMouseEvent;
                    _instance2 = "onMouseLeave";
                    reactEventName = "onMouseEnter";
                    instance = "mouse";
                    if ("pointerout" === domEventName || "pointerover" === domEventName)
                      inCapturePhase = SyntheticPointerEvent, _instance2 = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                    accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                    lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                    reactName = new inCapturePhase(
                      _instance2,
                      instance + "leave",
                      SyntheticEventCtor,
                      nativeEvent,
                      nativeEventTarget
                    );
                    reactName.target = accumulateTargetOnly;
                    reactName.relatedTarget = lastHostComponent;
                    _instance2 = null;
                    getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                      reactEventName,
                      instance + "enter",
                      reactEventType,
                      nativeEvent,
                      nativeEventTarget
                    ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance2 = inCapturePhase);
                    accumulateTargetOnly = _instance2;
                    if (SyntheticEventCtor && reactEventType)
                      b: {
                        inCapturePhase = getParent;
                        reactEventName = SyntheticEventCtor;
                        instance = reactEventType;
                        lastHostComponent = 0;
                        for (_instance2 = reactEventName; _instance2; _instance2 = inCapturePhase(_instance2))
                          lastHostComponent++;
                        _instance2 = 0;
                        for (var tempB = instance; tempB; tempB = inCapturePhase(tempB))
                          _instance2++;
                        for (; 0 < lastHostComponent - _instance2; )
                          reactEventName = inCapturePhase(reactEventName), lastHostComponent--;
                        for (; 0 < _instance2 - lastHostComponent; )
                          instance = inCapturePhase(instance), _instance2--;
                        for (; lastHostComponent--; ) {
                          if (reactEventName === instance || null !== instance && reactEventName === instance.alternate) {
                            inCapturePhase = reactEventName;
                            break b;
                          }
                          reactEventName = inCapturePhase(reactEventName);
                          instance = inCapturePhase(instance);
                        }
                        inCapturePhase = null;
                      }
                    else inCapturePhase = null;
                    null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                      dispatchQueue,
                      reactName,
                      SyntheticEventCtor,
                      inCapturePhase,
                      false
                    );
                    null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                      dispatchQueue,
                      accumulateTargetOnly,
                      reactEventType,
                      inCapturePhase,
                      true
                    );
                  }
                }
              }
              a: {
                reactName = targetInst ? getNodeFromInstance(targetInst) : window;
                SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
                if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                  var getTargetInstFunc = getTargetInstForChangeEvent;
                else if (isTextInputElement(reactName))
                  if (isInputEventSupported)
                    getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                  else {
                    getTargetInstFunc = getTargetInstForInputEventPolyfill;
                    var handleEventFunc = handleEventsForInputEventPolyfill;
                  }
                else
                  SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
                if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                  createAndAccumulateChangeEvent(
                    dispatchQueue,
                    getTargetInstFunc,
                    nativeEvent,
                    nativeEventTarget
                  );
                  break a;
                }
                handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
                "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
              }
              handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
              switch (domEventName) {
                case "focusin":
                  if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                    activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                  break;
                case "focusout":
                  lastSelection = activeElementInst = activeElement = null;
                  break;
                case "mousedown":
                  mouseDown = true;
                  break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                  mouseDown = false;
                  constructSelectEvent(
                    dispatchQueue,
                    nativeEvent,
                    nativeEventTarget
                  );
                  break;
                case "selectionchange":
                  if (skipSelectionChangeEvent) break;
                case "keydown":
                case "keyup":
                  constructSelectEvent(
                    dispatchQueue,
                    nativeEvent,
                    nativeEventTarget
                  );
              }
              var fallbackData;
              if (canUseCompositionEvent)
                b: {
                  switch (domEventName) {
                    case "compositionstart":
                      var eventType = "onCompositionStart";
                      break b;
                    case "compositionend":
                      eventType = "onCompositionEnd";
                      break b;
                    case "compositionupdate":
                      eventType = "onCompositionUpdate";
                      break b;
                  }
                  eventType = void 0;
                }
              else
                isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && nativeEvent.keyCode === START_KEYCODE && (eventType = "onCompositionStart");
              eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(
                targetInst,
                eventType
              ), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
                eventType,
                domEventName,
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({
                event: eventType,
                listeners: handleEventFunc
              }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
              if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
                eventType = accumulateTwoPhaseListeners(
                  targetInst,
                  "onBeforeInput"
                ), 0 < eventType.length && (handleEventFunc = new SyntheticInputEvent(
                  "onBeforeInput",
                  "beforeinput",
                  null,
                  nativeEvent,
                  nativeEventTarget
                ), dispatchQueue.push({
                  event: handleEventFunc,
                  listeners: eventType
                }), handleEventFunc.data = fallbackData);
              extractEvents$1(
                dispatchQueue,
                domEventName,
                targetInst,
                nativeEvent,
                nativeEventTarget
              );
            }
            processDispatchQueue(dispatchQueue, eventSystemFlags);
          });
        }
        function createDispatchListener(instance, listener, currentTarget) {
          return {
            instance,
            listener,
            currentTarget
          };
        }
        function accumulateTwoPhaseListeners(targetFiber, reactName) {
          for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
            var _instance3 = targetFiber, stateNode = _instance3.stateNode;
            _instance3 = _instance3.tag;
            5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (_instance3 = getListener(targetFiber, captureName), null != _instance3 && listeners.unshift(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ), _instance3 = getListener(targetFiber, reactName), null != _instance3 && listeners.push(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ));
            if (3 === targetFiber.tag) return listeners;
            targetFiber = targetFiber.return;
          }
          return [];
        }
        function getParent(inst) {
          if (null === inst) return null;
          do
            inst = inst.return;
          while (inst && 5 !== inst.tag && 27 !== inst.tag);
          return inst ? inst : null;
        }
        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
          for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
            var _instance4 = target, alternate = _instance4.alternate, stateNode = _instance4.stateNode;
            _instance4 = _instance4.tag;
            if (null !== alternate && alternate === common) break;
            5 !== _instance4 && 26 !== _instance4 && 27 !== _instance4 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
              createDispatchListener(target, stateNode, alternate)
            )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
              createDispatchListener(target, stateNode, alternate)
            )));
            target = target.return;
          }
          0 !== listeners.length && dispatchQueue.push({ event, listeners });
        }
        function validatePropertiesInDevelopment(type, props) {
          validateProperties$2(type, props);
          "input" !== type && "textarea" !== type && "select" !== type || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = true, "select" === type && props.multiple ? console.error(
            "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
            type
          ) : console.error(
            "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
            type
          ));
          var eventRegistry = {
            registrationNameDependencies,
            possibleRegistrationNames
          };
          isCustomElement(type) || "string" === typeof props.is || warnUnknownProperties(type, props, eventRegistry);
          props.contentEditable && !props.suppressContentEditableWarning && null != props.children && console.error(
            "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
          );
        }
        function warnForPropDifference(propName, serverValue, clientValue, serverDifferences) {
          serverValue !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(serverValue) !== clientValue && (serverDifferences[propName] = serverValue));
        }
        function warnForExtraAttributes(domElement, attributeNames, serverDifferences) {
          attributeNames.forEach(function(attributeName) {
            serverDifferences[getPropNameFromAttributeName(attributeName)] = "style" === attributeName ? getStylesObjectFromElement(domElement) : domElement.getAttribute(attributeName);
          });
        }
        function warnForInvalidEventListener(registrationName, listener) {
          false === listener ? console.error(
            "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
            registrationName,
            registrationName,
            registrationName
          ) : console.error(
            "Expected `%s` listener to be a function, instead got a value of `%s` type.",
            registrationName,
            typeof listener
          );
        }
        function normalizeHTML(parent, html) {
          parent = parent.namespaceURI === MATH_NAMESPACE || parent.namespaceURI === SVG_NAMESPACE ? parent.ownerDocument.createElementNS(
            parent.namespaceURI,
            parent.tagName
          ) : parent.ownerDocument.createElement(parent.tagName);
          parent.innerHTML = html;
          return parent.innerHTML;
        }
        function normalizeMarkupForTextOrAttribute(markup) {
          willCoercionThrow(markup) && (console.error(
            "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
            typeName(markup)
          ), testStringCoercion(markup));
          return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
        }
        function checkForUnmatchedText(serverText, clientText) {
          clientText = normalizeMarkupForTextOrAttribute(clientText);
          return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
        }
        function setProp(domElement, tag, key, value, props, prevValue) {
          switch (key) {
            case "children":
              if ("string" === typeof value)
                validateTextNesting(value, tag, false), "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value);
              else if ("number" === typeof value || "bigint" === typeof value)
                validateTextNesting("" + value, tag, false), "body" !== tag && setTextContent(domElement, "" + value);
              break;
            case "className":
              setValueForKnownAttribute(domElement, "class", value);
              break;
            case "tabIndex":
              setValueForKnownAttribute(domElement, "tabindex", value);
              break;
            case "dir":
            case "role":
            case "viewBox":
            case "width":
            case "height":
              setValueForKnownAttribute(domElement, key, value);
              break;
            case "style":
              setValueForStyles(domElement, value, prevValue);
              break;
            case "data":
              if ("object" !== tag) {
                setValueForKnownAttribute(domElement, "data", value);
                break;
              }
            case "src":
            case "href":
              if ("" === value && ("a" !== tag || "href" !== key)) {
                "src" === key ? console.error(
                  'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                ) : console.error(
                  'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                );
                domElement.removeAttribute(key);
                break;
              }
              if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
                domElement.removeAttribute(key);
                break;
              }
              checkAttributeStringCoercion(value, key);
              value = sanitizeURL("" + value);
              domElement.setAttribute(key, value);
              break;
            case "action":
            case "formAction":
              null != value && ("form" === tag ? "formAction" === key ? console.error(
                "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
              ) : "function" === typeof value && (null == props.encType && null == props.method || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
              )), null == props.target || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
              ))) : "input" === tag || "button" === tag ? "action" === key ? console.error(
                "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
              ) : "input" !== tag || "submit" === props.type || "image" === props.type || didWarnFormActionType ? "button" !== tag || null == props.type || "submit" === props.type || didWarnFormActionType ? "function" === typeof value && (null == props.name || didWarnFormActionName || (didWarnFormActionName = true, console.error(
                'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
              )), null == props.formEncType && null == props.formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
              )), null == props.formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
              ))) : (didWarnFormActionType = true, console.error(
                'A button can only specify a formAction along with type="submit" or no type.'
              )) : (didWarnFormActionType = true, console.error(
                'An input can only specify a formAction along with type="submit" or type="image".'
              )) : "action" === key ? console.error(
                "You can only pass the action prop to <form>."
              ) : console.error(
                "You can only pass the formAction prop to <input> or <button>."
              ));
              if ("function" === typeof value) {
                domElement.setAttribute(
                  key,
                  "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
                );
                break;
              } else
                "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                  domElement,
                  tag,
                  "formEncType",
                  props.formEncType,
                  props,
                  null
                ), setProp(
                  domElement,
                  tag,
                  "formMethod",
                  props.formMethod,
                  props,
                  null
                ), setProp(
                  domElement,
                  tag,
                  "formTarget",
                  props.formTarget,
                  props,
                  null
                )) : (setProp(
                  domElement,
                  tag,
                  "encType",
                  props.encType,
                  props,
                  null
                ), setProp(domElement, tag, "method", props.method, props, null), setProp(
                  domElement,
                  tag,
                  "target",
                  props.target,
                  props,
                  null
                )));
              if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
                domElement.removeAttribute(key);
                break;
              }
              checkAttributeStringCoercion(value, key);
              value = sanitizeURL("" + value);
              domElement.setAttribute(key, value);
              break;
            case "onClick":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
              break;
            case "onScroll":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
              break;
            case "onScrollEnd":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
              break;
            case "dangerouslySetInnerHTML":
              if (null != value) {
                if ("object" !== typeof value || !("__html" in value))
                  throw Error(
                    "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                  );
                key = value.__html;
                if (null != key) {
                  if (null != props.children)
                    throw Error(
                      "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                    );
                  domElement.innerHTML = key;
                }
              }
              break;
            case "multiple":
              domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
              break;
            case "muted":
              domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              break;
            case "autoFocus":
              break;
            case "xlinkHref":
              if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
                domElement.removeAttribute("xlink:href");
                break;
              }
              checkAttributeStringCoercion(value, key);
              key = sanitizeURL("" + value);
              domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
              break;
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
              null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, "" + value)) : domElement.removeAttribute(key);
              break;
            case "inert":
              "" !== value || didWarnForNewBooleanPropsWithEmptyValue[key] || (didWarnForNewBooleanPropsWithEmptyValue[key] = true, console.error(
                "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                key
              ));
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
              value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
              break;
            case "capture":
            case "download":
              true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
              break;
            case "cols":
            case "rows":
            case "size":
            case "span":
              null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
              break;
            case "rowSpan":
            case "start":
              null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value));
              break;
            case "popover":
              listenToNonDelegatedEvent("beforetoggle", domElement);
              listenToNonDelegatedEvent("toggle", domElement);
              setValueForAttribute(domElement, "popover", value);
              break;
            case "xlinkActuate":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:actuate",
                value
              );
              break;
            case "xlinkArcrole":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:arcrole",
                value
              );
              break;
            case "xlinkRole":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:role",
                value
              );
              break;
            case "xlinkShow":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:show",
                value
              );
              break;
            case "xlinkTitle":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:title",
                value
              );
              break;
            case "xlinkType":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:type",
                value
              );
              break;
            case "xmlBase":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:base",
                value
              );
              break;
            case "xmlLang":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:lang",
                value
              );
              break;
            case "xmlSpace":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:space",
                value
              );
              break;
            case "is":
              null != prevValue && console.error(
                'Cannot update the "is" prop after it has been initialized.'
              );
              setValueForAttribute(domElement, "is", value);
              break;
            case "innerText":
            case "textContent":
              break;
            case "popoverTarget":
              didWarnPopoverTargetObject || null == value || "object" !== typeof value || (didWarnPopoverTargetObject = true, console.error(
                "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
                value
              ));
            default:
              !(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1] ? (key = getAttributeAlias(key), setValueForAttribute(domElement, key, value)) : registrationNameDependencies.hasOwnProperty(key) && null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
          }
        }
        function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
          switch (key) {
            case "style":
              setValueForStyles(domElement, value, prevValue);
              break;
            case "dangerouslySetInnerHTML":
              if (null != value) {
                if ("object" !== typeof value || !("__html" in value))
                  throw Error(
                    "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                  );
                key = value.__html;
                if (null != key) {
                  if (null != props.children)
                    throw Error(
                      "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                    );
                  domElement.innerHTML = key;
                }
              }
              break;
            case "children":
              "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
              break;
            case "onScroll":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
              break;
            case "onScrollEnd":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
              break;
            case "onClick":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "innerHTML":
            case "ref":
              break;
            case "innerText":
            case "textContent":
              break;
            default:
              if (registrationNameDependencies.hasOwnProperty(key))
                null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
              else
                a: {
                  if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                    "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                    domElement.addEventListener(tag, value, props);
                    break a;
                  }
                  key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
                }
          }
        }
        function setInitialProperties(domElement, tag, props) {
          validatePropertiesInDevelopment(tag, props);
          switch (tag) {
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
              break;
            case "img":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              var hasSrc = false, hasSrcSet = false, propKey;
              for (propKey in props)
                if (props.hasOwnProperty(propKey)) {
                  var propValue = props[propKey];
                  if (null != propValue)
                    switch (propKey) {
                      case "src":
                        hasSrc = true;
                        break;
                      case "srcSet":
                        hasSrcSet = true;
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      default:
                        setProp(domElement, tag, propKey, propValue, props, null);
                    }
                }
              hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
              hasSrc && setProp(domElement, tag, "src", props.src, props, null);
              return;
            case "input":
              checkControlledValueProps("input", props);
              listenToNonDelegatedEvent("invalid", domElement);
              var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
              for (hasSrc in props)
                if (props.hasOwnProperty(hasSrc)) {
                  var _propValue = props[hasSrc];
                  if (null != _propValue)
                    switch (hasSrc) {
                      case "name":
                        hasSrcSet = _propValue;
                        break;
                      case "type":
                        propValue = _propValue;
                        break;
                      case "checked":
                        checked = _propValue;
                        break;
                      case "defaultChecked":
                        defaultChecked = _propValue;
                        break;
                      case "value":
                        propKey = _propValue;
                        break;
                      case "defaultValue":
                        defaultValue = _propValue;
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        if (null != _propValue)
                          throw Error(
                            tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                          );
                        break;
                      default:
                        setProp(domElement, tag, hasSrc, _propValue, props, null);
                    }
                }
              validateInputProps(domElement, props);
              initInput(
                domElement,
                propKey,
                defaultValue,
                checked,
                defaultChecked,
                propValue,
                hasSrcSet,
                false
              );
              return;
            case "select":
              checkControlledValueProps("select", props);
              listenToNonDelegatedEvent("invalid", domElement);
              hasSrc = propValue = propKey = null;
              for (hasSrcSet in props)
                if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                  switch (hasSrcSet) {
                    case "value":
                      propKey = defaultValue;
                      break;
                    case "defaultValue":
                      propValue = defaultValue;
                      break;
                    case "multiple":
                      hasSrc = defaultValue;
                    default:
                      setProp(
                        domElement,
                        tag,
                        hasSrcSet,
                        defaultValue,
                        props,
                        null
                      );
                  }
              validateSelectProps(domElement, props);
              tag = propKey;
              props = propValue;
              domElement.multiple = !!hasSrc;
              null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
              return;
            case "textarea":
              checkControlledValueProps("textarea", props);
              listenToNonDelegatedEvent("invalid", domElement);
              propKey = hasSrcSet = hasSrc = null;
              for (propValue in props)
                if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                  switch (propValue) {
                    case "value":
                      hasSrc = defaultValue;
                      break;
                    case "defaultValue":
                      hasSrcSet = defaultValue;
                      break;
                    case "children":
                      propKey = defaultValue;
                      break;
                    case "dangerouslySetInnerHTML":
                      if (null != defaultValue)
                        throw Error(
                          "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                        );
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        propValue,
                        defaultValue,
                        props,
                        null
                      );
                  }
              validateTextareaProps(domElement, props);
              initTextarea(domElement, hasSrc, hasSrcSet, propKey);
              return;
            case "option":
              validateOptionProps(domElement, props);
              for (checked in props)
                if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                  switch (checked) {
                    case "selected":
                      domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                      break;
                    default:
                      setProp(domElement, tag, checked, hasSrc, props, null);
                  }
              return;
            case "dialog":
              listenToNonDelegatedEvent("beforetoggle", domElement);
              listenToNonDelegatedEvent("toggle", domElement);
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              break;
            case "iframe":
            case "object":
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "video":
            case "audio":
              for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
                listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
              break;
            case "image":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              break;
            case "embed":
            case "source":
            case "link":
              listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
            case "area":
            case "base":
            case "br":
            case "col":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "track":
            case "wbr":
            case "menuitem":
              for (defaultChecked in props)
                if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                  switch (defaultChecked) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    default:
                      setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                  }
              return;
            default:
              if (isCustomElement(tag)) {
                for (_propValue in props)
                  props.hasOwnProperty(_propValue) && (hasSrc = props[_propValue], void 0 !== hasSrc && setPropOnCustomElement(
                    domElement,
                    tag,
                    _propValue,
                    hasSrc,
                    props,
                    void 0
                  ));
                return;
              }
          }
          for (defaultValue in props)
            props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
        }
        function updateProperties(domElement, tag, lastProps, nextProps) {
          validatePropertiesInDevelopment(tag, nextProps);
          switch (tag) {
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
              break;
            case "input":
              var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
              for (propKey in lastProps) {
                var lastProp = lastProps[propKey];
                if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                  switch (propKey) {
                    case "checked":
                      break;
                    case "value":
                      break;
                    case "defaultValue":
                      lastDefaultValue = lastProp;
                    default:
                      nextProps.hasOwnProperty(propKey) || setProp(
                        domElement,
                        tag,
                        propKey,
                        null,
                        nextProps,
                        lastProp
                      );
                  }
              }
              for (var _propKey8 in nextProps) {
                var propKey = nextProps[_propKey8];
                lastProp = lastProps[_propKey8];
                if (nextProps.hasOwnProperty(_propKey8) && (null != propKey || null != lastProp))
                  switch (_propKey8) {
                    case "type":
                      type = propKey;
                      break;
                    case "name":
                      name = propKey;
                      break;
                    case "checked":
                      checked = propKey;
                      break;
                    case "defaultChecked":
                      defaultChecked = propKey;
                      break;
                    case "value":
                      value = propKey;
                      break;
                    case "defaultValue":
                      defaultValue = propKey;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != propKey)
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      break;
                    default:
                      propKey !== lastProp && setProp(
                        domElement,
                        tag,
                        _propKey8,
                        propKey,
                        nextProps,
                        lastProp
                      );
                  }
              }
              tag = "checkbox" === lastProps.type || "radio" === lastProps.type ? null != lastProps.checked : null != lastProps.value;
              nextProps = "checkbox" === nextProps.type || "radio" === nextProps.type ? null != nextProps.checked : null != nextProps.value;
              tag || !nextProps || didWarnUncontrolledToControlled || (console.error(
                "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
              ), didWarnUncontrolledToControlled = true);
              !tag || nextProps || didWarnControlledToUncontrolled || (console.error(
                "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
              ), didWarnControlledToUncontrolled = true);
              updateInput(
                domElement,
                value,
                defaultValue,
                lastDefaultValue,
                checked,
                defaultChecked,
                type,
                name
              );
              return;
            case "select":
              propKey = value = defaultValue = _propKey8 = null;
              for (type in lastProps)
                if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
                  switch (type) {
                    case "value":
                      break;
                    case "multiple":
                      propKey = lastDefaultValue;
                    default:
                      nextProps.hasOwnProperty(type) || setProp(
                        domElement,
                        tag,
                        type,
                        null,
                        nextProps,
                        lastDefaultValue
                      );
                  }
              for (name in nextProps)
                if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
                  switch (name) {
                    case "value":
                      _propKey8 = type;
                      break;
                    case "defaultValue":
                      defaultValue = type;
                      break;
                    case "multiple":
                      value = type;
                    default:
                      type !== lastDefaultValue && setProp(
                        domElement,
                        tag,
                        name,
                        type,
                        nextProps,
                        lastDefaultValue
                      );
                  }
              nextProps = defaultValue;
              tag = value;
              lastProps = propKey;
              null != _propKey8 ? updateOptions(domElement, !!tag, _propKey8, false) : !!lastProps !== !!tag && (null != nextProps ? updateOptions(domElement, !!tag, nextProps, true) : updateOptions(domElement, !!tag, tag ? [] : "", false));
              return;
            case "textarea":
              propKey = _propKey8 = null;
              for (defaultValue in lastProps)
                if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
                  switch (defaultValue) {
                    case "value":
                      break;
                    case "children":
                      break;
                    default:
                      setProp(domElement, tag, defaultValue, null, nextProps, name);
                  }
              for (value in nextProps)
                if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
                  switch (value) {
                    case "value":
                      _propKey8 = name;
                      break;
                    case "defaultValue":
                      propKey = name;
                      break;
                    case "children":
                      break;
                    case "dangerouslySetInnerHTML":
                      if (null != name)
                        throw Error(
                          "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                        );
                      break;
                    default:
                      name !== type && setProp(domElement, tag, value, name, nextProps, type);
                  }
              updateTextarea(domElement, _propKey8, propKey);
              return;
            case "option":
              for (var _propKey13 in lastProps)
                if (_propKey8 = lastProps[_propKey13], lastProps.hasOwnProperty(_propKey13) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey13))
                  switch (_propKey13) {
                    case "selected":
                      domElement.selected = false;
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        _propKey13,
                        null,
                        nextProps,
                        _propKey8
                      );
                  }
              for (lastDefaultValue in nextProps)
                if (_propKey8 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                  switch (lastDefaultValue) {
                    case "selected":
                      domElement.selected = _propKey8 && "function" !== typeof _propKey8 && "symbol" !== typeof _propKey8;
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        lastDefaultValue,
                        _propKey8,
                        nextProps,
                        propKey
                      );
                  }
              return;
            case "img":
            case "link":
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr":
            case "menuitem":
              for (var _propKey15 in lastProps)
                _propKey8 = lastProps[_propKey15], lastProps.hasOwnProperty(_propKey15) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey15) && setProp(
                  domElement,
                  tag,
                  _propKey15,
                  null,
                  nextProps,
                  _propKey8
                );
              for (checked in nextProps)
                if (_propKey8 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                  switch (checked) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != _propKey8)
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        checked,
                        _propKey8,
                        nextProps,
                        propKey
                      );
                  }
              return;
            default:
              if (isCustomElement(tag)) {
                for (var _propKey17 in lastProps)
                  _propKey8 = lastProps[_propKey17], lastProps.hasOwnProperty(_propKey17) && void 0 !== _propKey8 && !nextProps.hasOwnProperty(_propKey17) && setPropOnCustomElement(
                    domElement,
                    tag,
                    _propKey17,
                    void 0,
                    nextProps,
                    _propKey8
                  );
                for (defaultChecked in nextProps)
                  _propKey8 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || _propKey8 === propKey || void 0 === _propKey8 && void 0 === propKey || setPropOnCustomElement(
                    domElement,
                    tag,
                    defaultChecked,
                    _propKey8,
                    nextProps,
                    propKey
                  );
                return;
              }
          }
          for (var _propKey19 in lastProps)
            _propKey8 = lastProps[_propKey19], lastProps.hasOwnProperty(_propKey19) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey19) && setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);
          for (lastProp in nextProps)
            _propKey8 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || _propKey8 === propKey || null == _propKey8 && null == propKey || setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);
        }
        function getPropNameFromAttributeName(attrName) {
          switch (attrName) {
            case "class":
              return "className";
            case "for":
              return "htmlFor";
            default:
              return attrName;
          }
        }
        function getStylesObjectFromElement(domElement) {
          var serverValueInObjectForm = {};
          domElement = domElement.style;
          for (var i = 0; i < domElement.length; i++) {
            var styleName = domElement[i];
            serverValueInObjectForm[styleName] = domElement.getPropertyValue(styleName);
          }
          return serverValueInObjectForm;
        }
        function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
          if (null != value$jscomp$0 && "object" !== typeof value$jscomp$0)
            console.error(
              "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
            );
          else {
            var clientValue;
            var delimiter = clientValue = "", styleName;
            for (styleName in value$jscomp$0)
              if (value$jscomp$0.hasOwnProperty(styleName)) {
                var value = value$jscomp$0[styleName];
                null != value && "boolean" !== typeof value && "" !== value && (0 === styleName.indexOf("--") ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName + ":" + ("" + value).trim()) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + ("" + value).trim()) : clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + value + "px", delimiter = ";");
              }
            clientValue = clientValue || null;
            value$jscomp$0 = domElement.getAttribute("style");
            value$jscomp$0 !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue && (serverDifferences.style = getStylesObjectFromElement(domElement)));
          }
        }
        function hydrateAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (checkAttributeStringCoercion(value, propKey), domElement === "" + value)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateBooleanAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
            }
            if (!value) return;
          } else
            switch (typeof value) {
              case "function":
              case "symbol":
                break;
              default:
                if (value) return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateBooleanishAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
                break;
              default:
                if (checkAttributeStringCoercion(value, attributeName), domElement === "" + value)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateNumericAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
              default:
                if (isNaN(value)) return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (!isNaN(value) && (checkAttributeStringCoercion(value, propKey), domElement === "" + value))
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateSanitizedAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (checkAttributeStringCoercion(value, propKey), attributeName = sanitizeURL("" + value), domElement === attributeName)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function diffHydratedProperties(domElement, tag, props, hostContext) {
          for (var serverDifferences = {}, extraAttributes = /* @__PURE__ */ new Set(), attributes = domElement.attributes, i = 0; i < attributes.length; i++)
            switch (attributes[i].name.toLowerCase()) {
              case "value":
                break;
              case "checked":
                break;
              case "selected":
                break;
              default:
                extraAttributes.add(attributes[i].name);
            }
          if (isCustomElement(tag))
            for (var propKey in props) {
              if (props.hasOwnProperty(propKey)) {
                var value = props[propKey];
                if (null != value) {
                  if (registrationNameDependencies.hasOwnProperty(propKey))
                    "function" !== typeof value && warnForInvalidEventListener(propKey, value);
                  else if (true !== props.suppressHydrationWarning)
                    switch (propKey) {
                      case "children":
                        "string" !== typeof value && "number" !== typeof value || warnForPropDifference(
                          "children",
                          domElement.textContent,
                          value,
                          serverDifferences
                        );
                        continue;
                      case "suppressContentEditableWarning":
                      case "suppressHydrationWarning":
                      case "defaultValue":
                      case "defaultChecked":
                      case "innerHTML":
                      case "ref":
                        continue;
                      case "dangerouslySetInnerHTML":
                        attributes = domElement.innerHTML;
                        value = value ? value.__html : void 0;
                        null != value && (value = normalizeHTML(domElement, value), warnForPropDifference(
                          propKey,
                          attributes,
                          value,
                          serverDifferences
                        ));
                        continue;
                      case "style":
                        extraAttributes.delete(propKey);
                        diffHydratedStyles(domElement, value, serverDifferences);
                        continue;
                      case "offsetParent":
                      case "offsetTop":
                      case "offsetLeft":
                      case "offsetWidth":
                      case "offsetHeight":
                      case "isContentEditable":
                      case "outerText":
                      case "outerHTML":
                        extraAttributes.delete(propKey.toLowerCase());
                        console.error(
                          "Assignment to read-only property will result in a no-op: `%s`",
                          propKey
                        );
                        continue;
                      case "className":
                        extraAttributes.delete("class");
                        attributes = getValueForAttributeOnCustomComponent(
                          domElement,
                          "class",
                          value
                        );
                        warnForPropDifference(
                          "className",
                          attributes,
                          value,
                          serverDifferences
                        );
                        continue;
                      default:
                        hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(propKey.toLowerCase()) : extraAttributes.delete(propKey), attributes = getValueForAttributeOnCustomComponent(
                          domElement,
                          propKey,
                          value
                        ), warnForPropDifference(
                          propKey,
                          attributes,
                          value,
                          serverDifferences
                        );
                    }
                }
              }
            }
          else
            for (value in props)
              if (props.hasOwnProperty(value) && (propKey = props[value], null != propKey)) {
                if (registrationNameDependencies.hasOwnProperty(value))
                  "function" !== typeof propKey && warnForInvalidEventListener(value, propKey);
                else if (true !== props.suppressHydrationWarning)
                  switch (value) {
                    case "children":
                      "string" !== typeof propKey && "number" !== typeof propKey || warnForPropDifference(
                        "children",
                        domElement.textContent,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "suppressContentEditableWarning":
                    case "suppressHydrationWarning":
                    case "value":
                    case "checked":
                    case "selected":
                    case "defaultValue":
                    case "defaultChecked":
                    case "innerHTML":
                    case "ref":
                      continue;
                    case "dangerouslySetInnerHTML":
                      attributes = domElement.innerHTML;
                      propKey = propKey ? propKey.__html : void 0;
                      null != propKey && (propKey = normalizeHTML(domElement, propKey), attributes !== propKey && (serverDifferences[value] = { __html: attributes }));
                      continue;
                    case "className":
                      hydrateAttribute(
                        domElement,
                        value,
                        "class",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "tabIndex":
                      hydrateAttribute(
                        domElement,
                        value,
                        "tabindex",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "style":
                      extraAttributes.delete(value);
                      diffHydratedStyles(domElement, propKey, serverDifferences);
                      continue;
                    case "multiple":
                      extraAttributes.delete(value);
                      warnForPropDifference(
                        value,
                        domElement.multiple,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "muted":
                      extraAttributes.delete(value);
                      warnForPropDifference(
                        value,
                        domElement.muted,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "autoFocus":
                      extraAttributes.delete("autofocus");
                      warnForPropDifference(
                        value,
                        domElement.autofocus,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "data":
                      if ("object" !== tag) {
                        extraAttributes.delete(value);
                        attributes = domElement.getAttribute("data");
                        warnForPropDifference(
                          value,
                          attributes,
                          propKey,
                          serverDifferences
                        );
                        continue;
                      }
                    case "src":
                    case "href":
                      if (!("" !== propKey || "a" === tag && "href" === value || "object" === tag && "data" === value)) {
                        "src" === value ? console.error(
                          'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        ) : console.error(
                          'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        );
                        continue;
                      }
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "action":
                    case "formAction":
                      attributes = domElement.getAttribute(value);
                      if ("function" === typeof propKey) {
                        extraAttributes.delete(value.toLowerCase());
                        "formAction" === value ? (extraAttributes.delete("name"), extraAttributes.delete("formenctype"), extraAttributes.delete("formmethod"), extraAttributes.delete("formtarget")) : (extraAttributes.delete("enctype"), extraAttributes.delete("method"), extraAttributes.delete("target"));
                        continue;
                      } else if (attributes === EXPECTED_FORM_ACTION_URL) {
                        extraAttributes.delete(value.toLowerCase());
                        warnForPropDifference(
                          value,
                          "function",
                          propKey,
                          serverDifferences
                        );
                        continue;
                      }
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        value.toLowerCase(),
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkHref":
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        "xlink:href",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "contentEditable":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        "contenteditable",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "spellCheck":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        "spellcheck",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "draggable":
                    case "autoReverse":
                    case "externalResourcesRequired":
                    case "focusable":
                    case "preserveAlpha":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "allowFullScreen":
                    case "async":
                    case "autoPlay":
                    case "controls":
                    case "default":
                    case "defer":
                    case "disabled":
                    case "disablePictureInPicture":
                    case "disableRemotePlayback":
                    case "formNoValidate":
                    case "hidden":
                    case "loop":
                    case "noModule":
                    case "noValidate":
                    case "open":
                    case "playsInline":
                    case "readOnly":
                    case "required":
                    case "reversed":
                    case "scoped":
                    case "seamless":
                    case "itemScope":
                      hydrateBooleanAttribute(
                        domElement,
                        value,
                        value.toLowerCase(),
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "capture":
                    case "download":
                      a: {
                        i = domElement;
                        var attributeName = attributes = value, serverDifferences$jscomp$0 = serverDifferences;
                        extraAttributes.delete(attributeName);
                        i = i.getAttribute(attributeName);
                        if (null === i)
                          switch (typeof propKey) {
                            case "undefined":
                            case "function":
                            case "symbol":
                              break a;
                            default:
                              if (false === propKey) break a;
                          }
                        else if (null != propKey)
                          switch (typeof propKey) {
                            case "function":
                            case "symbol":
                              break;
                            case "boolean":
                              if (true === propKey && "" === i) break a;
                              break;
                            default:
                              if (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey)
                                break a;
                          }
                        warnForPropDifference(
                          attributes,
                          i,
                          propKey,
                          serverDifferences$jscomp$0
                        );
                      }
                      continue;
                    case "cols":
                    case "rows":
                    case "size":
                    case "span":
                      a: {
                        i = domElement;
                        attributeName = attributes = value;
                        serverDifferences$jscomp$0 = serverDifferences;
                        extraAttributes.delete(attributeName);
                        i = i.getAttribute(attributeName);
                        if (null === i)
                          switch (typeof propKey) {
                            case "undefined":
                            case "function":
                            case "symbol":
                            case "boolean":
                              break a;
                            default:
                              if (isNaN(propKey) || 1 > propKey) break a;
                          }
                        else if (null != propKey)
                          switch (typeof propKey) {
                            case "function":
                            case "symbol":
                            case "boolean":
                              break;
                            default:
                              if (!(isNaN(propKey) || 1 > propKey) && (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey))
                                break a;
                          }
                        warnForPropDifference(
                          attributes,
                          i,
                          propKey,
                          serverDifferences$jscomp$0
                        );
                      }
                      continue;
                    case "rowSpan":
                      hydrateNumericAttribute(
                        domElement,
                        value,
                        "rowspan",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "start":
                      hydrateNumericAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xHeight":
                      hydrateAttribute(
                        domElement,
                        value,
                        "x-height",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkActuate":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:actuate",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkArcrole":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:arcrole",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkRole":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:role",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkShow":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:show",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkTitle":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:title",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkType":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:type",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlBase":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:base",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlLang":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:lang",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlSpace":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:space",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "inert":
                      "" !== propKey || didWarnForNewBooleanPropsWithEmptyValue[value] || (didWarnForNewBooleanPropsWithEmptyValue[value] = true, console.error(
                        "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                        value
                      ));
                      hydrateBooleanAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    default:
                      if (!(2 < value.length) || "o" !== value[0] && "O" !== value[0] || "n" !== value[1] && "N" !== value[1]) {
                        i = getAttributeAlias(value);
                        attributes = false;
                        hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(i.toLowerCase()) : (attributeName = value.toLowerCase(), attributeName = possibleStandardNames.hasOwnProperty(
                          attributeName
                        ) ? possibleStandardNames[attributeName] || null : null, null !== attributeName && attributeName !== value && (attributes = true, extraAttributes.delete(attributeName)), extraAttributes.delete(i));
                        a: if (attributeName = domElement, serverDifferences$jscomp$0 = i, i = propKey, isAttributeNameSafe(serverDifferences$jscomp$0))
                          if (attributeName.hasAttribute(serverDifferences$jscomp$0))
                            attributeName = attributeName.getAttribute(
                              serverDifferences$jscomp$0
                            ), checkAttributeStringCoercion(
                              i,
                              serverDifferences$jscomp$0
                            ), i = attributeName === "" + i ? i : attributeName;
                          else {
                            switch (typeof i) {
                              case "function":
                              case "symbol":
                                break a;
                              case "boolean":
                                if (attributeName = serverDifferences$jscomp$0.toLowerCase().slice(0, 5), "data-" !== attributeName && "aria-" !== attributeName)
                                  break a;
                            }
                            i = void 0 === i ? void 0 : null;
                          }
                        else i = void 0;
                        attributes || warnForPropDifference(
                          value,
                          i,
                          propKey,
                          serverDifferences
                        );
                      }
                  }
              }
          0 < extraAttributes.size && true !== props.suppressHydrationWarning && warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
          return 0 === Object.keys(serverDifferences).length ? null : serverDifferences;
        }
        function propNamesListJoin(list, combinator) {
          switch (list.length) {
            case 0:
              return "";
            case 1:
              return list[0];
            case 2:
              return list[0] + " " + combinator + " " + list[1];
            default:
              return list.slice(0, -1).join(", ") + ", " + combinator + " " + list[list.length - 1];
          }
        }
        function isLikelyStaticResource(initiatorType) {
          switch (initiatorType) {
            case "css":
            case "script":
            case "font":
            case "img":
            case "image":
            case "input":
            case "link":
              return true;
            default:
              return false;
          }
        }
        function estimateBandwidth() {
          if ("function" === typeof performance.getEntriesByType) {
            for (var count = 0, bits = 0, resourceEntries = performance.getEntriesByType("resource"), i = 0; i < resourceEntries.length; i++) {
              var entry = resourceEntries[i], transferSize = entry.transferSize, initiatorType = entry.initiatorType, duration = entry.duration;
              if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
                initiatorType = 0;
                duration = entry.responseEnd;
                for (i += 1; i < resourceEntries.length; i++) {
                  var overlapEntry = resourceEntries[i], overlapStartTime = overlapEntry.startTime;
                  if (overlapStartTime > duration) break;
                  var overlapTransferSize = overlapEntry.transferSize, overlapInitiatorType = overlapEntry.initiatorType;
                  overlapTransferSize && isLikelyStaticResource(overlapInitiatorType) && (overlapEntry = overlapEntry.responseEnd, initiatorType += overlapTransferSize * (overlapEntry < duration ? 1 : (duration - overlapStartTime) / (overlapEntry - overlapStartTime)));
                }
                --i;
                bits += 8 * (transferSize + initiatorType) / (entry.duration / 1e3);
                count++;
                if (10 < count) break;
              }
            }
            if (0 < count) return bits / count / 1e6;
          }
          return navigator.connection && (count = navigator.connection.downlink, "number" === typeof count) ? count : 5;
        }
        function getOwnerDocumentFromRootContainer(rootContainerElement) {
          return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
        }
        function getOwnHostContext(namespaceURI) {
          switch (namespaceURI) {
            case SVG_NAMESPACE:
              return HostContextNamespaceSvg;
            case MATH_NAMESPACE:
              return HostContextNamespaceMath;
            default:
              return HostContextNamespaceNone;
          }
        }
        function getChildHostContextProd(parentNamespace, type) {
          if (parentNamespace === HostContextNamespaceNone)
            switch (type) {
              case "svg":
                return HostContextNamespaceSvg;
              case "math":
                return HostContextNamespaceMath;
              default:
                return HostContextNamespaceNone;
            }
          return parentNamespace === HostContextNamespaceSvg && "foreignObject" === type ? HostContextNamespaceNone : parentNamespace;
        }
        function shouldSetTextContent(type, props) {
          return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
        }
        function shouldAttemptEagerTransition() {
          var event = window.event;
          if (event && "popstate" === event.type) {
            if (event === currentPopstateTransitionEvent) return false;
            currentPopstateTransitionEvent = event;
            return true;
          }
          currentPopstateTransitionEvent = null;
          return false;
        }
        function resolveEventType() {
          var event = window.event;
          return event && event !== schedulerEvent ? event.type : null;
        }
        function resolveEventTimeStamp() {
          var event = window.event;
          return event && event !== schedulerEvent ? event.timeStamp : -1.1;
        }
        function handleErrorInNextTick(error) {
          setTimeout(function() {
            throw error;
          });
        }
        function commitMount(domElement, type, newProps) {
          switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              newProps.autoFocus && domElement.focus();
              break;
            case "img":
              newProps.src ? domElement.src = newProps.src : newProps.srcSet && (domElement.srcset = newProps.srcSet);
          }
        }
        function commitHydratedInstance() {
        }
        function commitUpdate(domElement, type, oldProps, newProps) {
          updateProperties(domElement, type, oldProps, newProps);
          domElement[internalPropsKey] = newProps;
        }
        function resetTextContent(domElement) {
          setTextContent(domElement, "");
        }
        function commitTextUpdate(textInstance, oldText, newText) {
          textInstance.nodeValue = newText;
        }
        function warnForReactChildrenConflict(container) {
          if (!container.__reactWarnedAboutChildrenConflict) {
            var props = container[internalPropsKey] || null;
            if (null !== props) {
              var fiber = getInstanceFromNode(container);
              null !== fiber && ("string" === typeof props.children || "number" === typeof props.children ? (container.__reactWarnedAboutChildrenConflict = true, runWithFiberInDEV(fiber, function() {
                console.error(
                  'Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets "children" text content using React. It should be a leaf with no children. Otherwise it\'s ambiguous which children should be used.'
                );
              })) : null != props.dangerouslySetInnerHTML && (container.__reactWarnedAboutChildrenConflict = true, runWithFiberInDEV(fiber, function() {
                console.error(
                  'Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets "dangerouslySetInnerHTML" using React. It should be a leaf with no children. Otherwise it\'s ambiguous which children should be used.'
                );
              })));
            }
          }
        }
        function isSingletonScope(type) {
          return "head" === type;
        }
        function removeChild(parentInstance, child) {
          parentInstance.removeChild(child);
        }
        function removeChildFromContainer(container, child) {
          (9 === container.nodeType ? container.body : "HTML" === container.nodeName ? container.ownerDocument.body : container).removeChild(child);
        }
        function clearHydrationBoundary(parentInstance, hydrationInstance) {
          var node = hydrationInstance, depth = 0;
          do {
            var nextNode = node.nextSibling;
            parentInstance.removeChild(node);
            if (nextNode && 8 === nextNode.nodeType)
              if (node = nextNode.data, node === SUSPENSE_END_DATA || node === ACTIVITY_END_DATA) {
                if (0 === depth) {
                  parentInstance.removeChild(nextNode);
                  retryIfBlockedOn(hydrationInstance);
                  return;
                }
                depth--;
              } else if (node === SUSPENSE_START_DATA || node === SUSPENSE_PENDING_START_DATA || node === SUSPENSE_QUEUED_START_DATA || node === SUSPENSE_FALLBACK_START_DATA || node === ACTIVITY_START_DATA)
                depth++;
              else if (node === PREAMBLE_CONTRIBUTION_HTML)
                releaseSingletonInstance(
                  parentInstance.ownerDocument.documentElement
                );
              else if (node === PREAMBLE_CONTRIBUTION_HEAD) {
                node = parentInstance.ownerDocument.head;
                releaseSingletonInstance(node);
                for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
                  var nextNode$jscomp$0 = node$jscomp$0.nextSibling, nodeName = node$jscomp$0.nodeName;
                  node$jscomp$0[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node$jscomp$0.rel.toLowerCase() || node.removeChild(node$jscomp$0);
                  node$jscomp$0 = nextNode$jscomp$0;
                }
              } else
                node === PREAMBLE_CONTRIBUTION_BODY && releaseSingletonInstance(parentInstance.ownerDocument.body);
            node = nextNode;
          } while (node);
          retryIfBlockedOn(hydrationInstance);
        }
        function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
          var node = suspenseInstance;
          suspenseInstance = 0;
          do {
            var nextNode = node.nextSibling;
            1 === node.nodeType ? isHidden ? (node._stashedDisplay = node.style.display, node.style.display = "none") : (node.style.display = node._stashedDisplay || "", "" === node.getAttribute("style") && node.removeAttribute("style")) : 3 === node.nodeType && (isHidden ? (node._stashedText = node.nodeValue, node.nodeValue = "") : node.nodeValue = node._stashedText || "");
            if (nextNode && 8 === nextNode.nodeType)
              if (node = nextNode.data, node === SUSPENSE_END_DATA)
                if (0 === suspenseInstance) break;
                else suspenseInstance--;
              else
                node !== SUSPENSE_START_DATA && node !== SUSPENSE_PENDING_START_DATA && node !== SUSPENSE_QUEUED_START_DATA && node !== SUSPENSE_FALLBACK_START_DATA || suspenseInstance++;
            node = nextNode;
          } while (node);
        }
        function hideDehydratedBoundary(suspenseInstance) {
          hideOrUnhideDehydratedBoundary(suspenseInstance, true);
        }
        function hideInstance(instance) {
          instance = instance.style;
          "function" === typeof instance.setProperty ? instance.setProperty("display", "none", "important") : instance.display = "none";
        }
        function hideTextInstance(textInstance) {
          textInstance.nodeValue = "";
        }
        function unhideDehydratedBoundary(dehydratedInstance) {
          hideOrUnhideDehydratedBoundary(dehydratedInstance, false);
        }
        function unhideInstance(instance, props) {
          props = props[STYLE];
          props = void 0 !== props && null !== props && props.hasOwnProperty("display") ? props.display : null;
          instance.style.display = null == props || "boolean" === typeof props ? "" : ("" + props).trim();
        }
        function unhideTextInstance(textInstance, text) {
          textInstance.nodeValue = text;
        }
        function clearContainerSparingly(container) {
          var nextNode = container.firstChild;
          nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
          for (; nextNode; ) {
            var node = nextNode;
            nextNode = nextNode.nextSibling;
            switch (node.nodeName) {
              case "HTML":
              case "HEAD":
              case "BODY":
                clearContainerSparingly(node);
                detachDeletedInstance(node);
                continue;
              case "SCRIPT":
              case "STYLE":
                continue;
              case "LINK":
                if ("stylesheet" === node.rel.toLowerCase()) continue;
            }
            container.removeChild(node);
          }
        }
        function canHydrateInstance(instance, type, props, inRootOrSingleton) {
          for (; 1 === instance.nodeType; ) {
            var anyProps = props;
            if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
              if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
                break;
            } else if (!inRootOrSingleton)
              if ("input" === type && "hidden" === instance.type) {
                checkAttributeStringCoercion(anyProps.name, "name");
                var name = null == anyProps.name ? null : "" + anyProps.name;
                if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
                  return instance;
              } else return instance;
            else if (!instance[internalHoistableMarker])
              switch (type) {
                case "meta":
                  if (!instance.hasAttribute("itemprop")) break;
                  return instance;
                case "link":
                  name = instance.getAttribute("rel");
                  if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                    break;
                  else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                    break;
                  return instance;
                case "style":
                  if (instance.hasAttribute("data-precedence")) break;
                  return instance;
                case "script":
                  name = instance.getAttribute("src");
                  if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                    break;
                  return instance;
                default:
                  return instance;
              }
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) break;
          }
          return null;
        }
        function canHydrateTextInstance(instance, text, inRootOrSingleton) {
          if ("" === text) return null;
          for (; 3 !== instance.nodeType; ) {
            if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
              return null;
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) return null;
          }
          return instance;
        }
        function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
          for (; 8 !== instance.nodeType; ) {
            if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
              return null;
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) return null;
          }
          return instance;
        }
        function isSuspenseInstancePending(instance) {
          return instance.data === SUSPENSE_PENDING_START_DATA || instance.data === SUSPENSE_QUEUED_START_DATA;
        }
        function isSuspenseInstanceFallback(instance) {
          return instance.data === SUSPENSE_FALLBACK_START_DATA || instance.data === SUSPENSE_PENDING_START_DATA && instance.ownerDocument.readyState !== DOCUMENT_READY_STATE_LOADING;
        }
        function registerSuspenseInstanceRetry(instance, callback) {
          var ownerDocument = instance.ownerDocument;
          if (instance.data === SUSPENSE_QUEUED_START_DATA)
            instance._reactRetry = callback;
          else if (instance.data !== SUSPENSE_PENDING_START_DATA || ownerDocument.readyState !== DOCUMENT_READY_STATE_LOADING)
            callback();
          else {
            var listener = function() {
              callback();
              ownerDocument.removeEventListener("DOMContentLoaded", listener);
            };
            ownerDocument.addEventListener("DOMContentLoaded", listener);
            instance._reactRetry = listener;
          }
        }
        function getNextHydratable(node) {
          for (; null != node; node = node.nextSibling) {
            var nodeType = node.nodeType;
            if (1 === nodeType || 3 === nodeType) break;
            if (8 === nodeType) {
              nodeType = node.data;
              if (nodeType === SUSPENSE_START_DATA || nodeType === SUSPENSE_FALLBACK_START_DATA || nodeType === SUSPENSE_PENDING_START_DATA || nodeType === SUSPENSE_QUEUED_START_DATA || nodeType === ACTIVITY_START_DATA || nodeType === FORM_STATE_IS_MATCHING || nodeType === FORM_STATE_IS_NOT_MATCHING)
                break;
              if (nodeType === SUSPENSE_END_DATA || nodeType === ACTIVITY_END_DATA)
                return null;
            }
          }
          return node;
        }
        function describeHydratableInstanceForDevWarnings(instance) {
          if (1 === instance.nodeType) {
            for (var JSCompiler_temp_const = instance.nodeName.toLowerCase(), serverDifferences = {}, attributes = instance.attributes, i = 0; i < attributes.length; i++) {
              var attr = attributes[i];
              serverDifferences[getPropNameFromAttributeName(attr.name)] = "style" === attr.name.toLowerCase() ? getStylesObjectFromElement(instance) : attr.value;
            }
            return { type: JSCompiler_temp_const, props: serverDifferences };
          }
          return 8 === instance.nodeType ? instance.data === ACTIVITY_START_DATA ? { type: "Activity", props: {} } : { type: "Suspense", props: {} } : instance.nodeValue;
        }
        function diffHydratedTextForDevWarnings(textInstance, text, parentProps) {
          return null === parentProps || true !== parentProps[SUPPRESS_HYDRATION_WARNING] ? (textInstance.nodeValue === text ? textInstance = null : (text = normalizeMarkupForTextOrAttribute(text), textInstance = normalizeMarkupForTextOrAttribute(textInstance.nodeValue) === text ? null : textInstance.nodeValue), textInstance) : null;
        }
        function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
          hydrationInstance = hydrationInstance.nextSibling;
          for (var depth = 0; hydrationInstance; ) {
            if (8 === hydrationInstance.nodeType) {
              var data = hydrationInstance.data;
              if (data === SUSPENSE_END_DATA || data === ACTIVITY_END_DATA) {
                if (0 === depth)
                  return getNextHydratable(hydrationInstance.nextSibling);
                depth--;
              } else
                data !== SUSPENSE_START_DATA && data !== SUSPENSE_FALLBACK_START_DATA && data !== SUSPENSE_PENDING_START_DATA && data !== SUSPENSE_QUEUED_START_DATA && data !== ACTIVITY_START_DATA || depth++;
            }
            hydrationInstance = hydrationInstance.nextSibling;
          }
          return null;
        }
        function getParentHydrationBoundary(targetInstance) {
          targetInstance = targetInstance.previousSibling;
          for (var depth = 0; targetInstance; ) {
            if (8 === targetInstance.nodeType) {
              var data = targetInstance.data;
              if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_QUEUED_START_DATA || data === ACTIVITY_START_DATA) {
                if (0 === depth) return targetInstance;
                depth--;
              } else
                data !== SUSPENSE_END_DATA && data !== ACTIVITY_END_DATA || depth++;
            }
            targetInstance = targetInstance.previousSibling;
          }
          return null;
        }
        function commitHydratedContainer(container) {
          retryIfBlockedOn(container);
        }
        function commitHydratedActivityInstance(activityInstance) {
          retryIfBlockedOn(activityInstance);
        }
        function commitHydratedSuspenseInstance(suspenseInstance) {
          retryIfBlockedOn(suspenseInstance);
        }
        function resolveSingletonInstance(type, props, rootContainerInstance, hostContext, validateDOMNestingDev) {
          validateDOMNestingDev && validateDOMNesting(type, hostContext.ancestorInfo);
          props = getOwnerDocumentFromRootContainer(rootContainerInstance);
          switch (type) {
            case "html":
              type = props.documentElement;
              if (!type)
                throw Error(
                  "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type;
            case "head":
              type = props.head;
              if (!type)
                throw Error(
                  "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type;
            case "body":
              type = props.body;
              if (!type)
                throw Error(
                  "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type;
            default:
              throw Error(
                "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
              );
          }
        }
        function acquireSingletonInstance(type, props, instance, internalInstanceHandle) {
          if (!instance[internalContainerInstanceKey] && getInstanceFromNode(instance)) {
            var tagName = instance.tagName.toLowerCase();
            console.error(
              "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
              tagName,
              tagName,
              tagName
            );
          }
          switch (type) {
            case "html":
            case "head":
            case "body":
              break;
            default:
              console.error(
                "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
              );
          }
          for (tagName = instance.attributes; tagName.length; )
            instance.removeAttributeNode(tagName[0]);
          setInitialProperties(instance, type, props);
          instance[internalInstanceKey] = internalInstanceHandle;
          instance[internalPropsKey] = props;
        }
        function releaseSingletonInstance(instance) {
          for (var attributes = instance.attributes; attributes.length; )
            instance.removeAttributeNode(attributes[0]);
          detachDeletedInstance(instance);
        }
        function getHoistableRoot(container) {
          return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
        }
        function preconnectAs(rel, href, crossOrigin) {
          var ownerDocument = globalDocument;
          if (ownerDocument && "string" === typeof href && href) {
            var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
            limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
            "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
            preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
          }
        }
        function getResource(type, currentProps, pendingProps, currentResource) {
          var resourceRoot = (resourceRoot = rootInstanceStackCursor.current) ? getHoistableRoot(resourceRoot) : null;
          if (!resourceRoot)
            throw Error(
              '"resourceRoot" was expected to exist. This is a bug in React.'
            );
          switch (type) {
            case "meta":
            case "title":
              return null;
            case "style":
              return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (pendingProps = getStyleKey(pendingProps.href), currentProps = getResourcesFromRoot(resourceRoot).hoistableStyles, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                type: "style",
                instance: null,
                count: 0,
                state: null
              }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
            case "link":
              if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
                type = getStyleKey(pendingProps.href);
                var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles, _resource = _styles.get(type);
                if (!_resource && (resourceRoot = resourceRoot.ownerDocument || resourceRoot, _resource = {
                  type: "stylesheet",
                  instance: null,
                  count: 0,
                  state: { loading: NotLoaded, preload: null }
                }, _styles.set(type, _resource), (_styles = resourceRoot.querySelector(
                  getStylesheetSelectorFromKey(type)
                )) && !_styles._p && (_resource.instance = _styles, _resource.state.loading = Loaded | Inserted), !preloadPropsMap.has(type))) {
                  var preloadProps = {
                    rel: "preload",
                    as: "style",
                    href: pendingProps.href,
                    crossOrigin: pendingProps.crossOrigin,
                    integrity: pendingProps.integrity,
                    media: pendingProps.media,
                    hrefLang: pendingProps.hrefLang,
                    referrerPolicy: pendingProps.referrerPolicy
                  };
                  preloadPropsMap.set(type, preloadProps);
                  _styles || preloadStylesheet(
                    resourceRoot,
                    type,
                    preloadProps,
                    _resource.state
                  );
                }
                if (currentProps && null === currentResource)
                  throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                    "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
                  );
                return _resource;
              }
              if (currentProps && null !== currentResource)
                throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                  "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
                );
              return null;
            case "script":
              return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (pendingProps = getScriptKey(pendingProps), currentProps = getResourcesFromRoot(resourceRoot).hoistableScripts, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                type: "script",
                instance: null,
                count: 0,
                state: null
              }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
            default:
              throw Error(
                'getResource encountered a type it did not expect: "' + type + '". this is a bug in React.'
              );
          }
        }
        function describeLinkForResourceErrorDEV(props) {
          var describedProps = 0, description = "<link";
          "string" === typeof props.rel ? (describedProps++, description += ' rel="' + props.rel + '"') : hasOwnProperty.call(props, "rel") && (describedProps++, description += ' rel="' + (null === props.rel ? "null" : "invalid type " + typeof props.rel) + '"');
          "string" === typeof props.href ? (describedProps++, description += ' href="' + props.href + '"') : hasOwnProperty.call(props, "href") && (describedProps++, description += ' href="' + (null === props.href ? "null" : "invalid type " + typeof props.href) + '"');
          "string" === typeof props.precedence ? (describedProps++, description += ' precedence="' + props.precedence + '"') : hasOwnProperty.call(props, "precedence") && (describedProps++, description += " precedence={" + (null === props.precedence ? "null" : "invalid type " + typeof props.precedence) + "}");
          Object.getOwnPropertyNames(props).length > describedProps && (description += " ...");
          return description + " />";
        }
        function getStyleKey(href) {
          return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
        }
        function getStylesheetSelectorFromKey(key) {
          return 'link[rel="stylesheet"][' + key + "]";
        }
        function stylesheetPropsFromRawProps(rawProps) {
          return assign2({}, rawProps, {
            "data-precedence": rawProps.precedence,
            precedence: null
          });
        }
        function preloadStylesheet(ownerDocument, key, preloadProps, state) {
          ownerDocument.querySelector(
            'link[rel="preload"][as="style"][' + key + "]"
          ) ? state.loading = Loaded : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
            return state.loading |= Loaded;
          }), key.addEventListener("error", function() {
            return state.loading |= Errored;
          }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
        }
        function getScriptKey(src) {
          return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
        }
        function getScriptSelectorFromKey(key) {
          return "script[async]" + key;
        }
        function acquireResource(hoistableRoot, resource, props) {
          resource.count++;
          if (null === resource.instance)
            switch (resource.type) {
              case "style":
                var instance = hoistableRoot.querySelector(
                  'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
                );
                if (instance)
                  return resource.instance = instance, markNodeAsHoistable(instance), instance;
                var styleProps = assign2({}, props, {
                  "data-href": props.href,
                  "data-precedence": props.precedence,
                  href: null,
                  precedence: null
                });
                instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
                markNodeAsHoistable(instance);
                setInitialProperties(instance, "style", styleProps);
                insertStylesheet(instance, props.precedence, hoistableRoot);
                return resource.instance = instance;
              case "stylesheet":
                styleProps = getStyleKey(props.href);
                var _instance = hoistableRoot.querySelector(
                  getStylesheetSelectorFromKey(styleProps)
                );
                if (_instance)
                  return resource.state.loading |= Inserted, resource.instance = _instance, markNodeAsHoistable(_instance), _instance;
                instance = stylesheetPropsFromRawProps(props);
                (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
                _instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
                markNodeAsHoistable(_instance);
                var linkInstance = _instance;
                linkInstance._p = new Promise(function(resolve, reject2) {
                  linkInstance.onload = resolve;
                  linkInstance.onerror = reject2;
                });
                setInitialProperties(_instance, "link", instance);
                resource.state.loading |= Inserted;
                insertStylesheet(_instance, props.precedence, hoistableRoot);
                return resource.instance = _instance;
              case "script":
                _instance = getScriptKey(props.src);
                if (styleProps = hoistableRoot.querySelector(
                  getScriptSelectorFromKey(_instance)
                ))
                  return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
                instance = props;
                if (styleProps = preloadPropsMap.get(_instance))
                  instance = assign2({}, props), adoptPreloadPropsForScript(instance, styleProps);
                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                styleProps = hoistableRoot.createElement("script");
                markNodeAsHoistable(styleProps);
                setInitialProperties(styleProps, "link", instance);
                hoistableRoot.head.appendChild(styleProps);
                return resource.instance = styleProps;
              case "void":
                return null;
              default:
                throw Error(
                  'acquireResource encountered a resource type it did not expect: "' + resource.type + '". this is a bug in React.'
                );
            }
          else
            "stylesheet" === resource.type && (resource.state.loading & Inserted) === NotLoaded && (instance = resource.instance, resource.state.loading |= Inserted, insertStylesheet(instance, props.precedence, hoistableRoot));
          return resource.instance;
        }
        function insertStylesheet(instance, precedence, root2) {
          for (var nodes = root2.querySelectorAll(
            'link[rel="stylesheet"][data-precedence],style[data-precedence]'
          ), last2 = nodes.length ? nodes[nodes.length - 1] : null, prior = last2, i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (node.dataset.precedence === precedence) prior = node;
            else if (prior !== last2) break;
          }
          prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
        }
        function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
          null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
          null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
          null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
        }
        function adoptPreloadPropsForScript(scriptProps, preloadProps) {
          null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
          null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
          null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
        }
        function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
          if (null === tagCaches) {
            var cache = /* @__PURE__ */ new Map();
            var caches = tagCaches = /* @__PURE__ */ new Map();
            caches.set(ownerDocument, cache);
          } else
            caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
          if (cache.has(type)) return cache;
          cache.set(type, null);
          ownerDocument = ownerDocument.getElementsByTagName(type);
          for (caches = 0; caches < ownerDocument.length; caches++) {
            var node = ownerDocument[caches];
            if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && node.namespaceURI !== SVG_NAMESPACE) {
              var nodeKey = node.getAttribute(keyAttribute) || "";
              nodeKey = type + nodeKey;
              var existing = cache.get(nodeKey);
              existing ? existing.push(node) : cache.set(nodeKey, [node]);
            }
          }
          return cache;
        }
        function mountHoistable(hoistableRoot, type, instance) {
          hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
          hoistableRoot.head.insertBefore(
            instance,
            "title" === type ? hoistableRoot.querySelector("head > title") : null
          );
        }
        function isHostHoistableType(type, props, hostContext) {
          var outsideHostContainerContext = !hostContext.ancestorInfo.containerTagInScope;
          if (hostContext.context === HostContextNamespaceSvg || null != props.itemProp)
            return !outsideHostContainerContext || null == props.itemProp || "meta" !== type && "title" !== type && "style" !== type && "link" !== type && "script" !== type || console.error(
              "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
              type,
              type
            ), false;
          switch (type) {
            case "meta":
            case "title":
              return true;
            case "style":
              if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href) {
                outsideHostContainerContext && console.error(
                  'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.'
                );
                break;
              }
              return true;
            case "link":
              if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError) {
                if ("stylesheet" === props.rel && "string" === typeof props.precedence) {
                  type = props.href;
                  var onError = props.onError, disabled = props.disabled;
                  hostContext = [];
                  props.onLoad && hostContext.push("`onLoad`");
                  onError && hostContext.push("`onError`");
                  null != disabled && hostContext.push("`disabled`");
                  onError = propNamesListJoin(hostContext, "and");
                  onError += 1 === hostContext.length ? " prop" : " props";
                  disabled = 1 === hostContext.length ? "an " + onError : "the " + onError;
                  hostContext.length && console.error(
                    'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                    type,
                    disabled,
                    onError
                  );
                }
                outsideHostContainerContext && ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href ? console.error(
                  "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
                ) : (props.onError || props.onLoad) && console.error(
                  "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                ));
                break;
              }
              switch (props.rel) {
                case "stylesheet":
                  return type = props.precedence, props = props.disabled, "string" !== typeof type && outsideHostContainerContext && console.error(
                    'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
                  ), "string" === typeof type && null == props;
                default:
                  return true;
              }
            case "script":
              type = props.async && "function" !== typeof props.async && "symbol" !== typeof props.async;
              if (!type || props.onLoad || props.onError || !props.src || "string" !== typeof props.src) {
                outsideHostContainerContext && (type ? props.onLoad || props.onError ? console.error(
                  "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                ) : console.error(
                  "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
                ) : console.error(
                  'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
                ));
                break;
              }
              return true;
            case "noscript":
            case "template":
              outsideHostContainerContext && console.error(
                "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
                type
              );
          }
          return false;
        }
        function preloadResource(resource) {
          return "stylesheet" === resource.type && (resource.state.loading & Settled) === NotLoaded ? false : true;
        }
        function suspendResource(state, hoistableRoot, resource, props) {
          if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && (resource.state.loading & Inserted) === NotLoaded) {
            if (null === resource.instance) {
              var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
                getStylesheetSelectorFromKey(key)
              );
              if (instance) {
                hoistableRoot = instance._p;
                null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
                resource.state.loading |= Inserted;
                resource.instance = instance;
                markNodeAsHoistable(instance);
                return;
              }
              instance = hoistableRoot.ownerDocument || hoistableRoot;
              props = stylesheetPropsFromRawProps(props);
              (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
              instance = instance.createElement("link");
              markNodeAsHoistable(instance);
              var linkInstance = instance;
              linkInstance._p = new Promise(function(resolve, reject2) {
                linkInstance.onload = resolve;
                linkInstance.onerror = reject2;
              });
              setInitialProperties(instance, "link", props);
              resource.instance = instance;
            }
            null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
            state.stylesheets.set(resource, hoistableRoot);
            (hoistableRoot = resource.state.preload) && (resource.state.loading & Settled) === NotLoaded && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
          }
        }
        function waitForCommitToBeReady(state, timeoutOffset) {
          state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
          return 0 < state.count || 0 < state.imgCount ? function(commit2) {
            var stylesheetTimer = setTimeout(function() {
              state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
              if (state.unsuspend) {
                var unsuspend = state.unsuspend;
                state.unsuspend = null;
                unsuspend();
              }
            }, SUSPENSEY_STYLESHEET_TIMEOUT + timeoutOffset);
            0 < state.imgBytes && 0 === estimatedBytesWithinLimit && (estimatedBytesWithinLimit = 125 * estimateBandwidth() * SUSPENSEY_IMAGE_TIME_ESTIMATE);
            var imgTimer = setTimeout(
              function() {
                state.waitingForImages = false;
                if (0 === state.count && (state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets), state.unsuspend)) {
                  var unsuspend = state.unsuspend;
                  state.unsuspend = null;
                  unsuspend();
                }
              },
              (state.imgBytes > estimatedBytesWithinLimit ? 50 : SUSPENSEY_IMAGE_TIMEOUT) + timeoutOffset
            );
            state.unsuspend = commit2;
            return function() {
              state.unsuspend = null;
              clearTimeout(stylesheetTimer);
              clearTimeout(imgTimer);
            };
          } : null;
        }
        function onUnsuspend() {
          this.count--;
          if (0 === this.count && (0 === this.imgCount || !this.waitingForImages)) {
            if (this.stylesheets)
              insertSuspendedStylesheets(this, this.stylesheets);
            else if (this.unsuspend) {
              var unsuspend = this.unsuspend;
              this.unsuspend = null;
              unsuspend();
            }
          }
        }
        function insertSuspendedStylesheets(state, resources) {
          state.stylesheets = null;
          null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
        }
        function insertStylesheetIntoRoot(root2, resource) {
          if (!(resource.state.loading & Inserted)) {
            var precedences = precedencesByRoot.get(root2);
            if (precedences) var last2 = precedences.get(LAST_PRECEDENCE);
            else {
              precedences = /* @__PURE__ */ new Map();
              precedencesByRoot.set(root2, precedences);
              for (var nodes = root2.querySelectorAll(
                "link[data-precedence],style[data-precedence]"
              ), i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
                  precedences.set(node.dataset.precedence, node), last2 = node;
              }
              last2 && precedences.set(LAST_PRECEDENCE, last2);
            }
            nodes = resource.instance;
            node = nodes.getAttribute("data-precedence");
            i = precedences.get(node) || last2;
            i === last2 && precedences.set(LAST_PRECEDENCE, nodes);
            precedences.set(node, nodes);
            this.count++;
            last2 = onUnsuspend.bind(this);
            nodes.addEventListener("load", last2);
            nodes.addEventListener("error", last2);
            i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
            resource.state.loading |= Inserted;
          }
        }
        function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
          this.tag = 1;
          this.containerInfo = containerInfo;
          this.pingCache = this.current = this.pendingChildren = null;
          this.timeoutHandle = noTimeout;
          this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
          this.callbackPriority = 0;
          this.expirationTimes = createLaneMap(-1);
          this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
          this.entanglements = createLaneMap(0);
          this.hiddenUpdates = createLaneMap(null);
          this.identifierPrefix = identifierPrefix;
          this.onUncaughtError = onUncaughtError;
          this.onCaughtError = onCaughtError;
          this.onRecoverableError = onRecoverableError;
          this.pooledCache = null;
          this.pooledCacheLanes = 0;
          this.formState = formState;
          this.incompleteTransitions = /* @__PURE__ */ new Map();
          this.passiveEffectDuration = this.effectDuration = -0;
          this.memoizedUpdaters = /* @__PURE__ */ new Set();
          containerInfo = this.pendingUpdatersLaneMap = [];
          for (tag = 0; 31 > tag; tag++) containerInfo.push(/* @__PURE__ */ new Set());
          this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
        }
        function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
          containerInfo = new FiberRootNode(
            containerInfo,
            tag,
            hydrate,
            identifierPrefix,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            onDefaultTransitionIndicator,
            formState
          );
          tag = ConcurrentMode;
          true === isStrictMode && (tag |= StrictLegacyMode | StrictEffectsMode);
          tag |= ProfileMode;
          isStrictMode = createFiber(3, null, null, tag);
          containerInfo.current = isStrictMode;
          isStrictMode.stateNode = containerInfo;
          tag = createCache();
          retainCache(tag);
          containerInfo.pooledCache = tag;
          retainCache(tag);
          isStrictMode.memoizedState = {
            element: initialChildren,
            isDehydrated: hydrate,
            cache: tag
          };
          initializeUpdateQueue(isStrictMode);
          return containerInfo;
        }
        function getContextForSubtree(parentComponent) {
          if (!parentComponent) return emptyContextObject;
          parentComponent = emptyContextObject;
          return parentComponent;
        }
        function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
          if (injectedHook && "function" === typeof injectedHook.onScheduleFiberRoot)
            try {
              injectedHook.onScheduleFiberRoot(rendererID, container, element);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %o",
                err
              ));
            }
          parentComponent = getContextForSubtree(parentComponent);
          null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
          isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = true, console.error(
            "Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.",
            getComponentNameFromFiber(current) || "Unknown"
          ));
          container = createUpdate(lane);
          container.payload = { element };
          callback = void 0 === callback ? null : callback;
          null !== callback && ("function" !== typeof callback && console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ), container.callback = callback);
          element = enqueueUpdate(rootFiber, container, lane);
          null !== element && (startUpdateTimerByLane(lane, "root.render()", null), scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
        }
        function markRetryLaneImpl(fiber, retryLane) {
          fiber = fiber.memoizedState;
          if (null !== fiber && null !== fiber.dehydrated) {
            var a = fiber.retryLane;
            fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
          }
        }
        function markRetryLaneIfNotHydrated(fiber, retryLane) {
          markRetryLaneImpl(fiber, retryLane);
          (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
        }
        function attemptContinuousHydration(fiber) {
          if (13 === fiber.tag || 31 === fiber.tag) {
            var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
            null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
            markRetryLaneIfNotHydrated(fiber, 67108864);
          }
        }
        function attemptHydrationAtCurrentPriority(fiber) {
          if (13 === fiber.tag || 31 === fiber.tag) {
            var lane = requestUpdateLane(fiber);
            lane = getBumpedLaneForHydrationByLane(lane);
            var root2 = enqueueConcurrentRenderForLane(fiber, lane);
            null !== root2 && scheduleUpdateOnFiber(root2, fiber, lane);
            markRetryLaneIfNotHydrated(fiber, lane);
          }
        }
        function getCurrentFiberForDevTools() {
          return current;
        }
        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var prevTransition = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = DiscreteEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
          }
        }
        function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var prevTransition = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = ContinuousEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
          }
        }
        function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (_enabled) {
            var blockedOn = findInstanceBlockingEvent(nativeEvent);
            if (null === blockedOn)
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              ), clearIfContinuousEvent(domEventName, nativeEvent);
            else if (queueIfContinuousEvent(
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ))
              nativeEvent.stopPropagation();
            else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
              for (; null !== blockedOn; ) {
                var fiber = getInstanceFromNode(blockedOn);
                if (null !== fiber)
                  switch (fiber.tag) {
                    case 3:
                      fiber = fiber.stateNode;
                      if (fiber.current.memoizedState.isDehydrated) {
                        var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                        if (0 !== lanes) {
                          var root2 = fiber;
                          root2.pendingLanes |= 2;
                          for (root2.entangledLanes |= 2; lanes; ) {
                            var lane = 1 << 31 - clz32(lanes);
                            root2.entanglements[1] |= lane;
                            lanes &= ~lane;
                          }
                          ensureRootIsScheduled(fiber);
                          (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, false));
                        }
                      }
                      break;
                    case 31:
                    case 13:
                      root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                  }
                fiber = findInstanceBlockingEvent(nativeEvent);
                null === fiber && dispatchEventForPluginEventSystem(
                  domEventName,
                  eventSystemFlags,
                  nativeEvent,
                  return_targetInst,
                  targetContainer
                );
                if (fiber === blockedOn) break;
                blockedOn = fiber;
              }
              null !== blockedOn && nativeEvent.stopPropagation();
            } else
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                null,
                targetContainer
              );
          }
        }
        function findInstanceBlockingEvent(nativeEvent) {
          nativeEvent = getEventTarget(nativeEvent);
          return findInstanceBlockingTarget(nativeEvent);
        }
        function findInstanceBlockingTarget(targetNode) {
          return_targetInst = null;
          targetNode = getClosestInstanceFromNode(targetNode);
          if (null !== targetNode) {
            var nearestMounted = getNearestMountedFiber(targetNode);
            if (null === nearestMounted) targetNode = null;
            else {
              var tag = nearestMounted.tag;
              if (13 === tag) {
                targetNode = getSuspenseInstanceFromFiber(nearestMounted);
                if (null !== targetNode) return targetNode;
                targetNode = null;
              } else if (31 === tag) {
                targetNode = getActivityInstanceFromFiber(nearestMounted);
                if (null !== targetNode) return targetNode;
                targetNode = null;
              } else if (3 === tag) {
                if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                  return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                targetNode = null;
              } else nearestMounted !== targetNode && (targetNode = null);
            }
          }
          return_targetInst = targetNode;
          return null;
        }
        function getEventPriority(domEventName) {
          switch (domEventName) {
            case "beforetoggle":
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "toggle":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return DiscreteEventPriority;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return ContinuousEventPriority;
            case "message":
              switch (getCurrentPriorityLevel()) {
                case ImmediatePriority:
                  return DiscreteEventPriority;
                case UserBlockingPriority:
                  return ContinuousEventPriority;
                case NormalPriority$1:
                case LowPriority:
                  return DefaultEventPriority;
                case IdlePriority:
                  return IdleEventPriority;
                default:
                  return DefaultEventPriority;
              }
            default:
              return DefaultEventPriority;
          }
        }
        function clearIfContinuousEvent(domEventName, nativeEvent) {
          switch (domEventName) {
            case "focusin":
            case "focusout":
              queuedFocus = null;
              break;
            case "dragenter":
            case "dragleave":
              queuedDrag = null;
              break;
            case "mouseover":
            case "mouseout":
              queuedMouse = null;
              break;
            case "pointerover":
            case "pointerout":
              queuedPointers.delete(nativeEvent.pointerId);
              break;
            case "gotpointercapture":
            case "lostpointercapture":
              queuedPointerCaptures.delete(nativeEvent.pointerId);
          }
        }
        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
            return existingQueuedEvent = {
              blockedOn,
              domEventName,
              eventSystemFlags,
              nativeEvent,
              targetContainers: [targetContainer]
            }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
          existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
          blockedOn = existingQueuedEvent.targetContainers;
          null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
          return existingQueuedEvent;
        }
        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          switch (domEventName) {
            case "focusin":
              return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedFocus,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "dragenter":
              return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedDrag,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "mouseover":
              return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedMouse,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "pointerover":
              var pointerId = nativeEvent.pointerId;
              queuedPointers.set(
                pointerId,
                accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedPointers.get(pointerId) || null,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                )
              );
              return true;
            case "gotpointercapture":
              return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
                pointerId,
                accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedPointerCaptures.get(pointerId) || null,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                )
              ), true;
          }
          return false;
        }
        function attemptExplicitHydrationTarget(queuedTarget) {
          var targetInst = getClosestInstanceFromNode(queuedTarget.target);
          if (null !== targetInst) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (null !== nearestMounted) {
              if (targetInst = nearestMounted.tag, 13 === targetInst) {
                if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                  queuedTarget.blockedOn = targetInst;
                  runWithPriority2(queuedTarget.priority, function() {
                    attemptHydrationAtCurrentPriority(nearestMounted);
                  });
                  return;
                }
              } else if (31 === targetInst) {
                if (targetInst = getActivityInstanceFromFiber(nearestMounted), null !== targetInst) {
                  queuedTarget.blockedOn = targetInst;
                  runWithPriority2(queuedTarget.priority, function() {
                    attemptHydrationAtCurrentPriority(nearestMounted);
                  });
                  return;
                }
              } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
                queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                return;
              }
            }
          }
          queuedTarget.blockedOn = null;
        }
        function attemptReplayContinuousQueuedEvent(queuedEvent) {
          if (null !== queuedEvent.blockedOn) return false;
          for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
            var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
            if (null === nextBlockedOn) {
              nextBlockedOn = queuedEvent.nativeEvent;
              var nativeEventClone = new nextBlockedOn.constructor(
                nextBlockedOn.type,
                nextBlockedOn
              ), event = nativeEventClone;
              null !== currentReplayingEvent && console.error(
                "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
              );
              currentReplayingEvent = event;
              nextBlockedOn.target.dispatchEvent(nativeEventClone);
              null === currentReplayingEvent && console.error(
                "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
              );
              currentReplayingEvent = null;
            } else
              return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
            targetContainers.shift();
          }
          return true;
        }
        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map3) {
          attemptReplayContinuousQueuedEvent(queuedEvent) && map3.delete(key);
        }
        function replayUnblockedEvents() {
          hasScheduledReplayAttempt = false;
          null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
          null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
          null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
          queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
          queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
        }
        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
          queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            replayUnblockedEvents
          )));
        }
        function scheduleReplayQueueIfNeeded(formReplayingQueue) {
          lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            function() {
              lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
              for (var i = 0; i < formReplayingQueue.length; i += 3) {
                var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
                if ("function" !== typeof submitterOrAction)
                  if (null === findInstanceBlockingTarget(submitterOrAction || form))
                    continue;
                  else break;
                var formInst = getInstanceFromNode(form);
                null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, form = {
                  pending: true,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                }, Object.freeze(form), startHostTransition(
                  formInst,
                  form,
                  submitterOrAction,
                  formData
                ));
              }
            }
          ));
        }
        function retryIfBlockedOn(unblocked) {
          function unblock(queuedEvent) {
            return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
          }
          null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
          null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
          null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
          queuedPointers.forEach(unblock);
          queuedPointerCaptures.forEach(unblock);
          for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
            var queuedTarget = queuedExplicitHydrationTargets[i];
            queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
          }
          for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
            attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
          i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
          if (null != i)
            for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
              var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
              if ("function" === typeof submitterOrAction)
                formProps || scheduleReplayQueueIfNeeded(i);
              else if (formProps) {
                var action = null;
                if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                  if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                    action = formProps.formAction;
                  else {
                    if (null !== findInstanceBlockingTarget(form)) continue;
                  }
                else action = formProps.action;
                "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
                scheduleReplayQueueIfNeeded(i);
              }
            }
        }
        function defaultOnDefaultTransitionIndicator() {
          function handleNavigate(event) {
            event.canIntercept && "react-transition" === event.info && event.intercept({
              handler: function() {
                return new Promise(function(resolve) {
                  return pendingResolve = resolve;
                });
              },
              focusReset: "manual",
              scroll: "manual"
            });
          }
          function handleNavigateComplete() {
            null !== pendingResolve && (pendingResolve(), pendingResolve = null);
            isCancelled || setTimeout(startFakeNavigation, 20);
          }
          function startFakeNavigation() {
            if (!isCancelled && !navigation.transition) {
              var currentEntry = navigation.currentEntry;
              currentEntry && null != currentEntry.url && navigation.navigate(currentEntry.url, {
                state: currentEntry.getState(),
                info: "react-transition",
                history: "replace"
              });
            }
          }
          if ("object" === typeof navigation) {
            var isCancelled = false, pendingResolve = null;
            navigation.addEventListener("navigate", handleNavigate);
            navigation.addEventListener("navigatesuccess", handleNavigateComplete);
            navigation.addEventListener("navigateerror", handleNavigateComplete);
            setTimeout(startFakeNavigation, 100);
            return function() {
              isCancelled = true;
              navigation.removeEventListener("navigate", handleNavigate);
              navigation.removeEventListener(
                "navigatesuccess",
                handleNavigateComplete
              );
              navigation.removeEventListener(
                "navigateerror",
                handleNavigateComplete
              );
              null !== pendingResolve && (pendingResolve(), pendingResolve = null);
            };
          }
        }
        function ReactDOMRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function ReactDOMHydrationRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function warnIfReactDOMContainerInDEV(container) {
          container[internalContainerInstanceKey] && (container._reactRootContainer ? console.error(
            "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
          ) : console.error(
            "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
          ));
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var Scheduler = require_scheduler(), React9 = require_react(), ReactDOM2 = require_react_dom(), assign2 = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
        Symbol.for("react.scope");
        var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
        Symbol.for("react.legacy_hidden");
        Symbol.for("react.tracing_marker");
        var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
        Symbol.for("react.view_transition");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, ReactSharedInternals = React9.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
          pending: false,
          data: null,
          method: null,
          action: null
        }), valueStack = [];
        var fiberStack = [];
        var index$jscomp$0 = -1, contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
        disabledLog.__reactDisabledLog = true;
        var prefix, suffix, reentry = false;
        var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
        var current = null, isRendering = false, hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, hasLoggedError = false, isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2, nextTransitionUpdateLane = 256, nextTransitionDeferredLane = 262144, nextRetryLane = 4194304, DiscreteEventPriority = 2, ContinuousEventPriority = 8, DefaultEventPriority = 32, IdleEventPriority = 268435456, randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey, allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {}, possibleRegistrationNames = {}, hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        }, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
          "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g, didWarnValueDefaultValue$1 = false, didWarnCheckedDefaultChecked = false, didWarnSelectedSetOnOption = false, didWarnInvalidChild = false, didWarnInvalidInnerHTML = false;
        var didWarnValueDefaultValue = false;
        var valuePropNames = ["value", "defaultValue"], didWarnValDefaultVal = false, needsEscaping = /["'&<>\n\t]|^\s|\s$/, specialTags = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
          " "
        ), inScopeTags = "applet caption html table td th marquee object template foreignObject desc title".split(
          " "
        ), buttonScopeTags = inScopeTags.concat(["button"]), impliedEndTags = "dd dt li option optgroup p rp rt".split(" "), emptyAncestorInfoDev = {
          current: null,
          formTag: null,
          aTagInScope: null,
          buttonTagInScope: null,
          nobrTagInScope: null,
          pTagInButtonScope: null,
          listItemTagAutoclosing: null,
          dlItemTagAutoclosing: null,
          containerTagInScope: null,
          implicitRootScope: false
        }, didWarn = {}, shorthandToLonghand = {
          animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
            " "
          ),
          background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
            " "
          ),
          backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
          border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
            " "
          ),
          borderBlockEnd: [
            "borderBlockEndColor",
            "borderBlockEndStyle",
            "borderBlockEndWidth"
          ],
          borderBlockStart: [
            "borderBlockStartColor",
            "borderBlockStartStyle",
            "borderBlockStartWidth"
          ],
          borderBottom: [
            "borderBottomColor",
            "borderBottomStyle",
            "borderBottomWidth"
          ],
          borderColor: [
            "borderBottomColor",
            "borderLeftColor",
            "borderRightColor",
            "borderTopColor"
          ],
          borderImage: [
            "borderImageOutset",
            "borderImageRepeat",
            "borderImageSlice",
            "borderImageSource",
            "borderImageWidth"
          ],
          borderInlineEnd: [
            "borderInlineEndColor",
            "borderInlineEndStyle",
            "borderInlineEndWidth"
          ],
          borderInlineStart: [
            "borderInlineStartColor",
            "borderInlineStartStyle",
            "borderInlineStartWidth"
          ],
          borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
          borderRadius: [
            "borderBottomLeftRadius",
            "borderBottomRightRadius",
            "borderTopLeftRadius",
            "borderTopRightRadius"
          ],
          borderRight: [
            "borderRightColor",
            "borderRightStyle",
            "borderRightWidth"
          ],
          borderStyle: [
            "borderBottomStyle",
            "borderLeftStyle",
            "borderRightStyle",
            "borderTopStyle"
          ],
          borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderWidth: [
            "borderBottomWidth",
            "borderLeftWidth",
            "borderRightWidth",
            "borderTopWidth"
          ],
          columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
          columns: ["columnCount", "columnWidth"],
          flex: ["flexBasis", "flexGrow", "flexShrink"],
          flexFlow: ["flexDirection", "flexWrap"],
          font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
            " "
          ),
          fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
            " "
          ),
          gap: ["columnGap", "rowGap"],
          grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
            " "
          ),
          gridArea: [
            "gridColumnEnd",
            "gridColumnStart",
            "gridRowEnd",
            "gridRowStart"
          ],
          gridColumn: ["gridColumnEnd", "gridColumnStart"],
          gridColumnGap: ["columnGap"],
          gridGap: ["columnGap", "rowGap"],
          gridRow: ["gridRowEnd", "gridRowStart"],
          gridRowGap: ["rowGap"],
          gridTemplate: [
            "gridTemplateAreas",
            "gridTemplateColumns",
            "gridTemplateRows"
          ],
          listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
          margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
          marker: ["markerEnd", "markerMid", "markerStart"],
          mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
            " "
          ),
          maskPosition: ["maskPositionX", "maskPositionY"],
          outline: ["outlineColor", "outlineStyle", "outlineWidth"],
          overflow: ["overflowX", "overflowY"],
          padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
          placeContent: ["alignContent", "justifyContent"],
          placeItems: ["alignItems", "justifyItems"],
          placeSelf: ["alignSelf", "justifySelf"],
          textDecoration: [
            "textDecorationColor",
            "textDecorationLine",
            "textDecorationStyle"
          ],
          textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
          transition: [
            "transitionDelay",
            "transitionDuration",
            "transitionProperty",
            "transitionTimingFunction"
          ],
          wordWrap: ["overflowWrap"]
        }, uppercasePattern = /([A-Z])/g, msPattern$1 = /^ms-/, badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, unitlessNumbers = new Set(
          "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
            " "
          )
        ), MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML", SVG_NAMESPACE = "http://www.w3.org/2000/svg", aliases = /* @__PURE__ */ new Map([
          ["acceptCharset", "accept-charset"],
          ["htmlFor", "for"],
          ["httpEquiv", "http-equiv"],
          ["crossOrigin", "crossorigin"],
          ["accentHeight", "accent-height"],
          ["alignmentBaseline", "alignment-baseline"],
          ["arabicForm", "arabic-form"],
          ["baselineShift", "baseline-shift"],
          ["capHeight", "cap-height"],
          ["clipPath", "clip-path"],
          ["clipRule", "clip-rule"],
          ["colorInterpolation", "color-interpolation"],
          ["colorInterpolationFilters", "color-interpolation-filters"],
          ["colorProfile", "color-profile"],
          ["colorRendering", "color-rendering"],
          ["dominantBaseline", "dominant-baseline"],
          ["enableBackground", "enable-background"],
          ["fillOpacity", "fill-opacity"],
          ["fillRule", "fill-rule"],
          ["floodColor", "flood-color"],
          ["floodOpacity", "flood-opacity"],
          ["fontFamily", "font-family"],
          ["fontSize", "font-size"],
          ["fontSizeAdjust", "font-size-adjust"],
          ["fontStretch", "font-stretch"],
          ["fontStyle", "font-style"],
          ["fontVariant", "font-variant"],
          ["fontWeight", "font-weight"],
          ["glyphName", "glyph-name"],
          ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
          ["glyphOrientationVertical", "glyph-orientation-vertical"],
          ["horizAdvX", "horiz-adv-x"],
          ["horizOriginX", "horiz-origin-x"],
          ["imageRendering", "image-rendering"],
          ["letterSpacing", "letter-spacing"],
          ["lightingColor", "lighting-color"],
          ["markerEnd", "marker-end"],
          ["markerMid", "marker-mid"],
          ["markerStart", "marker-start"],
          ["overlinePosition", "overline-position"],
          ["overlineThickness", "overline-thickness"],
          ["paintOrder", "paint-order"],
          ["panose-1", "panose-1"],
          ["pointerEvents", "pointer-events"],
          ["renderingIntent", "rendering-intent"],
          ["shapeRendering", "shape-rendering"],
          ["stopColor", "stop-color"],
          ["stopOpacity", "stop-opacity"],
          ["strikethroughPosition", "strikethrough-position"],
          ["strikethroughThickness", "strikethrough-thickness"],
          ["strokeDasharray", "stroke-dasharray"],
          ["strokeDashoffset", "stroke-dashoffset"],
          ["strokeLinecap", "stroke-linecap"],
          ["strokeLinejoin", "stroke-linejoin"],
          ["strokeMiterlimit", "stroke-miterlimit"],
          ["strokeOpacity", "stroke-opacity"],
          ["strokeWidth", "stroke-width"],
          ["textAnchor", "text-anchor"],
          ["textDecoration", "text-decoration"],
          ["textRendering", "text-rendering"],
          ["transformOrigin", "transform-origin"],
          ["underlinePosition", "underline-position"],
          ["underlineThickness", "underline-thickness"],
          ["unicodeBidi", "unicode-bidi"],
          ["unicodeRange", "unicode-range"],
          ["unitsPerEm", "units-per-em"],
          ["vAlphabetic", "v-alphabetic"],
          ["vHanging", "v-hanging"],
          ["vIdeographic", "v-ideographic"],
          ["vMathematical", "v-mathematical"],
          ["vectorEffect", "vector-effect"],
          ["vertAdvY", "vert-adv-y"],
          ["vertOriginX", "vert-origin-x"],
          ["vertOriginY", "vert-origin-y"],
          ["wordSpacing", "word-spacing"],
          ["writingMode", "writing-mode"],
          ["xmlnsXlink", "xmlns:xlink"],
          ["xHeight", "x-height"]
        ]), possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          fetchpriority: "fetchPriority",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          inert: "inert",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          popover: "popover",
          popovertarget: "popoverTarget",
          popovertargetaction: "popoverTargetAction",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          transformorigin: "transformOrigin",
          "transform-origin": "transformOrigin",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        }, ariaProperties = {
          "aria-current": 0,
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0,
          "aria-braillelabel": 0,
          "aria-brailleroledescription": 0,
          "aria-colindextext": 0,
          "aria-rowindextext": 0
        }, warnedProperties$1 = {}, rARIA$1 = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel$1 = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), didWarnValueNull = false, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, currentReplayingEvent = null, restoreTarget = null, restoreQueue = null, isInsideEventHandler = false, canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
        if (canUseDOM)
          try {
            var options$jscomp$0 = {};
            Object.defineProperty(options$jscomp$0, "passive", {
              get: function() {
                passiveBrowserEventsSupported = true;
              }
            });
            window.addEventListener("test", options$jscomp$0, options$jscomp$0);
            window.removeEventListener("test", options$jscomp$0, options$jscomp$0);
          } catch (e) {
            passiveBrowserEventsSupported = false;
          }
        var root = null, startText = null, fallbackText = null, EventInterface = {
          eventPhase: 0,
          bubbles: 0,
          cancelable: 0,
          timeStamp: function(event) {
            return event.timeStamp || Date.now();
          },
          defaultPrevented: 0,
          isTrusted: 0
        }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign2({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign2({}, UIEventInterface, {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          getModifierState: getEventModifierState,
          button: 0,
          buttons: 0,
          relatedTarget: function(event) {
            return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
          },
          movementX: function(event) {
            if ("movementX" in event) return event.movementX;
            event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
            return lastMovementX;
          },
          movementY: function(event) {
            return "movementY" in event ? event.movementY : lastMovementY;
          }
        }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign2({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign2({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign2({}, EventInterface, {
          animationName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign2({}, EventInterface, {
          clipboardData: function(event) {
            return "clipboardData" in event ? event.clipboardData : window.clipboardData;
          }
        }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign2({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(
          CompositionEventInterface
        ), SyntheticInputEvent = SyntheticCompositionEvent, normalizeKey = {
          Esc: "Escape",
          Spacebar: " ",
          Left: "ArrowLeft",
          Up: "ArrowUp",
          Right: "ArrowRight",
          Down: "ArrowDown",
          Del: "Delete",
          Win: "OS",
          Menu: "ContextMenu",
          Apps: "ContextMenu",
          Scroll: "ScrollLock",
          MozPrintableKey: "Unidentified"
        }, translateToKey = {
          8: "Backspace",
          9: "Tab",
          12: "Clear",
          13: "Enter",
          16: "Shift",
          17: "Control",
          18: "Alt",
          19: "Pause",
          20: "CapsLock",
          27: "Escape",
          32: " ",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "ArrowLeft",
          38: "ArrowUp",
          39: "ArrowRight",
          40: "ArrowDown",
          45: "Insert",
          46: "Delete",
          112: "F1",
          113: "F2",
          114: "F3",
          115: "F4",
          116: "F5",
          117: "F6",
          118: "F7",
          119: "F8",
          120: "F9",
          121: "F10",
          122: "F11",
          123: "F12",
          144: "NumLock",
          145: "ScrollLock",
          224: "Meta"
        }, modifierKeyToProp = {
          Alt: "altKey",
          Control: "ctrlKey",
          Meta: "metaKey",
          Shift: "shiftKey"
        }, KeyboardEventInterface = assign2({}, UIEventInterface, {
          key: function(nativeEvent) {
            if (nativeEvent.key) {
              var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
              if ("Unidentified" !== key) return key;
            }
            return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
          },
          code: 0,
          location: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          repeat: 0,
          locale: 0,
          getModifierState: getEventModifierState,
          charCode: function(event) {
            return "keypress" === event.type ? getEventCharCode(event) : 0;
          },
          keyCode: function(event) {
            return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
          },
          which: function(event) {
            return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
          }
        }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign2({}, MouseEventInterface, {
          pointerId: 0,
          width: 0,
          height: 0,
          pressure: 0,
          tangentialPressure: 0,
          tiltX: 0,
          tiltY: 0,
          twist: 0,
          pointerType: 0,
          isPrimary: 0
        }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign2({}, UIEventInterface, {
          touches: 0,
          targetTouches: 0,
          changedTouches: 0,
          altKey: 0,
          metaKey: 0,
          ctrlKey: 0,
          shiftKey: 0,
          getModifierState: getEventModifierState
        }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign2({}, EventInterface, {
          propertyName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign2({}, MouseEventInterface, {
          deltaX: function(event) {
            return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
          },
          deltaY: function(event) {
            return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
          },
          deltaZ: 0,
          deltaMode: 0
        }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign2({}, EventInterface, {
          newState: 0,
          oldState: 0
        }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], START_KEYCODE = 229, canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
        canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
        var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CODE = 32, SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE), hasSpaceKeypress = false, isComposing = false, supportedInputTypes = {
          color: true,
          date: true,
          datetime: true,
          "datetime-local": true,
          email: true,
          month: true,
          number: true,
          password: true,
          range: true,
          search: true,
          tel: true,
          text: true,
          time: true,
          url: true,
          week: true
        }, activeElement$1 = null, activeElementInst$1 = null, isInputEventSupported = false;
        canUseDOM && (isInputEventSupported = isEventSupported("input") && (!document.documentMode || 9 < document.documentMode));
        var objectIs = "function" === typeof Object.is ? Object.is : is, skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false, vendorPrefixes = {
          animationend: makePrefixMap("Animation", "AnimationEnd"),
          animationiteration: makePrefixMap("Animation", "AnimationIteration"),
          animationstart: makePrefixMap("Animation", "AnimationStart"),
          transitionrun: makePrefixMap("Transition", "TransitionRun"),
          transitionstart: makePrefixMap("Transition", "TransitionStart"),
          transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
          transitionend: makePrefixMap("Transition", "TransitionEnd")
        }, prefixedEventNames = {}, style2 = {};
        canUseDOM && (style2 = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
        var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
          " "
        );
        simpleEventPluginEvents.push("scrollEnd");
        var lastResetTime = 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          var getCurrentTime = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          getCurrentTime = function() {
            return localDate.now();
          };
        }
        var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
          if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
              error
            });
            if (!window.dispatchEvent(event)) return;
          } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        }, OMITTED_PROP_ERROR = "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.", EMPTY_ARRAY = 0, COMPLEX_ARRAY = 1, PRIMITIVE_ARRAY = 2, ENTRIES_ARRAY = 3, REMOVED = "\u2013\xA0", ADDED = "+\xA0", UNCHANGED = "\u2007\xA0", supportsUserTiming = "undefined" !== typeof console && "function" === typeof console.timeStamp && "undefined" !== typeof performance && "function" === typeof performance.measure, COMPONENTS_TRACK = "Components \u269B", LANES_TRACK_GROUP = "Scheduler \u269B", currentTrack = "Blocking", alreadyWarnedForDeepEquality = false, reusableComponentDevToolDetails = {
          color: "primary",
          properties: null,
          tooltipText: "",
          track: COMPONENTS_TRACK
        }, reusableComponentOptions = {
          start: -0,
          end: -0,
          detail: { devtools: reusableComponentDevToolDetails }
        }, resuableChangedPropsEntry = ["Changed Props", ""], DEEP_EQUALITY_WARNING = "This component received deeply equal props. It might benefit from useMemo or the React Compiler in its owner.", reusableDeeplyEqualPropsEntry = ["Changed Props", DEEP_EQUALITY_WARNING], OffscreenVisible = 1, OffscreenPassiveEffectsConnected = 2, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, emptyContextObject = {};
        Object.freeze(emptyContextObject);
        var resolveFamily = null, failedBoundaries = null, NoMode = 0, ConcurrentMode = 1, ProfileMode = 2, StrictLegacyMode = 8, StrictEffectsMode = 16, SuspenseyImagesMode = 32;
        var hasBadMapPolyfill = false;
        try {
          var nonExtensibleObject = Object.preventExtensions({});
          /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
          /* @__PURE__ */ new Set([nonExtensibleObject]);
        } catch (e$3) {
          hasBadMapPolyfill = true;
        }
        var CapturedStacks = /* @__PURE__ */ new WeakMap(), forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "", hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(
          "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
        ), valueCursor = createCursor(null);
        var rendererCursorDEV = createCursor(null);
        var rendererSigil = {};
        var currentlyRenderingFiber$1 = null, lastContextDependency = null, isDisallowedContextReadInDEV = false, AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
          var listeners = [], signal = this.signal = {
            aborted: false,
            addEventListener: function(type, listener) {
              listeners.push(listener);
            }
          };
          this.abort = function() {
            signal.aborted = true;
            listeners.forEach(function(listener) {
              return listener();
            });
          };
        }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority2 = Scheduler.unstable_NormalPriority, CacheContext = {
          $$typeof: REACT_CONTEXT_TYPE,
          Consumer: null,
          Provider: null,
          _currentValue: null,
          _currentValue2: null,
          _threadCount: 0,
          _currentRenderer: null,
          _currentRenderer2: null
        }, now = Scheduler.unstable_now, createTask = console.createTask ? console.createTask : function() {
          return null;
        }, SPAWNED_UPDATE = 1, PINGED_UPDATE = 2, renderStartTime = -0, commitStartTime = -0, commitEndTime = -0, commitErrors = null, profilerStartTime = -1.1, profilerEffectDuration = -0, componentEffectDuration = -0, componentEffectStartTime = -1.1, componentEffectEndTime = -1.1, componentEffectErrors = null, componentEffectSpawnedUpdate = false, blockingClampTime = -0, blockingUpdateTime = -1.1, blockingUpdateTask = null, blockingUpdateType = 0, blockingUpdateMethodName = null, blockingUpdateComponentName = null, blockingEventTime = -1.1, blockingEventType = null, blockingEventRepeatTime = -1.1, blockingSuspendedTime = -1.1, transitionClampTime = -0, transitionStartTime = -1.1, transitionUpdateTime = -1.1, transitionUpdateType = 0, transitionUpdateTask = null, transitionUpdateMethodName = null, transitionUpdateComponentName = null, transitionEventTime = -1.1, transitionEventType = null, transitionEventRepeatTime = -1.1, transitionSuspendedTime = -1.1, retryClampTime = -0, idleClampTime = -0, animatingLanes = 0, animatingTask = null, yieldReason = 0, yieldStartTime = -1.1, currentUpdateIsNested = false, nestedUpdateScheduled = false, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish = ReactSharedInternals.S;
        ReactSharedInternals.S = function(transition, returnValue) {
          globalMostRecentTransitionTime = now$1();
          if ("object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then) {
            if (0 > transitionStartTime && 0 > transitionUpdateTime) {
              transitionStartTime = now();
              var newEventTime = resolveEventTimeStamp(), newEventType = resolveEventType();
              if (newEventTime !== transitionEventRepeatTime || newEventType !== transitionEventType)
                transitionEventRepeatTime = -1.1;
              transitionEventTime = newEventTime;
              transitionEventType = newEventType;
            }
            entangleAsyncAction(transition, returnValue);
          }
          null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
        };
        var resumedCache = createCursor(null), ReactStrictModeWarnings = {
          recordUnsafeLifecycleWarnings: function() {
          },
          flushPendingUnsafeLifecycleWarnings: function() {
          },
          recordLegacyContextWarning: function() {
          },
          flushLegacyContextWarning: function() {
          },
          discardPendingWarnings: function() {
          }
        }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
          didWarnAboutUnsafeLifecycles.has(fiber.type) || ("function" === typeof instance.componentWillMount && true !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), "function" === typeof instance.componentWillReceiveProps && true !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), "function" === typeof instance.componentWillUpdate && true !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
        };
        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
          var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {
            componentWillMountUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillMountWarnings = []);
          var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
            UNSAFE_componentWillMountUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillMountWarnings = []);
          var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
            componentWillReceivePropsUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillReceivePropsWarnings = []);
          var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(
            function(fiber) {
              UNSAFE_componentWillReceivePropsUniqueNames.add(
                getComponentNameFromFiber(fiber) || "Component"
              );
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            }
          ), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
          var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {
            componentWillUpdateUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillUpdateWarnings = []);
          var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
            UNSAFE_componentWillUpdateUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillUpdateWarnings = []);
          if (0 < UNSAFE_componentWillMountUniqueNames.size) {
            var sortedNames = setToSortedString(
              UNSAFE_componentWillMountUniqueNames
            );
            console.error(
              "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s",
              sortedNames
            );
          }
          0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
            UNSAFE_componentWillReceivePropsUniqueNames
          ), console.error(
            "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(
            UNSAFE_componentWillUpdateUniqueNames
          ), console.error(
            "Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(
            "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
            componentWillReceivePropsUniqueNames
          ), console.warn(
            "componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(
            "componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
        };
        var pendingLegacyContextWarning = /* @__PURE__ */ new Map(), didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
          var strictRoot = null;
          for (var node = fiber; null !== node; )
            node.mode & StrictLegacyMode && (strictRoot = node), node = node.return;
          null === strictRoot ? console.error(
            "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
          ) : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && "function" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));
        };
        ReactStrictModeWarnings.flushLegacyContextWarning = function() {
          pendingLegacyContextWarning.forEach(function(fiberArray) {
            if (0 !== fiberArray.length) {
              var firstFiber = fiberArray[0], uniqueNames = /* @__PURE__ */ new Set();
              fiberArray.forEach(function(fiber) {
                uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutLegacyContext.add(fiber.type);
              });
              var sortedNames = setToSortedString(uniqueNames);
              runWithFiberInDEV(firstFiber, function() {
                console.error(
                  "Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context",
                  sortedNames
                );
              });
            }
          });
        };
        ReactStrictModeWarnings.discardPendingWarnings = function() {
          pendingComponentWillMountWarnings = [];
          pendingUNSAFE_ComponentWillMountWarnings = [];
          pendingComponentWillReceivePropsWarnings = [];
          pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          pendingComponentWillUpdateWarnings = [];
          pendingUNSAFE_ComponentWillUpdateWarnings = [];
          pendingLegacyContextWarning = /* @__PURE__ */ new Map();
        };
        var callComponent = {
          react_stack_bottom_frame: function(Component, props, secondArg) {
            var wasRendering = isRendering;
            isRendering = true;
            try {
              return Component(props, secondArg);
            } finally {
              isRendering = wasRendering;
            }
          }
        }, callComponentInDEV = callComponent.react_stack_bottom_frame.bind(callComponent), callRender = {
          react_stack_bottom_frame: function(instance) {
            var wasRendering = isRendering;
            isRendering = true;
            try {
              return instance.render();
            } finally {
              isRendering = wasRendering;
            }
          }
        }, callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender), callComponentDidMount = {
          react_stack_bottom_frame: function(finishedWork, instance) {
            try {
              instance.componentDidMount();
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }, callComponentDidMountInDEV = callComponentDidMount.react_stack_bottom_frame.bind(
          callComponentDidMount
        ), callComponentDidUpdate = {
          react_stack_bottom_frame: function(finishedWork, instance, prevProps, prevState, snapshot) {
            try {
              instance.componentDidUpdate(prevProps, prevState, snapshot);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }, callComponentDidUpdateInDEV = callComponentDidUpdate.react_stack_bottom_frame.bind(
          callComponentDidUpdate
        ), callComponentDidCatch = {
          react_stack_bottom_frame: function(instance, errorInfo) {
            var stack = errorInfo.stack;
            instance.componentDidCatch(errorInfo.value, {
              componentStack: null !== stack ? stack : ""
            });
          }
        }, callComponentDidCatchInDEV = callComponentDidCatch.react_stack_bottom_frame.bind(
          callComponentDidCatch
        ), callComponentWillUnmount = {
          react_stack_bottom_frame: function(current2, nearestMountedAncestor, instance) {
            try {
              instance.componentWillUnmount();
            } catch (error) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error);
            }
          }
        }, callComponentWillUnmountInDEV = callComponentWillUnmount.react_stack_bottom_frame.bind(
          callComponentWillUnmount
        ), callCreate = {
          react_stack_bottom_frame: function(effect) {
            var create = effect.create;
            effect = effect.inst;
            create = create();
            return effect.destroy = create;
          }
        }, callCreateInDEV = callCreate.react_stack_bottom_frame.bind(callCreate), callDestroy = {
          react_stack_bottom_frame: function(current2, nearestMountedAncestor, destroy) {
            try {
              destroy();
            } catch (error) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error);
            }
          }
        }, callDestroyInDEV = callDestroy.react_stack_bottom_frame.bind(callDestroy), callLazyInit = {
          react_stack_bottom_frame: function(lazy) {
            var init = lazy._init;
            return init(lazy._payload);
          }
        }, callLazyInitInDEV = callLazyInit.react_stack_bottom_frame.bind(callLazyInit), SuspenseException = Error(
          "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
        ), SuspenseyCommitException = Error(
          "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
        ), SuspenseActionException = Error(
          "Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."
        ), noopSuspenseyCommitThenable = {
          then: function() {
            console.error(
              'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
            );
          }
        }, suspendedThenable = null, needsToResetSuspendedThenableDEV = false, thenableState$1 = null, thenableIndexCounter$1 = 0, currentDebugInfo = null, didWarnAboutMaps;
        var didWarnAboutGenerators = didWarnAboutMaps = false;
        var ownerHasKeyUseWarning = {};
        var ownerHasFunctionTypeWarning = {};
        var ownerHasSymbolTypeWarning = {};
        warnForMissingKey = function(returnFiber, workInProgress2, child) {
          if (null !== child && "object" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {
            if ("object" !== typeof child._store)
              throw Error(
                "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
              );
            child._store.validated = 1;
            var componentName2 = getComponentNameFromFiber(returnFiber), componentKey = componentName2 || "null";
            if (!ownerHasKeyUseWarning[componentKey]) {
              ownerHasKeyUseWarning[componentKey] = true;
              child = child._owner;
              returnFiber = returnFiber._debugOwner;
              var currentComponentErrorInfo = "";
              returnFiber && "number" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = "\n\nCheck the render method of `" + componentKey + "`.");
              currentComponentErrorInfo || componentName2 && (currentComponentErrorInfo = "\n\nCheck the top-level render call using <" + componentName2 + ">.");
              var childOwnerAppendix = "";
              null != child && returnFiber !== child && (componentName2 = null, "number" === typeof child.tag ? componentName2 = getComponentNameFromFiber(child) : "string" === typeof child.name && (componentName2 = child.name), componentName2 && (childOwnerAppendix = " It was passed a child from " + componentName2 + "."));
              runWithFiberInDEV(workInProgress2, function() {
                console.error(
                  'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
                  currentComponentErrorInfo,
                  childOwnerAppendix
                );
              });
            }
          }
        };
        var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = false;
        var didWarnUpdateInsideUpdate = false;
        var currentlyProcessingQueue = null;
        var didReadFromEntangledAsyncAction = false, currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, didWarnUncachedGetSnapshot;
        var didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUseWrappedInTryCatch = /* @__PURE__ */ new Set();
        var didWarnAboutAsyncClientComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUseFormState = /* @__PURE__ */ new Set();
        var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = false, ContextOnlyDispatcher = {
          readContext,
          use,
          useCallback: throwInvalidHookError,
          useContext: throwInvalidHookError,
          useEffect: throwInvalidHookError,
          useImperativeHandle: throwInvalidHookError,
          useLayoutEffect: throwInvalidHookError,
          useInsertionEffect: throwInvalidHookError,
          useMemo: throwInvalidHookError,
          useReducer: throwInvalidHookError,
          useRef: throwInvalidHookError,
          useState: throwInvalidHookError,
          useDebugValue: throwInvalidHookError,
          useDeferredValue: throwInvalidHookError,
          useTransition: throwInvalidHookError,
          useSyncExternalStore: throwInvalidHookError,
          useId: throwInvalidHookError,
          useHostTransitionStatus: throwInvalidHookError,
          useFormState: throwInvalidHookError,
          useActionState: throwInvalidHookError,
          useOptimistic: throwInvalidHookError,
          useMemoCache: throwInvalidHookError,
          useCacheRefresh: throwInvalidHookError
        };
        ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
        var HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;
        HooksDispatcherOnMountInDEV = {
          readContext: function(context2) {
            return readContext(context2);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountCallback(callback, deps);
          },
          useContext: function(context2) {
            currentHookNameInDev = "useContext";
            mountHookTypesDev();
            return readContext(context2);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            mountEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer2, initialArg, init) {
            currentHookNameInDev = "useReducer";
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer2, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            mountHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            mountHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            mountHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            mountHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            mountHookTypesDev();
            return mountId();
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            mountHookTypesDev();
            warnOnUseFormStateInDev();
            return mountActionState(action, initialState);
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            mountHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            mountHookTypesDev();
            return mountRefresh();
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            mountHookTypesDev();
            return mountEvent(callback);
          }
        };
        HooksDispatcherOnMountWithHookTypesInDEV = {
          readContext: function(context2) {
            return readContext(context2);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context2) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context2);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            mountEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer2, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer2, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return mountId();
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return mountActionState(action, initialState);
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return mountRefresh();
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            updateHookTypesDev();
            return mountEvent(callback);
          }
        };
        HooksDispatcherOnUpdateInDEV = {
          readContext: function(context2) {
            return readContext(context2);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context2) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context2);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer2, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer2, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return updateDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return updateTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return updateActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return updateActionState(action);
          },
          useOptimistic: function(passthrough, reducer2) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return updateOptimistic(passthrough, reducer2);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            updateHookTypesDev();
            return updateEvent(callback);
          }
        };
        HooksDispatcherOnRerenderInDEV = {
          readContext: function(context2) {
            return readContext(context2);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context2) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context2);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer2, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(reducer2, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return rerenderDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return rerenderTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return rerenderActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useOptimistic: function(passthrough, reducer2) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return rerenderOptimistic(passthrough, reducer2);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            updateHookTypesDev();
            return updateEvent(callback);
          }
        };
        InvalidNestedHooksDispatcherOnMountInDEV = {
          readContext: function(context2) {
            warnInvalidContextAccess();
            return readContext(context2);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context2) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return readContext(context2);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            mountEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer2, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer2, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountId();
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            mountHookTypesDev();
            return mountRefresh();
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEvent(callback);
          }
        };
        InvalidNestedHooksDispatcherOnUpdateInDEV = {
          readContext: function(context2) {
            warnInvalidContextAccess();
            return readContext(context2);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context2) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context2);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer2, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer2, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateActionState(action);
          },
          useOptimistic: function(passthrough, reducer2) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateOptimistic(passthrough, reducer2);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEvent(callback);
          }
        };
        InvalidNestedHooksDispatcherOnRerenderInDEV = {
          readContext: function(context2) {
            warnInvalidContextAccess();
            return readContext(context2);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context2) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context2);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer2, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(reducer2, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useOptimistic: function(passthrough, reducer2) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderOptimistic(passthrough, reducer2);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEvent(callback);
          }
        };
        var fakeInternalInstance = {};
        var didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
        var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
        var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
        var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
        var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        Object.freeze(fakeInternalInstance);
        var classComponentUpdater = {
          enqueueSetState: function(inst, payload, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.payload = payload;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload && (startUpdateTimerByLane(lane, "this.setState()", inst), scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
          },
          enqueueReplaceState: function(inst, payload, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.tag = ReplaceState;
            update.payload = payload;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload && (startUpdateTimerByLane(lane, "this.replaceState()", inst), scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
          },
          enqueueForceUpdate: function(inst, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.tag = ForceUpdate;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            callback = enqueueUpdate(inst, update, lane);
            null !== callback && (startUpdateTimerByLane(lane, "this.forceUpdate()", inst), scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
          }
        }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error(
          "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
        ), didReceiveUpdate = false;
        var didWarnAboutBadClass = {};
        var didWarnAboutContextTypeOnFunctionComponent = {};
        var didWarnAboutContextTypes = {};
        var didWarnAboutGetDerivedStateOnFunctionComponent = {};
        var didWarnAboutReassigningProps = false;
        var didWarnAboutRevealOrder = {};
        var didWarnAboutTailOptions = {};
        var SUSPENDED_MARKER = {
          dehydrated: null,
          treeContext: null,
          retryLane: 0,
          hydrationErrors: null
        }, hasWarnedAboutUsingNoValuePropOnContextProvider = false, didWarnAboutUndefinedSnapshotBeforeUpdate = null;
        didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
        var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, hostParent = null, hostParentIsContainer = false, currentHoistableRoot = null, inHydratedSubtree = false, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {
          getCacheForType: function(resourceType) {
            var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
            void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
            return cacheForType;
          },
          cacheSignal: function() {
            return readContext(CacheContext).controller.signal;
          },
          getOwner: function() {
            return current;
          }
        };
        if ("function" === typeof Symbol && Symbol.for) {
          var symbolFor = Symbol.for;
          symbolFor("selector.component");
          symbolFor("selector.has_pseudo_class");
          symbolFor("selector.role");
          symbolFor("selector.test_id");
          symbolFor("selector.text");
        }
        var commitHooks = [], PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootSuspendedAtTheShell = 6, RootCompleted = 5, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, SuspendedOnAction = 9, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, globalMostRecentTransitionTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, workInProgressUpdateTask = null, legacyErrorBoundariesThatAlreadyFailed = null, IMMEDIATE_COMMIT = 0, ABORTED_VIEW_TRANSITION_COMMIT = 1, DELAYED_PASSIVE_COMMIT = 2, ANIMATION_STARTED_COMMIT = 3, NO_PENDING_EFFECTS = 0, PENDING_MUTATION_PHASE = 1, PENDING_LAYOUT_PHASE = 2, PENDING_AFTER_MUTATION_PHASE = 3, PENDING_SPAWNED_WORK = 4, PENDING_PASSIVE_PHASE = 5, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingEffectsRenderEndTime = -0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, pendingSuspendedCommitReason = null, pendingDelayedCommitReason = IMMEDIATE_COMMIT, pendingSuspendedViewTransitionReason = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = false, didScheduleUpdateDuringPassiveEffects = false, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = false, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = false;
        var didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
        var fakeActCallbackNode$1 = {}, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, didScheduleMicrotask_act = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0, fakeActCallbackNode = {};
        (function() {
          for (var i = 0; i < simpleEventPluginEvents.length; i++) {
            var eventName = simpleEventPluginEvents[i], domEventName = eventName.toLowerCase();
            eventName = eventName[0].toUpperCase() + eventName.slice(1);
            registerSimpleEvent(domEventName, "on" + eventName);
          }
          registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
          registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
          registerSimpleEvent(ANIMATION_START, "onAnimationStart");
          registerSimpleEvent("dblclick", "onDoubleClick");
          registerSimpleEvent("focusin", "onFocus");
          registerSimpleEvent("focusout", "onBlur");
          registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
          registerSimpleEvent(TRANSITION_START, "onTransitionStart");
          registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
          registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
        })();
        registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
        registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
        registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
        registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
        registerTwoPhaseEvent(
          "onChange",
          "change click focusin focusout input keydown keyup selectionchange".split(
            " "
          )
        );
        registerTwoPhaseEvent(
          "onSelect",
          "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
            " "
          )
        );
        registerTwoPhaseEvent("onBeforeInput", [
          "compositionend",
          "keypress",
          "textInput",
          "paste"
        ]);
        registerTwoPhaseEvent(
          "onCompositionEnd",
          "compositionend focusout keydown keypress keyup mousedown".split(" ")
        );
        registerTwoPhaseEvent(
          "onCompositionStart",
          "compositionstart focusout keydown keypress keyup mousedown".split(" ")
        );
        registerTwoPhaseEvent(
          "onCompositionUpdate",
          "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
        );
        var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
          " "
        ), nonDelegatedEvents = new Set(
          "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
        ), listeningMarker = "_reactListening" + Math.random().toString(36).slice(2), didWarnControlledToUncontrolled = false, didWarnUncontrolledToControlled = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, didWarnPopoverTargetObject = false;
        var didWarnForNewBooleanPropsWithEmptyValue = {};
        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g, xlinkNamespace = "http://www.w3.org/1999/xlink", xmlNamespace = "http://www.w3.org/XML/1998/namespace", EXPECTED_FORM_ACTION_URL = "javascript:throw new Error('React form unexpectedly submitted.')", SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning", ACTIVITY_START_DATA = "&", ACTIVITY_END_DATA = "/&", SUSPENSE_START_DATA = "$", SUSPENSE_END_DATA = "/$", SUSPENSE_PENDING_START_DATA = "$?", SUSPENSE_QUEUED_START_DATA = "$~", SUSPENSE_FALLBACK_START_DATA = "$!", PREAMBLE_CONTRIBUTION_HTML = "html", PREAMBLE_CONTRIBUTION_BODY = "body", PREAMBLE_CONTRIBUTION_HEAD = "head", FORM_STATE_IS_MATCHING = "F!", FORM_STATE_IS_NOT_MATCHING = "F", DOCUMENT_READY_STATE_LOADING = "loading", STYLE = "style", HostContextNamespaceNone = 0, HostContextNamespaceSvg = 1, HostContextNamespaceMath = 2, eventsEnabled = null, selectionInformation = null, warnedUnknownTags = { dialog: true, webview: true }, currentPopstateTransitionEvent = null, schedulerEvent = void 0, scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, noTimeout = -1, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
          return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
        } : scheduleTimeout, previousHydratableOnEnteringScopedSingleton = null, NotLoaded = 0, Loaded = 1, Errored = 2, Settled = 3, Inserted = 4, preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set(), previousDispatcher = ReactDOMSharedInternals.d;
        ReactDOMSharedInternals.d = {
          f: function() {
            var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
            return previousWasRendering || wasRendering;
          },
          r: function(form) {
            var formInst = getInstanceFromNode(form);
            null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
          },
          D: function(href) {
            previousDispatcher.D(href);
            preconnectAs("dns-prefetch", href, null);
          },
          C: function(href, crossOrigin) {
            previousDispatcher.C(href, crossOrigin);
            preconnectAs("preconnect", href, crossOrigin);
          },
          L: function(href, as, options) {
            previousDispatcher.L(href, as, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href && as) {
              var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
              "image" === as ? options && options.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                options.imageSrcSet
              ) + '"]', "string" === typeof options.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                options.imageSizes
              ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
              var key = preloadSelector;
              switch (as) {
                case "style":
                  key = getStyleKey(href);
                  break;
                case "script":
                  key = getScriptKey(href);
              }
              preloadPropsMap.has(key) || (href = assign2(
                {
                  rel: "preload",
                  href: "image" === as && options && options.imageSrcSet ? void 0 : href,
                  as
                },
                options
              ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(
                getStylesheetSelectorFromKey(key)
              ) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
            }
          },
          m: function(href, options) {
            previousDispatcher.m(href, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href) {
              var as = options && "string" === typeof options.as ? options.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
              switch (as) {
                case "audioworklet":
                case "paintworklet":
                case "serviceworker":
                case "sharedworker":
                case "worker":
                case "script":
                  key = getScriptKey(href);
              }
              if (!preloadPropsMap.has(key) && (href = assign2({ rel: "modulepreload", href }, options), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
                switch (as) {
                  case "audioworklet":
                  case "paintworklet":
                  case "serviceworker":
                  case "sharedworker":
                  case "worker":
                  case "script":
                    if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                      return;
                }
                as = ownerDocument.createElement("link");
                setInitialProperties(as, "link", href);
                markNodeAsHoistable(as);
                ownerDocument.head.appendChild(as);
              }
            }
          },
          X: function(src, options) {
            previousDispatcher.X(src, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
              var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
              resource || (resource = ownerDocument.querySelector(
                getScriptSelectorFromKey(key)
              ), resource || (src = assign2({ src, async: true }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                type: "script",
                instance: resource,
                count: 1,
                state: null
              }, scripts.set(key, resource));
            }
          },
          S: function(href, precedence, options) {
            previousDispatcher.S(href, precedence, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href) {
              var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
              precedence = precedence || "default";
              var resource = styles.get(key);
              if (!resource) {
                var state = { loading: NotLoaded, preload: null };
                if (resource = ownerDocument.querySelector(
                  getStylesheetSelectorFromKey(key)
                ))
                  state.loading = Loaded | Inserted;
                else {
                  href = assign2(
                    {
                      rel: "stylesheet",
                      href,
                      "data-precedence": precedence
                    },
                    options
                  );
                  (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);
                  var link = resource = ownerDocument.createElement("link");
                  markNodeAsHoistable(link);
                  setInitialProperties(link, "link", href);
                  link._p = new Promise(function(resolve, reject2) {
                    link.onload = resolve;
                    link.onerror = reject2;
                  });
                  link.addEventListener("load", function() {
                    state.loading |= Loaded;
                  });
                  link.addEventListener("error", function() {
                    state.loading |= Errored;
                  });
                  state.loading |= Inserted;
                  insertStylesheet(resource, precedence, ownerDocument);
                }
                resource = {
                  type: "stylesheet",
                  instance: resource,
                  count: 1,
                  state
                };
                styles.set(key, resource);
              }
            }
          },
          M: function(src, options) {
            previousDispatcher.M(src, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
              var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
              resource || (resource = ownerDocument.querySelector(
                getScriptSelectorFromKey(key)
              ), resource || (src = assign2({ src, async: true, type: "module" }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                type: "script",
                instance: resource,
                count: 1,
                state: null
              }, scripts.set(key, resource));
            }
          }
        };
        var globalDocument = "undefined" === typeof document ? null : document, tagCaches = null, SUSPENSEY_STYLESHEET_TIMEOUT = 6e4, SUSPENSEY_IMAGE_TIMEOUT = 800, SUSPENSEY_IMAGE_TIME_ESTIMATE = 500, estimatedBytesWithinLimit = 0, LAST_PRECEDENCE = null, precedencesByRoot = null, NotPendingTransition = NotPending, HostTransitionContext = {
          $$typeof: REACT_CONTEXT_TYPE,
          Provider: null,
          Consumer: null,
          _currentValue: NotPendingTransition,
          _currentValue2: NotPendingTransition,
          _threadCount: 0
        }, badgeFormat = "%c%s%c", badgeStyle = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", resetStyle = "", pad2 = " ", bind = Function.prototype.bind;
        var didWarnAboutNestedUpdates = false;
        var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, scheduleRetry = null, setErrorHandler = null, setSuspenseHandler = null;
        overrideHookState = function(fiber, id, path, value) {
          id = findHook(fiber, id);
          null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign2({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
        };
        overrideHookStateDeletePath = function(fiber, id, path) {
          id = findHook(fiber, id);
          null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign2({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
        };
        overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
          id = findHook(fiber, id);
          null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign2({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
        };
        overrideProps = function(fiber, path, value) {
          fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          path = enqueueConcurrentRenderForLane(fiber, 2);
          null !== path && scheduleUpdateOnFiber(path, fiber, 2);
        };
        overridePropsDeletePath = function(fiber, path) {
          fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          path = enqueueConcurrentRenderForLane(fiber, 2);
          null !== path && scheduleUpdateOnFiber(path, fiber, 2);
        };
        overridePropsRenamePath = function(fiber, oldPath, newPath) {
          fiber.pendingProps = copyWithRename(
            fiber.memoizedProps,
            oldPath,
            newPath
          );
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          oldPath = enqueueConcurrentRenderForLane(fiber, 2);
          null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
        };
        scheduleUpdate = function(fiber) {
          var root2 = enqueueConcurrentRenderForLane(fiber, 2);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
        };
        scheduleRetry = function(fiber) {
          var lane = claimNextRetryLane(), root2 = enqueueConcurrentRenderForLane(fiber, lane);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, lane);
        };
        setErrorHandler = function(newShouldErrorImpl) {
          shouldErrorImpl = newShouldErrorImpl;
        };
        setSuspenseHandler = function(newShouldSuspendImpl) {
          shouldSuspendImpl = newShouldSuspendImpl;
        };
        var _enabled = true, return_targetInst = null, hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
          " "
        ), lastScheduledReplayQueue = null;
        ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
          var root2 = this._internalRoot;
          if (null === root2) throw Error("Cannot update an unmounted root.");
          var args = arguments;
          "function" === typeof args[1] ? console.error(
            "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
          ) : isValidContainer(args[1]) ? console.error(
            "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
          ) : "undefined" !== typeof args[1] && console.error(
            "You passed a second argument to root.render(...) but it only accepts one argument."
          );
          args = children;
          var current2 = root2.current, lane = requestUpdateLane(current2);
          updateContainerImpl(current2, lane, args, root2, null, null);
        };
        ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
          var args = arguments;
          "function" === typeof args[0] && console.error(
            "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
          );
          args = this._internalRoot;
          if (null !== args) {
            this._internalRoot = null;
            var container = args.containerInfo;
            (executionContext & (RenderContext | CommitContext)) !== NoContext && console.error(
              "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
            );
            updateContainerImpl(args.current, 2, null, args, null, null);
            flushSyncWork$1();
            container[internalContainerInstanceKey] = null;
          }
        };
        ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
          if (target) {
            var updatePriority = resolveUpdatePriority();
            target = { blockedOn: null, target, priority: updatePriority };
            for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
            queuedExplicitHydrationTargets.splice(i, 0, target);
            0 === i && attemptExplicitHydrationTarget(target);
          }
        };
        (function() {
          var isomorphicReactPackageVersion = React9.version;
          if ("19.2.0" !== isomorphicReactPackageVersion)
            throw Error(
              'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' + (isomorphicReactPackageVersion + "\n  - react-dom:  19.2.0\nLearn more: https://react.dev/warnings/version-mismatch")
            );
        })();
        "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
          "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
        );
        ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
          var fiber = componentOrElement._reactInternals;
          if (void 0 === fiber) {
            if ("function" === typeof componentOrElement.render)
              throw Error("Unable to find node on an unmounted component.");
            componentOrElement = Object.keys(componentOrElement).join(",");
            throw Error(
              "Argument appears to not be a ReactComponent. Keys: " + componentOrElement
            );
          }
          componentOrElement = findCurrentFiberUsingSlowPath(fiber);
          componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
          componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
          return componentOrElement;
        };
        if (!(function() {
          var internals = {
            bundleType: 1,
            version: "19.2.0",
            rendererPackageName: "react-dom",
            currentDispatcherRef: ReactSharedInternals,
            reconcilerVersion: "19.2.0"
          };
          internals.overrideHookState = overrideHookState;
          internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
          internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
          internals.overrideProps = overrideProps;
          internals.overridePropsDeletePath = overridePropsDeletePath;
          internals.overridePropsRenamePath = overridePropsRenamePath;
          internals.scheduleUpdate = scheduleUpdate;
          internals.scheduleRetry = scheduleRetry;
          internals.setErrorHandler = setErrorHandler;
          internals.setSuspenseHandler = setSuspenseHandler;
          internals.scheduleRefresh = scheduleRefresh;
          internals.scheduleRoot = scheduleRoot;
          internals.setRefreshHandler = setRefreshHandler;
          internals.getCurrentFiber = getCurrentFiberForDevTools;
          return injectInternals(internals);
        })() && canUseDOM && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && -1 === navigator.userAgent.indexOf("Edge") || -1 < navigator.userAgent.indexOf("Firefox"))) {
          var protocol = window.location.protocol;
          /^(https?|file):$/.test(protocol) && console.info(
            "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + ("file:" === protocol ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq" : ""),
            "font-weight:bold"
          );
        }
        exports2.createRoot = function(container, options) {
          if (!isValidContainer(container))
            throw Error("Target container is not a DOM element.");
          warnIfReactDOMContainerInDEV(container);
          var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError;
          null !== options && void 0 !== options && (options.hydrate ? console.warn(
            "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
          ) : "object" === typeof options && null !== options && options.$$typeof === REACT_ELEMENT_TYPE && console.error(
            "You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"
          ), true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError));
          options = createFiberRoot(
            container,
            1,
            false,
            null,
            null,
            isStrictMode,
            identifierPrefix,
            null,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            defaultOnDefaultTransitionIndicator
          );
          container[internalContainerInstanceKey] = options.current;
          listenToAllSupportedEvents(container);
          return new ReactDOMRoot(options);
        };
        exports2.hydrateRoot = function(container, initialChildren, options) {
          if (!isValidContainer(container))
            throw Error("Target container is not a DOM element.");
          warnIfReactDOMContainerInDEV(container);
          void 0 === initialChildren && console.error(
            "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
          );
          var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, formState = null;
          null !== options && void 0 !== options && (true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.formState && (formState = options.formState));
          initialChildren = createFiberRoot(
            container,
            1,
            true,
            initialChildren,
            null != options ? options : null,
            isStrictMode,
            identifierPrefix,
            formState,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            defaultOnDefaultTransitionIndicator
          );
          initialChildren.context = getContextForSubtree(null);
          options = initialChildren.current;
          isStrictMode = requestUpdateLane(options);
          isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
          identifierPrefix = createUpdate(isStrictMode);
          identifierPrefix.callback = null;
          enqueueUpdate(options, identifierPrefix, isStrictMode);
          startUpdateTimerByLane(isStrictMode, "hydrateRoot()", null);
          options = isStrictMode;
          initialChildren.current.lanes = options;
          markRootUpdated$1(initialChildren, options);
          ensureRootIsScheduled(initialChildren);
          container[internalContainerInstanceKey] = initialChildren.current;
          listenToAllSupportedEvents(container);
          return new ReactDOMHydrationRoot(initialChildren);
        };
        exports2.version = "19.2.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/react-dom/client.js"(exports2, module2) {
      "use strict";
      if (false) {
        checkDCE();
        module2.exports = null;
      } else {
        module2.exports = require_react_dom_client_development();
      }
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/ui/loader.js
  var React2, ORIGINAL_SIZE, Loader, loader_default;
  var init_loader = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/ui/loader.js"() {
      React2 = __toESM(require_react(), 1);
      ORIGINAL_SIZE = 54;
      Loader = (_ref) => {
        let {
          fillColor = "#888",
          scale = 0.3,
          className,
          style: style2
        } = _ref;
        return /* @__PURE__ */ React2.createElement("svg", {
          width: ORIGINAL_SIZE * scale,
          height: ORIGINAL_SIZE * scale,
          viewBox: `0 0 ${ORIGINAL_SIZE} ${ORIGINAL_SIZE}`,
          className,
          style: __spreadValues({
            shapeRendering: "geometricPrecision"
          }, style2)
        }, /* @__PURE__ */ React2.createElement("g", null, /* @__PURE__ */ React2.createElement("path", {
          d: "M10.9,48.6c-1.6-1.3-2-3.6-0.7-5.3c1.3-1.6,3.6-2.1,5.3-0.8c0.8,0.5,1.5,1.1,2.4,1.5c7.5,4.1,16.8,2.7,22.8-3.4c1.5-1.5,3.8-1.5,5.3,0c1.4,1.5,1.4,3.9,0,5.3c-8.4,8.5-21.4,10.6-31.8,4.8C13,50.1,11.9,49.3,10.9,48.6z",
          fill: fillColor
        }), /* @__PURE__ */ React2.createElement("path", {
          d: "M53.6,31.4c-0.3,2.1-2.3,3.5-4.4,3.2c-2.1-0.3-3.4-2.3-3.1-4.4c0.2-1.1,0.2-2.2,0.2-3.3c0-8.7-5.7-16.2-13.7-18.5c-2-0.5-3.2-2.7-2.6-4.7s2.6-3.2,4.7-2.6C46,4.4,53.9,14.9,53.9,27C53.9,28.5,53.8,30,53.6,31.4z",
          fill: fillColor
        }), /* @__PURE__ */ React2.createElement("path", {
          d: "M16.7,1.9c1.9-0.8,4.1,0.2,4.8,2.2s-0.2,4.2-2.1,5c-7.2,2.9-12,10-12,18.1c0,1.6,0.2,3.2,0.6,4.7c0.5,2-0.7,4.1-2.7,4.6c-2,0.5-4-0.7-4.5-2.8C0.3,31.5,0,29.3,0,27.1C0,15.8,6.7,5.9,16.7,1.9z",
          fill: fillColor
        })));
      };
      loader_default = Loader;
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/ui/sdk_context.js
  var React3, SdkContext;
  var init_sdk_context = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/ui/sdk_context.js"() {
      React3 = __toESM(require_react(), 1);
      init_error_utils();
      SdkContext = /* @__PURE__ */ React3.createContext(null);
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/ui/global_css_helpers.js
  var SPIN_SCALE_ANIMATION_NAME, spinScaleKeyframesStyle, getCssContentToAddToHead;
  var init_global_css_helpers = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/ui/global_css_helpers.js"() {
      SPIN_SCALE_ANIMATION_NAME = `spinScale_${Math.random().toString(36).substring(2, 11)}`;
      spinScaleKeyframesStyle = `
    @keyframes ${SPIN_SCALE_ANIMATION_NAME} {
        0% {
            transform: rotate(0) scale(1);
        }
        50% {
            transform: rotate(360deg) scale(0.9);
        }
        100% {
            transform: rotate(720deg) scale(1);
        }
    }
`;
      getCssContentToAddToHead = () => {
        return `${spinScaleKeyframesStyle}`;
      };
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/ui/block_wrapper.js
  var React4, suspenseFallbackStyle, animateSpinnerStyle, BlockWrapper;
  var init_block_wrapper = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/ui/block_wrapper.js"() {
      React4 = __toESM(require_react(), 1);
      init_loader();
      init_sdk_context();
      init_global_css_helpers();
      suspenseFallbackStyle = {
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      };
      animateSpinnerStyle = {
        animationIterationCount: "infinite",
        animationName: SPIN_SCALE_ANIMATION_NAME,
        animationDuration: "1800ms",
        animationTimingFunction: "cubic-bezier(0.785, 0.135, 0.15, 0.86)"
      };
      BlockWrapper = (_ref) => {
        let {
          sdk: sdk3,
          children
        } = _ref;
        React4.useLayoutEffect(() => {
          const styleElement = document.createElement("style");
          styleElement.textContent = getCssContentToAddToHead();
          document.head.appendChild(styleElement);
          return () => {
            if (document.head.contains(styleElement)) {
              document.head.removeChild(styleElement);
            }
          };
        }, []);
        return /* @__PURE__ */ React4.createElement(SdkContext.Provider, {
          value: sdk3
        }, /* @__PURE__ */ React4.createElement(React4.Suspense, {
          fallback: /* @__PURE__ */ React4.createElement("div", {
            style: suspenseFallbackStyle
          }, /* @__PURE__ */ React4.createElement(loader_default, {
            style: animateSpinnerStyle
          }))
        }, children));
      };
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/ui/initialize_block.js
  function initializeBlock(entryPoints) {
    const body = typeof document !== "undefined" ? document.body : null;
    if (!body) {
      throw spawnError("initializeBlock should only be called from browser environments");
    }
    if (hasBeenInitialized) {
      throw spawnError("initializeBlock should only be called once");
    }
    hasBeenInitialized = true;
    const airtableInterface2 = getAirtableInterface();
    let entryElement;
    const runContext = airtableInterface2.sdkInitData.runContext;
    switch (runContext.type) {
      case BlockRunContextType.PAGE_ELEMENT_IN_QUERY_CONTAINER: {
        if (entryPoints.interface === void 0) {
          throw spawnError("If running an extension within the interface, it must have a interface initialization function");
        }
        if (typeof entryPoints.interface !== "function") {
          throw spawnError("initializeBlock must contain a interface function that returns a React element");
        }
        entryElement = entryPoints.interface();
        break;
      }
      default:
        throw spawnError("Invalid context to run ");
    }
    if (!/* @__PURE__ */ React5.isValidElement(entryElement)) {
      throw spawnError("The first argument to initializeBlock didn't return a valid React element");
    }
    const container = document.createElement("div");
    container.style.height = "100%";
    container.style.width = "100%";
    body.appendChild(container);
    (0, import_client.createRoot)(container).render(/* @__PURE__ */ React5.createElement(BlockWrapper, {
      sdk: sdk2
    }, entryElement));
  }
  function __injectSdkIntoInitializeBlock(_sdk) {
    sdk2 = _sdk;
  }
  var React5, import_client, hasBeenInitialized, sdk2;
  var init_initialize_block = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/ui/initialize_block.js"() {
      React5 = __toESM(require_react(), 1);
      import_client = __toESM(require_client(), 1);
      init_error_utils();
      init_airtable_interface();
      init_airtable_interface2();
      init_block_wrapper();
      hasBeenInitialized = false;
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/index.js
  function __reset() {
    const __sdk = new InterfaceBlockSdk(getAirtableInterface());
    __injectSdkIntoInitializeBlock(__sdk);
    __injectSdkIntoWarning(__sdk);
  }
  var init_interface = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/index.js"() {
      init_warning();
      init_airtable_interface();
      init_sdk();
      init_initialize_block();
      __reset();
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/ui/use_array_identity.js
  var import_react2;
  var init_use_array_identity = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/ui/use_array_identity.js"() {
      import_react2 = __toESM(require_react(), 1);
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/ui/use_watchable.js
  var import_react3;
  var init_use_watchable = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/ui/use_watchable.js"() {
      import_react3 = __toESM(require_react(), 1);
      init_error_utils();
      init_private_utils();
      init_use_array_identity();
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/ui/cell_renderer.js
  var React6;
  var init_cell_renderer = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/ui/cell_renderer.js"() {
      React6 = __toESM(require_react(), 1);
      init_error_utils();
      init_field_core();
      init_use_watchable();
      init_sdk_context();
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/ui/cell_renderer.js
  var React7;
  var init_cell_renderer2 = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/ui/cell_renderer.js"() {
      React7 = __toESM(require_react(), 1);
      init_cell_renderer();
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/ui/expand_record.js
  var init_expand_record = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/ui/expand_record.js"() {
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/ui/use_base.js
  var init_use_base = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/ui/use_base.js"() {
      init_use_watchable();
      init_sdk_context();
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/ui/use_base.js
  var init_use_base2 = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/ui/use_base.js"() {
      init_use_base();
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/ui/use_color_scheme.js
  var import_react4;
  var init_use_color_scheme = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/ui/use_color_scheme.js"() {
      import_react4 = __toESM(require_react(), 1);
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/ui/use_global_config.js
  var init_use_global_config = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/ui/use_global_config.js"() {
      init_use_watchable();
      init_sdk_context();
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/ui/use_custom_properties.js
  var import_react5;
  var init_use_custom_properties = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/ui/use_custom_properties.js"() {
      import_react5 = __toESM(require_react(), 1);
      init_sdk_context();
      init_airtable_interface2();
      init_use_global_config();
      init_error_utils();
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/ui/use_records.js
  var init_use_records = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/ui/use_records.js"() {
      init_sdk_context();
      init_use_watchable();
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/ui/use_run_info.js
  var init_use_run_info = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/ui/use_run_info.js"() {
      init_sdk_context();
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/ui/use_session.js
  var init_use_session = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/ui/use_session.js"() {
      init_use_watchable();
      init_sdk_context();
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/ui/use_session.js
  var init_use_session2 = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/ui/use_session.js"() {
      init_use_session();
    }
  });

  // node_modules/@airtable/blocks/dist/esm/base/types/airtable_interface.js
  var init_airtable_interface3 = __esm({
    "node_modules/@airtable/blocks/dist/esm/base/types/airtable_interface.js"() {
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/ui/global_config_synced_component_helpers.js
  var init_global_config_synced_component_helpers = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/ui/global_config_synced_component_helpers.js"() {
      init_airtable_interface3();
      init_use_watchable();
      init_sdk_context();
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/ui/use_synced.js
  var init_use_synced = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/ui/use_synced.js"() {
      init_global_config_synced_component_helpers();
      init_sdk_context();
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/colors.js
  var Colors, rgbTuplesByColor;
  var init_colors = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/colors.js"() {
      Colors = {
        /** @docsPath UI/utils/Colors */
        BLUE_BRIGHT: "blueBright",
        /** @docsPath UI/utils/Colors */
        BLUE_DARK_1: "blueDark1",
        /** @docsPath UI/utils/Colors */
        BLUE_LIGHT_1: "blueLight1",
        /** @docsPath UI/utils/Colors */
        BLUE_LIGHT_2: "blueLight2",
        /** @docsPath UI/utils/Colors */
        BLUE: "blue",
        /** @docsPath UI/utils/Colors */
        CYAN_BRIGHT: "cyanBright",
        /** @docsPath UI/utils/Colors */
        CYAN_DARK_1: "cyanDark1",
        /** @docsPath UI/utils/Colors */
        CYAN_LIGHT_1: "cyanLight1",
        /** @docsPath UI/utils/Colors */
        CYAN_LIGHT_2: "cyanLight2",
        /** @docsPath UI/utils/Colors */
        CYAN: "cyan",
        /** @docsPath UI/utils/Colors */
        GRAY_BRIGHT: "grayBright",
        /** @docsPath UI/utils/Colors */
        GRAY_DARK_1: "grayDark1",
        /** @docsPath UI/utils/Colors */
        GRAY_LIGHT_1: "grayLight1",
        /** @docsPath UI/utils/Colors */
        GRAY_LIGHT_2: "grayLight2",
        /** @docsPath UI/utils/Colors */
        GRAY: "gray",
        /** @docsPath UI/utils/Colors */
        GREEN_BRIGHT: "greenBright",
        /** @docsPath UI/utils/Colors */
        GREEN_DARK_1: "greenDark1",
        /** @docsPath UI/utils/Colors */
        GREEN_LIGHT_1: "greenLight1",
        /** @docsPath UI/utils/Colors */
        GREEN_LIGHT_2: "greenLight2",
        /** @docsPath UI/utils/Colors */
        GREEN: "green",
        /** @docsPath UI/utils/Colors */
        ORANGE_BRIGHT: "orangeBright",
        /** @docsPath UI/utils/Colors */
        ORANGE_DARK_1: "orangeDark1",
        /** @docsPath UI/utils/Colors */
        ORANGE_LIGHT_1: "orangeLight1",
        /** @docsPath UI/utils/Colors */
        ORANGE_LIGHT_2: "orangeLight2",
        /** @docsPath UI/utils/Colors */
        ORANGE: "orange",
        /** @docsPath UI/utils/Colors */
        PINK_BRIGHT: "pinkBright",
        /** @docsPath UI/utils/Colors */
        PINK_DARK_1: "pinkDark1",
        /** @docsPath UI/utils/Colors */
        PINK_LIGHT_1: "pinkLight1",
        /** @docsPath UI/utils/Colors */
        PINK_LIGHT_2: "pinkLight2",
        /** @docsPath UI/utils/Colors */
        PINK: "pink",
        /** @docsPath UI/utils/Colors */
        PURPLE_BRIGHT: "purpleBright",
        /** @docsPath UI/utils/Colors */
        PURPLE_DARK_1: "purpleDark1",
        /** @docsPath UI/utils/Colors */
        PURPLE_LIGHT_1: "purpleLight1",
        /** @docsPath UI/utils/Colors */
        PURPLE_LIGHT_2: "purpleLight2",
        /** @docsPath UI/utils/Colors */
        PURPLE: "purple",
        /** @docsPath UI/utils/Colors */
        RED_BRIGHT: "redBright",
        /** @docsPath UI/utils/Colors */
        RED_DARK_1: "redDark1",
        /** @docsPath UI/utils/Colors */
        RED_LIGHT_1: "redLight1",
        /** @docsPath UI/utils/Colors */
        RED_LIGHT_2: "redLight2",
        /** @docsPath UI/utils/Colors */
        RED: "red",
        /** @docsPath UI/utils/Colors */
        TEAL_BRIGHT: "tealBright",
        /** @docsPath UI/utils/Colors */
        TEAL_DARK_1: "tealDark1",
        /** @docsPath UI/utils/Colors */
        TEAL_LIGHT_1: "tealLight1",
        /** @docsPath UI/utils/Colors */
        TEAL_LIGHT_2: "tealLight2",
        /** @docsPath UI/utils/Colors */
        TEAL: "teal",
        /** @docsPath UI/utils/Colors */
        YELLOW_BRIGHT: "yellowBright",
        /** @docsPath UI/utils/Colors */
        YELLOW_DARK_1: "yellowDark1",
        /** @docsPath UI/utils/Colors */
        YELLOW_LIGHT_1: "yellowLight1",
        /** @docsPath UI/utils/Colors */
        YELLOW_LIGHT_2: "yellowLight2",
        /** @docsPath UI/utils/Colors */
        YELLOW: "yellow"
      };
      rgbTuplesByColor = {
        [Colors.BLUE_BRIGHT]: [45, 127, 249],
        [Colors.BLUE_DARK_1]: [39, 80, 174],
        [Colors.BLUE_LIGHT_1]: [156, 199, 255],
        [Colors.BLUE_LIGHT_2]: [207, 223, 255],
        [Colors.BLUE]: [18, 131, 218],
        [Colors.CYAN_BRIGHT]: [24, 191, 255],
        [Colors.CYAN_DARK_1]: [11, 118, 183],
        [Colors.CYAN_LIGHT_1]: [119, 209, 243],
        [Colors.CYAN_LIGHT_2]: [208, 240, 253],
        [Colors.CYAN]: [1, 169, 219],
        [Colors.GRAY_BRIGHT]: [102, 102, 102],
        [Colors.GRAY_DARK_1]: [68, 68, 68],
        [Colors.GRAY_LIGHT_1]: [204, 204, 204],
        [Colors.GRAY_LIGHT_2]: [238, 238, 238],
        [Colors.GRAY]: [102, 102, 102],
        [Colors.GREEN_BRIGHT]: [32, 201, 51],
        [Colors.GREEN_DARK_1]: [51, 138, 23],
        [Colors.GREEN_LIGHT_1]: [147, 224, 136],
        [Colors.GREEN_LIGHT_2]: [209, 247, 196],
        [Colors.GREEN]: [17, 175, 34],
        [Colors.ORANGE_BRIGHT]: [255, 111, 44],
        [Colors.ORANGE_DARK_1]: [215, 77, 38],
        [Colors.ORANGE_LIGHT_1]: [255, 169, 129],
        [Colors.ORANGE_LIGHT_2]: [254, 226, 213],
        [Colors.ORANGE]: [247, 101, 59],
        [Colors.PINK_BRIGHT]: [255, 8, 194],
        [Colors.PINK_DARK_1]: [178, 21, 139],
        [Colors.PINK_LIGHT_1]: [249, 157, 226],
        [Colors.PINK_LIGHT_2]: [255, 218, 246],
        [Colors.PINK]: [233, 41, 186],
        [Colors.PURPLE_BRIGHT]: [139, 70, 255],
        [Colors.PURPLE_DARK_1]: [107, 28, 176],
        [Colors.PURPLE_LIGHT_1]: [205, 176, 255],
        [Colors.PURPLE_LIGHT_2]: [237, 226, 254],
        [Colors.PURPLE]: [124, 57, 237],
        [Colors.RED_BRIGHT]: [248, 43, 96],
        [Colors.RED_DARK_1]: [186, 30, 69],
        [Colors.RED_LIGHT_1]: [255, 158, 183],
        [Colors.RED_LIGHT_2]: [255, 220, 229],
        [Colors.RED]: [239, 48, 97],
        [Colors.TEAL_BRIGHT]: [32, 217, 210],
        [Colors.TEAL_DARK_1]: [6, 160, 155],
        [Colors.TEAL_LIGHT_1]: [114, 221, 195],
        [Colors.TEAL_LIGHT_2]: [194, 245, 233],
        [Colors.TEAL]: [2, 170, 164],
        [Colors.YELLOW_BRIGHT]: [252, 180, 0],
        [Colors.YELLOW_DARK_1]: [184, 117, 3],
        [Colors.YELLOW_LIGHT_1]: [255, 214, 110],
        [Colors.YELLOW_LIGHT_2]: [255, 234, 182],
        [Colors.YELLOW]: [224, 141, 0]
      };
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/color_utils.js
  var init_color_utils = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/color_utils.js"() {
      init_private_utils();
      init_colors();
    }
  });

  // node_modules/@airtable/blocks/dist/esm/shared/ui/remote_utils.js
  var init_remote_utils = __esm({
    "node_modules/@airtable/blocks/dist/esm/shared/ui/remote_utils.js"() {
      init_error_utils();
    }
  });

  // node_modules/@airtable/blocks/dist/esm/interface/ui/ui.js
  var init_ui = __esm({
    "node_modules/@airtable/blocks/dist/esm/interface/ui/ui.js"() {
      init_assert_run_context();
      init_interface();
      init_cell_renderer2();
      init_expand_record();
      init_initialize_block();
      init_use_base2();
      init_use_color_scheme();
      init_use_custom_properties();
      init_use_records();
      init_use_run_info();
      init_use_session2();
      init_use_global_config();
      init_use_synced();
      init_use_watchable();
      init_colors();
      init_color_utils();
      init_remote_utils();
    }
  });

  // frontend/style.css
  var style;
  var init_style = __esm({
    "frontend/style.css"() {
      style = document.createElement("style");
      style.textContent = '*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }\n\n/*! tailwindcss v3.4.18 | MIT License | https://tailwindcss.com*/*,:after,:before{box-sizing:border-box;border:0 solid #e5e7eb}:after,:before{--tw-content:""}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Courier,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.relative{position:relative}.mx-auto{margin-left:auto;margin-right:auto}.mb-2{margin-bottom:.5rem}.mt-10{margin-top:2.5rem}.mt-6{margin-top:1.5rem}.min-h-screen{min-height:100vh}.max-w-lg{max-width:32rem}.rounded-lg{border-radius:.875rem}.bg-gray-gray50{--tw-bg-opacity:1;background-color:rgb(246 248 252/var(--tw-bg-opacity,1))}.bg-white{--tw-bg-opacity:1;background-color:rgb(255 255 255/var(--tw-bg-opacity,1))}.p-4{padding:1rem}.p-6{padding:1.5rem}.text-center{text-align:center}.font-display{font-family:Inter Display,ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji}.text-4xl{font-size:1.6875rem;line-height:2.125rem}.font-bold{font-weight:700}.leading-tight{line-height:1.25}.text-gray-gray700{--tw-text-opacity:1;color:rgb(49 53 62/var(--tw-text-opacity,1))}.shadow-xl{--tw-shadow:0px 0px 1px rgba(0,0,0,.24),0px 0px 2px rgba(0,0,0,.16),0px 3px 4px rgba(0,0,0,.06),0px 6px 8px rgba(0,0,0,.06),0px 12px 16px rgba(0,0,0,.08),0px 18px 32px rgba(0,0,0,.06);--tw-shadow-colored:0px 0px 1px var(--tw-shadow-color),0px 0px 2px var(--tw-shadow-color),0px 3px 4px var(--tw-shadow-color),0px 6px 8px var(--tw-shadow-color),0px 12px 16px var(--tw-shadow-color),0px 18px 32px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}@media (min-width:640px){.sm\\:mt-20{margin-top:5rem}.sm\\:p-12{padding:3rem}.sm\\:p-8{padding:2rem}.sm\\:text-5xl{font-size:1.9375rem;line-height:2.5rem}}@media (min-width:768px){.md\\:text-5xl{font-size:1.9375rem;line-height:2.5rem}}@media (min-width:1024px){.lg\\:text-6xl{font-size:2.1875rem;line-height:2.75rem}}@media (prefers-color-scheme:dark){.dark\\:bg-gray-gray700{--tw-bg-opacity:1;background-color:rgb(49 53 62/var(--tw-bg-opacity,1))}.dark\\:bg-gray-gray800{--tw-bg-opacity:1;background-color:rgb(29 31 37/var(--tw-bg-opacity,1))}.dark\\:text-gray-gray200{--tw-text-opacity:1;color:rgb(218 222 230/var(--tw-text-opacity,1))}.dark\\:shadow-none{--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}}';
      document.head.appendChild(style);
    }
  });

  // node_modules/react/cjs/react-jsx-dev-runtime.development.js
  var require_react_jsx_dev_runtime_development = __commonJS({
    "node_modules/react/cjs/react-jsx-dev-runtime.development.js"(exports2) {
      "use strict";
      (function() {
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x) {
                }
            }
          return null;
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = false;
          } catch (e) {
            JSCompiler_inline_result = true;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            );
            return testStringCoercion(value);
          }
        }
        function getTaskName(type) {
          if (type === REACT_FRAGMENT_TYPE) return "<>";
          if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
            return "<...>";
          try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
          } catch (x) {
            return "<...>";
          }
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function UnknownOwner() {
          return Error("react-stack-top-frame");
        }
        function hasValidKey(config) {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return false;
          }
          return void 0 !== config.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement(type, key, props, owner, debugStack, debugTask) {
          var refProp = props.ref;
          type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            props,
            _owner: owner
          };
          null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
            enumerable: false,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
          type._store = {};
          Object.defineProperty(type._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: 0
          });
          Object.defineProperty(type, "_debugInfo", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: null
          });
          Object.defineProperty(type, "_debugStack", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugStack
          });
          Object.defineProperty(type, "_debugTask", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugTask
          });
          Object.freeze && (Object.freeze(type.props), Object.freeze(type));
          return type;
        }
        function jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStack, debugTask) {
          var children = config.children;
          if (void 0 !== children)
            if (isStaticChildren)
              if (isArrayImpl(children)) {
                for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
                  validateChildKeys(children[isStaticChildren]);
                Object.freeze && Object.freeze(children);
              } else
                console.error(
                  "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
                );
            else validateChildKeys(children);
          if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys3 = Object.keys(config).filter(function(k) {
              return "key" !== k;
            });
            isStaticChildren = 0 < keys3.length ? "{key: someKey, " + keys3.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys3 = 0 < keys3.length ? "{" + keys3.join(": ..., ") + ": ...}" : "{}", console.error(
              'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
              isStaticChildren,
              children,
              keys3,
              children
            ), didWarnAboutKeySpread[children + isStaticChildren] = true);
          }
          children = null;
          void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
          hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
          if ("key" in config) {
            maybeKey = {};
            for (var propName in config)
              "key" !== propName && (maybeKey[propName] = config[propName]);
          } else maybeKey = config;
          children && defineKeyPropWarningGetter(
            maybeKey,
            "function" === typeof type ? type.displayName || type.name || "Unknown" : type
          );
          return ReactElement(
            type,
            children,
            maybeKey,
            getOwner(),
            debugStack,
            debugTask
          );
        }
        function validateChildKeys(node) {
          isValidElement2(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE && ("fulfilled" === node._payload.status ? isValidElement2(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
        }
        function isValidElement2(object) {
          return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var React9 = require_react(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React9.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
          return null;
        };
        React9 = {
          react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
          }
        };
        var specialPropKeyWarningShown;
        var didWarnAboutElementRef = {};
        var unknownOwnerDebugStack = React9.react_stack_bottom_frame.bind(
          React9,
          UnknownOwner
        )();
        var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
        var didWarnAboutKeySpread = {};
        exports2.Fragment = REACT_FRAGMENT_TYPE;
        exports2.jsxDEV = function(type, config, maybeKey, isStaticChildren) {
          var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return jsxDEVImpl(
            type,
            config,
            maybeKey,
            isStaticChildren,
            trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
          );
        };
      })();
    }
  });

  // node_modules/react/jsx-dev-runtime.js
  var require_jsx_dev_runtime = __commonJS({
    "node_modules/react/jsx-dev-runtime.js"(exports2, module2) {
      "use strict";
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_react_jsx_dev_runtime_development();
      }
    }
  });

  // frontend/index.js
  var frontend_exports = {};
  function SpreadsheetApp() {
    const data = [
      [{ value: "Vanilla" }, { value: "Chocolate" }, { value: "Strawberry" }],
      [{ value: "2" }, { value: "3" }, { value: "5" }],
      [{ value: "4" }, { value: "6" }, { value: "8" }]
    ];
    return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { className: "p-4 sm:p-8 min-h-screen relative bg-gray-gray50 dark:bg-gray-gray800", children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(
      "div",
      {
        className: "rounded-lg p-6 sm:p-12 max-w-lg mx-auto text-center mt-10 sm:mt-20\n            bg-white shadow-xl\n            dark:bg-gray-gray700 dark:shadow-none",
        children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(
            "h1",
            {
              className: "text-4xl sm:text-5xl md:text-5xl lg:text-6xl font-display font-bold mb-2 leading-tight\n                text-gray-gray700\n                dark:text-gray-gray200",
              children: "My Spreadsheet \u{1F4CA}"
            },
            void 0,
            false,
            {
              fileName: "frontend/index.js",
              lineNumber: 18,
              columnNumber: 17
            },
            this
          ),
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { className: "mt-6", children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Spreadsheet$1, { data }, void 0, false, {
            fileName: "frontend/index.js",
            lineNumber: 26,
            columnNumber: 21
          }, this) }, void 0, false, {
            fileName: "frontend/index.js",
            lineNumber: 25,
            columnNumber: 17
          }, this)
        ]
      },
      void 0,
      true,
      {
        fileName: "frontend/index.js",
        lineNumber: 13,
        columnNumber: 13
      },
      this
    ) }, void 0, false, {
      fileName: "frontend/index.js",
      lineNumber: 12,
      columnNumber: 9
    }, this);
  }
  var import_jsx_dev_runtime;
  var init_frontend = __esm({
    "frontend/index.js"() {
      init_es();
      init_ui();
      init_style();
      import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime());
      initializeBlock({ interface: () => /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(SpreadsheetApp, {}, void 0, false, {
        fileName: "frontend/index.js",
        lineNumber: 33,
        columnNumber: 35
      }) });
    }
  });

  // .tmp/index.js
  var ReactDOM = require_react_dom();
  var React8 = require_react();
  var ReactDOMServer = require_server_browser();
  window["_airtableReact"] = React8;
  window["_airtableReactDOM"] = ReactDOM;
  window["_airtableReactDOMServer"] = ReactDOMServer;
  var didRun = false;
  window["_airtableRunBlock"] = function runBlock() {
    if (didRun) {
      console.log("Refusing to re-run block");
      return;
    }
    didRun = true;
    init_frontend();
  };
})();
/*! Bundled license information:

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-server-legacy.browser.development.js:
  (**
   * @license React
   * react-dom-server-legacy.browser.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-server.browser.development.js:
  (**
   * @license React
   * react-dom-server.browser.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-client.development.js:
  (**
   * @license React
   * react-dom-client.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-dev-runtime.development.js:
  (**
   * @license React
   * react-jsx-dev-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
